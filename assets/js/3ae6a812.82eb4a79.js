"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4884],{8990:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>A,default:()=>g,frontMatter:()=>h,metadata:()=>p,toc:()=>f});var a=n(1716),l=n(8604),i=n(2787),o=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,k=(e,t)=>{for(var n in t||(t={}))d.call(t,n)&&m(e,n,t[n]);if(u)for(var n of u(t))c.call(t,n)&&m(e,n,t[n]);return e};const h={sidebar_position:19},A="3.3 Objects and Named Numbers",p={unversionedId:"arm/AA-3/AA-3.3",id:"arm/AA-3/AA-3.3",title:"3.3 Objects and Named Numbers",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-3/AA-3.3.mdx",sourceDirName:"arm/AA-3",slug:"/arm/AA-3/AA-3.3",permalink:"/docs/arm/AA-3/AA-3.3",draft:!1,tags:[],version:"current",sidebarPosition:19,frontMatter:{sidebar_position:19},sidebar:"referenceManualSidebar",previous:{title:"3.2 Types and Subtypes",permalink:"/docs/arm/AA-3/AA-3.2"},next:{title:"3.4 Derived Types and Classes",permalink:"/docs/arm/AA-3/AA-3.4"}},b={},f=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"3.3.1  Object Declarations",id:"331--object-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"3.3.2  Number Declarations",id:"332--number-declarations",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4}],y={toc:f};function g(e){var t,n=e,{components:o}=n,m=((e,t)=>{var n={};for(var a in e)d.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&u)for(var a of u(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=k(k({},y),m),r(t,s({components:o,mdxType:"MDXLayout"}))),(0,a.kt)("h1",k({},{id:"33-objects-and-named-numbers"}),"3.3 Objects and Named Numbers"),(0,a.kt)("admonition",k({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.kt)("a",k({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"[Objects are created at run time and contain a value of a given type. An object can be created and initialized as part of elaborating a declaration, evaluating an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.8#S0164"},"allocator")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),", or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),", or passing a parameter by copy. Prior to reclaiming the storage for an object, it is finalized if necessary (see 7.6.1).] ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"All of the following are objects: ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"glossary-entry",title:"Glossary entry: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"An object is either a constant or a variable. An object contains a value. An object is created by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," or by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.8#S0164"},"allocator")),". A formal parameter is (a view of) an object. A subcomponent of an object is an object.",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"the entity declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"a formal parameter of a subprogram, entry, or generic subprogram;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"a generic formal object;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"a loop parameter;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0061-1"),"}"," ",(0,a.kt)("br",null),"the index parameter of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0119"},"iterated_component_association")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," ",(0,a.kt)("br",null),"the chunk parameter of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"a choice parameter of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"an entry index of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the result of dereferencing an access-to-object value (see 4.1);",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00416-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0015-1"),"}"," ",(0,a.kt)("br",null),"the return object of a function;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the result of evaluating an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0003-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0226-1"),"}"," ",(0,a.kt)("br",null),"a value conversion or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," whose operand denotes an object;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"a component, slice, or view conversion of another object. ",(0,a.kt)("br",null))),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0054-2"),"}"," ",(0,a.kt)("br",null),"An object is either a ",(0,a.kt)("em",null,"constant")," object or a ",(0,a.kt)("em",null,"variable")," object. Similarly, a view of an object is either a ",(0,a.kt)("em",null,"constant")," or a ",(0,a.kt)("em",null,"variable"),". All views of a constant elementary object are constant. All views of a constant composite object are constant, except for parts that are of controlled or immutably limited types; variable views of those parts and their subcomponents may exist. In this sense, objects of controlled and immutably limited types are ",(0,a.kt)("em",null,"inherently mutable"),". A constant view of an object cannot be used to modify its value. The terms constant and variable by themselves refer to constant and variable views of objects.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0422-1"),"}"," ",(0,a.kt)("br",null),"If some part of an object has a variable view, then the object as a whole has a variable view, and not all views of the object are constant. That's true even if only a subcomponent has a variable view. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0422-1"),"}"," ",(0,a.kt)("br",null),"A constant object is ",(0,a.kt)("em",null,"known to have no variable views")," if it does not have a part that is immutably limited, or of a controlled type, private type, or private extension.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0422-1"),"}"," ",(0,a.kt)("br",null),"This definition can be used in Legality Rules as it respects privacy. It is an assume-the-worst rule, as all private types and private extensions might have a controlled component. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"The value of an object is ",(0,a.kt)("em",null,"read")," when the value of any part of the object is evaluated, or when the value of an enclosing object is evaluated. The value of a variable is ",(0,a.kt)("em",null,"updated")," when an assignment is performed to any part of the variable, or when an assignment is performed to an enclosing object. ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'Reading and updating are intended to include read/write references of any kind, even if they are not associated with the evaluation of a particular construct. Consider, for example, the expression "X.',(0,a.kt)("strong",null,"all"),'(F)", where X is an access-to-array object, and F is a function. The implementation is allowed to first evaluate "X.',(0,a.kt)("strong",null,"all"),'" and then F. Finally, a read is performed to get the value of the F\'th component of the array. Note that the array is not necessarily read as part of the evaluation of "X.',(0,a.kt)("strong",null,"all"),'". This is important, because if F were to free X using Unchecked_Deallocation, we want the execution of the final read to be erroneous. ',(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"Whether a view of an object is constant or variable is determined by the definition of the view. The following (and no others) represent variables: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"an object declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," without the reserved word ",(0,a.kt)("strong",null,"constant"),";",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ",(0,a.kt)("br",null),"We mean the word ",(0,a.kt)("strong",null,"constant")," as defined by the grammar for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),", not some random word ",(0,a.kt)("strong",null,"constant"),". Thus, ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"X : access constant T;","\n"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"is not a constant. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a formal parameter of mode ",(0,a.kt)("strong",null,"in out")," or ",(0,a.kt)("strong",null,"out"),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a generic formal object of mode ",(0,a.kt)("strong",null,"in out"),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a non-discriminant component of a variable;",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"This includes both ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),"s and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"s. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," of a variable;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a loop parameter that is specified to be a variable for a generalized loop (see 5.5.2);",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a view conversion of a variable;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a dereference of an access-to-variable value;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0015-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"the return object declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.5#S0225"},"extended_return_statement"))," without the reserved word ",(0,a.kt)("strong",null,"constant"),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0015-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"the current instance of a type other than a protected type[, if the current instance is an object and not a value (see 8.6)];",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"We exclude current instances of protected types as they are protected units and the next bullet applies. ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"proof",title:"Proof: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"This list of bullets only applies to views of objects, so current instances that are not objects are not considered here. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI05-0003-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0120-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"the current instance of a protected unit except within the body of a protected function of that protected unit, or within a function declared immediately within the body of the protected unit;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," where the attribute is defined to denote a variable (for example, the Storage_Pool attribute  see 13.11).",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"In particular, this implies that the following are not variables: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0226-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"the result of evaluating a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),", an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),", a value conversion, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0148"},"conditional_expression")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.3#S0309"},"raise_expression")),", or a parenthesized expression;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0125-3"),"}"," ",(0,a.kt)("br",null),"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0174"},"target_name"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0173"},"assignment_statement"))," (see 5.2.1);",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0061-1"),"}"," ",(0,a.kt)("br",null),"the index parameter of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0119"},"iterated_component_association")),";",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"a choice parameter or entry index;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," ",(0,a.kt)("br",null),"a chunk parameter of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),". ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("br",null),"This list of constructs that yield constant views is not exhaustive. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0264-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0191-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0294-1"),"}"," ",(0,a.kt)("br",null),"At the place where a view of an object is defined, a ",(0,a.kt)("em",null,"nominal subtype")," is associated with the view. The ",(0,a.kt)("em",null,"nominal type")," of a view is the type of the nominal subtype of the view. The object's ",(0,a.kt)("em",null,"actual subtype")," (that is, its subtype) can be more restrictive than the nominal subtype of the view; it always is more restrictive if the nominal subtype is an ",(0,a.kt)("em",null,"indefinite subtype"),". A subtype is an indefinite subtype if it is an unconstrained array subtype, or if it has unknown discriminants or unconstrained discriminants without defaults (see 3.7); otherwise, the subtype is a ",(0,a.kt)("em",null,"definite")," subtype [(all elementary subtypes are definite subtypes)]. [A class-wide subtype is defined to have unknown discriminants, and is therefore an indefinite subtype. An indefinite subtype does not by itself provide enough information to create an object; an additional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0029"},"constraint"))," or explicit initialization ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is necessary (see 3.3.1). A component cannot have an indefinite nominal subtype.]",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"glossary-entry",title:"Glossary entry: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The nominal subtype of a view of an object is the subtype specified when the view is defined.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ",(0,a.kt)("br",null),"A view of a composite object is ",(0,a.kt)("em",null,"known to be constrained")," if:",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," ",(0,a.kt)("br",null),"its nominal subtype is constrained and not an untagged partial view, and it is neither a value conversion nor a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),"; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"its nominal subtype is indefinite; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0093-1"),"}"," ",(0,a.kt)("br",null),"its type is immutably limited (see 7.5); or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"it is part of a stand-alone constant (including a generic formal object of mode ",(0,a.kt)("strong",null,"in"),"); or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"it is part of a formal parameter of mode ",(0,a.kt)("strong",null,"in"),"; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"it is part of the object denoted by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),"; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0226-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"it is a value conversion or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," where the operand denotes a view of a composite object that is known to be constrained; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"it is part of a constant return object of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.5#S0225"},"extended_return_statement")),"; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0041-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"it is a dereference of a pool-specific access type, and there is no ancestor of its type that has a constrained partial view.",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"We do not include dereferences of general access types because they might denote stand-alone aliased unconstrained variables. That's true even for access-to-constant types (the denoted object does not have to be a constant).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0005-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"We don't mention view conversions as there are no mutable tagged types (discriminant defaults are allowed only if the type is immutably limited), so all tagged view conversions are either of an indefinite type (if it has discriminants without defaults), an immutably limited type (if the discriminants do have defaults), or constrained (if there are no discriminants). This matches the first three bullets here, so all tagged view conversions are known to be constrained without needing to mention them explicitly. Untagged view conversions only can occur in parameter passing (as actuals to ",(0,a.kt)("strong",null,"in out")," or ",(0,a.kt)("strong",null,"out"),' parameters), and "known to be constrained" is not used there.',(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"We don't need to mention the current instance of a (sub)type, either. If a current instance of a type or subtype appears in an aspect specification, it represents a value, so whether or not it is known to be constrained is irrelevant (the term is only defined for composite objects). Otherwise, the current instance of a type can only be used in an immutably limited type, so all such instances are known to be constrained by the third bullet. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0041-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("br",null),"For the purposes of determining within a generic body whether an object is known to be constrained: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"if a subtype is a descendant of an untagged generic formal private or derived type, and the subtype is not an unconstrained array subtype, it is not considered indefinite and is considered to have a constrained partial view;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"if a subtype is a descendant of a formal access type, it is not considered pool-specific.",(0,a.kt)("br",null))),(0,a.kt)("p",null,"A ",(0,a.kt)("em",null,"named number")," provides a name for a numeric value known at compile time. It is declared by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration")),". ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 1   A constant cannot be the target of an assignment operation, nor be passed as an ",(0,a.kt)("strong",null,"in")," ",(0,a.kt)("strong",null,"out")," or ",(0,a.kt)("strong",null,"out")," parameter, between its initialization and finalization, if any.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 2   ","{",(0,a.kt)("em",null,"AI05-0054-2"),"}"," ",(0,a.kt)("br",null),"The value of a constant object cannot be changed after its initialization, except in some cases where the object has a controlled or immutably limited part (see 7.5, 7.6, and 13.9.1).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 3   ","{",(0,a.kt)("em",null,"AI05-0264-1"),"}"," ",(0,a.kt)("br",null),"The nominal and actual subtypes of an elementary object are always the same. For a discriminated or array object, if the nominal subtype is constrained, then so is the actual subtype. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"There are additional kinds of objects (choice parameters and entry indices of entry bodies).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The result of a function and of evaluating an aggregate are considered (constant) objects. This is necessary to explain the action of finalization on such things. Because a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," is also syntactically a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," (see 4.1), the result of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," can be renamed, thereby allowing repeated use of the result without calling the function again. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"This subclause now follows the subclauses on types and subtypes, to cut down on the number of forward references.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'The term nominal subtype is new. It is used to distinguish what is known at compile time about an object\'s constraint, versus what its "true" run-time constraint is.',(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The terms definite and indefinite (which apply to subtypes) are new. They are used to aid in the description of generic formal type matching, and to specify when an explicit initial value is required in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),".",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We have moved the syntax for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration"))," down into their respective subclauses, to keep the syntax close to the description of the associated semantics.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We talk about variables and constants here, since the discussion is not specific to ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),"s, and it seems better to have the list of the kinds of constants juxtaposed with the kinds of objects.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We no longer talk about indirect updating due to parameter passing. Parameter passing is handled in 6.2 and 6.4.1 in a way that there is no need to mention it here in the definition of read and update. Reading and updating now includes the case of evaluating or assigning to an enclosing object. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00416-01"),"}"," ",(0,a.kt)("br",null),"Clarified that the return object is the object created by a function call. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0015-1"),"}"," ",(0,a.kt)("br",null),"Added wording to allow return objects to be declared as constants, and corrected the definition of return objects as objects. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0041-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0093-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," Added a definition of ",(0,a.kt)("em",null,"known to be constrained"),", for use in other rules.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0054-2"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," We now recognize the fact that not all declared constant objects are immutable; for those that a variable view can be constructed, they can be changed via that view.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0120-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," Added the current instance of a protected object to the list of constant views; since the list claims to include all possibilities, it had better include that one.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0003-1"),"}"," ",(0,a.kt)("br",null),"The result of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," is defined to be a constant view and is defined to be an object if the operand of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," is an object. These definitions, combined with some grammar changes, allow ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),"s to be used in more places. See 4.1 for details. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null)),' Corrected the definition of "known to be constrained" so that the status of the operand of value conversions and ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),"s is always used to determine whether the property exists. As the rules are ",(0,a.kt)("strong",null,"or"),"ed together, a value conversion or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),' with a constrained nominal subtype would have always met the requirements in Ada 2012, regardless of the operand. This change will mean that some conversions or qualifications (mostly of variables) will no longer be considered "known to be constrained" and therefore \'Access and renaming of such ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es will now be illegal. This is necessary to meet the design goal that subsequent execution cannot cause a renaming or 'Access to cause erroneous execution. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0228-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," of an object that is known to be constrained is now also known to be constrained. This allows qualification to be used to disambiguate a function call used as a prefix in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," without making the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," illegal.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0226-1"),"}"," ",(0,a.kt)("br",null),"A value conversion of an object is an object; this makes value conversions consistent with qualified expressions. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0392-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," Changed from a list of constants to a list of variables. This makes the default to be a constant, which is the more common case, and eliminates issues caused by omissions from the list (such as parenthesized expressions).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0422-1"),"}"," ",(0,a.kt)("br",null),'Added the term "known to have no variable views" in order to have a definition that can be used in Legality Rules without breaking privacy. ',(0,a.kt)("br",null)),(0,a.kt)("h2",k({},{id:"331--object-declarations"}),"3.3.1  Object Declarations"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ",(0,a.kt)("br",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," declares a ",(0,a.kt)("em",null,"stand-alone")," object with a given nominal subtype and, optionally, an explicit initial value given by an initialization expression. For an array, access, task, or protected object, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," may include the definition of the (anonymous) type of the object. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"syntax"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00406-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("br",null),(0,a.kt)("code",null,"object_declaration"),(0,a.kt)("a",{id:"S0032"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : [",(0,a.kt)("strong",null,"aliased"),"] [",(0,a.kt)("strong",null,"constant"),"] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," [:= ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"]",(0,a.kt)("br",null),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];",(0,a.kt)("br",null),"  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : [",(0,a.kt)("strong",null,"aliased"),"] [",(0,a.kt)("strong",null,"constant"),"] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," [:= ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"]",(0,a.kt)("br",null),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];",(0,a.kt)("br",null),"  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : [",(0,a.kt)("strong",null,"aliased"),"] [",(0,a.kt)("strong",null,"constant"),"] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition"))," [:= ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"]",(0,a.kt)("br",null),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];",(0,a.kt)("br",null),"  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0245"},"single_task_declaration")),(0,a.kt)("br",null),"  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0250"},"single_protected_declaration")),(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"defining_identifier_list"),(0,a.kt)("a",{id:"S0033"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"  ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," ","{",", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"}",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)("p",null,"For an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," with an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," following the compound delimiter :=, the type expected for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is that of the object. This ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is called the ",(0,a.kt)("em",null,"initialization expression"),". ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00287-01"),"}"," ",(0,a.kt)("br",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," without the reserved word ",(0,a.kt)("strong",null,"constant")," declares a variable object. If it has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition"))," that defines an indefinite subtype, then there shall be an initialization expression. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0264-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," with the reserved word ",(0,a.kt)("strong",null,"constant")," declares a constant object. If it has an initialization expression, then it is called a ",(0,a.kt)("em",null,"full constant declaration"),". Otherwise, it is called a ",(0,a.kt)("em",null,"deferred constant declaration"),". The rules for deferred constant declarations are given in subclause 7.4. The rules for full constant declarations are given in this subclause.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"Any declaration that includes a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," with more than one ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," is equivalent to a series of declarations each containing one ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," from the list, with the rest of the text of the declaration copied for each declaration in the series, in the same order as the list. The remainder of this Reference Manual relies on this equivalence; explanations are given for declarations with a single ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),".",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ",(0,a.kt)("br",null),"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", or full type definition of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," defines the nominal subtype of the object. The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," declares an object of the type of the nominal subtype. ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ",(0,a.kt)("br",null),'The phrase "full type definition" here includes the case of an anonymous array, access, task, or protected type. ',(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0192-1"),"}"," ",(0,a.kt)("br",null),"A component of an object is said to ",(0,a.kt)("em",null,"require late initialization")," if: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0192-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0404-1"),"}"," ",(0,a.kt)("br",null),"it has an access discriminant value constrained by a per-object expression; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0192-1"),"}"," ",(0,a.kt)("br",null),"it has an initialization expression that includes a name denoting an access discriminant; or",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0192-1"),"}"," ",(0,a.kt)("br",null),"it has an initialization expression that includes a reference to the current instance of the type either by name or implicitly as the target object of a call. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Such components can depend on the values of other components of the object. We want to initialize them as late and as reproducibly as possible. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00363-01"),"}"," ",(0,a.kt)("br",null),"If a composite object declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," has an unconstrained nominal subtype, then if this subtype is indefinite or the object is constant the actual subtype of this object is constrained. The constraint is determined by the bounds or discriminants (if any) of its initial value; the object is said to be ",(0,a.kt)("em",null,"constrained by its initial value"),". When not constrained by its initial value, the actual and nominal subtypes of the object are the same. If its actual subtype is constrained, the object is called a ",(0,a.kt)("em",null,"constrained object"),".",(0,a.kt)("br",null)),(0,a.kt)("p",null,"For an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," without an initialization expression, any initial values for the object or its subcomponents are determined by the ",(0,a.kt)("em",null,"implicit initial values")," defined for its nominal subtype, as follows: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"The implicit initial value for an access subtype is the null value of the access type.",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0228-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0439-1"),"}"," ",(0,a.kt)("br",null),'The implicit initial value for a scalar subtype that has the Default_Value aspect specified is the value of that aspect converted to the nominal subtype (which can raise Constraint_Error - see 4.6, "Type Conversions");',(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"This is a Dynamic Semantics rule, so the visibility of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," is not relevant - if the full type for a private type has the Default_Value aspect specified, partial views of the type also have this implicit initial value. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"The implicit initial (and only) value for each discriminant of a constrained discriminated subtype is defined by the subtype.",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI05-0228-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0439-1"),"}"," ",(0,a.kt)("br",null),"For a (definite) composite subtype, the implicit initial value of each component with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is obtained by evaluation of this expression and conversion to the component's nominal subtype (which can raise Constraint_Error), unless the component is a discriminant of a constrained subtype (the previous case), or is in an excluded ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.8#S0072"},"variant"))," (see 3.8.1). For each component that does not have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),", if the composite subtype has the Default_Component_Value aspect specified, the implicit initial value is the value of that aspect converted to the component's nominal subtype; otherwise, any implicit initial values are those determined by the component's nominal subtype.",(0,a.kt)("br",null)),(0,a.kt)("li",null,"For a protected or task subtype, there is an implicit component (an entry queue) corresponding to each entry, with its implicit initial value being an empty queue. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The implementation may add implicit components for its own use, which might have implicit initial values. For a task subtype, such components might represent the state of the associated thread of control. For a type with dynamic-sized components, such implicit components might be used to hold the offset to some explicit component. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"The elaboration of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," proceeds in the following sequence of steps: ",(0,a.kt)("br",null)),(0,a.kt)("dt",null,(0,a.kt)("br",null),"a)"),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ",(0,a.kt)("br",null),"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0245"},"single_task_declaration")),", or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0250"},"single_protected_declaration"))," is first elaborated. This creates the nominal subtype (and the anonymous type in the last four cases).",(0,a.kt)("br",null)),(0,a.kt)("dt",null,(0,a.kt)("br",null),"b)"),(0,a.kt)("dd",null,"{",(0,a.kt)("em",null,"AI12-0439-1"),"}"," ",(0,a.kt)("br",null),"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," includes an initialization expression, the (explicit) initial value is obtained by evaluating the expression and converting it to the nominal subtype (which can raise Constraint_Error - see 4.6). ",(0,a.kt)("br",null)),(0,a.kt)("dt",null,(0,a.kt)("br",null),"c)"),(0,a.kt)("dd",null,"{",(0,a.kt)("em",null,"8652/0002"),"}"," ","{",(0,a.kt)("em",null,"AI95-00171-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"The object is created, and, if there is not an initialization expression, the object is ",(0,a.kt)("em",null,"initialized by default"),". When an object is initialized by default, any per-object constraints (see 3.8) are elaborated and any implicit initial values for the object or for its subcomponents are obtained as determined by the nominal subtype. Any initial values (whether explicit or implicit) are assigned to the object or to the corresponding subcomponents. As described in 5.2 and 7.6, Initialize and Adjust procedures can be called. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"For a per-object constraint that contains some per-object expressions and some non-per-object expressions, the values used for the constraint consist of the values of the non-per-object expressions evaluated at the point of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration")),", and the values of the per-object expressions evaluated at the point of the creation of the object.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The elaboration of per-object constraints was presumably performed as part of the dependent compatibility check in Ada 83. If the object is of a limited type with an access discriminant, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," is elaborated at this time (see 3.7). ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'The reason we say that evaluating an explicit initialization expression happens before creating the object is that in some cases it is impossible to know the size of the object being created until its initial value is known, as in "X: String := Func_Call(...);". The implementation can create the object early in the common case where the size can be known early, since this optimization is semantically neutral. ',(0,a.kt)("br",null)),(0,a.kt)("dt",null,(0,a.kt)("br",null)),(0,a.kt)("dl",null,(0,a.kt)("dd",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Since the initial values have already been converted to the appropriate nominal subtype, the only Constraint_Errors that might occur as part of these assignments are for values outside their base range that are used to initialize unconstrained numeric subcomponents. See 3.5. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"For the third step above, evaluations and assignments are performed in an arbitrary order subject to the following restrictions: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"Assignment to any part of the object is preceded by the evaluation of the value that is to be assigned. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'Duh. But we ought to say it. Note that, like any rule in the Reference Manual, it doesn\'t prevent an "as-if" optimization; as long as the semantics as observed from the program are correct, the compiler can generate any code it wants. ',(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," that includes the name of a discriminant is preceded by the assignment to that discriminant. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Duh again. But we have to say this, too. It's odd that Ada 95 only required the default expressions to be evaluated before the discriminant is used; it says nothing about discriminant values that come from ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),"s. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"The evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," for any component that depends on a discriminant is preceded by the assignment to that discriminant. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"For example: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"type R(D : Integer := F) is","\n","    record","\n","        S : String(1..D) := (others =",">"," G);","\n","    end record;","\n","X : R;","\n"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"For the elaboration of the declaration of X, it is important that F be evaluated before the aggregate. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0092-1"),"}"," ",(0,a.kt)("br",null),"The assignments to any components, including implicit components, not requiring late initialization precede the initial value evaluations for any components requiring late initialization; if two components both require late initialization, then assignments to parts of the component occurring earlier in the order of the component declarations precede the initial value evaluations of the component occurring later. ",(0,a.kt)("br",null))),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Components that require late initialization can refer to the entire object during their initialization. We want them to be initialized as late as possible to reduce the chance that their initialization depends on uninitialized components. For instance: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"type T (D : Natural) is","\n","  limited record","\n","    C1 : T1 (T'Access);","\n","    C2 : Natural := F (D);","\n","    C3 : String (1 .. D) := (others =",">"," ' ');","\n","  end record;","\n"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Component C1 requires late initialization. The initialization could depend on the values of any component of T, including D, C2, or C3. Therefore, we want to it to be initialized last. Note that C2 and C3 do not require late initialization; they only have to be initialized after D.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"It is possible for there to be more than one component that requires late initialization. In this case, the language can't prevent problems, because all of the components can't be the last one initialized. In this case, we specify the order of initialization for components requiring late initialization; by doing so, programmers can arrange their code to avoid accessing uninitialized components, and such arrangements are portable. Note that if the program accesses an uninitialized component, 13.9.1 defines the execution to be erroneous. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0228-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0439-1"),"}"," ",(0,a.kt)("br",null),"[There is no implicit initial value defined for a scalar subtype unless the Default_Value aspect has been specified for the type.] In the absence of an explicit initialization or the specification of the Default_Value aspect, a newly created scalar object can have a value that does not belong to its subtype (see 13.9.1 and H.1). ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),'It could even be represented by a bit pattern that doesn\'t actually represent any value of the type at all, such as an invalid internal code for an enumeration type, or a NaN for a floating point type. It is a generally a bounded error to reference scalar objects with such "invalid representations", as explained in 13.9.1, "Data Validity". ',(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'There is no requirement that two objects of the same scalar subtype have the same implicit initial "value" (or representation). It might even be the case that two elaborations of the same ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," produce two different initial values. However, any particular uninitialized object is default-initialized to a single value (or invalid representation). Thus, multiple reads of such an uninitialized object will produce the same value each time (if the implementation chooses not to detect the error). ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 1   Implicit initial values are not defined for an indefinite subtype, because if an object's nominal subtype is indefinite, an explicit initial value is required.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 2   ","{",(0,a.kt)("em",null,"AI05-0092-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0255-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0061-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," ",(0,a.kt)("br",null),"As indicated above, a stand-alone object is an object declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),'. Similar definitions apply to "stand-alone constant" and "stand-alone variable". A subcomponent of an object is not a stand-alone object, nor is an object that is created by an ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.8#S0164"},"allocator")),". An object declared by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0119"},"iterated_component_association")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0306"},"choice_parameter_specification")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.5#S0225"},"extended_return_statement")),", or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.4#S0319"},"formal_object_declaration"))," of mode ",(0,a.kt)("strong",null,"in out")," is not considered a stand-alone object.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 3   The type of a stand-alone object cannot be abstract (see 3.9.3). ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"examples"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of a multiple object declaration:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"--  the multiple object declaration ","\n","--  ","{","AI95-00433-01","}","\n"," John, Paul : not null Person_Name := new Person(Sex =",">"," M);  --  see 3.10.1","\n","--  is equivalent to the two single object declarations in the order given","\n","--  ","{","AI95-00433-01","}","\n"," John : not null Person_Name := new Person(Sex =",">"," M);","\n","Paul : not null Person_Name := new Person(Sex =",">"," M);","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of variable declarations:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"--  ","{","AI95-00433-01","}","\n"," --  ","{","AI12-0430-1","}","\n"," Count, Sum  : Integer;","\n","Size        : Integer range 0 .. 10_000 := 0;","\n","Sorted      : Boolean := False;","\n","Color_Table : array(1 .. Max) of Color;","\n","Option      : Bit_Vector(1 .. 10) := (others =",">"," True); -- see 3.6","\n",'Hello       : aliased String := "Hi, world.";',"\n",",         : Float range - .. +;","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of constant declarations:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"--  ","{","AI95-00433-01","}","\n"," --  ","{","AI12-0425-1","}","\n"," Limit     : constant Integer := 10_000;","\n","Low_Limit : constant Integer := Limit/10;","\n","Tolerance : constant Real := Dispersion(1.15);","\n",'A_String  : constant String := "A";',"\n","Hello_Msg : constant access String := Hello'Access; -- see 3.10.2","\n"),(0,a.kt)("h4",k({},{id:"extensions-to-ada-83-1"}),"Extensions to Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," is modified to allow the ",(0,a.kt)("strong",null,"aliased")," reserved word.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"A variable declared by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," can be constrained by its initial value; that is, a variable of a nominally unconstrained array subtype, or discriminated type without defaults, can be declared so long as it has an explicit initial value. In Ada 83, this was permitted for constants, and for variables created by allocators, but not for variables declared by ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),"s. This is particularly important for tagged class-wide types, since there is no way to constrain them explicitly, and so an initial value is the only way to provide a constraint. It is also important for generic formal private types with unknown discriminants.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We now allow an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0052"},"unconstrained_array_definition"))," in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),'. This allows an object of an anonymous array type to have its bounds determined by its initial value. This is for uniformity: If one can write "X: ',(0,a.kt)("strong",null,"constant")," ",(0,a.kt)("strong",null,"array"),"(Integer ",(0,a.kt)("strong",null,"range")," 1..10) ",(0,a.kt)("strong",null,"of"),' Integer := ...;" then it makes sense to also allow "X: ',(0,a.kt)("strong",null,"constant")," ",(0,a.kt)("strong",null,"array"),"(Integer ",(0,a.kt)("strong",null,"range")," ","<",">",") ",(0,a.kt)("strong",null,"of")," Integer := ...;\". (Note that if anonymous array types are ever sensible, a common situation is for a table implemented as an array. Tables are often constant, and for constants, there's usually no point in forcing the user to count the number of elements in the value.) ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-83-1"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We have moved the syntax for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),"s into this subclause.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Deferred constants no longer have a separate syntax rule, but rather are incorporated in ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," as constants declared without an initialization expression. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"inconsistencies-with-ada-95"}),"Inconsistencies With Ada 95"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00363-01"),"}"," ",(0,a.kt)("br",null),"Unconstrained aliased objects of types with discriminants with defaults are no longer constrained by their initial values. This means that a program that raised Constraint_Error from an attempt to change the discriminants will no longer do so. The change only affects programs that depended on the raising of Constraint_Error in this case, so the inconsistency is unlikely to occur outside of the ACATS. This change may however cause compilers to implement these objects differently, possibly taking additional memory or time. This is unlikely to be worse than the differences caused by any major compiler upgrade. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00287-01"),"}"," ",(0,a.kt)("br",null),"A constant may have a limited type; the initialization ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," has to be built-in-place (see 7.5).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00385-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00406-01"),"}"," ",(0,a.kt)("br",null),"A stand-alone object may have an anonymous access type. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-95-1"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"8652/0002"),"}"," ","{",(0,a.kt)("em",null,"AI95-00171-01"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null),"Corrigendum:")," Corrected wording to say that per-object constraints are elaborated (not evaluated).",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00373-01"),"}"," ",(0,a.kt)("br",null),"The rules for evaluating default initialization have been tightened. In particular, components whose default initialization can refer to the rest of the object are required to be initialized last.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00433-01"),"}"," ",(0,a.kt)("br",null),"Added examples of various new constructs. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("br",null),"An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),". This is described in 13.1.1. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-2005-1"}),"Wording Changes from Ada 2005"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0228-1"),"}"," ",(0,a.kt)("br",null),"Implicit initial values can now be given for scalar types and for scalar array components, using the Default_Value (see 3.5) and Default_Component_Value (see 3.6) aspects; the extension is documented there. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"inconsistencies-with-ada-2012"}),"Inconsistencies With Ada 2012"),(0,a.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0192-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," Components of a protected type require late initialization if their initialization includes (implicitly) the current instance of the type. This means that the components could end up being initialized in a different order. In most cases, this will have no visible effect, or will even fix bugs. Most code for which this is an issue depends on the (unspecified) order of initialization, so it is at risk of failing with a new compiler version regardless of Ada rule changes. However, there do exist very unlikely cases where legal, portable Ada 2012 code would become erroneous. (See the discussion section of ","AI12-0192-1"," ",(0,a.kt)("br",null),"for an example.) These are so unlikely that it is expected that they only exist in the minds of Ada lawyers. ",(0,a.kt)("br",null)),(0,a.kt)("h2",k({},{id:"332--number-declarations"}),"3.3.2  Number Declarations"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration"))," declares a named number. ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"If a value or other property of a construct is required to be ",(0,a.kt)("em",null,"static")," that means it is required to be determined prior to execution. A ",(0,a.kt)("em",null,"static")," expression is an expression whose value is computed at compile time and is usable in contexts where the actual value might affect the legality of the construct. This is fully defined in subclause 4.9. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"syntax-1"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"number_declaration"),(0,a.kt)("a",{id:"S0034"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"     ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : ",(0,a.kt)("strong",null,"constant")," := ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),";",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," given for a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration"))," is expected to be of any numeric type.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0394-1"),"}"," ",(0,a.kt)("br",null),"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration"))," is interpreted as a value of a universal type, unless the expected type for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a non-numeric type with an Integer_Literal or Real_Literal aspect, in which case it is interpreted to be of its expected type.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"This is only a Name Resolution Rule; all named numbers are values of a universal type (see the Static Semantics below). We need this rule so that named numbers can match types with user-defined literals; we need the other rules so the value of the named number is well-defined in all cases. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"legality-rules-1"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"The ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," given for a number declaration shall be a static expression, as defined by subclause 4.9. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"static-semantics-2"}),"Static Semantics"),(0,a.kt)("p",null,"The named number denotes a value of type ",(0,a.kt)("em",null,"universal_integer")," if the type of the ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is an integer type. The named number denotes a value of type ",(0,a.kt)("em",null,"universal_real")," if the type of the ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is a real type.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"The value denoted by the named number is the value of the ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", converted to the corresponding universal type. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,a.kt)("p",null,"The elaboration of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0034"},"number_declaration"))," has no effect. ",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"proof",title:"Proof: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Since the ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," was evaluated at compile time. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"examples-1"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of number declarations:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"Two_Pi        : constant := 2.0*Ada.Numerics.Pi;   -- a real number (see A.5)","\n","--  ","{","AI95-00433-01","}","\n"," Max           : constant := 500;                   -- an integer number","\n","Max_Line_Size : constant := Max/6;                 -- the integer 83","\n","Power_16      : constant := 2**16;                 -- the integer 65_536","\n","One, Un, Eins : constant := 1;                     -- three different names for 1","\n"),(0,a.kt)("h4",k({},{id:"extensions-to-ada-83-2"}),"Extensions to Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We now allow a static expression of any numeric type to initialize a named number. For integer types, it was possible in Ada 83 to use 'Pos to define a named number, but there was no way to use a static expression of some nonuniversal real type to define a named number. This change is upward compatible because of the preference rule for the operators of the root numeric types. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"wording-changes-from-ada-83-2"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"We have moved the syntax rule into this subclause.",(0,a.kt)("br",null)),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"AI83-00263 describes the elaboration of a number declaration in words similar to that of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),". However, since there is no expression to be evaluated and no object to be created, it seems simpler to say that the elaboration has no effect. ",(0,a.kt)("br",null)),(0,a.kt)("h4",k({},{id:"extensions-to-ada-2012-1"}),"Extensions to Ada 2012"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0394-1"),"}"," ",(0,a.kt)("br",null),"Named numbers now can be used with (non-numeric) types that define user-defined literals (see 4.2.1). ",(0,a.kt)("br",null)))}g.isMDXComponent=!0}}]);