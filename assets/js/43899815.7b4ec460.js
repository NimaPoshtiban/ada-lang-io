"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2619],{1716:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(6687);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=i,m=u["".concat(c,".").concat(h)]||u[h]||d[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(9440),i=(n(6687),n(1716));const r={sidebar_position:90},o="11.4  Exception Handling",s={unversionedId:"arm/AA-11.4",id:"arm/AA-11.4",title:"11.4  Exception Handling",description:"When an exception occurrence is raised, normal program execution is abandoned and control is transferred to an applicable [exception_handler, if any. To handle an exception occurrence is to respond to the exceptional event. To propagate an exception occurrence is to raise it again in another context; that is, to fail to respond to the exceptional event in the present context.]",source:"@site/docs/arm/AA-11.4.md",sourceDirName:"arm",slug:"/arm/AA-11.4",permalink:"/docs/arm/AA-11.4",draft:!1,tags:[],version:"current",sidebarPosition:90,frontMatter:{sidebar_position:90},sidebar:"tutorialSidebar",previous:{title:"11.3  Raise Statements and Raise Expressions",permalink:"/docs/arm/AA-11.3"},next:{title:"11.5  Suppressing Checks",permalink:"/docs/arm/AA-11.5"}},c={},l=[{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"11.4.1  The Package Exceptions",id:"1141--the-package-exceptions",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"11.4.2  Pragmas Assert and Assertion_Policy",id:"1142--pragmas-assert-and-assertion_policy",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"11.4.3  Example of Exception Handling",id:"1143--example-of-exception-handling",level:2},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"114--exception-handling"},"11.4  Exception Handling"),(0,i.kt)("p",null,"[When an exception occurrence is raised, normal program execution is abandoned and control is transferred to an applicable ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.2#S0305"},"exception_handler"),", if any. To handle an exception occurrence is to respond to the exceptional event. To propagate an exception occurrence is to raise it again in another context; that is, to fail to respond to the exceptional event in the present context.] "),(0,i.kt)("p",null,"Ramification: In other words, if the execution of a given construct raises an exception, but does not handle it, the exception is propagated to an enclosing execution (except in the case of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0248"},"task_body"),")."),(0,i.kt)("p",null,"Propagation involves re-raising the same exception occurrence. For example, calling an entry of an uncallable task raises Tasking_Error; this is not propagation. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"Within a given task, if the execution of construct a is defined by this document to consist (in part) of the execution of construct b, then while b is executing, the execution of a is said to dynamically enclose the execution of b. The innermost dynamically enclosing execution of a given execution is the dynamically enclosing execution that started most recently. "),(0,i.kt)("p",null,"To be honest: If the execution of a dynamically encloses that of b, then we also say that the execution of b is included in the execution of a. "),(0,i.kt)("p",null,"Ramification: Examples: The execution of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.3#S0175"},"if_statement")," dynamically encloses the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition"),' after the if (during that evaluation). (Recall that "execution" includes both "elaboration" and "evaluation", as well as other executions.) The evaluation of a function call dynamically encloses the execution of the ',(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0166"},"sequence_of_statements")," of the function ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.11#S0089"},"body")," (during that execution). Note that, due to recursion, several simultaneous executions of the same construct can be occurring at once during the execution of a particular task."),(0,i.kt)("p",null,"Dynamically enclosing is not defined across task boundaries; a task's execution does not include the execution of any other tasks."),(0,i.kt)("p",null,"Dynamically enclosing is only defined for executions that are occurring at a given moment in time; if an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.3#S0175"},"if_statement")," is currently executing the ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0166"},"sequence_of_statements")," after then, then the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition")," is no longer dynamically enclosed by the execution of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.3#S0175"},"if_statement")," (or anything else). "),(0,i.kt)("p",null,"When an exception occurrence is raised by the execution of a given construct, the rest of the execution of that construct is abandoned; that is, any portions of the execution that have not yet taken place are not performed. The construct is first completed, and then left, as explained in 7.6.1. Then: "),(0,i.kt)("p",null,"If the construct is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0248"},"task_body"),", the exception does not propagate further; "),(0,i.kt)("p",null,"Ramification: When an exception is raised by the execution of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0248"},"task_body"),", there is no dynamically enclosing execution, so the exception does not propagate any further. If the exception occurred during the activation of the task, then the activator raises Tasking_Error, as explained in 9.2, \"Task Execution - Task Activation\", but we don't define that as propagation; it's a special rule. Otherwise (the exception occurred during the execution of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements")," of the task), the task silently disappears. Thus, abnormal termination of tasks is not always considered to be an error. "),(0,i.kt)("p",null,"If the construct is the ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0166"},"sequence_of_statements")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements")," that has a handler with a choice covering the exception, the occurrence is handled by that handler;"),(0,i.kt)("p",null,"Otherwise, the occurrence is propagated to the innermost dynamically enclosing execution, which means that the occurrence is raised again in that context. "),(0,i.kt)("p",null,"To be honest: As shorthands, we refer to the propagation of an exception, and the propagation by a construct, if the execution of the construct propagates an exception occurrence. "),(0,i.kt)("p",null,"When an occurrence is handled by a given handler, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.2#S0306"},"choice_parameter_specification"),", if any, is first elaborated, which creates the choice parameter and initializes it to the occurrence. Then, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0166"},"sequence_of_statements")," of the handler is executed; this execution replaces the abandoned portion of the execution of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0166"},"sequence_of_statements"),". "),(0,i.kt)("p",null,'Ramification: {AI95-00318-02} This "replacement" semantics implies that the handler can do pretty much anything the abandoned sequence could do; for example, in a function, the handler can execute a return statement that applies to the function. '),(0,i.kt)("p",null,"Ramification: The rules for exceptions raised in library units, main subprograms and partitions follow from the normal rules, plus the semantics of the environment task described in Clause 10 (for example, the environment task of a partition elaborates library units and calls the main subprogram). If an exception is propagated by the main subprogram, it is propagated to the environment task, which then terminates abnormally, causing the partition to terminate abnormally. Although abnormal termination of tasks is not necessarily an error, abnormal termination of a partition due to an exception is an error. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[handle an exception]",", Def=","[performing some actions in response to the arising of an exception]"," "),(0,i.kt)("p",null,"NOTE 1   Note that exceptions raised in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part")," of a body are not handled by the handlers of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements")," of that body. "),(0,i.kt)("h2",{id:"1141--the-package-exceptions"},"11.4.1  The Package Exceptions"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00362-01} {AI95-00400-01} {AI95-00438-01} {AI12-0241-1} {AI12-0302-1} {AI12-0399-1} with Ada.Streams;\npackage Ada.Exceptions \n    with Preelaborate, Nonblocking, Global =&gt in out synchronized is\n    type Exception_Id is private\n        with Preelaborable_Initialization;\n    Null_Id : constant Exception_Id;\n    function Exception_Name(Id : Exception_Id) return String;\n    function Wide_Exception_Name(Id : Exception_Id) return Wide_String;\n    function Wide_Wide_Exception_Name(Id : Exception_Id)\n        return Wide_Wide_String;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00362-01} {AI12-0399-1}     type Exception_Occurrence is limited private\n        with Preelaborable_Initialization;\n    type Exception_Occurrence_Access is access all Exception_Occurrence;\n    Null_Occurrence : constant Exception_Occurrence;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'{AI95-00329-01} {AI05-0229-1}     procedure Raise_Exception(E : in Exception_Id;\n                              Message : in String := "")\n        with No_Return;\n    function Exception_Message(X : Exception_Occurrence) return String;\n    procedure Reraise_Occurrence(X : in Exception_Occurrence);\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00400-01}     function Exception_Identity(X : Exception_Occurrence)\n                                return Exception_Id;\n    function Exception_Name(X : Exception_Occurrence) return String;\n        -- Same as Exception_Name(Exception_Identity(X)).\n    function Wide_Exception_Name(X : Exception_Occurrence)\n        return Wide_String;\n        -- Same as Wide_Exception_Name(Exception_Identity(X)).\n    function Wide_Wide_Exception_Name(X : Exception_Occurrence)\n        return Wide_Wide_String;\n        -- Same as Wide_Wide_Exception_Name(Exception_Identity(X)).\n    function Exception_Information(X : Exception_Occurrence) return String;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00438-01}     procedure Save_Occurrence(Target : out Exception_Occurrence;\n                              Source : in Exception_Occurrence);\n    function Save_Occurrence(Source : Exception_Occurrence)\n                             return Exception_Occurrence_Access;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00438-01}     procedure Read_Exception_Occurrence\n       (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n        Item   : out Exception_Occurrence);\n    procedure Write_Exception_Occurrence\n       (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n        Item   : in Exception_Occurrence);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00438-01}     for Exception_Occurrence'Read use Read_Exception_Occurrence;\n    for Exception_Occurrence'Write use Write_Exception_Occurrence;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00438-01} private\n   ... -- not specified by the language\nend Ada.Exceptions;\n\n")),(0,i.kt)("p",null,"Each distinct exception is represented by a distinct value of type Exception_Id. Null_Id does not represent any exception, and is the default initial value of type Exception_Id. Each occurrence of an exception is represented by a value of type Exception_Occurrence. Null_Occurrence does not represent any exception occurrence, and is the default initial value of type Exception_Occurrence."),(0,i.kt)("p",null,"For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," E that denotes an exception, the following attribute is defined: "),(0,i.kt)("p",null,"E'IdentityE'Identity returns the unique identity of the exception. The type of this attribute is Exception_Id. "),(0,i.kt)("p",null,"Ramification: In a distributed program, the identity is unique across an entire program, not just across a single partition. Exception propagation works properly across RPC's. An exception can be propagated from one partition to another, and then back to the first, where its identity is known. "),(0,i.kt)("p",null,"{AI95-00361-01} Raise_Exception raises a new occurrence of the identified exception."),(0,i.kt)("p",null,"{AI95-00361-01} {AI95-00378-01} {AI05-0043-1} {AI05-0248-1} {AI12-0022-1} {AI12-0152-1} Exception",(0,i.kt)("em",{parentName:"p"},"Message returns the message associated with the given Exception_Occurrence. For an occurrence raised by a call to Raise_Exception, the message is the Message parameter passed to Raise_Exception. For the occurrence raised by a ",(0,i.kt)("a",{parentName:"em",href:"./AA-11.3#S0308"},"raise_statement")," or ",(0,i.kt)("a",{parentName:"em",href:"./AA-11.3#S0309"},"raise_expression")," with an exception"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," and a string",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," or string"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),", the message is the string",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," or string"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),". For the occurrence raised by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," with an exception",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.1#S0091"},"name")," but without a string"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," or string_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),", the message is a string giving implementation-defined information about the exception occurrence. For an occurrence originally raised in some other manner (including by the failure of a language-defined check), the message is an unspecified string. In all cases, Exception_Message returns a string with lower bound 1. "),(0,i.kt)("p",null,"Implementation defined: The information returned by Exception_Message."),(0,i.kt)("p",null,"Discussion: {AI05-0043-1} There is Implementation Advice about the contents of this string for language-defined checks. "),(0,i.kt)("p",null,"Ramification: Given an exception E, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement"),": "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"raise E;\n\n")),(0,i.kt)("p",null,"is equivalent to this call to Raise_Exception: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Raise_Exception(E'Identity, Message =&gt implementation-defined-string);\n\n")),(0,i.kt)("p",null,"{AI95-00361-01} Similarly, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement"),": "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'raise E with "some information";\n\n')),(0,i.kt)("p",null,"is equivalent to this call to Raise_Exception: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Raise_Exception(E\'Identity, Message =&gt "some information");\n\n')),(0,i.kt)("p",null,"{AI95-00361-01} Reraise_Occurrence reraises the specified exception occurrence."),(0,i.kt)("p",null,"Ramification: The following handler: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"when others =&gt\n    Cleanup;\n    raise;\n\n")),(0,i.kt)("p",null,"is equivalent to this one: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"when X : others =&gt\n    Cleanup;\n    Reraise_Occurrence(X);\n\n")),(0,i.kt)("p",null,"Exception_Identity returns the identity of the exception of the occurrence."),(0,i.kt)("p",null,"{AI95-00400-01} The Wide_Wide_Exception_Name functions return the full expanded name of the exception, in upper case, starting with a root library unit. For an exception declared immediately within package Standard, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," is returned. The result is implementation defined if the exception is declared within an unnamed ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.6#S0191"},"block_statement"),". "),(0,i.kt)("p",null,"Ramification: See the Implementation Permission below. "),(0,i.kt)("p",null,"To be honest: This name, as well as each ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," of it, does not denote a ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.5#S0238"},"renaming_declaration"),". "),(0,i.kt)("p",null,"Implementation defined: The result of Exceptions.Wide_Wide_Exception_Name for exceptions declared within an unnamed ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.6#S0191"},"block_statement"),"."),(0,i.kt)("p",null,"Ramification: Note that we're talking about the name of the exception, not the name of the occurrence. "),(0,i.kt)("p",null,"{AI95-00400-01} The Exception_Name functions (respectively, Wide_Exception_Name) return the same sequence of graphic characters as that defined for Wide_Wide_Exception_Name, if all the graphic characters are defined in Character (respectively, Wide_Character); otherwise, the sequence of characters is implementation defined, but no shorter than that returned by Wide_Wide_Exception_Name for the same value of the argument. "),(0,i.kt)("p",null,"Implementation defined: The sequence of characters of the value returned by Exceptions.Exception_Name (respectively, Exceptions.Wide_Exception_Name) when some of the graphic characters of Exceptions.Wide_Wide_Exception_Name are not defined in Character (respectively, Wide_Character)."),(0,i.kt)("p",null,"{AI95-00378-01} {AI95-00417-01} The string returned by the Exception_Name, Wide_Exception_Name, and Wide_Wide_Exception_Name functions has lower bound 1."),(0,i.kt)("p",null,"{AI95-00378-01} Exception_Information returns implementation-defined information about the exception occurrence. The returned string has lower bound 1. "),(0,i.kt)("p",null,"Implementation defined: The information returned by Exception_Information."),(0,i.kt)("p",null,"{AI95-00241-01} {AI95-00446-01} Reraise_Occurrence has no effect in the case of Null_Occurrence. Raise_Exception and Exception_Name raise Constraint_Error for a Null_Id. Exception_Message, Exception_Name, and Exception_Information raise Constraint_Error for a Null_Occurrence. Exception_Identity applied to Null_Occurrence returns Null_Id."),(0,i.kt)("p",null,"Ramification: {AI95-00241-01} Null_Occurrence can be tested for by comparing Exception_Identity(Occurrence) to Null_Id. "),(0,i.kt)("p",null,"Discussion: {AI95-00446-01} Raise_Exception was changed so that it always raises an exception and thus can be a No_Return procedure. A similar change was not made for Reraise_Occurrence, as doing so was determined to be a significant incompatibility. It is not unusual to pass an Exception_Occurrence to other code to delay raising it. If there was no exception, passing Null_Occurrence works fine (nothing is raised). Moreover, as there is no test for Null_Occurrence in Ada 95, this is the only way to write such code without using additional flags. Breaking this sort of code is unacceptable. "),(0,i.kt)("p",null,"The Save_Occurrence procedure copies the Source to the Target. The Save_Occurrence function uses an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.8#S0164"},"allocator")," of type Exception_Occurrence_Access to create a new object, copies the Source to this new object, and returns an access value designating this new object; ","[the result may be deallocated using an instance of Unchecked_Deallocation.]"," "),(0,i.kt)("p",null,"Ramification: It's OK to pass Null_Occurrence to the Save_Occurrence subprograms; they don't raise an exception, but simply save the Null_Occurrence. "),(0,i.kt)("p",null,"{AI95-00438-01} Write_Exception_Occurrence writes a representation of an exception occurrence to a stream; Read_Exception_Occurrence reconstructs an exception occurrence from a stream (including one written in a different partition). "),(0,i.kt)("p",null,"Ramification: {AI12-0005-1} These routines are used to define the stream attributes (see 13.13.2) for Exception_Occurrence."),(0,i.kt)("p",null,"The identity of the exception, as well as the Exception_Name and Exception_Message, have to be preserved across partitions."),(0,i.kt)("p",null,"The string returned by Exception_Name or Exception_Message on the result of calling the Read attribute on a given stream has to be the same as the value returned by calling the corresponding function on the exception occurrence that was written into the stream with the Write attribute. The string returned by Exception_Information need not be the same, since it is implementation defined anyway. "),(0,i.kt)("p",null,"Reason: This is important for supporting writing exception occurrences to external files for post-mortem analysis, as well as propagating exceptions across remote subprogram calls in a distributed system (see E.4). "),(0,i.kt)("p",null,"Paragraph 16 was deleted. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation of Exception_Name in a space-constrained environment may return the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," instead of the full expanded name."),(0,i.kt)("p",null,"The string returned by Exception_Message may be truncated (to no less than 200 characters) by the Save_Occurrence procedure ","[(not the function)]",", the Reraise_Occurrence procedure, and the re-raise statement. "),(0,i.kt)("p",null,'Reason: The reason for allowing truncation is to ease implementations. The reason for choosing the number 200 is that this is the minimum source line length that implementations have to support, and this feature seems vaguely related since it\'s usually a "one-liner". Note that an implementation is allowed to do this truncation even if it supports arbitrarily long lines. '),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"Exception_Message (by default) and Exception_Information should produce information useful for debugging. Exception_Message should be short (about one line), whereas Exception_Information can be long. Exception_Message should not include the Exception_Name. Exception_Information should include both the Exception_Name and the Exception_Message."),(0,i.kt)("p",null,"Implementation Advice: Exception_Information should provide information useful for debugging, and should include the Exception_Name and Exception_Message."),(0,i.kt)("p",null,"Implementation Advice: Exception_Message by default should be short, provide information useful for debugging, and should not include the Exception_Name."),(0,i.kt)("p",null,"Reason: It may seem strange to define two subprograms whose semantics is implementation defined. The idea is that a program can print out debugging/error-logging information in a portable way. The program is portable in the sense that it will work in any implementation; it might print out different information, but the presumption is that the information printed out is appropriate for debugging/error analysis on that system. "),(0,i.kt)("p",null,"Implementation Note: As an example, Exception_Information might include information identifying the location where the exception occurred, and, for predefined exceptions, the specific kind of language-defined check that failed. There is an implementation trade-off here, between how much information is represented in an Exception_Occurrence, and how much can be passed through a re-raise."),(0,i.kt)("p",null,"The string returned should be in a form suitable for printing to an error log file. This means that it might need to contain line-termination control characters with implementation-defined I/O semantics. The string should neither start nor end with a newline."),(0,i.kt)("p",null,"If an implementation chooses to provide additional functionality related to exceptions and their occurrences, it should do so by providing one or more children of Ada.Exceptions."),(0,i.kt)("p",null,'Note that exceptions behave as if declared at library level; there is no "natural scope" for an exception; an exception always exists. Hence, there is no harm in saving an exception occurrence in a data structure, and reraising it later. The reraise has to occur as part of the same program execution, so saving an exception occurrence in a file, reading it back in from a different program execution, and then reraising it is not required to work. This is similar to I/O of access types. Note that it is possible to use RPC to propagate exceptions across partitions.'),(0,i.kt)("p",null,"Here's one way to implement Exception_Occurrence in the private part of the package. Using this method, an implementation need store only the actual number of characters in exception messages. If the user always uses small messages, then exception occurrences can be small. If the user never uses messages, then exception occurrences can be smaller still: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence(Message_Length : Natural := 200) is\n    limited record\n        Id : Exception_Id;\n        Message : String(1..Message_Length);\n    end record;\n\n")),(0,i.kt)("p",null,"At the point where an exception is raised, an Exception_Occurrence can be allocated on the stack with exactly the right amount of space for the message - none for an empty message. This is just like declaring a constrained object of the type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Temp : Exception_Occurrence(10); -- for a 10-character message\n\n")),(0,i.kt)("p",null,"After finding the appropriate handler, the stack can be cut back, and the Temp copied to the right place. This is similar to returning an unknown-sized object from a function. It is not necessary to allocate the maximum possible size for every Exception_Occurrence. If, however, the user declares an Exception_Occurrence object, the discriminant will be permanently set to 200. The Save_Occurrence procedure would then truncate the Exception_Message. Thus, nothing is lost until the user tries to save the occurrence. If the user is willing to pay the cost of heap allocation, the Save_Occurrence function can be used instead."),(0,i.kt)("p",null,"Note that any arbitrary-sized implementation-defined Exception_Information can be handled in a similar way. For example, if the Exception_Occurrence includes a stack traceback, a discriminant can control the number of stack frames stored. The traceback would be truncated or entirely deleted by the Save_Occurrence procedure - as the implementation sees fit."),(0,i.kt)("p",null,"If the internal representation involves pointers to data structures that might disappear, it would behoove the implementation to implement it as a controlled type, so that assignment can either copy the data structures or else null out the pointers. Alternatively, if the data structures being pointed at are in a task control block, the implementation could keep a unique sequence number for each task, so it could tell when a task's data structures no longer exist."),(0,i.kt)("p",null,"Using the above method, heap space is never allocated unless the user calls the Save_Occurrence function."),(0,i.kt)("p",null,"An alternative implementation would be to store the message strings on the heap when the exception is raised. (It could be the global heap, or it could be a special heap just for this purpose - it doesn't matter.)  This representation would be used only for choice parameters. For normal user-defined exception occurrences, the Save_Occurrence procedure would copy the message string into the occurrence itself, truncating as necessary. Thus, in this implementation, Exception_Occurrence would be implemented as a variant record: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence_Kind is (Normal, As_Choice_Param);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence(Kind : Exception_Occurrence_Kind := Normal) is\n    limited record\n        case Kind is\n            when Normal =&gt\n                ... -- space for 200 characters\n            when As_Choice_Param =&gt\n                ... -- pointer to heap string\n        end case;\n    end record;\n\n")),(0,i.kt)("p",null,"Exception_Occurrences created by the run-time system during exception raising would be As_Choice_Param. User-declared ones would be Normal - the user cannot see the discriminant, and so cannot set it to As_Choice_Param. The strings in the heap would be freed upon completion of the handler."),(0,i.kt)("p",null,"This alternative implementation corresponds to a heap-based implementation of functions returning unknown-sized results."),(0,i.kt)("p",null,"One possible implementation of Reraise_Occurrence is as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Reraise_Occurrence(X : in Exception_Occurrence) is\nbegin\n    Raise_Exception(Identity(X), Exception_Message(X));\nend Reraise_Occurrence;\n\n")),(0,i.kt)("p",null,"However, some implementations may wish to retain more information across a re-raise - a stack traceback, for example. "),(0,i.kt)("p",null,"Ramification: Note that Exception_Occurrence is a definite subtype. Hence, values of type Exception_Occurrence may be written to an error log for later analysis, or may be passed to subprograms for immediate error analysis. "),(0,i.kt)("p",null,"This paragraph was deleted.{AI95-00400-01} "),(0,i.kt)("p",null,"NOTE 1   {AI12-0021-1} UTF-8 encoding (see A.4.11) can be used to represent non-ASCII characters in exception messages. "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The Identity attribute of exceptions is new, as is the package Exceptions. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,i.kt)("p",null,"{AI95-00241-01} Amendment Correction: Exception_Identity of an Exception_Occurrence now is defined to return Null_Id for Null_Occurrence, rather than raising Constraint_Error. This provides a simple way to test for Null_Occurrence. We expect that programs that need Constraint_Error raised will be very rare; they can be easily fixed by explicitly testing for Null_Id or by using Exception_Name instead."),(0,i.kt)("p",null,"{AI95-00378-01} {AI95-00417-01} Amendment Correction: We now define the lower bound of the string returned from [","[Wide_]","Wide_]Exception_Name, Exception_Message, and Exception_Information. This makes working with the returned string easier, and is consistent with many other string-returning functions in Ada. This is technically an inconsistency; if a program depended on some other lower bound for the string returned from one of these functions, it could fail when compiled with Ada 2005. Such code is not portable even between Ada 95 implementations, so it should be very rare."),(0,i.kt)("p",null,"{AI95-00446-01} Amendment Correction: Raise_Exception now raises Constraint_Error if passed Null_Id. This means that it always raises an exception, and thus we can apply pragma No_Return to it. We expect that programs that call Raise_Exception with Null_Id will be rare, and programs that do that and expect no exception to be raised will be rarer; such programs can be easily fixed by explicitly testing for Null_Id before calling Raise_Exception. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-95"},"Incompatibilities With Ada 95"),(0,i.kt)("p",null,"{AI95-00400-01} {AI95-00438-01} {AI05-0005-1} Functions Wide_Exception_Name and Wide_Wide_Exception_Name, and procedures Read_Exception_Occurrence and Write_Exception_Occurrence are added to Exceptions. If Exceptions is referenced in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.4#S0235"},"use_clause"),", and an entity E with the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," as a new entity in Exceptions is defined in a package that is also referenced in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.4#S0235"},"use_clause"),", the entity E may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00362-01} The package Exceptions is preelaborated, and types Exception_Id and Exception_Occurrence have preelaborable initialization, allowing this package to be used in preelaborated units. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00361-01} The meaning of Exception_Message is reworded to reflect that the string can come from a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," as well as a call of Raise_Exception."),(0,i.kt)("p",null,"{AI95-00400-01} Added Wide_Exception_Name and Wide_Wide_Exception_Name because identifiers can now contain characters outside of Latin-1. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0043-1} Correction: Added explicit wording that the exception message for language-defined checks is unspecified. The old wording appeared inclusive, but it was not. "),(0,i.kt)("h2",{id:"1142--pragmas-assert-and-assertion_policy"},"11.4.2  Pragmas Assert and Assertion_Policy"),(0,i.kt)("p",null,"{AI95-00286-01} {AI05-0274-1} Pragma Assert is used to assert the truth of a boolean expression at a point within a sequence of declarations or statements."),(0,i.kt)("p",null,"{AI05-0274-1} {AI12-0265-1} Assert pragmas, subtype predicates (see 3.2.4), preconditions and postconditions (see 6.1.1), type invariants (see 7.3.2), and default initial conditions (see 7.3.3) are collectively referred to as assertions; their boolean expressions are referred to as assertion expressions."),(0,i.kt)("p",null,"Glossary entry: A predicate is an assertion that is expected to be True for all objects of a given subtype."),(0,i.kt)("p",null,"Glossary entry: A precondition is an assertion that is expected to be True when a given subprogram is called."),(0,i.kt)("p",null,"Glossary entry: A postcondition is an assertion that is expected to be True when a given subprogram returns normally."),(0,i.kt)("p",null,"Glossary entry: An invariant is an assertion that is expected to be True for all objects of a given private type when viewed from outside the defining package."),(0,i.kt)("p",null,"Glossary entry: See Invariant."),(0,i.kt)("p",null,"Glossary entry: An assertion is a boolean expression that appears in any of the following: a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert, a predicate, a precondition, a postcondition, an invariant, a constraint, or a null exclusion. An assertion is expected to be True at run time at certain specified places."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[R]",",Term=","[assertion]",", Def=","[a boolean expression that is expected to be True at run time at certain specified places]",", Note1=","[Certain pragmas and aspects define various kinds of assertions.]"),(0,i.kt)("p",null,"{AI05-0274-1} Pragma Assertion_Policy is used to control whether assertions are to be ignored by the implementation, checked at run time, or handled in some implementation-defined manner. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"{AI95-00286-01} The form of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert is as follows: "),(0,i.kt)("p",null,"  pragma Assert(","[Check =",">]"," boolean",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression"),"[, ","[Message =",">]"," string"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"]);"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert is allowed at the place where a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.11#S0087"},"declarative_item")," or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.1#S0167"},"statement")," is allowed."),(0,i.kt)("p",null,"{AI95-00286-01} The form of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy is as follows: "),(0,i.kt)("p",null,"  pragma Assertion",(0,i.kt)("em",{parentName:"p"},"Policy(policy"),(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),");"),(0,i.kt)("p",null,"{AI05-0290-1}   pragma Assertion",(0,i.kt)("em",{parentName:"p"},"Policy(\nassertion"),(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0347"},"aspect_mark")," =",">"," policy",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-2.3#S0002"},"identifier"),"\n{, assertion"),(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0347"},"aspect_mark")," =",">"," policy_",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),"});"),(0,i.kt)("p",null,"{AI05-0290-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy is allowed only immediately within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part"),", immediately within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.1#S0230"},"package_specification"),", or as a configuration pragma."),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI95-00286-01} The expected type for the boolean",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," of a ",(0,i.kt)("a",{parentName:"em",href:"./AA-2.8#S0019"},"pragma")," Assert is any boolean type. The expected type for the string"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert is type String. "),(0,i.kt)("p",null,"Reason: We allow any boolean type to be like ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.3#S0175"},"if_statement"),"s and other conditionals; we only allow String for the message in order to match ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement"),"s. "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"{AI95-00286-01} {AI05-0290-1} {AI12-0265-1} {AI12-0396-1} The assertion",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-13.1#S0347"},"aspect_mark")," of a ",(0,i.kt)("a",{parentName:"em",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy shall identify an assertion aspect, namely  one of Assert, Static_Predicate, Dynamic_Predicate, Pre, Pre'Class, Post, Post'Class, Type_Invariant, Type_Invariant'Class, Default_Initial_Condition, or some implementation-defined (assertion) ",(0,i.kt)("a",{parentName:"em",href:"./AA-13.1#S0347"},"aspect_mark"),". The policy"),(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," shall be either Check, Ignore, or some implementation-defined ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),". "),(0,i.kt)("p",null,"Implementation defined: Implementation-defined policy",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-2.3#S0002"},"identifier"),"s and assertion"),(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0347"},"aspect_mark"),"s allowed in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy."),(0,i.kt)("p",null,'To be honest: {AI12-0396-1} "Assert" is considered an "assertion aspect" for the purposes of this rule, even though there is no sort of entity that has an Assert aspect. It can only be specified using an Assert pragma, and applies to a particular point in the execution of a logical thread of control. '),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"{AI95-00286-01} {AI05-0290-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion",(0,i.kt)("em",{parentName:"p"},"Policy determines for each assertion aspect named in the ",(0,i.kt)("a",{parentName:"em",href:"./AA-2.8#S0020"},"pragma_argument_association"),"s whether assertions of the given aspect are to be enforced by a runtime check. The policy"),(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," Check requires that assertion expressions of the given aspect be checked that they evaluate to True at the points specified for the given aspect; the policy_",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," Ignore requires that the assertion expression not be evaluated at these points, and the runtime checks not be performed. [Note that for subtype predicate aspects (see 3.2.4), even when the applicable Assertion_Policy is Ignore, the predicate will still be evaluated as part of membership tests and Valid ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),"s, and if static, will still have an effect on loop iteration over the subtype, and the selection of ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0177"},"case_statement_alternative"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"s.]"),(0,i.kt)("p",null,"{AI05-0290-1} If no assertion_",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0347"},"aspect_mark"),"s are specified in the pragma, the specified policy applies to all assertion aspects."),(0,i.kt)("p",null,"{AI05-0290-1} {AI12-0396-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy applies to the named assertion aspects in a specific region, and applies to all assertion expressions associated with those aspects specified in that region. A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy given in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part")," or immediately within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.1#S0230"},"package_specification")," applies from the place of the pragma to the end of the innermost enclosing declarative region. The region for a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy given as a configuration pragma is the declarative region for the entire compilation unit (or units) to which it applies."),(0,i.kt)("p",null,"{AI05-0290-1} If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy applies to a ",(0,i.kt)("a",{parentName:"p",href:"./AA-12.3#S0315"},"generic_instantiation"),", then the ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy applies to the entire instance."),(0,i.kt)("p",null,"Ramification: This means that an Assertion_Policy pragma that occurs in a scope enclosing the declaration of a generic unit but not also enclosing the declaration of a given instance of that generic unit will not apply to assertion expressions occurring within the given instance. "),(0,i.kt)("p",null,"{AI05-0290-1} If multiple Assertion_Policy pragmas apply to a given construct for a given assertion aspect, the assertion policy is determined by the one in the innermost enclosing region of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assertion_Policy specifying a policy for the assertion aspect. If no such Assertion_Policy pragma exists, the policy is implementation defined."),(0,i.kt)("p",null,"Implementation defined: The default assertion policy."),(0,i.kt)("p",null,"{AI95-00286-01} The following language-defined library package exists:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Assertions\n    with Pure is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Assertion_Error : exception;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Assert(Check : in Boolean);\n   procedure Assert(Check : in Boolean; Message : in String);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end Ada.Assertions;\n\n")),(0,i.kt)("p",null,"{AI95-00286-01} {AI05-0290-1} A compilation unit containing a check for an assertion (including a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert) has a semantic dependence on the Assertions library unit."),(0,i.kt)("p",null,"This paragraph was deleted.{AI95-00286-01} {AI05-0290-1} "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"{AI95-00286-01} {AI05-0290-1} If performing checks is required by the Assert assertion policy in effect at the place of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert, the elaboration of the pragma consists of evaluating the boolean expression, and if the result is False, evaluating the Message argument, if any, and raising the exception Assertions.Assertion_Error, with a message if the Message argument is provided."),(0,i.kt)("p",null,"{AI95-00286-01} Calling the procedure Assertions.Assert without a Message parameter is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"if Check = False then\n   raise Ada.Assertions.Assertion_Error;\nend if;\n\n")),(0,i.kt)("p",null,"{AI95-00286-01} Calling the procedure Assertions.Assert with a Message parameter is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"if Check = False then\n   raise Ada.Assertions.Assertion_Error with Message;\nend if;\n\n")),(0,i.kt)("p",null,"{AI95-00286-01} The procedures Assertions.Assert have these effects independently of the assertion policy in effect."),(0,i.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,i.kt)("p",null,"{AI05-0274-1} {AI12-0439-1} It is a bounded error to invoke a potentially blocking operation (see 9.5.1) during the evaluation of an assertion expression associated with a call on, or return from, a protected operation. If the bounded error is detected, Program_Error is raised. If not detected, execution proceeds normally, but if it is invoked within a protected action, it can result in deadlock or a (nested) protected action. "),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"{AI12-0179-1} {AI12-0265-1} Any postcondition expression, type invariant expression, or default initial condition expression occurring in the specification of a language-defined unit is enabled (see 6.1.1, 7.3.2, and 7.3.3)."),(0,i.kt)("p",null,"Ramification: The Assertion_Policy does not have an effect on such postconditions, invariants, and default initial conditions. This has no execution impact since such assertions shouldn't fail anyway (see the next rule). "),(0,i.kt)("p",null,"{AI12-0179-1} {AI12-0265-1} The evaluation of any such postcondition, type invariant, or default initial condition expression shall either yield True or propagate an exception from a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," that appears within the assertion expression."),(0,i.kt)("p",null,"Ramification: In other words, evaluating such an assertion expression will not return a result of False, nor will it propagate an exception other than by evaluating a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," which is syntactically all or part of the assertion expression. "),(0,i.kt)("p",null,"To be honest: Evaluation of any expression might raise Storage_Error. "),(0,i.kt)("p",null,"Reason: This allows the Reference Manual to express semantic requirements as postconditions, invariants, or default initial conditions (which are invariably clearer than English prose would be) while keeping it clear that failing the assertion check (or any other run time check) is not conforming behavior. "),(0,i.kt)("p",null,"{AI12-0112-1} Any precondition expression occurring in the specification of a language-defined unit is enabled (see 6.1.1) unless suppressed (see 11.5). Similarly, any predicate checks for a subtype occurring in the specification of a language-defined unit are enabled (see 3.2.4) unless suppressed."),(0,i.kt)("p",null,"Reason: {AI12-0005-1} {AI12-0112-1} This allows the Reference Manual to express runtime requirements on the client of a language-defined unit as preconditions or predicates (which are clearer than English prose would be). Some such requirements can be suppressed with pragma Suppress. Ada 2012 and earlier versions did not provide a mechanism to suppress such code. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI95-00286-01} Assertion_Error may be declared by renaming an implementation-defined exception from another package. "),(0,i.kt)("p",null,"Reason: This permission is intended to allow implementations which had an implementation-defined Assert pragma to continue to use their originally defined exception. Without this permission, such an implementation would be incorrect, as Exception_Name would return the wrong name. "),(0,i.kt)("p",null,"{AI95-00286-01} Implementations may define their own assertion policies."),(0,i.kt)("p",null,"{AI05-0274-1} {AI12-0445-1} If the result of a function call in an assertion is not used to determine the value of the assertion expression, an implementation is permitted to omit the function call. ","[This permission applies even if the function has side effects.]"),(0,i.kt)("p",null,"{AI05-0274-1} {AI12-0444-1} An implementation may disallow the specification of an assertion expression if the evaluation of the expression has a side effect such that an immediate reevaluation of the expression can produce a different value. Similarly, an implementation may disallow the specification of an assertion expression that is checked as part of a call on or return from a callable entity C, if the evaluation of the expression has a side effect such that the evaluation of some other assertion expression associated with the same call of (or return from) C can produce a different value than in the case when the first expression had not been evaluated. "),(0,i.kt)("p",null,"Ramification: This allows an implementation to reject such assertions. To maximize portability, assertions should not include expressions that contain these sorts of side effects. "),(0,i.kt)("p",null,'Discussion: The intended effect of the second part of the rule (the part starting with "Similarly") is that an evaluation of the involved assertion expressions (subtype predicates, type invariants, preconditions and postconditions) in any order yields identical results.'),(0,i.kt)("p",null,"The rule is intended to apply to all of the assertion expressions that are evaluated at the start of call (and similarly for the assertion expressions that are evaluated during the return from a call), but not other assertions actually given in the body, nor between the assertions checked at the start and end of the call. Specifically, a side effect that alters a variable in a function called from a precondition expression that changes the result of a postcondition expression of the same subprogram does not trigger these rules unless it also changes the value of a reevaluation of the precondition expression. "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,"{AI12-0005-1} Our intent is that any assertion expression that violates this Implementation Permission is considered pathological. We definitely want compilers to be able to assume that if you evaluate an assertion expression once and it is True, you don't need to evaluate it again if all you are doing in the meantime is evaluating assertion expressions. We were unable to find wording that had this effect that didn't throw out important other cases (logging, memo functions), so we settled for a strong warning that compilers can reject such pathologies. Perhaps in a future version of Ada we'll be able to tighten this up. "),(0,i.kt)("p",null,"NOTE 1   {AI95-00286-01} {AI12-0442-1} Normally, the boolean expression in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert does not call functions that have significant side effects when the result of the expression is True, so that the particular assertion policy in effect will not affect normal operation of the program. "),(0,i.kt)("h4",{id:"extensions-to-ada-95-1"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00286-01} Pragmas Assert and Assertion_Policy, and package Assertions are new. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,i.kt)("p",null,"{AI05-0274-1} There now is an Implementation Permission to reject an assertion expression that calls a function that has a side effect such that an immediate reevalution of the expression could produce a different value. This means that a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Assert that works in Ada 2005 might be illegal in Ada 2012 in the unlikely event that the compiler detected such an error. This should be unlikely to occur in practice and it is considered a good thing, as the original expression was tricky and probably was not portable (as order of evaluation is unspecified within an expression). Moreover, no compiler is required to reject such expressions, so there is no need for any compiler to change behavior. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0290-1} Assertion_Policy pragmas are now allowed in more places and can specify behavior for individual kinds of assertions. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0112-1} Added wording that preconditions and predicates given on language-defined units are always checked unless suppressed (that is, they act like language-defined checks). This is not considered an inconsistency, since there are no such preconditions or predicates in Ada 2012."),(0,i.kt)("p",null,"{AI12-0179-1} {AI12-0265-1} Correction: Added wording that postconditions, type invariants, and default initial conditions given on language-defined units cannot fail. This is not considered an inconsistency, since there are no such postconditions, invariants, or default initial conditions in Ada 2012."),(0,i.kt)("p",null,"{AI12-0265-1} Added default initial conditions to the kinds of assertions (see 7.3.3)."),(0,i.kt)("p",null,"{AI12-0396-1} Correction: Added a definition of assertion aspects, used in some freezing rules (see 13.14). "),(0,i.kt)("h2",{id:"1143--example-of-exception-handling"},"11.4.3  Example of Exception Handling"),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"{AI12-0440-1} Exception handling can be used to separate the detection of an error from the response to that error: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00433-01} {AI12-0178-1} package File_System is\n    type Data_Type is ...;\n    type File_Handle is limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    File_Not_Found : exception;\n    procedure Open(F : in out File_Handle; Name : String);\n        -- raises File_Not_Found if named file does not exist\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    End_Of_File : exception;\n    procedure Read(F : in out File_Handle; Data : out Data_Type);\n        -- raises End_Of_File if the file is not open\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0178-1}     ...\nprivate\n    ...\nend File_System;\n\n")),(0,i.kt)("p",null,"Reason: {AI12-0178-1} The first ... provides a place for Close to be declared, and the second ... provides a place for File_Handle to be completed. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0178-1} package body File_System is\n    ...\n\n")),(0,i.kt)("p",null,"Reason: {AI12-0178-1} This ... provides a place for File_Exists and the body of Close to be declared. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'{AI95-00433-01} {AI12-0178-1}     procedure Open(F : in out File_Handle; Name : String) is\n    begin\n        if File_Exists(Name) then\n            ...\n        else\n            raise File_Not_Found with "File not found: " & Name & ".";\n        end if;\n    end Open;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Read(F : in out File_Handle; Data : out Data_Type) is\n    begin\n        if F.Current_Position &lt= F.Last_Position then\n            ...\n        else\n            raise End_Of_File;\n        end if;\n    end Read;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end File_System;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'{AI12-0178-1} with Ada.Text_IO;\nwith Ada.Exceptions;\nwith File_System; use File_System;\nuse Ada;\nprocedure Main is\n    Verbosity_Desired : Boolean := ...;\nbegin\n    ... -- call operations in File_System\nexception\n    when End_Of_File =&gt\n        Close(Some_File);\n    when Not_Found_Error : File_Not_Found =&gt\n        Text_IO.Put_Line(Exceptions.Exception_Message(Not_Found_Error));\n    when The_Error : others =&gt\n        Text_IO.Put_Line("Unknown error:");\n        if Verbosity_Desired then\n            Text_IO.Put_Line(Exceptions.Exception_Information(The_Error));\n        else\n            Text_IO.Put_Line(Exceptions.Exception_Name(The_Error));\n            Text_IO.Put_Line(Exceptions.Exception_Message(The_Error));\n        end if;\n        raise;\nend Main;\n\n')),(0,i.kt)("p",null,"{AI12-0440-1} In the above example, the File_System package contains information about detecting certain exceptional situations, but it does not specify how to handle those situations. Procedure Main specifies how to handle them; other clients of File_System can have different handlers, even though the exceptional situations arise from the same basic causes. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'{AI05-0299-1} The sections labeled "Exceptions Raised During ..." are subsumed by this subclause, and by parts of Clause 9.'))}d.isMDXComponent=!0}}]);