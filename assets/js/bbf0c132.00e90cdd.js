"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[858],{38554:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(58168),i=(t(96540),t(15680));const o={title:"5.6 Statements"},l=void 0,r={unversionedId:"style-guide/s5/06",id:"style-guide/s5/06",title:"5.6 Statements",description:"Careless or convoluted use of statements can make a program hard to read",source:"@site/docs/style-guide/s5/06.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/06",permalink:"/docs/style-guide/s5/06",draft:!1,tags:[],version:"current",frontMatter:{title:"5.6 Statements"},sidebar:"styleGuideSidebar",previous:{title:"5.5 Expressions",permalink:"/docs/style-guide/s5/05"},next:{title:"5.7 Visibility",permalink:"/docs/style-guide/s5/07"}},s={},d=[{value:"Nesting",id:"nesting",level:3},{value:"guideline",id:"guideline",level:4},{value:"instantiation",id:"instantiation",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Slices",id:"slices",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Case Statements",id:"case-statements",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-1",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Loops",id:"loops",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Exit Statements",id:"exit-statements",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Recursion and Iteration Bounds",id:"recursion-and-iteration-bounds",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Goto Statements",id:"goto-statements",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-3",level:4},{value:"Return Statements",id:"return-statements",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"exceptions",id:"exceptions-3",level:4},{value:"Blocks",id:"blocks",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Aggregates",id:"aggregates",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-9",level:4}],p={toc:d},u="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"Careless or convoluted use of statements can make a program hard to read\nand maintain even if its global structure is well organized. You should\nstrive for simple and consistent use of statements to achieve clarity of\nlocal program structure. Some of the guidelines in this section counsel\nuse or avoidance of particular statements. As pointed out in the\nindividual guidelines, rigid adherence to those guidelines would be\nexcessive, but experience has shown that they generally lead to code\nwith improved reliability and maintainability."),(0,i.yg)("h3",{id:"nesting"},"Nesting"),(0,i.yg)("h4",{id:"guideline"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Minimize the depth of nested expressions (Nissen and Wallis 1984 )."),(0,i.yg)("li",{parentName:"ul"},"Minimize the depth of nested control structures (Nissen and Wallis\n1984 )."),(0,i.yg)("li",{parentName:"ul"},"Try using simplification heuristics (see the following Notes ).")),(0,i.yg)("h4",{id:"instantiation"},"instantiation"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Do not nest expressions or control structures beyond a nesting level\nof five.")),(0,i.yg)("h4",{id:"example"},"example"),(0,i.yg)("p",null,"The following section of code:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"if not Condition_1 then\n   if Condition_2 then\n      Action_A;\n   else  -- not Condition_2\n      Action_B;\n   end if;\nelse  -- Condition_1\n   Action_C;\nend if;\n")),(0,i.yg)("p",null,"can be rewritten more clearly and with less nesting as:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"if Condition_1 then\n   Action_C;\nelsif Condition_2 then\n   Action_A;\nelse  -- not (Condition_1 or Condition_2)\n   Action_B;\nend if;\n")),(0,i.yg)("h4",{id:"rationale"},"rationale"),(0,i.yg)("p",null,"Deeply nested structures are confusing, difficult to understand, and\ndifficult to maintain. The problem lies in the difficulty of determining\nwhat part of a program is contained at any given level. For expressions,\nthis is important in achieving the correct placement of balanced\ngrouping symbols and in achieving the desired operator precedence. For\ncontrol structures, the question involves what part is controlled.\nSpecifically, is a given statement at the proper level of nesting, that\nis, is it too deeply or too shallowly nested, or is the given statement\nassociated with the proper choice, for example, for ",(0,i.yg)("inlineCode",{parentName:"p"},"if")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"case"),"\nstatements? Indentation helps, but it is not a panacea. Visually\ninspecting alignment of indented code (mainly intermediate levels) is an\nuncertain job at best. To minimize the complexity of the code, keep the\nmaximum number of nesting levels between three and five."),(0,i.yg)("h4",{id:"notes"},"notes"),(0,i.yg)("p",null,"Ask yourself the following questions to help you simplify the code:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Can some part of the expression be put into a constant or variable?"),(0,i.yg)("li",{parentName:"ul"},"Does some part of the lower nested control structures represent a\nsignificant and, perhaps, reusable computation that I can factor\ninto a subprogram ?"),(0,i.yg)("li",{parentName:"ul"},"Can I convert these nested ",(0,i.yg)("inlineCode",{parentName:"li"},"if")," statements into a ",(0,i.yg)("inlineCode",{parentName:"li"},"case")," statement?"),(0,i.yg)("li",{parentName:"ul"},"Am I using ",(0,i.yg)("inlineCode",{parentName:"li"},"else if")," where I could be using ",(0,i.yg)("inlineCode",{parentName:"li"},"elsif"),"?"),(0,i.yg)("li",{parentName:"ul"},"Can I reorder the conditional expressions controlling this nested\nstructure?"),(0,i.yg)("li",{parentName:"ul"},"Is there a different design that would be simpler?")),(0,i.yg)("h4",{id:"exceptions"},"exceptions"),(0,i.yg)("p",null,"If deep nesting is required frequently, there may be overall design\ndecisions for the code that should be changed. Some algorithms require\ndeeply nested loops and segments controlled by conditional branches.\nTheir continued use can be ascribed to their efficiency, familiarity,\nand time-proven utility. When nesting is required, proceed cautiously\nand take special care with the choice of identifiers and loop and block\nnames."),(0,i.yg)("h3",{id:"slices"},"Slices"),(0,i.yg)("h4",{id:"guideline-1"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use slices rather than a loop to copy part of an array.")),(0,i.yg)("h4",{id:"example-1"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"First  : constant Index := Index'First;\nSecond : constant Index := Index'Succ(First);\nThird  : constant Index := Index'Succ(Second);\ntype Vector is array (Index range <>) of Element;\nsubtype Column_Vector is Vector (Index);\ntype    Square_Matrix is array  (Index) of Column_Vector;\nsubtype Small_Range  is Index range First .. Third;\nsubtype Diagonals    is Vector (Small_Range);\ntype    Tri_Diagonal is array  (Index) of Diagonals;\nMarkov_Probabilities : Square_Matrix;\nDiagonal_Data        : Tri_Diagonal;\n...\n-- Remove diagonal and off diagonal elements.\nDiagonal_Data(Index'First)(First) := Null_Value;\nDiagonal_Data(Index'First)(Second .. Third) :=\n      Markov_Probabilities(Index'First)(First .. Second);\nfor I in Second .. Index'Pred(Index'Last) loop\n   Diagonal_Data(I) :=\n         Markov_Probabilities(I)(Index'Pred(I) .. Index'Succ(I));\nend loop;\nDiagonal_Data(Index'Last)(First .. Second) :=\n      Markov_Probabilities(Index'Last)(Index'Pred(Index'Last) .. Index'Last);\nDiagonal_Data(Index'Last)(Third) := Null_Value;\n")),(0,i.yg)("h4",{id:"rationale-1"},"rationale"),(0,i.yg)("p",null,"An assignment statement with slices is simpler and clearer than a loop\nand helps the reader see the intended action. See also Guideline 10.5.7\nregarding possible performance issues of slice assignments versus loops."),(0,i.yg)("h3",{id:"case-statements"},"Case Statements"),(0,i.yg)("h4",{id:"guideline-2"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Minimize the use of an ",(0,i.yg)("inlineCode",{parentName:"li"},"others")," choice in a ",(0,i.yg)("inlineCode",{parentName:"li"},"case")," statement."),(0,i.yg)("li",{parentName:"ul"},"Do not use ranges of enumeration literals in ",(0,i.yg)("inlineCode",{parentName:"li"},"case")," statements."),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"case")," statements rather than ",(0,i.yg)("inlineCode",{parentName:"li"},"if/elsif")," statements, wherever\npossible."),(0,i.yg)("li",{parentName:"ul"},"Use type extension and dispatching rather than ",(0,i.yg)("inlineCode",{parentName:"li"},"case")," statements if,\npossible.")),(0,i.yg)("h4",{id:"example-2"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"type Color is (Red, Green, Blue, Purple);\nCar_Color : Color := Red;\n...\ncase Car_Color is\n   when Red .. Blue => ...\n   when Purple      => ...\nend case;  -- Car_Color\n")),(0,i.yg)("p",null,"Now consider a change in the type:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"type Color is (Red, Yellow, Green, Blue, Purple);\n")),(0,i.yg)("p",null,"This change may have an unnoticed and undesired effect in the ",(0,i.yg)("inlineCode",{parentName:"p"},"case"),"\nstatement. If the choices had been enumerated explicitly, as ",(0,i.yg)("inlineCode",{parentName:"p"},"when Red | Green | Blue =>")," instead of ",(0,i.yg)("inlineCode",{parentName:"p"},"when")," ",(0,i.yg)("inlineCode",{parentName:"p"},"Red .. Blue =>"),", then the ",(0,i.yg)("inlineCode",{parentName:"p"},"case"),"\nstatement would not have compiled. This would have forced the maintainer\nto make a conscious decision about what to do in the case of ",(0,i.yg)("inlineCode",{parentName:"p"},"Yellow"),"."),(0,i.yg)("p",null,"In the following example, assume that a menu has been posted, and the\nuser is expected to enter one of the four choices. Assume that\n",(0,i.yg)("inlineCode",{parentName:"p"},"User_Choice")," is declared as a ",(0,i.yg)("inlineCode",{parentName:"p"},"Character")," and that ",(0,i.yg)("inlineCode",{parentName:"p"},"Terminal_IO.Get"),"\nhandles errors in user input. The less readable alternative with the\n",(0,i.yg)("inlineCode",{parentName:"p"},"if/elsif")," statement is shown after the ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statement:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"Do_Menu_Choices_1:\n   loop\n      ...\n\n      case User_Choice is\n         when 'A'    => Item := Terminal_IO.Get (&quot;Item to add&quot;);\n         when 'D'    => Item := Terminal_IO.Get (&quot;Item to delete&quot;);\n         when 'M'    => Item := Terminal_IO.Get (&quot;Item to modify&quot;);\n         when 'Q'    => exit Do_Menu_Choices_1;\n\n         when others => -- error has already been signaled to user\n            null;\n      end case;\n   end loop Do_Menu_Choices_1;\n\nDo_Menu_Choices_2:\n   loop\n      ...\n\n      if User_Choice = 'A' then\n         Item := Terminal_IO.Get (&quot;Item to add&quot;);\n\n      elsif User_Choice = 'D' then\n         Item := Terminal_IO.Get (&quot;Item to delete&quot;);\n\n      elsif User_Choice = 'M' then\n         Item := Terminal_IO.Get (&quot;Item to modify&quot;);\n\n      elsif User_Choice = 'Q' then\n         exit Do_Menu_Choices_2;\n\n      end if;\n   end loop Do_Menu_Choices_2;\n")),(0,i.yg)("h4",{id:"rationale-2"},"rationale"),(0,i.yg)("p",null,"All possible values for an object should be known and should be assigned\nspecific actions. Use of an ",(0,i.yg)("inlineCode",{parentName:"p"},"others")," clause may prevent the developer\nfrom carefully considering the actions for each value. A compiler warns\nthe user about omitted values if an ",(0,i.yg)("inlineCode",{parentName:"p"},"others")," clause is not used."),(0,i.yg)("p",null,"You may not be able to avoid the use of ",(0,i.yg)("inlineCode",{parentName:"p"},"others")," in a ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statement\nwhen the subtype of the case expression has many values, for example,\n",(0,i.yg)("inlineCode",{parentName:"p"},"universal_integer"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Wide_Character"),", or ",(0,i.yg)("inlineCode",{parentName:"p"},"Character"),"). If your choice\nof values is small compared to the range of the subtype, you should\nconsider using an ",(0,i.yg)("inlineCode",{parentName:"p"},"if/elsif")," statement. Note that you must supply an\n",(0,i.yg)("inlineCode",{parentName:"p"},"others")," alternative when your ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," expression is of a generic type."),(0,i.yg)("p",null,"Each possible value should be explicitly enumerated. Ranges can be\ndangerous because of the possibility that the range could change and the\n",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statement may not be reexamined. If you have declared a subtype\nto correspond to the range of interest, you can consider using this\nnamed subtype."),(0,i.yg)("p",null,"In many instances, ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statements enhance the readability of the\ncode. See Guideline 10.5.3 for a discussion of the performance\nconsiderations. In many implementations, ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statements may be more\nefficient."),(0,i.yg)("p",null,"Type extension and dispatching ease the maintenance burden when you add\na new variant to a data structure. See also Guidelines 5.4.2 and 5.4.4 ."),(0,i.yg)("h4",{id:"notes-1"},"notes"),(0,i.yg)("p",null,"Ranges that are needed in ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statements can use constrained subtypes\nto enhance maintainability. It is easier to maintain because the\ndeclaration of the range can be placed where it is logically part of the\nabstraction, not buried in a ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statement in the executable code:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"subtype Lower_Case is Character range 'a' .. 'z';\nsubtype Upper_Case is Character range 'A' .. 'Z';\nsubtype Control    is Character range Ada.Characters.Latin_1.NUL ..\n                                      Ada.Characters.Latin_1.US;\nsubtype Numbers    is Character range '0' .. '9';\n...\ncase Input_Char is\n   when Lower_Case => Capitalize(Input_Char);\n   when Upper_Case => null;\n   when Control    => raise Invalid_Input;\n   when Numbers    => null;\n   ...\nend case;\n")),(0,i.yg)("h4",{id:"exceptions-1"},"exceptions"),(0,i.yg)("p",null,"It is acceptable to use ranges for possible values only when the user is\ncertain that new values will never be inserted among the old ones, as\nfor example, in the range of ASCII characters: ",(0,i.yg)("inlineCode",{parentName:"p"},"'a' .. 'z'"),"."),(0,i.yg)("h3",{id:"loops"},"Loops"),(0,i.yg)("h4",{id:"guideline-3"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"for")," loops, whenever possible."),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"while")," loops when the number of iterations cannot be calculated\nbefore entering the loop but a simple continuation condition can be\napplied at the top of the loop."),(0,i.yg)("li",{parentName:"ul"},"Use plain loops with ",(0,i.yg)("inlineCode",{parentName:"li"},"exit")," statements for more complex situations."),(0,i.yg)("li",{parentName:"ul"},"Avoid ",(0,i.yg)("inlineCode",{parentName:"li"},"exit")," statements in ",(0,i.yg)("inlineCode",{parentName:"li"},"while")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"for")," loops."),(0,i.yg)("li",{parentName:"ul"},"Minimize the number of ways to ",(0,i.yg)("inlineCode",{parentName:"li"},"exit")," a loop.")),(0,i.yg)("h4",{id:"example-3"},"example"),(0,i.yg)("p",null,"To iterate over all elements of an array:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"for I in Array_Name'Range loop\n   ...\nend loop;\n")),(0,i.yg)("p",null,"To iterate over all elements in a linked list:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Pointer := Head_Of_List;\nwhile Pointer /= null loop\n   ...\n   Pointer := Pointer.Next;\nend loop;\n")),(0,i.yg)("p",null,'Situations requiring a "loop and a half" arise often. For this, use:'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"P_And_Q_Processing:\n   loop\n      P;\n      exit P_And_Q_Processing when Condition_Dependent_On_P;\n      Q;\n   end loop P_And_Q_Processing;\n")),(0,i.yg)("p",null,"rather than:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"P;\nwhile not Condition_Dependent_On_P loop\n   Q;\n   P;\nend loop;\n")),(0,i.yg)("h4",{id:"rationale-3"},"rationale"),(0,i.yg)("p",null,"A ",(0,i.yg)("inlineCode",{parentName:"p"},"for"),' loop is bounded, so it cannot be an "infinite loop." This is\nenforced by the Ada language, which requires a finite range in the loop\nspecification and does not allow the loop counter of a ',(0,i.yg)("inlineCode",{parentName:"p"},"for"),"loop to be\nmodified by a statement executed within the loop. This yields a\ncertainty of understanding for the reader and the writer not associated\nwith other forms of loops. A ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," loop is also easier to maintain\nbecause the iteration range can be expressed using attributes of the\ndata structures upon which the loop operates, as shown in the example\nabove where the range changes automatically whenever the declaration of\nthe array is modified. For these reasons, it is best to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"for"),"\nloop whenever possible, that is, whenever simple expressions can be used\nto describe the first and last values of the loop counter."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop has become a very familiar construct to most\nprogrammers. At a glance, it indicates the condition under which the\nloop continues. Use the ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop whenever it is not possible to use\nthe ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," loop but when there is a simple Boolean expression describing\nthe conditions under which the loop should continue, as shown in the\nexample above."),(0,i.yg)("p",null,"The plain loop statement should be used in more complex situations, even\nif it is possible to contrive a solution using a ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop\nin conjunction with extra flag variables or ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements. The\ncriteria in selecting a loop construct are to be as clear and\nmaintainable as possible. It is a bad idea to use an ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statement\nfrom within a ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop because it is misleading to the\nreader after having apparently described the complete set of loop\nconditions at the top of the loop. A reader who encounters a plain loop\nstatement expects to see ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements."),(0,i.yg)("p",null,"There are some familiar looping situations that are best achieved with\nthe plain loop statement. For example, the semantics of the Pascal\n",(0,i.yg)("inlineCode",{parentName:"p"},"repeat")," ",(0,i.yg)("inlineCode",{parentName:"p"},"until")," loop, where the loop is always executed at least once\nbefore the termination test occurs, are best achieved by a plain loop\nwith a single ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," at the end of the loop. Another common situation is\nthe ",(0,i.yg)("em",{parentName:"p"},'"loop and a half" construct, shown in the example above, where a\nloop must terminate somewhere within the sequence of statements of the\nbody. Complicated "loop and a half"')," constructs simulated with ",(0,i.yg)("inlineCode",{parentName:"p"},"while"),"\nloops often require the introduction of flag variables or duplication of\ncode before and during the loop, as shown in the example. Such\ncontortions make the code more complex and less reliable."),(0,i.yg)("p",null,"Minimize the number of ways to ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," a loop to make the loop more\nunderstandable to the reader. It should be rare that you need more than\ntwo exit paths from a loop. When you do, be sure to use ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),"\nstatements for all of them, rather than adding an ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statement to a\n",(0,i.yg)("inlineCode",{parentName:"p"},"for")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop."),(0,i.yg)("h3",{id:"exit-statements"},"Exit Statements"),(0,i.yg)("h4",{id:"guideline-4"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"exit")," statements to enhance the readability of loop termination\ncode (NASA 1987)."),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"exit when ...")," rather than",(0,i.yg)("inlineCode",{parentName:"li"},"if ... then exit"),"whenever possible\n(NASA 1987)."),(0,i.yg)("li",{parentName:"ul"},"Review ",(0,i.yg)("inlineCode",{parentName:"li"},"exit")," statement placement.")),(0,i.yg)("h4",{id:"example-4"},"example"),(0,i.yg)("p",null,"See the examples in Guidelines 5.1.1 and Guidelines 5.6.4."),(0,i.yg)("h4",{id:"rationale-4"},"rationale"),(0,i.yg)("p",null,"It is more readable to use ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements than to try to add Boolean\nflags to a ",(0,i.yg)("inlineCode",{parentName:"p"},"while")," loop condition to simulate exits from the middle of a\nloop. Even if all ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements would be clustered at the top of the\nloop body, the separation of a complex condition into multiple ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),"\nstatements can simplify and make it more readable and clear. The\nsequential execution of two ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements is often more clear than\nthe short-circuit control forms."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"exit when")," form is preferable to the ",(0,i.yg)("inlineCode",{parentName:"p"},"if ... then exit")," form\nbecause it makes the word ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," more visible by not nesting it inside\nof any control construct. The ",(0,i.yg)("inlineCode",{parentName:"p"},"if ... then exit")," form is needed only in\nthe case where other statements, in addition to the ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statement,\nmust be executed conditionally. For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Process_Requests:\n   loop\n      if Status = Done then\n\n         Shut_Down;\n         exit Process_Requests;\n\n      end if;\n\n      ...\n\n   end loop Process_Requests;\n")),(0,i.yg)("p",null,"Loops with many scattered ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements can indicate fuzzy thinking\nregarding the loop's purpose in the algorithm. Such an algorithm might\nbe coded better some other way, for example, with a series of loops.\nSome rework can often reduce the number of ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," statements and make\nthe code clearer."),(0,i.yg)("p",null,"See also Guidelines 5.1.3 and 5.6.4."),(0,i.yg)("h3",{id:"recursion-and-iteration-bounds"},"Recursion and Iteration Bounds"),(0,i.yg)("h4",{id:"guideline-5"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Consider specifying bounds on loops ."),(0,i.yg)("li",{parentName:"ul"},"Consider specifying bounds on recursion .")),(0,i.yg)("h4",{id:"example-5"},"example"),(0,i.yg)("p",null,"Establishing an iteration bound:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Safety_Counter := 0;\nProcess_List:\n   loop\n      exit when Current_Item = null;\n      ...\n      Current_Item := Current_Item.Next;\n      ...\n      Safety_Counter := Safety_Counter + 1;\n      if Safety_Counter > 1_000_000 then\n         raise Safety_Error;\n      end if;\n   end loop Process_List;\n")),(0,i.yg)("p",null,"Establishing a recursion bound:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"subtype Recursion_Bound is Natural range 0 .. 1_000;\n\nprocedure Depth_First (Root           : in     Tree;\n                       Safety_Counter : in     Recursion_Bound\n                                      := Recursion_Bound'Last) is\nbegin\n   if Root /= null then\n      if Safety_Counter = 0 then\n         raise Recursion_Error;\n      end if;\n      Depth_First (Root           => Root.Left_Branch,\n                   Safety_Counter => Safety_Counter - 1);\n\n      Depth_First (Root           => Root.Right_Branch,\n                   Safety_Counter => Safety_Counter - 1);\n      ... -- normal subprogram body\n   end if;\nend Depth_First;\n")),(0,i.yg)("p",null,"Following are examples of this subprogram's usage. One call specifies a\nmaximum recursion depth of 50. The second takes the default (1,000). The\nthird uses a computed bound:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Depth_First(Root => Tree_1, Safety_Counter => 50);\nDepth_First(Tree_2);\nDepth_First(Root => Tree_3, Safety_Counter => Current_Tree_Height);\n")),(0,i.yg)("h4",{id:"rationale-5"},"rationale"),(0,i.yg)("p",null,"Recursion, and iteration using structures other than ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," statements,\ncan be infinite because the expected terminating condition does not\narise. Such faults are sometimes quite subtle, may occur rarely, and may\nbe difficult to detect because an external manifestation might be absent\nor substantially delayed."),(0,i.yg)("p",null,"By including counters and checks on the counter values, in addition to\nthe loops themselves, you can prevent many forms of infinite loops. The\ninclusion of such checks is one aspect of the technique called Safe\nProgramming (Anderson and Witty 1978)."),(0,i.yg)("p",null,'The bounds of these checks do not have to be exact, just realistic. Such\ncounters and checks are not part of the primary control structure of the\nprogram but a benign addition functioning as an execution-time "safety\nnet," allowing error detection and possibly recovery from potential\ninfinite loops or infinite recursion.'),(0,i.yg)("h4",{id:"notes-2"},"notes"),(0,i.yg)("p",null,"If a loop uses the ",(0,i.yg)("inlineCode",{parentName:"p"},"for")," iteration scheme (Guideline 5.6.4), it follows\nthis guideline."),(0,i.yg)("h4",{id:"exceptions-2"},"exceptions"),(0,i.yg)("p",null,"Embedded control applications have loops that are intended to be\ninfinite. Only a few loops within such applications should qualify as\nexceptions to this guideline. The exceptions should be deliberate (and\ndocumented ) policy decisions."),(0,i.yg)("p",null,"This guideline is most important to safety critical systems. For other\nsystems, it may be overkill."),(0,i.yg)("h3",{id:"goto-statements"},"Goto Statements"),(0,i.yg)("h4",{id:"guideline-6"},"guideline"),(0,i.yg)("p",null,"Do not use ",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statements."),(0,i.yg)("h4",{id:"rationale-6"},"rationale"),(0,i.yg)("p",null,"A ",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statement is an unstructured change in the control flow. Worse,\nthe label does not require an indicator of where the corresponding\n",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statement(s) are. This makes code unreadable and makes its\ncorrect execution suspect."),(0,i.yg)("p",null,"Other languages use ",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statements to implement loop exits and\nexception handling. Ada's support of these constructs makes the ",(0,i.yg)("inlineCode",{parentName:"p"},"goto"),"\nstatement extremely rare."),(0,i.yg)("h4",{id:"notes-3"},"notes"),(0,i.yg)("p",null,"If you should ever use a ",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statement, highlight both it and the\nlabel with blank space. Indicate at the label where the corresponding\n",(0,i.yg)("inlineCode",{parentName:"p"},"goto")," statement(s) may be found."),(0,i.yg)("h3",{id:"return-statements"},"Return Statements"),(0,i.yg)("h4",{id:"guideline-7"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Minimize the number of ",(0,i.yg)("inlineCode",{parentName:"li"},"return"),"statementsfrom a subprogram (NASA\n1987)."),(0,i.yg)("li",{parentName:"ul"},"Highlight ",(0,i.yg)("inlineCode",{parentName:"li"},"return"),"statements with comments or white space to keep\nthem from being lost in other code.")),(0,i.yg)("h4",{id:"example-6"},"example"),(0,i.yg)("p",null,"The following code fragment is longer and more complex than necessary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"if Pointer /= null then\n   if Pointer.Count > 0 then\n      return True;\n   else  -- Pointer.Count = 0\n      return False;\n   end if;\nelse  -- Pointer = null\n   return False;\nend if;\n")),(0,i.yg)("p",null,"It should be replaced with the shorter, more concise, and clearer\nequivalent line:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"return Pointer /= null and then Pointer.Count > 0;\n")),(0,i.yg)("h4",{id:"rationale-7"},"rationale"),(0,i.yg)("p",null,"Excessive use of returns can make code confusing and unreadable. Only\nuse ",(0,i.yg)("inlineCode",{parentName:"p"},"return")," statements where warranted. Too many returns from a\nsubprogram may be an indicator of cluttered logic. If the application\nrequires multiple returns, use them at the same level (i.e., as in\ndifferent branches of a ",(0,i.yg)("inlineCode",{parentName:"p"},"case")," statement), rather than scattered\nthroughout the subprogram code. Some rework can often reduce the number\nof ",(0,i.yg)("inlineCode",{parentName:"p"},"return")," statements to one and make the code more clear."),(0,i.yg)("h4",{id:"exceptions-3"},"exceptions"),(0,i.yg)("p",null,"Do not avoid ",(0,i.yg)("inlineCode",{parentName:"p"},"return")," statements if it detracts from natural structure\nand code readability."),(0,i.yg)("h3",{id:"blocks"},"Blocks"),(0,i.yg)("h4",{id:"guideline-8"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use blocks to localize the scope of declarations."),(0,i.yg)("li",{parentName:"ul"},"Use blocks to perform local renaming."),(0,i.yg)("li",{parentName:"ul"},"Use blocks to define local exception handlers.")),(0,i.yg)("h4",{id:"example-7"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"with Motion;\nwith Accelerometer_Device;\n...\n\n   ---------------------------------------------------------------------\n   function Maximum_Velocity return Motion.Velocity is\n\n      Cumulative : Motion.Velocity := 0.0;\n\n   begin  -- Maximum_Velocity\n\n      -- Initialize the needed devices\n      ...\n\n      Calculate_Velocity_From_Sample_Data:\n         declare\n            use type Motion.Acceleration;\n\n            Current       : Motion.Acceleration := 0.0;\n            Time_Delta    : Duration;\n\n         begin  -- Calculate_Velocity_From_Sample_Data\n            for I in 1 .. Accelerometer_Device.Sample_Limit loop\n\n               Get_Samples_And_Ignore_Invalid_Data:\n                  begin\n                     Accelerometer_Device.Get_Value(Current, Time_Delta);\n                  exception\n                     when Constraint_Error =>\n                        null; -- Continue trying\n\n                     when Accelerometer_Device.Failure =>\n                        raise Accelerometer_Device_Failed;\n                  end Get_Samples_And_Ignore_Invalid_Data;\n\n               exit when Current <= 0.0; -- Slowing down\n\n               Update_Velocity:\n                  declare\n                     use type Motion.Velocity;\n                     use type Motion.Acceleration;\n\n                  begin\n                     Cumulative := Cumulative + Current * Time_Delta;\n\n                  exception\n                     when Constraint_Error =>\n                        raise Maximum_Velocity_Exceeded;\n                  end Update_Velocity;\n\n            end loop;\n         end Calculate_Velocity_From_Sample_Data;\n\n      return Cumulative;\n\n   end Maximum_Velocity;\n   ---------------------------------------------------------------------\n...\n")),(0,i.yg)("h4",{id:"rationale-8"},"rationale"),(0,i.yg)("p",null,"Blocks break up large segments of code and isolate details relevant to\neach subsection of code. Variables that are only used in a particular\nsection of code are clearly visible when a declarative block delineates\nthat code."),(0,i.yg)("p",null,"Renaming may simplify the expression of algorithms and enhance\nreadability for a given section of code. But it is confusing when a\n",(0,i.yg)("inlineCode",{parentName:"p"},"renames")," clause is visually separated from the code to which it\napplies. The declarative region allows the ",(0,i.yg)("inlineCode",{parentName:"p"},"renames")," to be immediately\nvisible when the reader is examining code that uses that abbreviation.\nGuideline 5.7.1 discusses a similar guideline concerning the ",(0,i.yg)("inlineCode",{parentName:"p"},"use"),"\nclause."),(0,i.yg)("p",null,"Local exception handlers can catch exceptions close to the point of\norigin and allow them to be either handled, propagated, or converted."),(0,i.yg)("h3",{id:"aggregates"},"Aggregates"),(0,i.yg)("h4",{id:"guideline-9"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use an aggregate instead of a sequence of assignments to assign\nvalues to all components of a record."),(0,i.yg)("li",{parentName:"ul"},"Use an aggregate instead of a temporary variable when building a\nrecord to pass as an actual parameter."),(0,i.yg)("li",{parentName:"ul"},"Use positional association only when there is a conventional\nordering of the arguments.")),(0,i.yg)("h4",{id:"example-8"},"example"),(0,i.yg)("p",null,"It is better to use aggregates:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Set_Position((X, Y));\nEmployee_Record := (Number     => 42,\n                    Age        => 51,\n                    Department => Software_Engineering);\n")),(0,i.yg)("p",null,"than to use consecutive assignments or temporary variables:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Temporary_Position.X := 100;\nTemporary_Position.Y := 200;\nSet_Position(Temporary_Position);\nEmployee_Record.Number     := 42;\nEmployee_Record.Age        := 51;\nEmployee_Record.Department := Software_Engineering;\n")),(0,i.yg)("h4",{id:"rationale-9"},"rationale"),(0,i.yg)("p",null,"Using aggregates during maintenance is beneficial. If a record structure\nis altered, but the corresponding aggregate is not, the compiler flags\nthe missing field in the aggregate assignment. It would not be able to\ndetect the fact that a new assignment statement should have been added\nto a list of assignment statements."),(0,i.yg)("p",null,"Aggregates can also be a real convenience in combining data items into a\nrecord or array structure required for passing the information as a\nparameter. Named component association makes aggregates more readable."),(0,i.yg)("p",null,"See Guideline 10.4.5 for the performance impact of aggregates."))}c.isMDXComponent=!0}}]);