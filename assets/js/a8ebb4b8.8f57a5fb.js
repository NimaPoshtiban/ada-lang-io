"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[417],{1716:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var a=n(6687);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=i,m=d["".concat(c,".").concat(u)]||d[u]||p[u]||o;return n?a.createElement(m,r(r({ref:t},h),{},{components:n})):a.createElement(m,r({ref:t},h))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7818:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(9440),i=(n(6687),n(1716));const o={sidebar_position:12},r="11 Exceptions",s={unversionedId:"arm/AA-11",id:"arm/AA-11",title:"11 Exceptions",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-11.md",sourceDirName:"arm",slug:"/arm/AA-11",permalink:"/docs/arm/AA-11",draft:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"10 Program Structure and Compilation Issues",permalink:"/docs/arm/AA-10"},next:{title:"12 Generic Units",permalink:"/docs/arm/AA-12"}},c={},l=[{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"11.1  Exception Declarations",id:"111--exception-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"11.2  Exception Handlers",id:"112--exception-handlers",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"11.3  Raise Statements",id:"113--raise-statements",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"11.4  Exception Handling",id:"114--exception-handling",level:2},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"11.4.1  The Package Exceptions",id:"1141--the-package-exceptions",level:3},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Syntax",id:"syntax-3",level:4},{value:"11.4.2  Example of Exception Handling",id:"1142--example-of-exception-handling",level:3},{value:"Examples",id:"examples-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"11.5  Suppressing Checks",id:"115--suppressing-checks",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"11.6  Exceptions and Optimization",id:"116--exceptions-and-optimization",level:2},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4}],h={toc:l};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"11-exceptions"},"11 Exceptions"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"[This section defines the facilities for dealing with errors or other exceptional situations that arise during program execution.]"," An exception represents a kind of exceptional situation; an occurrence of such a situation (at run time) is called an exception occurrence. ","[ To raise an exception is to abandon normal program execution so as to draw attention to the fact that the corresponding situation has arisen. Performing some actions in response to the arising of an exception is called handling the exception. ]"),(0,i.kt)("p",null,"To be honest: ...or handling the exception occurrence. "),(0,i.kt)("p",null,"Ramification: For example, an exception End_Error might represent error situations in which an attempt is made to read beyond end-of-file. During the execution of a partition, there might be numerous occurrences of this exception. "),(0,i.kt)("p",null,'To be honest: When the meaning is clear from the context, we sometimes use "occurrence" as a short-hand for "exception occurrence". '),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[exception]",", Def=","[a kind of exceptional situation]"," Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[exception occurrence]",", Def=","[a run-time occurrence of an exceptional situation]"),(0,i.kt)("p",null,"[An exception_declaration declares a name for an exception. An exception is raised initially either by a raise_statement or by the failure of a language-defined check. When an exception arises, control can be transferred to a user-provided exception_handler at the end of a handled_sequence_of_statements, or it can be propagated to a dynamically enclosing execution.]"," "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We are more explicit about the difference between an exception and an occurrence of an exception. This is necessary because we now have a type (Exception_Occurrence) that represents exception occurrences, so the program can manipulate them. Furthermore, we say that when an exception is propagated, it is the same occurrence that is being propagated (as opposed to a new occurrence of the same exception). The same issue applies to a re-raise statement. In order to understand these semantics, we have to make this distinction. "),(0,i.kt)("h2",{id:"111--exception-declarations"},"11.1  Exception Declarations"),(0,i.kt)("p",null,"An exception_declaration declares a name for an exception. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"exception_declaration ::= defining_identifier_list : exception;"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"Each single exception_declaration declares a name for a different exception. If a generic unit includes an exception_declaration, the exception_declarations implicitly generated by different instantiations of the generic unit refer to distinct exceptions (but all have the same defining_identifier). The particular exception denoted by an exception name is determined at compilation time and is the same regardless of how many times the exception_declaration is elaborated. "),(0,i.kt)("p",null,"Reason: We considered removing this requirement inside generic bodies, because it is an implementation burden for implementations that wish to share code among several instances. In the end, it was decided that it would introduce too much implementation dependence. "),(0,i.kt)("p",null,"Ramification: Hence, if an exception_declaration occurs in a recursive subprogram, the exception name denotes the same exception for all invocations of the recursive subprogram. The reason for this rule is that we allow an exception occurrence to propagate out of its declaration's innermost containing master; if exceptions were created by their declarations like other entities, they would presumably be destroyed upon leaving the master; we would have to do something special to prevent them from propagating to places where they no longer exist. "),(0,i.kt)("p",null,"Ramification: Exception identities are unique across all partitions of a program. "),(0,i.kt)("p",null,"The predefined exceptions are the ones declared in the declaration of package Standard: Constraint_Error, Program_Error, Storage_Error, and Tasking_Error","[; one of them is raised when a language-defined check fails.]"," "),(0,i.kt)("p",null,"Ramification: The exceptions declared in the language-defined package IO_Exceptions, for example, are not predefined. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an exception_declaration has no effect."),(0,i.kt)("p",null,"The execution of any construct raises Storage_Error if there is insufficient storage for that execution. The amount of storage needed for the execution of constructs is unspecified. "),(0,i.kt)("p",null,"Ramification: Note that any execution whatsoever can raise Storage_Error. This allows much implementation freedom in storage management. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of user-defined exception declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Singular : exception;\nError    : exception;\nOverflow, Underflow : exception;\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,'The exception Numeric_Error is now defined in the Obsolescent features Annex, as a rename of Constraint_Error. All checks that raise Numeric_Error in Ada 83 instead raise Constraint_Error in Ada 95. To increase upward compatibility, we also changed the rules to allow the same exception to be named more than once by a given handler. Thus, "when Constraint_Error | Numeric_Error =',">",'" will remain legal in Ada 95, even though Constraint_Error and Numeric_Error now denote the same exception. However, it will not be legal to have separate handlers for Constraint_Error and Numeric_Error. This change is inconsistent in the rare case that an existing program explicitly raises Numeric_Error at a point where there is a handler for Constraint_Error; the exception will now be caught by that handler. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We explicitly define elaboration for exception_declarations. "),(0,i.kt)("h2",{id:"112--exception-handlers"},"11.2  Exception Handlers"),(0,i.kt)("p",null,"[The response to one or more exceptions is specified by an exception_handler.]"," "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"handled_sequence_of_statements ::=\nsequence_of_statements\n","[exception\nexception_handler\n{exception_handler}]"),(0,i.kt)("p",null,"exception_handler ::=\nwhen ","[choice_parameter_specification:]"," exception_choice {| exception_choice} =",">","\nsequence_of_statements"),(0,i.kt)("p",null,"choice_parameter_specification ::= defining_identifier"),(0,i.kt)("p",null,"exception_choice ::= exception_name | others"),(0,i.kt)("p",null,'To be honest: "Handler" is an abbreviation for "exception_handler".'),(0,i.kt)("p",null,'Within this section, we sometimes abbreviate "exception_choice" to "choice". '),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"A choice with an exception_name covers the named exception. A choice with others covers all exceptions not named by previous choices of the same handled_sequence_of_statements. Two choices in different exception_handlers of the same handled_sequence_of_statements shall not cover the same exception. "),(0,i.kt)("p",null,'Ramification: Two exception_choices of the same exception_handler may cover the same exception. For example, given two renaming declarations in separate packages for the same exception, one may nevertheless write, for example, "when Ada.Text_IO.Data_Error | My_Seq_IO.Data_Error =',">",'".'),(0,i.kt)("p",null,"An others choice even covers exceptions that are not visible at the place of the handler. Since exception raising is a dynamic activity, it is entirely possible for an others handler to handle an exception that it could not have named. "),(0,i.kt)("p",null,"A choice with others is allowed only for the last handler of a handled_sequence_of_statements and as the only choice of that handler."),(0,i.kt)("p",null,"An exception_name of a choice shall not denote an exception declared in a generic formal package. "),(0,i.kt)("p",null,"Reason: This is because the compiler doesn't know the identity of such an exception, and thus can't enforce the coverage rules. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"A choice_parameter_specification declares a choice parameter, which is a constant object of type Exception_Occurrence (see 11.4.1). During the handling of an exception occurrence, the choice parameter, if any, of the handler represents the exception occurrence that is being handled."),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"The execution of a handled_sequence_of_statements consists of the execution of the sequence_of_statements. ","[The optional handlers are used to handle any exceptions that are propagated by the sequence_of_statements.]"," "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Example of an exception handler: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'begin\n   Open(File, In_File, "input.txt");   -- see A.8.2\nexception\n   when E : Name_Error =&gt\n      Put("Cannot open input file : ");\n      Put_Line(Exception_Message(E));  -- see 11.4.1\n      raise;\nend;\n\n')),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for exception_handler is modified to allow a choice_parameter_specification."),(0,i.kt)("p",null,'Different choices of the same exception_handler may cover the same exception. This allows for "when Numeric_Error | Constraint_Error =',">",'" even though Numeric_Error is a rename of Constraint_Error. This also allows one to "with" two different I/O packages, and then write, for example, "when Ada.Text_IO.Data_Error | My_Seq_IO.Data_Error =',">",'" even though these might both be renames of the same exception. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for handled_sequence_of_statements is new. These are now used in all the places where handlers are allowed. This obviates the need to explain (in Sections 5, 6, 7, and 9) what portions of the program are handled by the handlers. Note that there are more such cases in Ada 95."),(0,i.kt)("p",null,"The syntax rule for choice_parameter_specification is new. "),(0,i.kt)("h2",{id:"113--raise-statements"},"11.3  Raise Statements"),(0,i.kt)("p",null,"[A raise_statement raises an exception.]"," "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"raise_statement ::= raise ","[exception_name]",";"),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"The name, if any, in a raise_statement shall denote an exception. A raise_statement with no exception_name (that is, a re-raise statement) shall be within a handler, but not within a body enclosed by that handler. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"To raise an exception is to raise a new occurrence of that exception","[, as explained in 11.4]",". For the execution of a raise_statement with an exception_name, the named exception is raised. For the execution of a re-raise statement, the exception occurrence that caused transfer of control to the innermost enclosing handler is raised ","[again]",". "),(0,i.kt)("p",null,"Implementation Note: For a re-raise statement, the implementation does not create a new Exception_Occurrence, but instead propagates the same Exception_Occurrence value. This allows the original cause of the exception to be determined. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[raise an exception]",", Def=","[to abandon normal program execution so as to draw attention to the fact that the corresponding situation has arisen]"," "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Examples of raise statements: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"raise Ada.IO_Exceptions.Name_Error;   -- see A.13\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"raise;                                -- re-raise the current exception\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The fact that the name in a raise_statement has to denote an exception is not clear from RM83. Clearly that was the intent, since the italicized part of the syntax rules so indicate, but there was no explicit rule. RM83-1.5(11) doesn't seem to give the italicized parts of the syntax any force. "),(0,i.kt)("h2",{id:"114--exception-handling"},"11.4  Exception Handling"),(0,i.kt)("p",null,"[When an exception occurrence is raised, normal program execution is abandoned and control is transferred to an applicable exception_handler, if any. To handle an exception occurrence is to respond to the exceptional event. To propagate an exception occurrence is to raise it again in another context; that is, to fail to respond to the exceptional event in the present context.]"," "),(0,i.kt)("p",null,"Ramification: In other words, if the execution of a given construct raises an exception, but does not handle it, the exception is propagated to an enclosing execution (except in the case of a task_body)."),(0,i.kt)("p",null,"Propagation involves re-raising the same exception occurrence(assuming the implementation has not taken advantage of the Implementation Permission of 11.3). For example, calling an entry of an uncallable task raises Tasking_Error; this is not propagation. "),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"Within a given task, if the execution of construct a is defined by this document to consist (in part) of the execution of construct b, then while b is executing, the execution of a is said to dynamically enclose the execution of b. The innermost dynamically enclosing execution of a given execution is the dynamically enclosing execution that started most recently. "),(0,i.kt)("p",null,"To be honest: If the execution of a dynamically encloses that of b, then we also say that the execution of b is included in the execution of a. "),(0,i.kt)("p",null,'Ramification: Examples: The execution of an if_statement dynamically encloses the evaluation of the condition after the if (during that evaluation). (Recall that "execution" includes both "elaboration" and "evaluation", as well as other executions.) The evaluation of a function call dynamically encloses the execution of the sequence_of_statements of the function body (during that execution). Note that, due to recursion, several simultaneous executions of the same construct can be occurring at once during the execution of a particular task.'),(0,i.kt)("p",null,"Dynamically enclosing is not defined across task boundaries; a task's execution does not include the execution of any other tasks."),(0,i.kt)("p",null,"Dynamically enclosing is only defined for executions that are occurring at a given moment in time; if an if_statement is currently executing the sequence_of_statements after then, then the evaluation of the condition is no longer dynamically enclosed by the execution of the if_statement (or anything else). "),(0,i.kt)("p",null,"When an exception occurrence is raised by the execution of a given construct, the rest of the execution of that construct is abandoned; that is, any portions of the execution that have not yet taken place are not performed. The construct is first completed, and then left, as explained in 7.6.1. Then: "),(0,i.kt)("p",null,"If the construct is a task_body, the exception does not propagate further; "),(0,i.kt)("p",null,"Ramification: When an exception is raised by the execution of a task_body, there is no dynamically enclosing execution, so the exception does not propagate any further. If the exception occurred during the activation of the task, then the activator raises Tasking_Error, as explained in 9.2, \"Task Execution - Task Activation\", but we don't define that as propagation; it's a special rule. Otherwise (the exception occurred during the execution of the handled_sequence_of_statements of the task), the task silently disappears. Thus, abnormal termination of tasks is not always considered to be an error. "),(0,i.kt)("p",null,"If the construct is the sequence_of_statements of a handled_sequence_of_statements that has a handler with a choice covering the exception, the occurrence is handled by that handler;"),(0,i.kt)("p",null,"Otherwise, the occurrence is propagated to the innermost dynamically enclosing execution, which means that the occurrence is raised again in that context. "),(0,i.kt)("p",null,"To be honest: As shorthands, we refer to the propagation of an exception, and the propagation by a construct, if the execution of the construct propagates an exception occurrence. "),(0,i.kt)("p",null,"When an occurrence is handled by a given handler, the choice_parameter_specification, if any, is first elaborated, which creates the choice parameter and initializes it to the occurrence. Then, the sequence_of_statements of the handler is executed; this execution replaces the abandoned portion of the execution of the sequence_of_statements. "),(0,i.kt)("p",null,'Ramification: This "replacement" semantics implies that the handler can do pretty much anything the abandoned sequence could do; for example, in a function, the handler can execute a return_statement that applies to the function. '),(0,i.kt)("p",null,"Ramification: The rules for exceptions raised in library units, main subprograms and partitions follow from the normal rules, plus the semantics of the environment task described in Section 10 (for example, the environment task of a partition elaborates library units and calls the main subprogram). If an exception is propagated by the main subprogram, it is propagated to the environment task, which then terminates abnormally, causing the partition to terminate abnormally. Although abnormal termination of tasks is not necessarily an error, abnormal termination of a partition due to an exception is an error. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[handle an exception]",", Def=","[performing some actions in response to the arising of an exception]"," "),(0,i.kt)("p",null,"NOTE 1   Note that exceptions raised in a declarative_part of a body are not handled by the handlers of the handled_sequence_of_statements of that body. "),(0,i.kt)("h3",{id:"1141--the-package-exceptions"},"11.4.1  The Package Exceptions"),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Exceptions  is\n    type Exception_Id is private;\n    Null_Id : constant Exception_Id;\n    function Exception_Name(Id : Exception_Id) return String;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Exception_Occurrence is limited private;\n    type Exception_Occurrence_Access is access all Exception_Occurrence;\n    Null_Occurrence : constant Exception_Occurrence;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'    procedure Raise_Exception(E : in Exception_Id;\n                              Message : in String := "");\n    function Exception_Message(X : Exception_Occurrence) return String;\n    procedure Reraise_Occurrence(X : in Exception_Occurrence);\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    function Exception_Identity(X : Exception_Occurrence)\n                                return Exception_Id;\n    function Exception_Name(X : Exception_Occurrence) return String;\n        -- Same as Exception_Name(Exception_Identity(X)).\n    function Exception_Information(X : Exception_Occurrence) return String;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Save_Occurrence(Target : out Exception_Occurrence;\n                              Source : in Exception_Occurrence);\n    function Save_Occurrence(Source : Exception_Occurrence)\n                             return Exception_Occurrence_Access;\nprivate\n   ... -- not specified by the language\nend Ada.Exceptions;\n\n")),(0,i.kt)("p",null,"Each distinct exception is represented by a distinct value of type Exception_Id. Null_Id does not represent any exception, and is the default initial value of type Exception_Id. Each occurrence of an exception is represented by a value of type Exception_Occurrence. Null_Occurrence does not represent any exception occurrence, and is the default initial value of type Exception_Occurrence."),(0,i.kt)("p",null,"For a prefix E that denotes an exception, the following attribute is defined: "),(0,i.kt)("p",null,"E'IdentityE'Identity returns the unique identity of the exception. The type of this attribute is Exception_Id. "),(0,i.kt)("p",null,"Ramification: In a distributed program, the identity is unique across an entire program, not just across a single partition. Exception propagation works properly across RPC's. An exception can be propagated from one partition to another, and then back to the first, where its identity is known. "),(0,i.kt)("p",null,"Raise_Exception raises a new occurrence of the identified exception. In this case Exception_Message returns the Message parameter of Raise_Exception. For a raise_statement with an exception_name, Exception_Message returns implementation-defined information about the exception occurrence. Reraise_Occurrence reraises the specified exception occurrence."),(0,i.kt)("p",null,"Implementation defined: The information returned by Exception_Message."),(0,i.kt)("p",null,"Ramification: Given an exception E, the raise_statement: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"raise E;\n\n")),(0,i.kt)("p",null,"is equivalent to this call to Raise_Exception: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Raise_Exception(E'Identity, Message =&gt implementation-defined-string);\n\n")),(0,i.kt)("p",null,"Ramification: The following handler: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"when others =&gt\n    Cleanup;\n    raise;\n\n")),(0,i.kt)("p",null,"is equivalent to this one: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"when X : others =&gt\n    Cleanup;\n    Reraise_Occurrence(X);\n\n")),(0,i.kt)("p",null,"Exception_Identity returns the identity of the exception of the occurrence."),(0,i.kt)("p",null,"The Exception_Name functions return the full expanded name of the exception, in upper case, starting with a root library unit. For an exception declared immediately within package Standard, the defining_identifier is returned. The result is implementation defined if the exception is declared within an unnamed block_statement. "),(0,i.kt)("p",null,"Ramification: See the Implementation Permission below. "),(0,i.kt)("p",null,"To be honest: This name, as well as each prefix of it, does not denote a renaming_declaration. "),(0,i.kt)("p",null,"Implementation defined: The result of Exceptions.Exception_Name for types declared within an unnamed block_statement."),(0,i.kt)("p",null,"Ramification: Note that we're talking about the name of the exception, not the name of the occurrence. "),(0,i.kt)("p",null,"Exception_Information returns implementation-defined information about the exception occurrence. "),(0,i.kt)("p",null,"Implementation defined: The information returned by Exception_Information."),(0,i.kt)("p",null,"Raise_Exception and Reraise_Occurrence have no effect in the case of Null_Id or Null_Occurrence. Exception_Message, Exception_Identity, Exception_Name, and Exception_Information raise Constraint_Error for a Null_Id or Null_Occurrence."),(0,i.kt)("p",null,"The Save_Occurrence procedure copies the Source to the Target. The Save_Occurrence function uses an allocator of type Exception_Occurrence_Access to create a new object, copies the Source to this new object, and returns an access value designating this new object; ","[the result may be deallocated using an instance of Unchecked_Deallocation.]"," "),(0,i.kt)("p",null,"Ramification: It's OK to pass Null_Occurrence to the Save_Occurrence subprograms; they don't raise an exception, but simply save the Null_Occurrence. "),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation of the Write attribute (see 13.13.2) of Exception_Occurrence shall support writing a representation of an exception occurrence to a stream; the implementation of the Read attribute of Exception_Occurrence shall support reconstructing an exception occurrence from a stream (including one written in a different partition). "),(0,i.kt)("p",null,"Ramification: The identity of the exception, as well as the Exception_Name and Exception_Message, have to be preserved across partitions."),(0,i.kt)("p",null,"The string returned by Exception_Name or Exception_Message on the result of calling the Read attribute on a given stream has to be the same as the value returned by calling the corresponding function on the exception occurrence that was written into the stream with the Write attribute. The string returned by Exception_Information need not be the same, since it is implementation defined anyway. "),(0,i.kt)("p",null,"Reason: This is important for supporting writing exception occurrences to external files for post-mortem analysis, as well as propagating exceptions across remote subprogram calls in a distributed system (see E.4). "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation of Exception_Name in a space-constrained environment may return the defining_identifier instead of the full expanded name."),(0,i.kt)("p",null,"The string returned by Exception_Message may be truncated (to no less than 200 characters) by the Save_Occurrence procedure ","[(not the function)]",", the Reraise_Occurrence procedure, and the re-raise statement. "),(0,i.kt)("p",null,'Reason: The reason for allowing truncation is to ease implementations. The reason for choosing the number 200 is that this is the minimum source line length that implementations have to support, and this feature seems vaguely related since it\'s usually a "one-liner". Note that an implementation is allowed to do this truncation even if it supports arbitrarily long lines. '),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"Exception_Message (by default) and Exception_Information should produce information useful for debugging. Exception_Message should be short (about one line), whereas Exception_Information can be long. Exception_Message should not include the Exception_Name. Exception_Information should include both the Exception_Name and the Exception_Message."),(0,i.kt)("p",null,"Reason: It may seem strange to define two subprograms whose semantics is implementation defined. The idea is that a program can print out debugging/error-logging information in a portable way. The program is portable in the sense that it will work in any implementation; it might print out different information, but the presumption is that the information printed out is appropriate for debugging/error analysis on that system. "),(0,i.kt)("p",null,"Implementation Note: As an example, Exception_Information might include information identifying the location where the exception occurred, and, for predefined exceptions, the specific kind of language-defined check that failed. There is an implementation trade-off here, between how much information is represented in an Exception_Occurrence, and how much can be passed through a re-raise."),(0,i.kt)("p",null,"The string returned should be in a form suitable for printing to an error log file. This means that it might need to contain line-termination control characters with implementation-defined I/O semantics. The string should neither start nor end with a newline."),(0,i.kt)("p",null,"If an implementation chooses to provide additional functionality related to exceptions and their occurrences, it should do so by providing one or more children of Ada.Exceptions."),(0,i.kt)("p",null,'Note that exceptions behave as if declared at library level; there is no "natural scope" for an exception; an exception always exists. Hence, there is no harm in saving an exception occurrence in a data structure, and reraising it later. The reraise has to occur as part of the same program execution, so saving an exception occurrence in a file, reading it back in from a different program execution, and then reraising it is not required to work. This is similar to I/O of access types. Note that it is possible to use RPC to propagate exceptions across partitions.'),(0,i.kt)("p",null,"Here's one way to implement Exception_Occurrence in the private part of the package. Using this method, an implementation need store only the actual number of characters in exception messages. If the user always uses small messages, then exception occurrences can be small. If the user never uses messages, then exception occurrences can be smaller still: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence(Message_Length : Natural := 200) is\n    limited record\n        Id : Exception_Id;\n        Message : String(1..Message_Length);\n    end record;\n\n")),(0,i.kt)("p",null,"At the point where an exception is raised, an Exception_Occurrence can be allocated on the stack with exactly the right amount of space for the message - none for an empty message. This is just like declaring a constrained object of the type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Temp : Exception_Occurrence(10); -- for a 10-character message\n\n")),(0,i.kt)("p",null,"After finding the appropriate handler, the stack can be cut back, and the Temp copied to the right place. This is similar to returning an unknown-sized object from a function. It is not necessary to allocate the maximum possible size for every Exception_Occurrence. If, however, the user declares an Exception_Occurrence object, the discriminant will be permanently set to 200. The Save_Occurrence procedure would then truncate the Exception_Message. Thus, nothing is lost until the user tries to save the occurrence. If the user is willing to pay the cost of heap allocation, the Save_Occurrence function can be used instead."),(0,i.kt)("p",null,"Note that any arbitrary-sized implementation-defined Exception_Information can be handled in a similar way. For example, if the Exception_Occurrence includes a stack traceback, a discriminant can control the number of stack frames stored. The traceback would be truncated or entirely deleted by the Save_Occurrence procedure - as the implementation sees fit."),(0,i.kt)("p",null,"If the internal representation involves pointers to data structures that might disappear, it would behoove the implementation to implement it as a controlled type, so that assignment can either copy the data structures or else null out the pointers. Alternatively, if the data structures being pointed at are in a task control block, the implementation could keep a unique sequence number for each task, so it could tell when a task's data structures no longer exist."),(0,i.kt)("p",null,"Using the above method, heap space is never allocated unless the user calls the Save_Occurrence function."),(0,i.kt)("p",null,"An alternative implementation would be to store the message strings on the heap when the exception is raised. (It could be the global heap, or it could be a special heap just for this purpose - it doesn't matter.)  This representation would be used only for choice parameters. For normal user-defined exception occurrences, the Save_Occurrence procedure would copy the message string into the occurrence itself, truncating as necessary. Thus, in this implementation, Exception_Occurrence would be implemented as a variant record: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence_Kind is (Normal, As_Choice_Param);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Exception_Occurrence(Kind : Exception_Occurrence_Kind := Normal) is\n    limited record\n        case Kind is\n            when Normal =&gt\n                ... -- space for 200 characters\n            when As_Choice_Param =&gt\n                ... -- pointer to heap string\n        end case;\n    end record;\n\n")),(0,i.kt)("p",null,"Exception_Occurrences created by the run-time system during exception raising would be As_Choice_Param. User-declared ones would be Normal - the user cannot see the discriminant, and so cannot set it to As_Choice_Param. The strings in the heap would be freed upon completion of the handler."),(0,i.kt)("p",null,"This alternative implementation corresponds to a heap-based implementation of functions returning unknown-sized results."),(0,i.kt)("p",null,"One possible implementation of Reraise_Occurrence is as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Reraise_Occurrence(X : in Exception_Occurrence) is\nbegin\n    Raise_Exception(Identity(X), Exception_Message(X));\nend Reraise_Occurrence;\n\n")),(0,i.kt)("p",null,"However, some implementations may wish to retain more information across a re-raise - a stack traceback, for example. "),(0,i.kt)("p",null,"Ramification: Note that Exception_Occurrence is a definite subtype. Hence, values of type Exception_Occurrence may be written to an error log for later analysis, or may be passed to subprograms for immediate error analysis. "),(0,i.kt)("p",null,"Implementation Note: If an implementation chooses to have a mode in which it supports non-Latin-1 characters in identifiers, then it needs to define what the above functions return in the case where the name of an exception contains such a character. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The Identity attribute of exceptions is new, as is the package Exceptions. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[R]",",Term=","[assertion]",", Def=","[a boolean expression that is expected to be True at run time at certain specified places]",", Note1=","[Certain pragmas and aspects define various kinds of assertions.]"),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"Implementation defined: "),(0,i.kt)("h3",{id:"1142--example-of-exception-handling"},"11.4.2  Example of Exception Handling"),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Exception handling may be used to separate the detection of an error from the response to that error: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Exceptions;\nuse Ada;\npackage File_System is\n    type File_Handle is limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    File_Not_Found : exception;\n    procedure Open(F : in out File_Handle; Name : String);\n        -- raises File_Not_Found if named file does not exist\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    End_Of_File : exception;\n    procedure Read(F : in out File_Handle; Data : out Data_Type);\n        -- raises End_Of_File if the file is not open\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    ...\nend File_System;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package body File_System is\n    procedure Open(F : in out File_Handle; Name : String) is\n    begin\n        if File_Exists(Name) then\n            ...\n        else\n            Exceptions.Raise_Exception(File_Not_Found\'Identity,\n                                      "File not found: " & Name & ".");\n        end if;\n    end Open;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Read(F : in out File_Handle; Data : out Data_Type) is\n    begin\n        if F.Current_Position &lt= F.Last_Position then\n            ...\n        else\n            raise End_Of_File;\n        end if;\n    end Read;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end File_System;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'with Ada.Text_IO;\nwith Ada.Exceptions;\nwith File_System; use File_System;\nuse Ada;\nprocedure Main is\nbegin\n    ... -- call operations in File_System\nexception\n    when End_Of_File =&gt\n        Close(Some_File);\n    when Not_Found_Error : File_Not_Found =&gt\n        Text_IO.Put_Line(Exceptions.Exception_Message(Not_Found_Error));\n    when The_Error : others =&gt\n        Text_IO.Put_Line("Unknown error:");\n        if Verbosity_Desired then\n            Text_IO.Put_Line(Exceptions.Exception_Information(The_Error));\n        else\n            Text_IO.Put_Line(Exceptions.Exception_Name(The_Error));\n            Text_IO.Put_Line(Exceptions.Exception_Message(The_Error));\n        end if;\n        raise;\nend Main;\n\n')),(0,i.kt)("p",null,"In the above example, the File_System package contains information about detecting certain exceptional situations, but it does not specify how to handle those situations. Procedure Main specifies how to handle them; other clients of File_System might have different handlers, even though the exceptional situations arise from the same basic causes. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The sections labeled "Exceptions Raised During ..." are subsumed by this clause, and by parts of Section 9. '),(0,i.kt)("h2",{id:"115--suppressing-checks"},"11.5  Suppressing Checks"),(0,i.kt)("p",null,"A pragma Suppress gives permission to an implementation to omit certain language-defined checks."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[suppress a check]",", Def=","[to assert that the check cannot fail, and to request that the compiler optimize by disabling the check]",", Note1=","[The compiler is not required to honor this request. Suppressing checks that can fail can cause a program to behave in arbitrary ways.]"),(0,i.kt)("p",null,'A language-defined check (or simply, a "check") is one of the situations defined by this document that requires a check to be made at run time to determine whether some condition is true. A check fails when the condition being checked is false, causing an exception to be raised. '),(0,i.kt)("p",null,'Discussion: All such checks are defined under "Dynamic Semantics" in clauses and subclauses throughout the standard. '),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[check]",", Def=","[a test made during execution to determine whether a language rule has been violated]"," "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Suppress is as follows: "),(0,i.kt)("p",null,"  pragma Suppress(identifier [, ","[On =",">]"," name]);"),(0,i.kt)("p",null,"A pragma Suppress is allowed only immediately within a declarative_part, immediately within a package_specification, or as a configuration pragma. "),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"The identifier shall be the name of a check. The name (if present) shall statically denote some entity."),(0,i.kt)("p",null,"For a pragma Suppress that is immediately within a package_specification and includes a name, the name shall denote an entity (or several overloaded subprograms) declared immediately within the package_specification. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"A pragma Suppress gives permission to an implementation to omit the named check from the place of the pragma to the end of the innermost enclosing declarative region, or, if the pragma is given in a package_specification and includes a name, to the end of the scope of the named entity. If the pragma includes a name, the permission applies only to checks performed on the named entity, or, for a subtype, on objects and values of its type. Otherwise, the permission applies to all entities. If permission has been given to suppress a given check, the check is said to be suppressed. "),(0,i.kt)("p",null,"Ramification: A check is suppressed even if the implementation chooses not to actually generate better code. This allows the implementation to raise Program_Error, for example, if the erroneousness is detected. "),(0,i.kt)("p",null,"The following are the language-defined checks: "),(0,i.kt)("p",null,"[The following checks correspond to situations in which the exception Constraint_Error is raised upon failure.]"),(0,i.kt)("p",null,"Access_Check When evaluating a dereference (explicit or implicit), check that the value of the name is not null. When passing an actual parameter to a formal access parameter, check that the value of the actual parameter is not null. "),(0,i.kt)("p",null,"Discriminant_Check Check that the discriminants of a composite value have the values imposed by a discriminant constraint. Also, when accessing a record component, check that it exists for the current discriminant values."),(0,i.kt)("p",null,"Division_Check Check that the second operand is not zero for the operations /, rem and mod."),(0,i.kt)("p",null,"Index_Check Check that the bounds of an array value are equal to the corresponding bounds of an index constraint. Also, when accessing a component of an array object, check for each dimension that the given index value belongs to the range defined by the bounds of the array object. Also, when accessing a slice of an array object, check that the given discrete range is compatible with the range defined by the bounds of the array object."),(0,i.kt)("p",null,"Length_Check Check that two arrays have matching components, in the case of array subtype conversions, and logical operators for arrays of boolean components."),(0,i.kt)("p",null,"Overflow_Check Check that a scalar value is within the base range of its type, in cases where the implementation chooses to raise an exception instead of returning the correct mathematical result."),(0,i.kt)("p",null,"Range_Check Check that a scalar value satisfies a range constraint. Also, for the elaboration of a subtype_indication, check that the constraint (if present) is compatible with the subtype denoted by the subtype_mark. Also, for an aggregate, check that an index or discriminant value belongs to the corresponding subtype. Also, check that when the result of an operation yields an array, the value of each component belongs to the component subtype."),(0,i.kt)("p",null,"Tag_Check Check that operand tags in a dispatching call are all equal. Check for the correct tag on tagged type conversions, for an assignment_statement, and when returning a tagged limited object from a function. "),(0,i.kt)("p",null,"[The following checks correspond to situations in which the exception Program_Error is raised upon failure.]"," "),(0,i.kt)("p",null,"Elaboration_Check When a subprogram or protected entry is called, a task activation is accomplished, or a generic instantiation is elaborated, check that the body of the corresponding unit has already been elaborated."),(0,i.kt)("p",null,"Accessibility_Check - Check the accessibility level of an entity or view. "),(0,i.kt)("p",null,"[The following check corresponds to situations in which the exception Storage_Error is raised upon failure.]"," "),(0,i.kt)("p",null,"Storage_Check Check that evaluation of an allocator does not require more space than is available for a storage pool. Check that the space available for a task or subprogram has not been exceeded. "),(0,i.kt)("p",null,"Reason: We considered splitting this out into three categories: Pool_Check (for allocators), Stack_Check (for stack usage), and Heap_Check (for implicit use of the heap - use of the heap other than through an allocator). Storage_Check would then represent the union of these three. However, there seems to be no compelling reason to do this, given that it is not feasible to split Storage_Error. "),(0,i.kt)("p",null,"[The following check corresponds to all situations in which any predefined exception is raised.]"," "),(0,i.kt)("p",null,"All_Checks Represents the union of all checks; suppressing All_Checks suppresses all checks."),(0,i.kt)("p",null,"Ramification: All_Checks includes both language-defined and implementation-defined checks. "),(0,i.kt)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,i.kt)("p",null,"If a given check has been suppressed, and the corresponding error situation occurs, the execution of the program is erroneous."),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation is allowed to place restrictions on Suppress pragmas. An implementation is allowed to add additional check names, with implementation-defined semantics. When Overflow_Check has been suppressed, an implementation may also suppress an unspecified subset of the Range_Checks. "),(0,i.kt)("p",null,"Reason: The permission to restrict is given so the implementation can give an error message when the requested suppression is nonsense, such as suppressing a Range_Check on a task type. It would be verbose and pointless to list all the cases of nonsensical language-defined checks in the standard, and since the list of checks is open-ended, we can't list the restrictions for implementation-defined checks anyway. "),(0,i.kt)("p",null,"Implementation defined: Implementation-defined check names."),(0,i.kt)("p",null,"Discussion: For Overflow_Check, the intention is that the implementation will suppress any Range_Checks that are implemented in the same manner as Overflow_Checks (unless they are free). "),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"The implementation should minimize the code executed for checks that have been suppressed. "),(0,i.kt)("p",null,"Implementation Note: However, if a given check comes for free (for example, the hardware automatically performs the check in parallel with doing useful work) or nearly free (for example, the check is a tiny portion of an expensive run-time system call), the implementation should not bother to suppress the check. Similarly, if the implementation detects the failure at compile time and provides a warning message, there is no need to actually suppress the check. "),(0,i.kt)("p",null,"NOTE 1   There is no guarantee that a suppressed check is actually removed; hence a pragma Suppress should be used only for efficiency reasons."),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Examples of suppressing checks: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"pragma Suppress(Range_Check);\npragma Suppress(Index_Check, On =&gt Table);\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"A pragma Suppress is allowed as a configuration pragma. A pragma Suppress without a name is allowed in a package_specification."),(0,i.kt)("p",null,"Additional check names are added. We allow implementations to define their own checks. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We define the checks in a distributed manner. Therefore, the long list of what checks apply to what is merely a NOTE."),(0,i.kt)("p",null,"We have removed the detailed rules about what is allowed in a pragma Suppress, and allow implementations to invent their own. The RM83 rules weren't quite right, and such a change is necessary anyway in the presence of implementation-defined checks."),(0,i.kt)("p",null,"We make it clear that the difference between a Range_Check and an Overflow_Check is fuzzy. This was true in Ada 83, given RM83-11.6, but it was not clear. We considered removing Overflow_Check from the language or making it obsolescent, just as we did for Numeric_Error. However, we kept it for upward compatibility, and because it may be useful on machines where range checking costs more than overflow checking, but overflow checking still costs something. Different compilers will suppress different checks when asked to suppress Overflow_Check - the nonuniformity in this case is not harmful, and removing it would have a serious impact on optimizers."),(0,i.kt)("p",null,"Under Access_Check, dereferences cover the cases of selected_component, indexed_component, slice, and attribute that are listed in RM83, as well as the new explicit_dereference, which was included in selected_component in RM83. "),(0,i.kt)("h2",{id:"116--exceptions-and-optimization"},"11.6  Exceptions and Optimization"),(0,i.kt)("p",null,'[ This clause gives permission to the implementation to perform certain "optimizations" that do not necessarily preserve the canonical semantics.]'," "),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"The rest of this Reference Manual (outside this clause) defines the canonical semantics of the language. ","[The canonical semantics of a given (legal) program determines a set of possible external effects that can result from the execution of the program with given inputs.]"," "),(0,i.kt)("p",null,"Ramification: Note that the canonical semantics is a set of possible behaviors, since some reordering, parallelism, and nondeterminism is allowed by the canonical semantics. "),(0,i.kt)("p",null,"Discussion: The following parts of the canonical semantics are of particular interest to the reader of this clause: "),(0,i.kt)("p",null,"Behavior in the presence of abnormal objects and objects with invalid representations (see 13.9.1)."),(0,i.kt)("p",null,"Various actions that are defined to occur in an arbitrary order."),(0,i.kt)("p",null,"Behavior in the presence of a misuse of Unchecked_Deallocation, Unchecked_Access, or imported or exported entity (see Section 13). "),(0,i.kt)("p",null,"[As explained in , the external effect of a program is defined in terms of its interactions with its external environment. Hence, the implementation can perform any internal actions whatsoever, in any order or in parallel, so long as the external effect of the execution of the program is one that is allowed by the canonical semantics, or by the rules of this clause.]"," "),(0,i.kt)("p",null,"Ramification: Note that an optimization can change the external effect of the program, so long as the changed external effect is an external effect that is allowed by the semantics. Note that the canonical semantics of an erroneous execution allows any external effect whatsoever. Hence, if the implementation can prove that program execution will be erroneous in certain circumstances, there need not be any constraints on the machine code executed in those circumstances. "),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"The following additional permissions are granted to the implementation: "),(0,i.kt)("p",null,"An implementation need not always raise an exception when a language-defined check fails. Instead, the operation that failed the check can simply yield an undefined result. The exception need be raised by the implementation only if, in the absence of raising it, the value of this undefined result would have some effect on the external interactions of the program. In determining this, the implementation shall not presume that an undefined result has a value that belongs to its subtype, nor even to the base range of its type, if scalar. ","[Having removed the raise of the exception, the canonical semantics will in general allow the implementation to omit the code for the check, and some or all of the operation itself.]"," "),(0,i.kt)("p",null,"Ramification: Even without this permission, an implementation can always remove a check if it cannot possibly fail. "),(0,i.kt)("p",null,'Reason: We express the permission in terms of removing the raise, rather than the operation or the check, as it minimizes the disturbance to the canonical semantics (thereby simplifying reasoning). By allowing the implementation to omit the raise, it thereby does not need to "look" at what happens in the exception handler to decide whether the optimization is allowed. '),(0,i.kt)("p",null,"Discussion: The implementation can also omit checks if they cannot possibly fail, or if they could only fail in erroneous executions. This follows from the canonical semantics. "),(0,i.kt)("p",null,'Implementation Note: This permission is intended to allow normal "dead code removal" optimizations, even if some of the removed code might have failed some language-defined check. However, one may not eliminate the raise of an exception if subsequent code presumes in some way that the check succeeded. For example: '),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'  if X * Y &gt Integer\'Last then\n      Put_Line("X * Y overflowed");\n  end if;\nexception\n  when others =&gt\n      Put_Line("X * Y overflowed");\n\n')),(0,i.kt)("p",null,"If X*Y does overflow, you may not remove the raise of the exception if the code that does the comparison against Integer'Last presumes that it is comparing it with an in-range Integer value, and hence always yields False."),(0,i.kt)("p",null,"As another example where a raise may not be eliminated: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'  subtype Str10 is String(1..10);\n  type P10 is access Str10;\n  X : P10 := null;\nbegin\n  if X.all\'Last = 10 then\n      Put_Line("Oops");\n  end if;\n\n')),(0,i.kt)("p",null,'In the above code, it would be wrong to eliminate the raise of Constraint_Error on the "X.all" (since X is null), if the code to evaluate \'Last always yields 10 by presuming that X.all belongs to the subtype Str10, without even "looking". '),(0,i.kt)("p",null,"If an exception is raised due to the failure of a language-defined check, then upon reaching the corresponding exception_handler (or the termination of the task, if none), the external interactions that have occurred need reflect only that the exception was raised somewhere within the execution of the sequence_of_statements with the handler (or the task_body), possibly earlier (or later if the interactions are independent of the result of the checked operation) than that defined by the canonical semantics, but not within the execution of some abort-deferred operation or independent subprogram that does not dynamically enclose the execution of the construct whose check failed. An independent subprogram is one that is defined outside the library unit containing the construct whose check failed, and has no Inline pragma applied to it. Any assignment that occurred outside of such abort-deferred operations or independent subprograms can be disrupted by the raising of the exception, causing the object or its parts to become abnormal, and certain subsequent uses of the object to be erroneous, as explained in 13.9.1. "),(0,i.kt)("p",null,'Reason: We allow such variables to become abnormal so that assignments (other than to atomic variables) can be disrupted due to "imprecise" exceptions or instruction scheduling, and so that assignments can be reordered so long as the correct results are produced in the end if no language-defined checks fail. '),(0,i.kt)("p",null,"Ramification: If a check fails, no result dependent on the check may be incorporated in an external interaction. In other words, there is no permission to output meaningless results due to postponing a check. "),(0,i.kt)("p",null,"Discussion: We believe it is important to state the extra permission to reorder actions in terms of what the programmer can expect at run time, rather than in terms of what the implementation can assume, or what transformations the implementation can perform. Otherwise, how can the programmer write reliable programs?"),(0,i.kt)("p",null,"This clause has two conflicting goals: to allow as much optimization as possible, and to make program execution as predictable as possible (to ease the writing of reliable programs). The rules given above represent a compromise."),(0,i.kt)("p",null,"Consider the two extremes:"),(0,i.kt)("p",null,"The extreme conservative rule would be to delete this clause entirely. The semantics of Ada would be the canonical semantics. This achieves the best predictability. It sounds like a disaster from the efficiency point of view, but in practice, implementations would provide modes in which less predictability but more efficiency would be achieved. Such a mode could even be the out-of-the-box mode. In practice, implementers would provide a compromise based on their customer's needs. Therefore, we view this as one viable alternative."),(0,i.kt)("p",null,'The extreme liberal rule would be "the language does not specify the execution of a program once a language-defined check has failed; such execution can be unpredictable". This achieves the best efficiency. It sounds like a disaster from the predictability point of view, but in practice it might not be so bad. A user would have to assume that exception handlers for exceptions raised by language-defined checks are not portable. They would have to isolate such code (like all nonportable code), and would have to find out, for each implementation of interest, what behaviors can be expected. In practice, implementations would tend to avoid going so far as to punish their customers too much in terms of predictability.'),(0,i.kt)("p",null,"The most important thing about this clause is that users understand what they can expect at run time, and implementers understand what optimizations are allowed. Any solution that makes this clause contain rules that can interpreted in more than one way is unacceptable."),(0,i.kt)("p",null,"We have chosen a compromise between the extreme conservative and extreme liberal rules. The current rule essentially allows arbitrary optimizations within a library unit and inlined subprograms reachable from it, but disallow semantics-disrupting optimizations across library units in the absence of inlined subprograms. This allows a library unit to be debugged, and then reused with some confidence that the abstraction it manages cannot be broken by bugs outside the library unit. "),(0,i.kt)("p",null,"NOTE 1   The permissions granted by this clause can have an effect on the semantics of a program only if the program fails a language-defined check. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"RM83-11.6 was unclear. It has been completely rewritten here; we hope this version is clearer. Here's what happened to each paragraph of RM83-11.6: "),(0,i.kt)("p",null,'Paragraphs 1 and 2 contain no semantics; they are merely pointing out that anything goes if the canonical semantics is preserved. We have similar introductory paragraphs, but we have tried to clarify that these are not granting any "extra" permission beyond what the rest of the document allows.'),(0,i.kt)("p",null,'Paragraphs 3 and 4 are reflected in the "extra permission to reorder actions". Note that this permission now allows the reordering of assignments in many cases.'),(0,i.kt)("p",null,'Paragraph 5 is moved to 4.5, "Operators and Expression Evaluation", where operator association is discussed. Hence, this is no longer an "extra permission" but is part of the canonical semantics.'),(0,i.kt)("p",null,"Paragraph 6 now follows from the general permission to store out-of-range values for unconstrained subtypes. Note that the parameters and results of all the predefined operators of a type are of the unconstrained subtype of the type."),(0,i.kt)("p",null,'Paragraph 7 is reflected in the "extra permission to avoid raising exceptions". '),(0,i.kt)("p",null,'We moved clause 11.5, "Suppressing Checks" from after 11.6 to before 11.6, in order to preserve the famous number "11.6" (given the changes to earlier clauses in Section 11).'))}p.isMDXComponent=!0}}]);