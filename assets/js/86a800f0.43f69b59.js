"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8200],{5794:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(9440),o=(n(6687),n(1716)),i=n(2526);const r={sidebar_position:116},l="13.14  Freezing Rules",s={unversionedId:"arm/AA-13.14",id:"arm/AA-13.14",title:"13.14  Freezing Rules",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-13.14.mdx",sourceDirName:"arm",slug:"/arm/AA-13.14",permalink:"/docs/arm/AA-13.14",draft:!1,tags:[],version:"current",sidebarPosition:116,frontMatter:{sidebar_position:116},sidebar:"tutorialSidebar",previous:{title:"13.13  Streams",permalink:"/docs/arm/AA-13.13"},next:{title:"Annex A Predefined Language Environment",permalink:"/docs/arm/AA-A"}},c={},u=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],h={toc:u};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"1314--freezing-rules"},"13.14  Freezing Rules"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0299-1"),"}",' [This subclause defines a place in the program text where each declared entity becomes "frozen". A use of an entity, such as a reference to it by name, or (for a type) an expression of the type, causes freezing of the entity in some contexts, as described below. The Legality Rules forbid certain kinds of uses of an entity in the region of text where it is frozen.] '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This concept has two purposes: a compile-time one and a run-time one."),(0,o.kt)("p",null,"The compile-time purpose of the freezing rules comes from the fact that the evaluation of static expressions depends on overload resolution, and overload resolution sometimes depends on the value of a static expression. (The dependence of static evaluation upon overload resolution is obvious. The dependence in the other direction is more subtle. There are three rules that require static expressions in contexts that can appear in declarative places: The expression in an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0101"},"attribute_designator"))," shall be static. In a record aggregate, variant-controlling discriminants shall be static. In an array aggregate with more than one named association, the choices shall be static. The compiler needs to know the value of these expressions in order to perform overload resolution and legality checking.) We wish to allow a compiler to evaluate static expressions when it sees them in a single pass over the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0286"},"compilation_unit")),". The freezing rules ensure that."),(0,o.kt)("p",null,'The run-time purpose of the freezing rules is called the "linear elaboration model". This means that declarations are elaborated in the order in which they appear in the program text, and later elaborations can depend on the results of earlier ones. The elaboration of the declarations of certain entities requires run-time information about the implementation details of other entities. The freezing rules ensure that this information has been calculated by the time it is used. For example, suppose the initial value of a constant is the result of a function call that takes a parameter of type ',(0,o.kt)("em",null,"T"),". In order to pass that parameter, the size of type ",(0,o.kt)("em",null,"T")," has to be known. If ",(0,o.kt)("em",null,"T")," is composite, that size might be known only at run time."),(0,o.kt)("p",null,'(Note that in these discussions, words like "before" and "after" generally refer to places in the program text, as opposed to times at run time.) '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),'The "implementation details" we\'re talking about above are: '),(0,o.kt)("p",null,"For a tagged type, the implementations of all the primitive subprograms of the type - that is (in the canonical implementation model), the contents of the type descriptor, which contains pointers to the code for each primitive subprogram."),(0,o.kt)("p",null,"For a type, the full type declaration of any parts (including the type itself) that are private."),(0,o.kt)("p",null,"For a deferred constant, the full constant declaration, which gives the constant's value. (Since this information necessarily comes after the constant's type and subtype are fully known, there's no need to worry about its type or subtype.)"),(0,o.kt)("p",null,"For any entity, representation information specified by the user via representation items. Most representation items are for types or subtypes; however, various other kinds of entities, such as objects and subprograms, are possible. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," Similar issues arise for incomplete types. However, we do not use freezing to prevent premature access; incomplete types have different, more severe, restrictions. Similar issues also arise for subprograms, protected operations, tasks and generic units. However, we do not use freezing to prevent premature access for those, either; 3.11 prevents problems with run-time Elaboration_Checks. Even so, freezing is used for these entities to prevent giving representation items too late (that is, after uses that require representation information, such as calls). "),(0,o.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,o.kt)("p",null,"An evaluable construct should freeze anything that's needed to evaluate it."),(0,o.kt)("p",null,"However, if the construct is not evaluated where it appears, let it cause freezing later, when it is evaluated. This is the case for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),"s and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.6#S0339"},"default_name")),"s. (Formal parameters, generic formal parameters, and components can have ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),"s or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.6#S0339"},"default_name")),"s.)"),(0,o.kt)("p",null,"The compiler should be allowed to evaluate static expressions without knowledge of their context. (I.e. there should not be any special rules for static expressions that happen to occur in a context that requires a static expression.)"),(0,o.kt)("p",null,"Compilers should be allowed to evaluate static expressions (and record the results) using the run-time representation of the type. For example, suppose Color'Pos(Red) = 1, but the internal code for Red is 37. If the value of a static expression is Red, some compilers might store 1 in their symbol table, and other compilers might store 37. Either compiler design should be feasible."),(0,o.kt)("p",null,"Compilers should never be required to detect erroneousness or exceptions at compile time (although it's very nice if they do). This implies that we should not require code-generation for a nonstatic expression of type ",(0,o.kt)("em",null,"T")," too early, even if we can prove that that expression will be erroneous, or will raise an exception."),(0,o.kt)("p",null,"Here's an example (modified from AI83-00039, Example 3): "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type T is","\n","    record","\n","        ...","\n","    end record;","\n","function F return T;","\n","function G(X : T) return Boolean;","\n","Y : Boolean := G(F); -- doesn't force T in Ada 83","\n","for T use","\n","    record","\n","        ...","\n","    end record;","\n"),(0,o.kt)("p",null,"AI83-00039 says this is legal. Of course, it raises Program_Error because the function bodies aren't elaborated yet. A one-pass compiler has to generate code for an expression of type T before it knows the representation of T. Here's a similar example, which AI83-00039 also says is legal: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package P is","\n","    type T is private;","\n","    function F return T;","\n","    function G(X : T) return Boolean;","\n","    Y : Boolean := G(F); -- doesn't force T in Ada 83","\n","private","\n","    type T is","\n","        record","\n","            ...","\n","        end record;","\n","end P;","\n"),(0,o.kt)("p",null,"If T's size were dynamic, that size would be stored in some compiler-generated dope; this dope would be initialized at the place of the full type declaration. However, the generated code for the function calls would most likely allocate a temp of the size specified by the dope ",(0,o.kt)("em",null,"before")," checking for Program_Error. That dope would contain uninitialized junk, resulting in disaster. To avoid doing that, the compiler would have to determine, at compile time, that the expression will raise Program_Error."),(0,o.kt)("p",null,"This is silly. If we're going to require compilers to detect the exception at compile time, we might as well formulate the rule as a legality rule."),(0,o.kt)("p",null,"Compilers should not be required to generate code to load the value of a variable before the address of the variable has been determined."),(0,o.kt)("p",null,"After an entity has been frozen, no further requirements may be placed on its representation (such as by a representation item or a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.2#S0024"},"full_type_declaration")),"). "),(0,o.kt)("p",null,"The ",(0,o.kt)("em",null,"freezing")," of an entity occurs at one or more places (",(0,o.kt)("em",null,"freezing points"),") in the program text where the representation for the entity has to be fully determined. Each entity is frozen from its first freezing point to the end of the program text (given the ordering of compilation units defined in 10.1.4). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),'The "representation" for a subprogram includes its calling convention and means for referencing the subprogram body, either a "link-name" or specified address. It does not include the code for the subprogram body itself, nor its address if a link-name is used to reference the body. '),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," This subclause also defines a place in the program text where the profile of each declared callable entity becomes ",(0,o.kt)("em",null,"frozen"),". A use of a callable entity causes freezing of its profile in some contexts, as described below. At the place where the profile of a callable entity becomes frozen, the entity itself becomes frozen."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0014"),"}"," ","{",(0,o.kt)("em",null,"AI05-0017-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0155-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0168-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0373-1"),"}"," The end of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.4#S0254"},"protected_body")),", or a declaration of a library package or generic library package, causes ",(0,o.kt)("em",null,"freezing")," of each entity and profile declared within it, as well as the entity itself in the case of the declaration of a library unit. A noninstance ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0090"},"proper_body")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0297"},"body_stub")),", or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.5#S0260"},"entry_body"))," causes freezing of each entity and profile declared before it within the same ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),". "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"This is worded carefully to handle nested packages and private types. Entities declared in a nested ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-7.1#S0230"},"package_specification"))," will be frozen by some containing construct."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0017-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0155-1"),"}"," An incomplete type declared in the private part of a library ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-7.1#S0230"},"package_specification"))," can be completed in the body. For other incomplete types (and in the bodies of library packages), the completion of the type will be frozen at the end of the package or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The part about bodies does not say ",(0,o.kt)("em",null,"immediately")," within. A renaming-as-body does not have this property. Nor does an imported body "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0300-1"),"}"," The reason bodies cause freezing is because we want ",(0,o.kt)("code",null,"proper_bodies")," and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0297"},"body_stub")),"s to be interchangeable - one should be able to move a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0090"},"proper_body"))," to a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0302"},"subunit")),", and vice versa, without changing the semantics. Clearly, anything that should cause freezing should do so even if it's inside a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0090"},"proper_body")),". However, if we make it a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0297"},"body_stub")),", then the compiler can't see that thing that should cause freezing. So we make ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-10.1#S0297"},"body_stub")),"s cause freezing, just in case they contain something that should cause freezing. But that means we need to do the same for ",(0,o.kt)("code",null,"proper_bodies"),"."),(0,o.kt)("p",null,"Another reason for bodies to cause freezing, there could be an added implementation burden if an entity declared in an enclosing ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," is frozen within a nested body, since some compilers look at bodies after looking at the containing ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," Note that ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.7#S0227"},"null_procedure_declaration")),"s and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.8#S0228"},"expression_function_declaration")),"s (even when those are used as completions), as well as ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.3#S0315"},"generic_instantiation")),"s and renames-as-bodies do not necessarily cause freezing; each have their own specific rules. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," Note that the rule about proper bodies causing freezing only applies in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"s. All of the kinds of bodies (see 3.11.1  keep in mind the difference from ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0089"},"body")),"s) that are allowed in a package specification have their own freezing rules, so they don't need to be covered by the above rule. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," A construct that (explicitly or implicitly) references an entity can cause the ",(0,o.kt)("em",null,"freezing")," of the entity, as defined by subsequent paragraphs. At the place where a construct causes freezing, each ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0095"},"implicit_dereference")),"[, or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.5#S0037"},"range")),"] within the construct causes freezing: "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Note that in the sense of this paragraph, a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.2#S0028"},"subtype_mark")),' "references" the denoted subtype, but not the type. '),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0213-1"),"}"," The occurrence of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.3#S0315"},"generic_instantiation"))," causes freezing, except that a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," which is a generic actual parameter whose corresponding generic formal parameter is a formal incomplete type (see 12.5.1) does not cause freezing. In addition, if a parameter of the instantiation is defaulted, the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.6#S0339"},"default_name"))," for that parameter causes freezing."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0213-1"),"}"," Thus, an actual parameter corresponding to a formal incomplete type parameter may denote an incomplete or private type which is not completely defined at the point of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.3#S0315"},"generic_instantiation")),". "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," At the occurrence of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.8#S0228"},"expression_function_declaration"))," that is a completion, the return expression of the expression function causes freezing."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," This rule prevents calls through access values to an expression that might have unfrozen parts. Typically, elaboration checks and other freezing rules prevent this, but in this case the completion is elaborated and since this is not a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0089"},"body"))," it does not by itself freeze anything that precedes it. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0132-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," At the occurrence of a renames-as-body whose ",(0,o.kt)("em",null,"callable_entity_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," denotes an expression function, the return expression of the expression function causes freezing."),(0,o.kt)("p",null,"The occurrence of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration"))," that has no corresponding completion causes freezing. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Note that this does not include a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.4#S0319"},"formal_object_declaration")),". "),(0,o.kt)("p",null,"The declaration of a record extension causes freezing of the parent subtype. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This combined with another rule specifying that primitive subprogram declarations shall precede freezing ensures that all descendants of a tagged type implement all of its dispatching operations."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00251-01"),"}"," The declaration of a private extension does not cause freezing. The freezing is deferred until the full type declaration, which will necessarily be for a record extension, task, or protected type (the latter only for a limited private extension derived from an interface). "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00251-01"),"}"," The declaration of a record extension, interface type, task unit, or protected unit causes freezing of any progenitor types specified in the declaration. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This rule has the same purpose as the one above: ensuring that all descendants of an interface tagged type implement all of its dispatching operations. As with the previous rule, a private extension does not freeze its progenitors; the full type declaration (which must have the same progenitors) will do that. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"An interface type can be a parent as well as a progenitor; these rules are similar so that the location of an interface in a record extension does not have an effect on the freezing of the interface type. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0396-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0407-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0439-1"),"}"," At the freezing point of the entity associated with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),", any static expressions within the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification"))," cause freezing, as do ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name")),"s in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0348"},"aspect_definition")),"s for representation aspects, or operational aspects that have a corresponding operational attribute. Similarly, if an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0348"},"aspect_definition"))," for an operational aspect, other than an assertion aspect, can affect the Name Resolution, Static Semantics, or Legality Rules of a subsequent construct, then any ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name")),"s within the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0348"},"aspect_definition"))," cause freezing at the freezing point of the associated entity. Any static expressions within an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification"))," also cause freezing at the end of the immediately enclosing declaration list. For the purposes of this rule, if there is no declared entity associated with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),", the freezing point is considered to occur immediately following the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),". "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0157-1"),"}"," A static expression (other than within an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),") causes freezing where it occurs. An object name or nonstatic expression causes freezing where it occurs, unless the name or expression is part of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),", a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.6#S0339"},"default_name")),", the return expression of an expression function, an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),", or a per-object expression of a component's ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.2#S0029"},"constraint")),", in which case, the freezing occurs later as part of another construct or at the freezing point of an associated entity."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," An implicit call freezes the same entities and profiles that would be frozen by an explicit call. This is true even if the implicit call is removed via implementation permissions."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," If an expression is implicitly converted to a type or subtype ",(0,o.kt)("em",null,"T"),", then at the place where the expression causes freezing, ",(0,o.kt)("em",null,"T")," is frozen."),(0,o.kt)("p",null,"The following rules define which entities are frozen at the place where a construct causes freezing: "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0367-1"),"}"," At the place where an expression causes freezing, the type of the expression is frozen, unless the expression is an enumeration literal used as a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.8#S0074"},"discrete_choice"))," of the ",(0,o.kt)("code",null,"[array_aggregate](./AA-4.3#S0113)")," of an ",(0,o.kt)("code",null,"[enumeration_representation_clause](./AA-13.4#S0350)")," or as the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0348"},"aspect_definition"))," of a specification for aspect Default_Value. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We considered making enumeration literals never cause freezing, which would be more upward compatible, but examples like the variant record aggregate (Discrim =",">"," Red, ...) caused us to change our mind. Furthermore, an enumeration literal is a static expression, so the implementation should be allowed to represent it using its representation."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0367-1"),"}"," We exclude uses of enumeration literals that are used in part for setting the representation of the type (aspect Default_Value is defined to be a representation aspect) so we don't freeze the type while determining its representation. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"The following pathological example was legal in Ada 83, but is illegal in Ada 95: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package P1 is","\n","    type T is private;","\n","    package P2 is","\n","        type Composite(D : Boolean) is","\n","            record","\n","                case D is","\n","                    when False =",">"," Cf : Integer;","\n","                    when True  =",">"," Ct : T;","\n","                end case;","\n","            end record;","\n","    end P2;","\n",'    X : Boolean := P2."="( (False,1), (False,1) );',"\n","private","\n","    type T is array(1..Func_Call) of Integer;","\n","end;","\n"),(0,o.kt)("p",null,"In Ada 95, the declaration of X freezes Composite (because it contains an expression of that type), which in turn freezes T (even though Ct does not exist in this particular case). But type T is not completely defined at that point, violating the rule that a type shall be completely defined before it is frozen. In Ada 83, on the other hand, there is no occurrence of the name T, hence no forcing occurrence of T. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," At the place where a function call causes freezing, the profile of the function is frozen. Furthermore, if a parameter of the call is defaulted, the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression"))," for that parameter causes freezing. If the function call is to an expression function, the return expression of the expression function causes freezing."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," This is the important rule for profile freezing: a call freezes the profile. That's because generating the call will need to know how the parameters are passed, and that will require knowing details of the types. Other uses of subprograms do not need to know about the parameters, and thus only freeze the subprogram, and not the profile."),(0,o.kt)("p",null,"Note that we don't need to consider procedure or entry calls, since a body freezes everything that precedes it, and the end of a declarative part freezes everything in the declarative part. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," Freezing of the return expression of an expression function only needs to be considered when the expression function is in the same compilation unit and there are no intervening ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0089"},"body")),"s; the end of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," or library package freezes everything in it, and a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0089"},"body"))," freezes everything declared before it. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0296-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," At the place where a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.3#S0315"},"generic_instantiation"))," causes freezing of a callable entity, the profile of that entity is frozen unless the formal subprogram corresponding to the callable entity has a parameter or result of a formal untagged incomplete type; if the callable entity is an expression function, the return expression of the expression function causes freezing."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"Elaboration of the generic might call the actual for one of its formal subprograms, so we need to know the profile and (for an expression function) ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),". "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0157-1"),"}"," At the place where a use of the Access or Unchecked_Access attribute whose ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0093"},"prefix"))," denotes an expression function causes freezing, the return expression of the expression function causes freezing."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This is needed to avoid calls to unfrozen expressions. Consider: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package Pack is","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type Flub is range 0 .. 100;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"function Foo (A : in Natural) return Natural is","\n","      (A + Flub'Size); -- The expression is not frozen here.","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI12-0005-1","}","    type Bar is access function (A : in Natural) return Natural;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"P : Bar := Foo'Access; -- (A)","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"Val : Natural := P.all(5); -- (B)","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"end Pack;","\n"),(0,o.kt)("p",null,"If point (A) did not freeze the expression of Foo (which freezes Flub), then the call at point (B) would be depending on the aspects of the unfrozen type Flub. That would be bad. "),(0,o.kt)("p",null,"At the place where a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," causes freezing, the entity denoted by the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," is frozen, unless the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," is a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0093"},"prefix"))," of an expanded name; at the place where an object ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," causes freezing, the nominal subtype associated with the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," is frozen. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," This only matters in the presence of deferred constants or access types; an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration"))," other than a deferred constant declaration causes freezing of the nominal subtype, plus all component junk."),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," At the place where an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0095"},"implicit_dereference"))," causes freezing, the nominal subtype associated with the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0095"},"implicit_dereference"))," is frozen."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"This rule ensures that X.D freezes the same entities that X.",(0,o.kt)("strong",null,"all"),".D does. Note that an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0095"},"implicit_dereference"))," is neither a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," nor ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," by itself, so it isn't covered by other rules. "),(0,o.kt)("p",null,"[ At the place where a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.5#S0037"},"range"))," causes freezing, the type of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.5#S0037"},"range"))," is frozen.] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),'This is consequence of the facts that expressions freeze their type, and the Range attribute is defined to be equivalent to a pair of expressions separated by "..".',"}"," "),(0,o.kt)("p",null,"At the place where an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator"))," causes freezing, the designated subtype of its type is frozen. If the type of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator"))," is a derived type, then all ancestor types are also frozen. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"Allocator")),"s also freeze the named subtype, as a consequence of other rules."),(0,o.kt)("p",null,"The ancestor types are frozen to prevent things like this: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type Pool_Ptr is access System.Storage_Pools.Root_Storage_Pool'Class;","\n","function F return Pool_Ptr;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package P is","\n","    type A1 is access Boolean;","\n","    type A2 is new A1;","\n","    type A3 is new A2;","\n","    X : A3 := new Boolean; -- Don't know what pool yet!","\n","    for A1'Storage_Pool use F.all;","\n","end P;","\n"),(0,o.kt)("p",null,"This is necessary because derived access types share their parent's pool. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," At the place where a profile is frozen, each subtype of the profile is frozen. If the corresponding callable entity is a member of an entry family, the index subtype of the family is frozen. "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0186-1"),"}"," At the place where a subtype is frozen, its type is frozen. At the place where a type is frozen, any expressions or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name")),"s within the full type definition cause freezing, other than those that occur within an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.10#S0079"},"access_type_definition"))," or an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.10#S0084"},"access_definition")),"; the first subtype, and any component subtypes, index subtypes, and parent subtype of the type are frozen as well. For a specific tagged type, the corresponding class-wide type is frozen as well. For a class-wide type, the corresponding specific type is frozen as well. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Freezing a type needs to freeze its first subtype in order to preserve the property that the subtype-specific aspects of statically matching subtypes are the same."),(0,o.kt)("p",null,"Freezing an access type does not freeze its designated subtype. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00341-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," At the place where a specific tagged type is frozen, the primitive subprograms of the type are frozen. At the place where a type is frozen, any subprogram named in an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.3#S0349"},"attribute_definition_clause"))," for the type is frozen. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We have a language design principle that all of the details of a specific tagged type are known at its freezing point. But that is only true if the primitive subprograms are frozen at this point as well. Late changes of Import and address clauses violate the principle. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"This rule means that no implicit call to Initialize or Adjust can freeze a subprogram (the type and thus subprograms would have been frozen at worst at the same point). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," The second sentence is the rule that makes it possible to check that only subprograms with convention Ada are specified in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.3#S0349"},"attribute_definition_clause")),"s without jumping through hoops. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0396-1"),"}"," At the place where a construct causes freezing, if the construct includes a check associated with some assertion aspect [(independent of whether the check is enabled)], or depends on the definition of some operational aspect as part of its Dynamic Semantics, any ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name")),"s or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s in the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0348"},"aspect_definition"))," for the aspect cause freezing. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Aspects such as Constant_Indexing cause freezing when they are used - the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," in a Constant_Indexing would cause freezing when a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0105"},"generalized_indexing"))," that makes use of it causes freezing. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0155-1"),"}"," Notwithstanding the rest of this subclause, freezing an incomplete view has no effect."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"In particular, freezing an incomplete view does not freeze the completion of the view. For an incomplete type, once the completion of the incomplete type is seen, any further references to the type will be of the complete type, which will be frozen in the normal way. Legality Rules prevent all problems for incomplete types themselves."),(0,o.kt)("p",null,"In contrast, freezing a partial view does have an effect (the completion of the view is frozen and the program is illegal if it hasn't occurred yet). "),(0,o.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,o.kt)("p",null,"[The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen (see 3.9.2).] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This rule is needed because (1) we don't want people dispatching to things that haven't been declared yet, and (2) we want to allow tagged type descriptors to be static (allocated statically, and initialized to link-time-known symbols). Suppose T2 inherits primitive P from T1, and then overrides P. Suppose P is called ",(0,o.kt)("em",null,"before")," the declaration of the overriding P. What should it dispatch to? If the answer is the new P, we've violated the first principle above. If the answer is the old P, we've violated the second principle. (A call to the new one necessarily raises Program_Error, but that's beside the point.)"),(0,o.kt)("p",null,"Note that a call upon a dispatching operation of type ",(0,o.kt)("em",null,"T")," will freeze ",(0,o.kt)("em",null,"T"),"."),(0,o.kt)("p",null,"We considered applying this rule to all derived types, for uniformity. However, that would be upward incompatible, so we rejected the idea. As in Ada 83, for an untagged type, the above call upon P will call the old P (which is arguably confusing). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI05-0222-1"),"}",' This rule only applies to "original" declarations and not to the completion of a primitive subprogram, even though a completion is technically an explicit declaration, and it may declare a primitive subprogram. '),(0,o.kt)("p",null,"[A type shall be completely defined before it is frozen (see 3.11.1 and 7.3).]"),(0,o.kt)("p",null,"[The completion of a deferred constant declaration shall occur before the constant is frozen (see 7.4).]"),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0181-1"),"}"," "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0009"),"}"," ","{",(0,o.kt)("em",null,"AI95-00137-01"),"}"," [An operational or representation item that directly specifies an aspect of an entity shall appear before the entity is frozen (see 13.1).] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"8652/0009"),"}"," ","{",(0,o.kt)("em",null,"AI95-00137-01"),"}"," From RM83-13.1(7). The wording here forbids freezing within the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0343"},"aspect_clause"))," itself, which was not true of the Ada 83 wording. The wording of this rule is carefully written to work properly for type-related representation items. For example, an ",(0,o.kt)("code",null,"[enumeration_representation_clause](./AA-13.4#S0350)")," is illegal after the type is frozen, even though the ",(0,o.kt)("code",null,"_clause")," refers to the first subtype."),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,o.kt)("em",null,"AI12-0181-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,o.kt)("em",null,"AI12-0181-1"),"}",' The above Legality Rules are stated "officially" in the referenced subclauses. '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"Here's an example that illustrates when freezing occurs in the presence of defaults: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type T is ...;","\n","function F return T;","\n","type R is","\n","    record","\n","        C : T := F;","\n","        D : Boolean := F = F;","\n","    end record;","\n","X : R;","\n"),(0,o.kt)("p",null,"Since the elaboration of R's declaration does not allocate component C, there is no need to freeze C's subtype at that place. Similarly, since the elaboration of R does not evaluate the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),' "F = F", there is no need to freeze the types involved at that point. However, the declaration of X ',(0,o.kt)("em",null,"does")," need to freeze these things. Note that even if component C did not exist, the elaboration of the declaration of X would still need information about T - even though D is not of type T, its ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression"))," requires that information. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," Although we define freezing in terms of the program text as a whole (i.e. after applying the rules of Clause 10), the freezing rules actually have no effect beyond compilation unit boundaries. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," That is important, because Clause 10 allows some implementation definedness in the order of things, and we don't want the freezing rules to be implementation defined. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"These rules also have no effect in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0167"},"statement")),"s - they only apply within a single ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-7.1#S0230"},"package_specification")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),", or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.4#S0254"},"protected_body")),". "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"An implementation may choose to generate code for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),"s and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.6#S0339"},"default_name")),"s in line at the place of use. Alternatively, an implementation may choose to generate thunks (subprograms implicitly generated by the compiler) for evaluation of defaults. Thunk generation cannot, in general, be done at the place of the declaration that includes the default. Instead, they can be generated at the first freezing point of the type(s) involved. (It is impossible to write a purely one-pass Ada compiler, for various reasons. This is one of them - the compiler needs to store a representation of defaults in its symbol table, and then walk that representation later, no earlier than the first freezing point.)"),(0,o.kt)("p",null,"In implementation terms, the linear elaboration model can be thought of as preventing uninitialized dope. For example, the implementation might generate dope to contain the size of a private type. This dope is initialized at the place where the type becomes completely defined. It cannot be initialized earlier, because of the order-of-elaboration rules. The freezing rules prevent elaboration of earlier declarations from accessing the size dope for a private type before it is initialized."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," 2.8 overrides the freezing rules in the case of unrecognized ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s; similarly 13.1.1 overrides the freezing rules in the case of a specification of an unrecognized aspect."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0009"),"}"," ","{",(0,o.kt)("em",null,"AI95-00137-01"),"}"," An ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0343"},"aspect_clause"))," for an entity should most certainly ",(0,o.kt)("em",null,"not")," be a freezing point for the entity. "),(0,o.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00279-01"),"}"," The tag (see 3.9) of a tagged type T is created at the point where T is frozen. "),(0,o.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,o.kt)("p",null,'RM83 defines a forcing occurrence of a type as follows: "A forcing occurrence is any occurrence [of the name of the type, subtypes of the type, or types or subtypes with subcomponents of the type] other than in a type or subtype declaration, a subprogram specification, an entry declaration, a deferred constant declaration, a ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),", or a ",(0,o.kt)("code",null,"representation_clause"),' for the type itself. In any case, an occurrence within an expression is always forcing."'),(0,o.kt)("p",null,"It seems like the wording allows things like this: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type A is array(Integer range 1..10) of Boolean;","\n","subtype S is Integer range A'Range;","\n","    -- not forcing for A","\n"),(0,o.kt)("p",null,"Occurrences within ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s can cause freezing in Ada 95. (Since such ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are ignored in Ada 83, this will probably fix more bugs than it causes.) "),(0,o.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,o.kt)("p",null,"In Ada 95, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.1#S0314"},"generic_formal_parameter_declaration")),"s do not normally freeze the entities from which they are defined. For example: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package Outer is","\n","    type T is tagged limited private;","\n","    generic","\n","        type T2 is","\n","            new T with private; -- Does not freeze T","\n","                                -- in Ada 95.","\n","    package Inner is","\n","        ...","\n","    end Inner;","\n","private","\n","    type T is ...;","\n","end Outer;","\n"),(0,o.kt)("p",null,"This is important for the usability of generics. The above example uses the Ada 95 feature of formal derived types. Examples using the kinds of formal parameters already allowed in Ada 83 are well known. See, for example, comments 83-00627 and 83-00688. The extensive use expected for formal derived types makes this issue even more compelling than described by those comments. Unfortunately, we are unable to solve the problem that ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.3#S0318"},"explicit_generic_actual_parameter")),"s cause freezing, even though a package equivalent to the instance would not cause freezing. This is primarily because such an equivalent package would have its body in the body of the containing program unit, whereas an instance has its body right there. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,o.kt)("p",null,'The concept of freezing is based on Ada 83\'s concept of "forcing occurrences". The first freezing point of an entity corresponds roughly to the place of the first forcing occurrence, in Ada 83 terms. The reason for changing the terminology is that the new rules do not refer to any particular "occurrence" of a name of an entity. Instead, we refer to "uses" of an entity, which are sometimes implicit.'),(0,o.kt)("p",null,"In Ada 83, forcing occurrences were used only in rules about ",(0,o.kt)("code",null,"representation_clause"),"s. We have expanded the concept to cover private types, because the rules stated in RM83-7.4.1(4) are almost identical to the forcing occurrence rules."),(0,o.kt)("p",null,"The Ada 83 rules are changed in Ada 95 for the following reasons: "),(0,o.kt)("p",null,"The Ada 83 rules do not work right for subtype-specific aspects. In an earlier version of Ada 9X, we considered allowing representation items to apply to subtypes other than the first subtype. This was part of the reason for changing the Ada 83 rules. However, now that we have dropped that functionality, we still need the rules to be different from the Ada 83 rules."),(0,o.kt)("p",null,"The Ada 83 rules do not achieve the intended effect. In Ada 83, either with or without the AIs, it is possible to force the compiler to generate code that references uninitialized dope, or force it to detect erroneousness and exception raising at compile time."),(0,o.kt)("p",null,"It was a goal of Ada 83 to avoid uninitialized access values. However, in the case of deferred constants, this goal was not achieved."),(0,o.kt)("p",null,"The Ada 83 rules are not only too weak - they are also too strong. They allow loopholes (as described above), but they also prevent certain kinds of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),"s that are harmless, and certain kinds of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-12.1#S0310"},"generic_declaration")),"s that are both harmless and very useful."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," Ada 83 had a case where an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0343"},"aspect_clause"))," had a strong effect on the semantics of the program - 'Small. This caused certain semantic anomalies. There are more cases in Ada 95, because the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.3#S0349"},"attribute_definition_clause"))," has been generalized. "),(0,o.kt)("h4",{id:"incompatibilities-with-ada-95"},"Incompatibilities With Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0046"),"}"," ","{",(0,o.kt)("em",null,"AI95-00106-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00341-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Various freezing rules were added to fix holes in the rules. Most importantly, implicit calls are now freezing, which make some representation clauses illegal in Ada 2005 that were legal (but dubious) in Ada 95. ",(0,o.kt)("strong",null,"Amendment Correction:")," Similarly, the primitive subprograms of a specific tagged type are frozen when the type is frozen, preventing dubious convention changes (and address clauses) after the freezing point. In both cases, the code is dubious and the workaround is easy. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0009"),"}"," ","{",(0,o.kt)("em",null,"AI95-00137-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Added wording to specify that both operational and representation attributes must be specified before the type is frozen."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00251-01"),"}"," Added wording that declaring a specific descendant of an interface type freezes the interface type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00279-01"),"}"," Added wording that defines when a tag is created for a type (at the freezing point of the type). This is used to specify checking for uncreated tags (see 3.9). "),(0,o.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0019-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Separated the freezing of the profile from the rest of a subprogram, in order to reduce the impact of the Ada 95 incompatibility noted above. (The effects were much more limiting than expected.) "),(0,o.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0017-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Reworded so that incomplete types with a deferred completion aren't prematurely frozen."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," Added freezing rules for expression functions; these are frozen at the point of call, not the point of declaration, like default expressions."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," Added freezing rules for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),"s; these are frozen at the freezing point of the associated entity, not the point of declaration."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0213-1"),"}"," Added freezing rules for formal incomplete types; the corresponding actual is not frozen. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0103-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0132-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Clarified when and what an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.8#S0228"},"expression_function_declaration"))," that is a completion or that is the target of a renames-as-body freezes. This is formally an incompatibility, but as all known implementations freeze expression functions more aggressively than allowed by either the old or new wording, practically this will be an extension."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0168-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Clarified that the implicit body created by an instance doesn't have any freezing effect. This was an unintentional change caused by the Technical Corrigendum 1 oversimplifying wording."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0155-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Clarified that incomplete types do not freeze in any case. The one known case where incomplete freezing was necessary has been plugged with a new Legality Rules (see 3.10.1). This matches the original intent (see Language Design Principles above) and eliminates whack-a-mole trying to allow such freezing without it having (almost) any effects."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0186-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Clarified that the subtype names in an access type are not frozen at the point of the type declaration. This has always been true (there is an Ada 95-era AARM note that says so) but it didn't follow from the actual wording. Since the ACATS requires the AARM note to be true, no compiler could actually get this wrong, so no incompatibility is possible."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0367-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Added a freezing exclusion for enumeration literals in the expression of a Default_Value aspect; otherwise, one could not set a default value for an enumeration type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0373-1"),"}"," Added missing definition of freezing of library units."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0396-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Improved and clarified the freezing rules for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-13.1#S0346"},"aspect_specification")),"s; these now depend on the kind of aspect. "))}d.isMDXComponent=!0}}]);