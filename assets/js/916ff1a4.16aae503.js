"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5145],{70471:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var i=a(58168),t=(a(96540),a(15680));const l={title:"5.7 Visibility"},o=void 0,r={unversionedId:"style-guide/s5/07",id:"style-guide/s5/07",title:"5.7 Visibility",description:"As noted in Guideline 4.2, Ada's ability to enforce information hiding",source:"@site/docs/style-guide/s5/07.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/07",permalink:"/docs/style-guide/s5/07",draft:!1,tags:[],version:"current",frontMatter:{title:"5.7 Visibility"},sidebar:"styleGuideSidebar",previous:{title:"5.6 Statements",permalink:"/docs/style-guide/s5/06"},next:{title:"5.8 Using exceptions",permalink:"/docs/style-guide/s5/08"}},s={},u=[{value:"The Use Clause",id:"the-use-clause",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"automation notes",id:"automation-notes",level:4},{value:"The Renames Clause",id:"the-renames-clause",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes-1",level:4},{value:"Overloaded Subprograms",id:"overloaded-subprograms",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-2",level:4},{value:"Overloaded Operators",id:"overloaded-operators",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-3",level:4},{value:"Overloading the Equality Operator",id:"overloading-the-equality-operator",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"rationale",id:"rationale-4",level:4}],d={toc:u},p="wrapper";function m(e){let{components:n,...a}=e;return(0,t.yg)(p,(0,i.A)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"As noted in Guideline 4.2, Ada's ability to enforce information hiding\nand separation of concerns through its visibility controlling features\nis one of the most important advantages of the language. Subverting\nthese features, for example, by too liberal use of the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause, is\nwasteful and dangerous."),(0,t.yg)("h3",{id:"the-use-clause"},"The Use Clause"),(0,t.yg)("h4",{id:"guideline"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"When you need to provide visibility to operators, use the ",(0,t.yg)("inlineCode",{parentName:"li"},"use type"),"\nclause."),(0,t.yg)("li",{parentName:"ul"},"Avoid/minimize the use of the ",(0,t.yg)("inlineCode",{parentName:"li"},"use")," clause (Nissen and Wallis 1984)."),(0,t.yg)("li",{parentName:"ul"},"Consider using a package ",(0,t.yg)("inlineCode",{parentName:"li"},"renames")," clause rather than a ",(0,t.yg)("inlineCode",{parentName:"li"},"use")," clause\nfor a package."),(0,t.yg)("li",{parentName:"ul"},"Consider using the ",(0,t.yg)("inlineCode",{parentName:"li"},"use")," clause in the following situations:",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"When standard packages are needed and no ambiguous references\nare introduced"),(0,t.yg)("li",{parentName:"ul"},"When references to enumeration literals are needed"))),(0,t.yg)("li",{parentName:"ul"},"Localize the effect of all ",(0,t.yg)("inlineCode",{parentName:"li"},"use")," clauses.")),(0,t.yg)("h4",{id:"example"},"example"),(0,t.yg)("p",null,"This is a modification of the example from Guideline 4.2.3. The effect\nof a ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause is localized:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},'----------------------------------------------------------------------------------\npackage Rational_Numbers is\n   type Rational is private;\n   function "=" (X, Y : Rational) return Boolean;\n   function "/" (X, Y : Integer)  return Rational;  -- construct a rational number\n   function "+" (X, Y : Rational) return Rational;\n   function "-" (X, Y : Rational) return Rational;\n   function "*" (X, Y : Rational) return Rational;\n   function "/" (X, Y : Rational) return Rational;  -- rational division\nprivate\n   ...\nend Rational_Numbers;\n----------------------------------------------------------------------------------\npackage body Rational_Numbers is\n   procedure Reduce (R : in out Rational) is . . . end Reduce;\n   . . .\nend Rational_Numbers;\n----------------------------------------------------------------------------------\npackage Rational_Numbers.IO is\n   ...\n\n   procedure Put (R : in  Rational);\n   procedure Get (R : out Rational);\nend Rational_Numbers.IO;\n----------------------------------------------------------------------------------\nwith Rational_Numbers;\nwith Rational_Numbers.IO;\nwith Ada.Text_IO;\nprocedure Demo_Rationals is\n   package R_IO renames Rational_Numbers.IO;\n\n   use type Rational_Numbers.Rational;\n   use R_IO;\n   use Ada.Text_IO;\n\n   X : Rational_Numbers.Rational;\n   Y : Rational_Numbers.Rational;\nbegin  -- Demo_Rationals\n   Put ("Please input two rational numbers: ");\n   Get (X);\n   Skip_Line;\n   Get (Y);\n   Skip_Line;\n   Put ("X / Y = ");\n   Put (X / Y);\n   New_Line;\n   Put ("X * Y = ");\n   Put (X * Y);\n   New_Line;\n   Put ("X + Y = ");\n   Put (X + Y);\n   New_Line;\n   Put ("X - Y = ");\n   Put (X - Y);\n   New_Line;\nend Demo_Rationals;\n')),(0,t.yg)("h4",{id:"rationale"},"rationale"),(0,t.yg)("p",null,"These guidelines allow you to maintain a careful balance between\nmaintainability and readability. Use of the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause may indeed make\nthe code read more like prose text. However, the maintainer may also\nneed to resolve references and identify ambiguous operations. In the\nabsence of tools to resolve these references and identify the impact of\nchanging use clauses, fully qualified names are the best alternative."),(0,t.yg)("p",null,"Avoiding the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause forces you to use fully qualified names. In\nlarge systems, there may be many library units named in ",(0,t.yg)("inlineCode",{parentName:"p"},"with")," clauses.\nWhen corresponding ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clauses accompany the ",(0,t.yg)("inlineCode",{parentName:"p"},"with")," clauses and the\nsimple names of the library packages are omitted (as is allowed by the\n",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause), references to external entities are obscured and\nidentification of external dependencies becomes difficult."),(0,t.yg)("p",null,"In some situations, the benefits of the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause are clear. A\nstandard package can be used with the obvious assumption that the reader\nis very familiar with those packages and that additional overloading\nwill not be introduced."),(0,t.yg)("p",null,"The ",(0,t.yg)("inlineCode",{parentName:"p"},"use type")," clause makes both infix and prefix operators visible\nwithout the need for ",(0,t.yg)("inlineCode",{parentName:"p"},"renames")," clauses. You enhance readability with the\n",(0,t.yg)("inlineCode",{parentName:"p"},"use type")," clause because you can write statements using the more\nnatural infix notation for operators. See also Guideline 5.7.2."),(0,t.yg)("p",null,"You can minimize the scope of the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause by placing it in the body\nof a package or subprogram or by encapsulating it in a block to restrict\nvisibility."),(0,t.yg)("h4",{id:"notes"},"notes"),(0,t.yg)("p",null,"Avoiding the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause completely can cause problems with enumeration\nliterals, which must then be fully qualified. This problem can be solved\nby declaring constants with the enumeration literals as their values,\nexcept that such constants cannot be overloaded like enumeration\nliterals."),(0,t.yg)("p",null,"An argument defending the use clause can be found in Rosen (1987)."),(0,t.yg)("h4",{id:"automation-notes"},"automation notes"),(0,t.yg)("p",null,"There are tools that can analyze your Ada source code, resolve\noverloading of names, and automatically convert between the ",(0,t.yg)("inlineCode",{parentName:"p"},"use")," clause\nor fully qualified names."),(0,t.yg)("h3",{id:"the-renames-clause"},"The Renames Clause"),(0,t.yg)("h4",{id:"guideline-1"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Limit the scope of a renaming declaration to the minimum necessary\nscope."),(0,t.yg)("li",{parentName:"ul"},"Rename a long, fully qualified name to reduce the complexity if it\nbecomes unwieldy (see Guideline 3.1.4)."),(0,t.yg)("li",{parentName:"ul"},"Use renaming to provide the body of a subprogram if this subprogram\nmerely calls the first subprogram."),(0,t.yg)("li",{parentName:"ul"},"Rename declarations for visibility purposes rather than using the\nuse clause, except for operators (see Guideline 5.7.1)."),(0,t.yg)("li",{parentName:"ul"},"Rename parts when your code interfaces to reusable components\noriginally written with nondescriptive or inapplicable nomenclature."),(0,t.yg)("li",{parentName:"ul"},"Use a project-wide standard list of abbreviations to rename common\npackages."),(0,t.yg)("li",{parentName:"ul"},"Provide a ",(0,t.yg)("inlineCode",{parentName:"li"},"use type")," rather than a ",(0,t.yg)("inlineCode",{parentName:"li"},"renames")," clause to provide\nvisibility to operators.")),(0,t.yg)("h4",{id:"example-1"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},"procedure Disk_Write (Track_Name : in     Track;\n                      Item       : in     Data) renames\n   System_Specific.Device_Drivers.Disk_Head_Scheduler.Transmit;\n")),(0,t.yg)("p",null,"See also the example in Guideline 5.7.1, where a package-level ",(0,t.yg)("inlineCode",{parentName:"p"},"renames"),"\nclause provides an abbreviation for the package ",(0,t.yg)("inlineCode",{parentName:"p"},"Rational_Numbers_IO"),"."),(0,t.yg)("h4",{id:"rationale-1"},"rationale"),(0,t.yg)("p",null,"If the renaming facility is abused, the code can be difficult to read. A\n",(0,t.yg)("inlineCode",{parentName:"p"},"renames")," clause can substitute an abbreviation for a qualifier or long\npackage name locally. This can make code more readable yet anchor the\ncode to the full name. You can use the ",(0,t.yg)("inlineCode",{parentName:"p"},"renames")," clause to evaluate a\ncomplex name once or to provide a new ",(0,t.yg)("em",{parentName:"p"},'"view"')," of an object (regardless\nof whether it is tagged). However, the use of ",(0,t.yg)("inlineCode",{parentName:"p"},"renames")," clauses can\noften be avoided or made obviously undesirable by carefully choosing\nnames so that fully qualified names read well."),(0,t.yg)("p",null,"When a subprogram body calls another subprogram without adding local\ndata or other algorithmic content, it is more readable to have this\nsubprogram body rename the subprogram that actually does the work. Thus,\nyou avoid having to write code to ",(0,t.yg)("em",{parentName:"p"},'"pass through"')," a subprogram call\n(Rationale 1995, \xa7II.12)."),(0,t.yg)("p",null,"The list of renaming declarations serves as a list of abbreviation\ndefinitions (see Guideline 3.1.4). As an alternative, you can rename a\npackage at the library level to define project-wide abbreviations for\npackages and then ",(0,t.yg)("inlineCode",{parentName:"p"},"with")," the renamed packages. Often the parts recalled\nfrom a reuse library do not have names that are as general as they could\nbe or that match the new application's naming scheme. An interface\npackage exporting the renamed subprograms can map to your project's\nnomenclature. See also Guideline 5.7.1."),(0,t.yg)("p",null,"The method described in the ",(0,t.yg)("a",{parentName:"p",href:"http://www.adahome.com/rm95/rm9x-08-05.html"},"Ada Reference Manual\n(1995)")," for renaming a type\nis to use a subtype (see Guideline 3.4.1)."),(0,t.yg)("p",null,"The ",(0,t.yg)("inlineCode",{parentName:"p"},"use type")," clause eliminates the need for renaming infix operators.\nBecause you no longer need to rename each operator explicitly, you avoid\nerrors such as renaming a ",(0,t.yg)("inlineCode",{parentName:"p"},"+")," to a ",(0,t.yg)("inlineCode",{parentName:"p"},"-"),". See also Guideline 5.7.1."),(0,t.yg)("h4",{id:"notes-1"},"notes"),(0,t.yg)("p",null,"You should choose package names to be minimally meaningful, recognizing\nthat package names will be widely used as prefixes (e.g.,\n",(0,t.yg)("inlineCode",{parentName:"p"},"Pkg.Operation")," or ",(0,t.yg)("inlineCode",{parentName:"p"},"Object : Pkg.Type_Name;"),"). If you rename every\npackage to some abbreviation, you defeat the purpose of choosing\nmeaningful names, and it becomes hard to keep track of what all the\nabbreviations represent."),(0,t.yg)("p",null,"For upward compatibility of Ada 83 programs in an Ada 95 environment,\nthe environment includeslibrary-level renamings of the Ada 83 library\nlevel packages (",(0,t.yg)("a",{parentName:"p",href:"http://www.adahome.com/rm95/rm9x-J-01.html"},"Ada Reference Manual 1995,\n\xa7J.1"),"). It is not\nrecommended that you use these renamings in Ada 95 code."),(0,t.yg)("h3",{id:"overloaded-subprograms"},"Overloaded Subprograms"),(0,t.yg)("h4",{id:"guideline-2"},"guideline"),(0,t.yg)("p",null,"Limit overloading to widely used subprograms that perform similar\nactions on arguments of different types (Nissen and Wallis 1984)."),(0,t.yg)("h4",{id:"example-2"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},"function Sin (Angles : in     Matrix_Of_Radians) return Matrix;\nfunction Sin (Angles : in     Vector_Of_Radians) return Vector;\nfunction Sin (Angle  : in     Radians)           return Small_Real;\nfunction Sin (Angle  : in     Degrees)           return Small_Real;\n")),(0,t.yg)("h4",{id:"rationale-2"},"rationale"),(0,t.yg)("p",null,"Excessive overloading can be confusing to maintainers (Nissen and Wallis\n1984, 65). There is also the danger of hiding declarations if\noverloading becomes habitual. Attempts to overload an operation may\nactually hide the original operation if the parameter profile is not\ndistinct. From that point on, it is not clear whether invoking the new\noperation is what the programmer intended or whether the programmer\nintended to invoke the hidden operation and accidentally hid it."),(0,t.yg)("h4",{id:"notes-2"},"notes"),(0,t.yg)("p",null,"This guideline does not prohibit subprograms with identical names\ndeclared in different packages."),(0,t.yg)("h3",{id:"overloaded-operators"},"Overloaded Operators"),(0,t.yg)("h4",{id:"guideline-3"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Preserve the conventional meaning of overloaded operators (Nissen\nand Wallis 1984)."),(0,t.yg)("li",{parentName:"ul"},'Use "',(0,t.yg)("inlineCode",{parentName:"li"},"+"),'" to identify adding, joining, increasing, and enhancing\nkinds of functions.'),(0,t.yg)("li",{parentName:"ul"},'Use "',(0,t.yg)("inlineCode",{parentName:"li"},"-"),'" to identify subtraction, separation, decreasing, and\ndepleting kinds of functions.'),(0,t.yg)("li",{parentName:"ul"},"Use operator overloading sparingly and uniformly when applied to\ntagged types.")),(0,t.yg)("h4",{id:"example-3"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},'function "+" (X : in     Matrix;\n              Y : in     Matrix)\n  return Matrix;\n...\nSum := A + B;\n')),(0,t.yg)("h4",{id:"rationale-3"},"rationale"),(0,t.yg)("p",null,"Subverting the conventional interpretation of operators leads to\nconfusing code."),(0,t.yg)("p",null,"The advantage of operator overloading is that the code can become more\nclear and written more compactly (and readably) when it is used. This\ncan make the semantics simple and natural. However, it can be easy to\nmisunderstand the meaning of an overloaded operator, especially when\napplied to descendants. This is especially true if the programmer has\nnot applied natural semantics. Thus, do not use overloading if it cannot\nbe used uniformly and if it is easily misunderstood."),(0,t.yg)("h4",{id:"notes-3"},"notes"),(0,t.yg)("p",null,"There are potential problems with any overloading. For example, if there\nare several versions of the ",(0,t.yg)("inlineCode",{parentName:"p"},'"+"')," operator and a change to one of them\naffects the number or order of its parameters, locating the occurrences\nthat must be changed can be difficult."),(0,t.yg)("h3",{id:"overloading-the-equality-operator"},"Overloading the Equality Operator"),(0,t.yg)("h4",{id:"guideline-4"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Define an appropriate equality operator for private types."),(0,t.yg)("li",{parentName:"ul"},"Consider redefining the equality operator for a private type."),(0,t.yg)("li",{parentName:"ul"},"When overloading the equality operator for types, maintain the\nproperties of an algebraic equivalence relation.")),(0,t.yg)("h4",{id:"rationale-4"},"rationale"),(0,t.yg)("p",null,"The predefined equality operation provided with private types depends on\nthe data structure chosen to implement that type . If access types are\nused, then equality will mean the operands have the same pointer value.\nIf discrete types are used, then equality will mean the operands have\nthe same value. If a floating- point type is used, then equality is\nbased on Ada model intervals (see Guideline 7.2.7). You should,\ntherefore, redefine equality to provide the meaning expected by the\nclient. If you implement a private type using an access type, you should\nredefine equality to provide a deep equality. For floating-point types,\nyou may want to provide an equality that tests for equality within some\napplication-dependent epsilon value."),(0,t.yg)("p",null,"Any assumptions about the meaning of equality for private types will\ncreate a dependency on the implementation of that type. See Gonzalez\n(1991) for a detailed discussion."),(0,t.yg)("p",null,'When the definition of "',(0,t.yg)("inlineCode",{parentName:"p"},"="),'" is provided, there is a conventional\nalgebraic meaning implied by this symbol. As described in Baker (1991),\nthe following properties should remain true for the equality operator:'),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Reflexive: ",(0,t.yg)("inlineCode",{parentName:"li"},"a = a")),(0,t.yg)("li",{parentName:"ul"},"Symmetric: ",(0,t.yg)("inlineCode",{parentName:"li"},"a = b ==> b = a")),(0,t.yg)("li",{parentName:"ul"},"Transitive:",(0,t.yg)("inlineCode",{parentName:"li"},"a = b and b = c ==> a = c"))))),(0,t.yg)("p",null,"In redefining equality, you are not required to have a result type of\n",(0,t.yg)("inlineCode",{parentName:"p"},"Standard.Boolean"),". The Rationale (1995, \xa76.3) gives two examples where\nyour result type is a user-defined type. In a three-valued logic\nabstraction, you redefine equality to return one of ",(0,t.yg)("inlineCode",{parentName:"p"},"True"),", ",(0,t.yg)("inlineCode",{parentName:"p"},"False"),", or\n",(0,t.yg)("inlineCode",{parentName:"p"},"Unknown"),". In a vector processing application, you can define a\ncomponent-wise equality operator that returns a vector of Boolean\nvalues. In both these instances, you should also redefine inequality\nbecause it is not the Boolean complement of the equality function."))}m.isMDXComponent=!0}}]);