"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Why Ada?","href":"/docs/why-ada","docId":"why-ada"},{"type":"category","label":"Tutorial","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Lesson 1: Hello, World!","href":"/docs/tutorial/hello-world","docId":"tutorial/hello-world"},{"type":"link","label":"Lesson 2: Command Line Arguments","href":"/docs/tutorial/command-line-arguments","docId":"tutorial/command-line-arguments"}],"href":"/docs/category/tutorial"},{"type":"category","label":"Overview","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"The Big Five Structural Elements","href":"/docs/overview/five-structural-elements","docId":"overview/five-structural-elements"},{"type":"link","label":"Building Blocks","href":"/docs/overview/building-blocks","docId":"overview/building-blocks"},{"type":"link","label":"Debunking Ada Myths","href":"/docs/overview/debunking-ada-myths","docId":"overview/debunking-ada-myths"}],"href":"/docs/category/overview"},{"type":"category","label":"Tips and Tricks","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Advanced Techniques","href":"/docs/tips/advanced-techniques","docId":"tips/advanced-techniques"},{"type":"link","label":"Being More Terse","href":"/docs/tips/being-more-terse","docId":"tips/being-more-terse"}],"href":"/docs/category/tips-and-tricks"},{"type":"category","label":"Reference Manual","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Table of Contents","href":"/docs/arm/AA-TOC","docId":"arm/AA-TOC"},{"type":"link","label":"1 General","href":"/docs/arm/AA-1","docId":"arm/AA-1"},{"type":"link","label":"1.1  Scope","href":"/docs/arm/AA-1.1","docId":"arm/AA-1.1"},{"type":"link","label":"1.2  Normative References","href":"/docs/arm/AA-1.2","docId":"arm/AA-1.2"},{"type":"link","label":"1.3  Terms and Definitions","href":"/docs/arm/AA-1.3","docId":"arm/AA-1.3"},{"type":"link","label":"2 Lexical Elements","href":"/docs/arm/AA-2","docId":"arm/AA-2"},{"type":"link","label":"2.1  Character Set","href":"/docs/arm/AA-2.1","docId":"arm/AA-2.1"},{"type":"link","label":"2.2  Lexical Elements, Separators, and Delimiters","href":"/docs/arm/AA-2.2","docId":"arm/AA-2.2"},{"type":"link","label":"2.3  Identifiers","href":"/docs/arm/AA-2.3","docId":"arm/AA-2.3"},{"type":"link","label":"2.4  Numeric Literals","href":"/docs/arm/AA-2.4","docId":"arm/AA-2.4"},{"type":"link","label":"2.5  Character Literals","href":"/docs/arm/AA-2.5","docId":"arm/AA-2.5"},{"type":"link","label":"2.6  String Literals","href":"/docs/arm/AA-2.6","docId":"arm/AA-2.6"},{"type":"link","label":"2.7  Comments","href":"/docs/arm/AA-2.7","docId":"arm/AA-2.7"},{"type":"link","label":"2.8  Pragmas","href":"/docs/arm/AA-2.8","docId":"arm/AA-2.8"},{"type":"link","label":"2.9  Reserved Words","href":"/docs/arm/AA-2.9","docId":"arm/AA-2.9"},{"type":"link","label":"3 Declarations and Types","href":"/docs/arm/AA-3","docId":"arm/AA-3"},{"type":"link","label":"3.1  Declarations","href":"/docs/arm/AA-3.1","docId":"arm/AA-3.1"},{"type":"link","label":"3.2  Types and Subtypes","href":"/docs/arm/AA-3.2","docId":"arm/AA-3.2"},{"type":"link","label":"3.3  Objects and Named Numbers","href":"/docs/arm/AA-3.3","docId":"arm/AA-3.3"},{"type":"link","label":"3.4  Derived Types and Classes","href":"/docs/arm/AA-3.4","docId":"arm/AA-3.4"},{"type":"link","label":"3.5  Scalar Types","href":"/docs/arm/AA-3.5","docId":"arm/AA-3.5"},{"type":"link","label":"3.6  Array Types","href":"/docs/arm/AA-3.6","docId":"arm/AA-3.6"},{"type":"link","label":"3.7  Discriminants","href":"/docs/arm/AA-3.7","docId":"arm/AA-3.7"},{"type":"link","label":"3.8  Record Types","href":"/docs/arm/AA-3.8","docId":"arm/AA-3.8"},{"type":"link","label":"3.9  Tagged Types and Type Extensions","href":"/docs/arm/AA-3.9","docId":"arm/AA-3.9"},{"type":"link","label":"3.10  Access Types","href":"/docs/arm/AA-3.10","docId":"arm/AA-3.10"},{"type":"link","label":"3.11  Declarative Parts","href":"/docs/arm/AA-3.11","docId":"arm/AA-3.11"},{"type":"link","label":"4 Names and Expressions","href":"/docs/arm/AA-4","docId":"arm/AA-4"},{"type":"link","label":"4.1  Names","href":"/docs/arm/AA-4.1","docId":"arm/AA-4.1"},{"type":"link","label":"4.2  Literals","href":"/docs/arm/AA-4.2","docId":"arm/AA-4.2"},{"type":"link","label":"4.3  Aggregates","href":"/docs/arm/AA-4.3","docId":"arm/AA-4.3"},{"type":"link","label":"4.4  Expressions","href":"/docs/arm/AA-4.4","docId":"arm/AA-4.4"},{"type":"link","label":"4.5  Operators and Expression Evaluation","href":"/docs/arm/AA-4.5","docId":"arm/AA-4.5"},{"type":"link","label":"4.6  Type Conversions","href":"/docs/arm/AA-4.6","docId":"arm/AA-4.6"},{"type":"link","label":"4.7  Qualified Expressions","href":"/docs/arm/AA-4.7","docId":"arm/AA-4.7"},{"type":"link","label":"4.8  Allocators","href":"/docs/arm/AA-4.8","docId":"arm/AA-4.8"},{"type":"link","label":"4.9  Static Expressions and Static Subtypes","href":"/docs/arm/AA-4.9","docId":"arm/AA-4.9"},{"type":"link","label":"4.10  Image Attributes","href":"/docs/arm/AA-4.10","docId":"arm/AA-4.10"},{"type":"link","label":"5 Statements","href":"/docs/arm/AA-5","docId":"arm/AA-5"},{"type":"link","label":"5.1  Simple and Compound Statements - Sequences of Statements","href":"/docs/arm/AA-5.1","docId":"arm/AA-5.1"},{"type":"link","label":"5.2  Assignment Statements","href":"/docs/arm/AA-5.2","docId":"arm/AA-5.2"},{"type":"link","label":"5.3  If Statements","href":"/docs/arm/AA-5.3","docId":"arm/AA-5.3"},{"type":"link","label":"5.4  Case Statements","href":"/docs/arm/AA-5.4","docId":"arm/AA-5.4"},{"type":"link","label":"5.5  Loop Statements","href":"/docs/arm/AA-5.5","docId":"arm/AA-5.5"},{"type":"link","label":"5.6  Block Statements","href":"/docs/arm/AA-5.6","docId":"arm/AA-5.6"},{"type":"link","label":"5.7  Exit Statements","href":"/docs/arm/AA-5.7","docId":"arm/AA-5.7"},{"type":"link","label":"5.8  Goto Statements","href":"/docs/arm/AA-5.8","docId":"arm/AA-5.8"},{"type":"link","label":"6 Subprograms","href":"/docs/arm/AA-6","docId":"arm/AA-6"},{"type":"link","label":"6.1  Subprogram Declarations","href":"/docs/arm/AA-6.1","docId":"arm/AA-6.1"},{"type":"link","label":"6.2  Formal Parameter Modes","href":"/docs/arm/AA-6.2","docId":"arm/AA-6.2"},{"type":"link","label":"6.3  Subprogram Bodies","href":"/docs/arm/AA-6.3","docId":"arm/AA-6.3"},{"type":"link","label":"6.4  Subprogram Calls","href":"/docs/arm/AA-6.4","docId":"arm/AA-6.4"},{"type":"link","label":"6.5  Return Statements","href":"/docs/arm/AA-6.5","docId":"arm/AA-6.5"},{"type":"link","label":"6.6  Overloading of Operators","href":"/docs/arm/AA-6.6","docId":"arm/AA-6.6"},{"type":"link","label":"6.7  Null Procedures","href":"/docs/arm/AA-6.7","docId":"arm/AA-6.7"},{"type":"link","label":"6.8  Expression Functions","href":"/docs/arm/AA-6.8","docId":"arm/AA-6.8"},{"type":"link","label":"7 Packages","href":"/docs/arm/AA-7","docId":"arm/AA-7"},{"type":"link","label":"7.1  Package Specifications and Declarations","href":"/docs/arm/AA-7.1","docId":"arm/AA-7.1"},{"type":"link","label":"7.2  Package Bodies","href":"/docs/arm/AA-7.2","docId":"arm/AA-7.2"},{"type":"link","label":"7.3  Private Types and Private Extensions","href":"/docs/arm/AA-7.3","docId":"arm/AA-7.3"},{"type":"link","label":"7.4  Deferred Constants","href":"/docs/arm/AA-7.4","docId":"arm/AA-7.4"},{"type":"link","label":"7.5  Limited Types","href":"/docs/arm/AA-7.5","docId":"arm/AA-7.5"},{"type":"link","label":"7.6  Assignment and Finalization","href":"/docs/arm/AA-7.6","docId":"arm/AA-7.6"},{"type":"link","label":"8 Visibility Rules","href":"/docs/arm/AA-8","docId":"arm/AA-8"},{"type":"link","label":"8.1  Declarative Region","href":"/docs/arm/AA-8.1","docId":"arm/AA-8.1"},{"type":"link","label":"8.2  Scope of Declarations","href":"/docs/arm/AA-8.2","docId":"arm/AA-8.2"},{"type":"link","label":"8.3  Visibility","href":"/docs/arm/AA-8.3","docId":"arm/AA-8.3"},{"type":"link","label":"8.4  Use Clauses","href":"/docs/arm/AA-8.4","docId":"arm/AA-8.4"},{"type":"link","label":"8.5  Renaming Declarations","href":"/docs/arm/AA-8.5","docId":"arm/AA-8.5"},{"type":"link","label":"8.6  The Context of Overload Resolution","href":"/docs/arm/AA-8.6","docId":"arm/AA-8.6"},{"type":"link","label":"9 Tasks and Synchronization","href":"/docs/arm/AA-9","docId":"arm/AA-9"},{"type":"link","label":"9.1  Task Units and Task Objects","href":"/docs/arm/AA-9.1","docId":"arm/AA-9.1"},{"type":"link","label":"9.2  Task Execution - Task Activation","href":"/docs/arm/AA-9.2","docId":"arm/AA-9.2"},{"type":"link","label":"9.3  Task Dependence - Termination of Tasks","href":"/docs/arm/AA-9.3","docId":"arm/AA-9.3"},{"type":"link","label":"9.4  Protected Units and Protected Objects","href":"/docs/arm/AA-9.4","docId":"arm/AA-9.4"},{"type":"link","label":"9.5  Intertask Communication","href":"/docs/arm/AA-9.5","docId":"arm/AA-9.5"},{"type":"link","label":"9.6  Delay Statements, Duration, and Time","href":"/docs/arm/AA-9.6","docId":"arm/AA-9.6"},{"type":"link","label":"9.7  Select Statements","href":"/docs/arm/AA-9.7","docId":"arm/AA-9.7"},{"type":"link","label":"9.8  Abort of a Task - Abort of a Sequence of Statements","href":"/docs/arm/AA-9.8","docId":"arm/AA-9.8"},{"type":"link","label":"9.9  Task and Entry Attributes","href":"/docs/arm/AA-9.9","docId":"arm/AA-9.9"},{"type":"link","label":"9.10  Shared Variables","href":"/docs/arm/AA-9.10","docId":"arm/AA-9.10"},{"type":"link","label":"9.11  Example of Tasking and Synchronization","href":"/docs/arm/AA-9.11","docId":"arm/AA-9.11"},{"type":"link","label":"10 Program Structure and Compilation Issues","href":"/docs/arm/AA-10","docId":"arm/AA-10"},{"type":"link","label":"10.1  Separate Compilation","href":"/docs/arm/AA-10.1","docId":"arm/AA-10.1"},{"type":"link","label":"10.2  Program Execution","href":"/docs/arm/AA-10.2","docId":"arm/AA-10.2"},{"type":"link","label":"11 Exceptions","href":"/docs/arm/AA-11","docId":"arm/AA-11"},{"type":"link","label":"11.1  Exception Declarations","href":"/docs/arm/AA-11.1","docId":"arm/AA-11.1"},{"type":"link","label":"11.2  Exception Handlers","href":"/docs/arm/AA-11.2","docId":"arm/AA-11.2"},{"type":"link","label":"11.3  Raise Statements and Raise Expressions","href":"/docs/arm/AA-11.3","docId":"arm/AA-11.3"},{"type":"link","label":"11.4  Exception Handling","href":"/docs/arm/AA-11.4","docId":"arm/AA-11.4"},{"type":"link","label":"11.5  Suppressing Checks","href":"/docs/arm/AA-11.5","docId":"arm/AA-11.5"},{"type":"link","label":"11.6  Exceptions and Optimization","href":"/docs/arm/AA-11.6","docId":"arm/AA-11.6"},{"type":"link","label":"12 Generic Units","href":"/docs/arm/AA-12","docId":"arm/AA-12"},{"type":"link","label":"12.1  Generic Declarations","href":"/docs/arm/AA-12.1","docId":"arm/AA-12.1"},{"type":"link","label":"12.2  Generic Bodies","href":"/docs/arm/AA-12.2","docId":"arm/AA-12.2"},{"type":"link","label":"12.3  Generic Instantiation","href":"/docs/arm/AA-12.3","docId":"arm/AA-12.3"},{"type":"link","label":"12.4  Formal Objects","href":"/docs/arm/AA-12.4","docId":"arm/AA-12.4"},{"type":"link","label":"12.5  Formal Types","href":"/docs/arm/AA-12.5","docId":"arm/AA-12.5"},{"type":"link","label":"12.6  Formal Subprograms","href":"/docs/arm/AA-12.6","docId":"arm/AA-12.6"},{"type":"link","label":"12.7  Formal Packages","href":"/docs/arm/AA-12.7","docId":"arm/AA-12.7"},{"type":"link","label":"12.8  Example of a Generic Package","href":"/docs/arm/AA-12.8","docId":"arm/AA-12.8"},{"type":"link","label":"13 Representation Issues","href":"/docs/arm/AA-13","docId":"arm/AA-13"},{"type":"link","label":"13.1  Operational and Representation Aspects","href":"/docs/arm/AA-13.1","docId":"arm/AA-13.1"},{"type":"link","label":"13.2  Packed Types","href":"/docs/arm/AA-13.2","docId":"arm/AA-13.2"},{"type":"link","label":"13.3  Operational and Representation Attributes","href":"/docs/arm/AA-13.3","docId":"arm/AA-13.3"},{"type":"link","label":"13.4  Enumeration Representation Clauses","href":"/docs/arm/AA-13.4","docId":"arm/AA-13.4"},{"type":"link","label":"13.5  Record Layout","href":"/docs/arm/AA-13.5","docId":"arm/AA-13.5"},{"type":"link","label":"13.6  Change of Representation","href":"/docs/arm/AA-13.6","docId":"arm/AA-13.6"},{"type":"link","label":"13.7  The Package System","href":"/docs/arm/AA-13.7","docId":"arm/AA-13.7"},{"type":"link","label":"13.8  Machine Code Insertions","href":"/docs/arm/AA-13.8","docId":"arm/AA-13.8"},{"type":"link","label":"13.9  Unchecked Type Conversions","href":"/docs/arm/AA-13.9","docId":"arm/AA-13.9"},{"type":"link","label":"13.10  Unchecked Access Value Creation","href":"/docs/arm/AA-13.10","docId":"arm/AA-13.10"},{"type":"link","label":"13.11  Storage Management","href":"/docs/arm/AA-13.11","docId":"arm/AA-13.11"},{"type":"link","label":"13.12  Pragma Restrictions and Pragma Profile","href":"/docs/arm/AA-13.12","docId":"arm/AA-13.12"},{"type":"link","label":"13.13  Streams","href":"/docs/arm/AA-13.13","docId":"arm/AA-13.13"},{"type":"link","label":"13.14  Freezing Rules","href":"/docs/arm/AA-13.14","docId":"arm/AA-13.14"},{"type":"link","label":"Annex A Predefined Language Environment","href":"/docs/arm/AA-Annex A","docId":"arm/AA-Annex A"},{"type":"link","label":"A.1  The Package Standard","href":"/docs/arm/AA-A.1","docId":"arm/AA-A.1"},{"type":"link","label":"A.2  The Package Ada","href":"/docs/arm/AA-A.2","docId":"arm/AA-A.2"},{"type":"link","label":"A.3  Character Handling","href":"/docs/arm/AA-A.3","docId":"arm/AA-A.3"},{"type":"link","label":"A.4  String Handling","href":"/docs/arm/AA-A.4","docId":"arm/AA-A.4"},{"type":"link","label":"A.5  The Numerics Packages","href":"/docs/arm/AA-A.5","docId":"arm/AA-A.5"},{"type":"link","label":"A.6  Input-Output","href":"/docs/arm/AA-A.6","docId":"arm/AA-A.6"},{"type":"link","label":"A.7  External Files and File Objects","href":"/docs/arm/AA-A.7","docId":"arm/AA-A.7"},{"type":"link","label":"A.8  Sequential and Direct Files","href":"/docs/arm/AA-A.8","docId":"arm/AA-A.8"},{"type":"link","label":"A.9  The Generic Package Storage_IO","href":"/docs/arm/AA-A.9","docId":"arm/AA-A.9"},{"type":"link","label":"A.10  Text Input-Output","href":"/docs/arm/AA-A.10","docId":"arm/AA-A.10"},{"type":"link","label":"A.11  Wide Text Input-Output and Wide Wide Text Input-Output","href":"/docs/arm/AA-A.11","docId":"arm/AA-A.11"},{"type":"link","label":"A.12  Stream Input-Output","href":"/docs/arm/AA-A.12","docId":"arm/AA-A.12"},{"type":"link","label":"A.13  Exceptions in Input-Output","href":"/docs/arm/AA-A.13","docId":"arm/AA-A.13"},{"type":"link","label":"A.14  File Sharing","href":"/docs/arm/AA-A.14","docId":"arm/AA-A.14"},{"type":"link","label":"A.15  The Package Command_Line","href":"/docs/arm/AA-A.15","docId":"arm/AA-A.15"},{"type":"link","label":"A.16  The Package Directories","href":"/docs/arm/AA-A.16","docId":"arm/AA-A.16"},{"type":"link","label":"A.17  The Package Environment_Variables","href":"/docs/arm/AA-A.17","docId":"arm/AA-A.17"},{"type":"link","label":"A.18  Containers","href":"/docs/arm/AA-A.18","docId":"arm/AA-A.18"},{"type":"link","label":"A.19  The Package Locales","href":"/docs/arm/AA-A.19","docId":"arm/AA-A.19"},{"type":"link","label":"Annex B Interface to Other Languages","href":"/docs/arm/AA-Annex B","docId":"arm/AA-Annex B"},{"type":"link","label":"B.1  Interfacing Aspects","href":"/docs/arm/AA-B.1","docId":"arm/AA-B.1"},{"type":"link","label":"B.2  The Package Interfaces","href":"/docs/arm/AA-B.2","docId":"arm/AA-B.2"},{"type":"link","label":"B.3  Interfacing with C and C++","href":"/docs/arm/AA-B.3","docId":"arm/AA-B.3"},{"type":"link","label":"B.4  Interfacing with COBOL","href":"/docs/arm/AA-B.4","docId":"arm/AA-B.4"},{"type":"link","label":"B.5  Interfacing with Fortran","href":"/docs/arm/AA-B.5","docId":"arm/AA-B.5"},{"type":"link","label":"Annex C Systems Programming","href":"/docs/arm/AA-Annex C","docId":"arm/AA-Annex C"},{"type":"link","label":"C.1  Access to Machine Operations","href":"/docs/arm/AA-C.1","docId":"arm/AA-C.1"},{"type":"link","label":"C.2  Required Representation Support","href":"/docs/arm/AA-C.2","docId":"arm/AA-C.2"},{"type":"link","label":"C.3  Interrupt Support","href":"/docs/arm/AA-C.3","docId":"arm/AA-C.3"},{"type":"link","label":"C.4  Preelaboration Requirements","href":"/docs/arm/AA-C.4","docId":"arm/AA-C.4"},{"type":"link","label":"C.5  Aspect Discard_Names","href":"/docs/arm/AA-C.5","docId":"arm/AA-C.5"},{"type":"link","label":"C.6  Shared Variable Control","href":"/docs/arm/AA-C.6","docId":"arm/AA-C.6"},{"type":"link","label":"C.7  Task Information","href":"/docs/arm/AA-C.7","docId":"arm/AA-C.7"},{"type":"link","label":"Annex D Real-Time Systems","href":"/docs/arm/AA-Annex D","docId":"arm/AA-Annex D"},{"type":"link","label":"D.1  Task Priorities","href":"/docs/arm/AA-D.1","docId":"arm/AA-D.1"},{"type":"link","label":"D.2  Priority Scheduling","href":"/docs/arm/AA-D.2","docId":"arm/AA-D.2"},{"type":"link","label":"D.3  Priority Ceiling Locking","href":"/docs/arm/AA-D.3","docId":"arm/AA-D.3"},{"type":"link","label":"D.4  Entry Queuing Policies","href":"/docs/arm/AA-D.4","docId":"arm/AA-D.4"},{"type":"link","label":"D.5  Dynamic Priorities","href":"/docs/arm/AA-D.5","docId":"arm/AA-D.5"},{"type":"link","label":"D.6  Preemptive Abort","href":"/docs/arm/AA-D.6","docId":"arm/AA-D.6"},{"type":"link","label":"D.7  Tasking Restrictions","href":"/docs/arm/AA-D.7","docId":"arm/AA-D.7"},{"type":"link","label":"D.8  Monotonic Time","href":"/docs/arm/AA-D.8","docId":"arm/AA-D.8"},{"type":"link","label":"D.9  Delay Accuracy","href":"/docs/arm/AA-D.9","docId":"arm/AA-D.9"},{"type":"link","label":"D.10  Synchronous Task Control","href":"/docs/arm/AA-D.10","docId":"arm/AA-D.10"},{"type":"link","label":"D.11  Asynchronous Task Control","href":"/docs/arm/AA-D.11","docId":"arm/AA-D.11"},{"type":"link","label":"D.12  Other Optimizations and Determinism Rules","href":"/docs/arm/AA-D.12","docId":"arm/AA-D.12"},{"type":"link","label":"D.13  The Ravenscar and Jorvik Profiles","href":"/docs/arm/AA-D.13","docId":"arm/AA-D.13"},{"type":"link","label":"D.14  Execution Time","href":"/docs/arm/AA-D.14","docId":"arm/AA-D.14"},{"type":"link","label":"D.15  Timing Events","href":"/docs/arm/AA-D.15","docId":"arm/AA-D.15"},{"type":"link","label":"D.16  Multiprocessor Implementation","href":"/docs/arm/AA-D.16","docId":"arm/AA-D.16"},{"type":"link","label":"Annex E Distributed Systems","href":"/docs/arm/AA-Annex E","docId":"arm/AA-Annex E"},{"type":"link","label":"E.1  Partitions","href":"/docs/arm/AA-E.1","docId":"arm/AA-E.1"},{"type":"link","label":"E.2  Categorization of Library Units","href":"/docs/arm/AA-E.2","docId":"arm/AA-E.2"},{"type":"link","label":"E.3  Consistency of a Distributed System","href":"/docs/arm/AA-E.3","docId":"arm/AA-E.3"},{"type":"link","label":"E.4  Remote Subprogram Calls","href":"/docs/arm/AA-E.4","docId":"arm/AA-E.4"},{"type":"link","label":"E.5  Partition Communication Subsystem","href":"/docs/arm/AA-E.5","docId":"arm/AA-E.5"},{"type":"link","label":"Annex F Information Systems","href":"/docs/arm/AA-Annex F","docId":"arm/AA-Annex F"},{"type":"link","label":"F.1  Machine_Radix Attribute Definition Clause","href":"/docs/arm/AA-F.1","docId":"arm/AA-F.1"},{"type":"link","label":"F.2  The Package Decimal","href":"/docs/arm/AA-F.2","docId":"arm/AA-F.2"},{"type":"link","label":"F.3  Edited Output for Decimal Types","href":"/docs/arm/AA-F.3","docId":"arm/AA-F.3"},{"type":"link","label":"Annex G Numerics","href":"/docs/arm/AA-Annex G","docId":"arm/AA-Annex G"},{"type":"link","label":"G.1  Complex Arithmetic","href":"/docs/arm/AA-G.1","docId":"arm/AA-G.1"},{"type":"link","label":"G.2  Numeric Performance Requirements","href":"/docs/arm/AA-G.2","docId":"arm/AA-G.2"},{"type":"link","label":"G.3  Vector and Matrix Manipulation","href":"/docs/arm/AA-G.3","docId":"arm/AA-G.3"},{"type":"link","label":"Annex H High Integrity Systems","href":"/docs/arm/AA-Annex H","docId":"arm/AA-Annex H"},{"type":"link","label":"H.1  Pragma Normalize_Scalars","href":"/docs/arm/AA-H.1","docId":"arm/AA-H.1"},{"type":"link","label":"H.2  Documentation of Implementation Decisions","href":"/docs/arm/AA-H.2","docId":"arm/AA-H.2"},{"type":"link","label":"H.3  Reviewable Object Code","href":"/docs/arm/AA-H.3","docId":"arm/AA-H.3"},{"type":"link","label":"H.4  High Integrity Restrictions","href":"/docs/arm/AA-H.4","docId":"arm/AA-H.4"},{"type":"link","label":"H.5  Pragma Detect_Blocking","href":"/docs/arm/AA-H.5","docId":"arm/AA-H.5"},{"type":"link","label":"H.6  Pragma Partition_Elaboration_Policy","href":"/docs/arm/AA-H.6","docId":"arm/AA-H.6"},{"type":"link","label":"H.7  Extensions to Global and Global\'Class Aspects","href":"/docs/arm/AA-H.7","docId":"arm/AA-H.7"},{"type":"link","label":"Annex J Obsolescent Features","href":"/docs/arm/AA-Annex J","docId":"arm/AA-Annex J"},{"type":"link","label":"J.1  Renamings of Library Units","href":"/docs/arm/AA-J.1","docId":"arm/AA-J.1"},{"type":"link","label":"J.2  Allowed Replacements of Characters","href":"/docs/arm/AA-J.2","docId":"arm/AA-J.2"},{"type":"link","label":"J.3  Reduced Accuracy Subtypes","href":"/docs/arm/AA-J.3","docId":"arm/AA-J.3"},{"type":"link","label":"J.4  The Constrained Attribute","href":"/docs/arm/AA-J.4","docId":"arm/AA-J.4"},{"type":"link","label":"J.5  ASCII","href":"/docs/arm/AA-J.5","docId":"arm/AA-J.5"},{"type":"link","label":"J.6  Numeric_Error","href":"/docs/arm/AA-J.6","docId":"arm/AA-J.6"},{"type":"link","label":"J.7  At Clauses","href":"/docs/arm/AA-J.7","docId":"arm/AA-J.7"},{"type":"link","label":"J.8  Mod Clauses","href":"/docs/arm/AA-J.8","docId":"arm/AA-J.8"},{"type":"link","label":"J.9  The Storage_Size Attribute","href":"/docs/arm/AA-J.9","docId":"arm/AA-J.9"},{"type":"link","label":"J.10  Specific Suppression of Checks","href":"/docs/arm/AA-J.10","docId":"arm/AA-J.10"},{"type":"link","label":"J.11  The Class Attribute of Untagged Incomplete Types","href":"/docs/arm/AA-J.11","docId":"arm/AA-J.11"},{"type":"link","label":"J.12  Pragma Interface","href":"/docs/arm/AA-J.12","docId":"arm/AA-J.12"},{"type":"link","label":"J.13  Dependence Restriction Identifiers","href":"/docs/arm/AA-J.13","docId":"arm/AA-J.13"},{"type":"link","label":"J.14  Character and Wide_Character Conversion Functions","href":"/docs/arm/AA-J.14","docId":"arm/AA-J.14"},{"type":"link","label":"J.15  Aspect-related Pragmas","href":"/docs/arm/AA-J.15","docId":"arm/AA-J.15"},{"type":"link","label":"Annex K Language-Defined Aspects and Attributes","href":"/docs/arm/AA-Annex K","docId":"arm/AA-Annex K"},{"type":"link","label":"K.1  Language-Defined Aspects","href":"/docs/arm/AA-K.1","docId":"arm/AA-K.1"},{"type":"link","label":"K.2  Language-Defined Attributes","href":"/docs/arm/AA-K.2","docId":"arm/AA-K.2"},{"type":"link","label":"Annex L Language-Defined Pragmas","href":"/docs/arm/AA-Annex L","docId":"arm/AA-Annex L"},{"type":"link","label":"Annex M Summary of Documentation Requirements","href":"/docs/arm/AA-Annex M","docId":"arm/AA-Annex M"},{"type":"link","label":"M.1  Specific Documentation Requirements","href":"/docs/arm/AA-M.1","docId":"arm/AA-M.1"},{"type":"link","label":"M.2  Implementation-Defined Characteristics","href":"/docs/arm/AA-M.2","docId":"arm/AA-M.2"},{"type":"link","label":"M.3  Implementation Advice","href":"/docs/arm/AA-M.3","docId":"arm/AA-M.3"},{"type":"link","label":"Annex N Glossary","href":"/docs/arm/AA-Annex N","docId":"arm/AA-Annex N"},{"type":"link","label":"Annex P Syntax Summary","href":"/docs/arm/AA-Annex P","docId":"arm/AA-Annex P"},{"type":"link","label":"P.1  Syntax Rules","href":"/docs/arm/AA-P.1","docId":"arm/AA-P.1"},{"type":"link","label":"P.2  Syntax Cross Reference","href":"/docs/arm/AA-P.2","docId":"arm/AA-P.2"},{"type":"link","label":"Annex Q Language-Defined Entities","href":"/docs/arm/AA-Annex Q","docId":"arm/AA-Annex Q"},{"type":"link","label":"Q.1  Language-Defined Packages","href":"/docs/arm/AA-Q.1","docId":"arm/AA-Q.1"},{"type":"link","label":"Q.2  Language-Defined Types and Subtypes","href":"/docs/arm/AA-Q.2","docId":"arm/AA-Q.2"},{"type":"link","label":"Q.3  Language-Defined Subprograms","href":"/docs/arm/AA-Q.3","docId":"arm/AA-Q.3"},{"type":"link","label":"Q.4  Language-Defined Exceptions","href":"/docs/arm/AA-Q.4","docId":"arm/AA-Q.4"},{"type":"link","label":"Q.5  Language-Defined Objects","href":"/docs/arm/AA-Q.5","docId":"arm/AA-Q.5"}],"href":"/docs/category/reference-manual"},{"type":"link","label":"Glossary","href":"/docs/glossary","docId":"glossary"},{"type":"link","label":"Contribute","href":"/docs/contribute","docId":"contribute"}]},"docs":{"arm/AA-1":{"id":"arm/AA-1","title":"1 General","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-1.1":{"id":"arm/AA-1.1","title":"1.1  Scope","description":"This Reference Manual specifies the form and meaning of programs written in Ada. Its purpose is to promote the portability of Ada programs to a variety of computing systems.","sidebar":"tutorialSidebar"},"arm/AA-1.2":{"id":"arm/AA-1.2","title":"1.2  Normative References","description":"The following documents, in whole or in part, are normatively referenced in this document and are indispensable for its application. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies. For other documents mentioned in this document, see 1.2.1, \\"Bibliography\\".","sidebar":"tutorialSidebar"},"arm/AA-1.3":{"id":"arm/AA-1.3","title":"1.3  Terms and Definitions","description":"{AI12-0443-1} Terms are defined throughout this document, indicated by italic type. Terms explicitly defined in this document are not to be presumed to refer implicitly to similar terms defined elsewhere. Mathematical terms not defined in this document are to be interpreted according to the CRC Concise Encyclopedia of Mathematics, Second Edition. Other terms not defined in this document are to be interpreted according to the Webster\'s Third New International Dictionary of the English Language. Informal descriptions of some terms are also given below.","sidebar":"tutorialSidebar"},"arm/AA-10":{"id":"arm/AA-10","title":"10 Program Structure and Compilation Issues","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-10.1":{"id":"arm/AA-10.1","title":"10.1  Separate Compilation","description":"[ A program unit is either a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal. Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units. Version=[5],Kind=(AddedNormal),Group=[C],Term=[program unit], Def=[a language construct that is a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal], Note1=[Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units.]","sidebar":"tutorialSidebar"},"arm/AA-10.2":{"id":"arm/AA-10.2","title":"10.2  Program Execution","description":"An Ada program consists of a set of partitions[, which can execute in parallel with one another, possibly in a separate address space, and possibly on a separate computer.]","sidebar":"tutorialSidebar"},"arm/AA-11":{"id":"arm/AA-11","title":"11 Exceptions","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-11.1":{"id":"arm/AA-11.1","title":"11.1  Exception Declarations","description":"An exception_declaration declares a name for an exception.","sidebar":"tutorialSidebar"},"arm/AA-11.2":{"id":"arm/AA-11.2","title":"11.2  Exception Handlers","description":"The response to one or more exceptions is specified by an [exception_handler.]","sidebar":"tutorialSidebar"},"arm/AA-11.3":{"id":"arm/AA-11.3","title":"11.3  Raise Statements and Raise Expressions","description":"A [raise_statement raises an exception.]","sidebar":"tutorialSidebar"},"arm/AA-11.4":{"id":"arm/AA-11.4","title":"11.4  Exception Handling","description":"When an exception occurrence is raised, normal program execution is abandoned and control is transferred to an applicable [exception_handler, if any. To handle an exception occurrence is to respond to the exceptional event. To propagate an exception occurrence is to raise it again in another context; that is, to fail to respond to the exceptional event in the present context.]","sidebar":"tutorialSidebar"},"arm/AA-11.5":{"id":"arm/AA-11.5","title":"11.5  Suppressing Checks","description":"Checking pragmas give instructions to an implementation on handling language-defined checks. A pragma Suppress gives permission to an implementation to omit certain language-defined checks, while a pragma Unsuppress revokes the permission to omit checks.","sidebar":"tutorialSidebar"},"arm/AA-11.6":{"id":"arm/AA-11.6","title":"11.6  Exceptions and Optimization","description":"[ This subclause gives permission to the implementation to perform certain \\"optimizations\\" that do not necessarily preserve the canonical semantics.]","sidebar":"tutorialSidebar"},"arm/AA-12":{"id":"arm/AA-12","title":"12 Generic Units","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-12.1":{"id":"arm/AA-12.1","title":"12.1  Generic Declarations","description":"A [genericdeclaration declares a generic unit, which is either a generic subprogram or a generic package. A genericdeclaration includes a genericformalpart declaring any generic formal parameters. A generic formal parameter can be an object; alternatively (unlike a parameter of a subprogram), it can be a type, a subprogram, or a package.]","sidebar":"tutorialSidebar"},"arm/AA-12.2":{"id":"arm/AA-12.2","title":"12.2  Generic Bodies","description":"The body of a generic unit (a generic body) [is a template for the instance bodies. The syntax of a generic body is identical to that of a nongeneric body].","sidebar":"tutorialSidebar"},"arm/AA-12.3":{"id":"arm/AA-12.3","title":"12.3  Generic Instantiation","description":"An instance of a generic unit is declared by a [generic_instantiation.]","sidebar":"tutorialSidebar"},"arm/AA-12.4":{"id":"arm/AA-12.4","title":"12.4  Formal Objects","description":"[ A generic formal object can be used to pass a value or variable to a generic unit.]","sidebar":"tutorialSidebar"},"arm/AA-12.5":{"id":"arm/AA-12.5","title":"12.5  Formal Types","description":"[A generic formal subtype can be used to pass to a generic unit a subtype whose type is in a certain category of types.]","sidebar":"tutorialSidebar"},"arm/AA-12.6":{"id":"arm/AA-12.6","title":"12.6  Formal Subprograms","description":"[ Formal subprograms can be used to pass callable entities to a generic unit.]","sidebar":"tutorialSidebar"},"arm/AA-12.7":{"id":"arm/AA-12.7","title":"12.7  Formal Packages","description":"Formal packages can be used to pass packages to a generic unit. The [formalpackagedeclaration declares that the formal package is an instance of a given generic package. Upon instantiation, the actual package has to be an instance of that generic package.]","sidebar":"tutorialSidebar"},"arm/AA-12.8":{"id":"arm/AA-12.8","title":"12.8  Example of a Generic Package","description":"The following example provides a possible formulation of stacks by means of a generic package. The size of each stack and the type of the stack elements are provided as generic formal parameters.","sidebar":"tutorialSidebar"},"arm/AA-13":{"id":"arm/AA-13","title":"13 Representation Issues","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-13.1":{"id":"arm/AA-13.1","title":"13.1  Operational and Representation Aspects","description":"{8652/0009}  {AI05-0295-1} [Two kinds of aspects of entities can be specified: representation aspects and operational aspects. Representation aspects affect how the types and other entities of the language are to be mapped onto the underlying machine. Operational aspects determine other properties of entities.]","sidebar":"tutorialSidebar"},"arm/AA-13.10":{"id":"arm/AA-13.10","title":"13.10  Unchecked Access Value Creation","description":"[The attribute Unchecked_Access is used to create access values in an unsafe manner - the programmer is responsible for preventing \\"dangling references\\".]","sidebar":"tutorialSidebar"},"arm/AA-13.11":{"id":"arm/AA-13.11","title":"13.11  Storage Management","description":"Each access-to-object type has an associated storage pool. The storage allocated by an [allocator comes from the pool; instances of Unchecked_Deallocation return storage to the pool. Several access types can share the same pool.]","sidebar":"tutorialSidebar"},"arm/AA-13.12":{"id":"arm/AA-13.12","title":"13.12  Pragma Restrictions and Pragma Profile","description":"A [pragma Restrictions expresses the user\'s intent to abide by certain restrictions. A pragma Profile expresses the user\'s intent to abide by a set of Restrictions or other specified run-time policies. These may facilitate the construction of simpler run-time environments.]","sidebar":"tutorialSidebar"},"arm/AA-13.13":{"id":"arm/AA-13.13","title":"13.13  Streams","description":"A stream is a sequence of elements comprising values from possibly different types and allowing sequential access to these values. A stream type is a type in the class whose root type is Streams.RootStreamType. A stream type may be implemented in various ways, such as an external sequential file, an internal buffer, or a network channel.","sidebar":"tutorialSidebar"},"arm/AA-13.14":{"id":"arm/AA-13.14","title":"13.14  Freezing Rules","description":"[This subclause defines a place in the program text where each declared entity becomes \\"frozen\\". A use of an entity, such as a reference to it by name, or (for a type) an expression of the type, causes freezing of the entity in some contexts, as described below. The Legality Rules forbid certain kinds of uses of an entity in the region of text where it is frozen.]","sidebar":"tutorialSidebar"},"arm/AA-13.2":{"id":"arm/AA-13.2","title":"13.2  Packed Types","description":"[The Pack aspect having the value True specifies that storage minimization should be the main criterion when selecting the representation of a composite type.]","sidebar":"tutorialSidebar"},"arm/AA-13.3":{"id":"arm/AA-13.3","title":"13.3  Operational and Representation Attributes","description":"{8652/0009}   The values of certain implementation-dependent characteristics can be obtained by interrogating appropriate operational or representation attributes. Some of these attributes are specifiable via an [attributedefinitionclause.]","sidebar":"tutorialSidebar"},"arm/AA-13.4":{"id":"arm/AA-13.4","title":"13.4  Enumeration Representation Clauses","description":"An [enumerationrepresentationclause specifies the internal codes for enumeration literals.]","sidebar":"tutorialSidebar"},"arm/AA-13.5":{"id":"arm/AA-13.5","title":"13.5  Record Layout","description":"The (record) layout aspect of representation consists of the storage places for some or all components, that is, storage place attributes of the components. The layout can be specified with a recordrepresentationclause.","sidebar":"tutorialSidebar"},"arm/AA-13.6":{"id":"arm/AA-13.6","title":"13.6  Change of Representation","description":"{AI12-0445-1}  A [type_conversion (see 4.6) can be used to convert between two different representations of the same array or record. To convert an array from one representation to another, two array types with matching component subtypes and convertible index types are required. If one type has Pack specified and the other does not, then explicit conversion can be used to pack or unpack an array.","sidebar":"tutorialSidebar"},"arm/AA-13.7":{"id":"arm/AA-13.7","title":"13.7  The Package System","description":"[For each implementation there is a library package called System which includes the definitions of certain configuration-dependent characteristics.]","sidebar":"tutorialSidebar"},"arm/AA-13.8":{"id":"arm/AA-13.8","title":"13.8  Machine Code Insertions","description":"A machine code insertion can be achieved by a call to a subprogram whose [sequenceofstatements contains code_statements.]","sidebar":"tutorialSidebar"},"arm/AA-13.9":{"id":"arm/AA-13.9","title":"13.9  Unchecked Type Conversions","description":"[ An unchecked type conversion can be achieved by a call to an instance of the generic function Unchecked_Conversion.]","sidebar":"tutorialSidebar"},"arm/AA-2":{"id":"arm/AA-2","title":"2 Lexical Elements","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-2.1":{"id":"arm/AA-2.1","title":"2.1  Character Set","description":"{AI95-00395-01} {AI05-0266-1} {AI12-0263-1} The character repertoire for the text of an Ada program consists of the entire coding space described by the ISO/IEC 10646:2017 Universal Coded Character Set. This coding space is organized in planes, each plane comprising 65536 characters.","sidebar":"tutorialSidebar"},"arm/AA-2.2":{"id":"arm/AA-2.2","title":"2.2  Lexical Elements, Separators, and Delimiters","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-2.3":{"id":"arm/AA-2.3","title":"2.3  Identifiers","description":"Identifiers are used as names.","sidebar":"tutorialSidebar"},"arm/AA-2.4":{"id":"arm/AA-2.4","title":"2.4  Numeric Literals","description":"There are two kinds of numericliterals, real literals and integer literals. A real literal is a numericliteral that includes a point; an integer literal is a numeric_literal without a point.","sidebar":"tutorialSidebar"},"arm/AA-2.5":{"id":"arm/AA-2.5","title":"2.5  Character Literals","description":"A [character_literal is formed by enclosing a graphic character between two apostrophe characters.]","sidebar":"tutorialSidebar"},"arm/AA-2.6":{"id":"arm/AA-2.6","title":"2.6  String Literals","description":"A [stringliteral is formed by a sequence of graphic characters (possibly none) enclosed between two quotation marks used as string brackets. They are used to represent operatorsymbols (see 6.1), values of a string type (see 4.2), and array subaggregates (see 4.3.3). ]","sidebar":"tutorialSidebar"},"arm/AA-2.7":{"id":"arm/AA-2.7","title":"2.7  Comments","description":"A comment starts with two adjacent hyphens and extends up to the end of the line.","sidebar":"tutorialSidebar"},"arm/AA-2.8":{"id":"arm/AA-2.8","title":"2.8  Pragmas","description":"A pragma is a compiler directive. There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation may support additional (implementation-defined) pragmas. Version=[5],Kind=(AddedNormal),Group=[C],Term=[pragma], Def=[a compiler directive to provide control over and above that provided by the other syntactic constructs of the language], Note1=[There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation can support additional (implementation-defined) pragmas.]","sidebar":"tutorialSidebar"},"arm/AA-2.9":{"id":"arm/AA-2.9","title":"2.9  Reserved Words","description":"Syntax","sidebar":"tutorialSidebar"},"arm/AA-3":{"id":"arm/AA-3","title":"3 Declarations and Types","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-3.1":{"id":"arm/AA-3.1","title":"3.1  Declarations","description":"The language defines several kinds of named entities that are declared by declarations. The entity\'s name is defined by the declaration, usually by a definingidentifier, but sometimes by a definingcharacterliteral or definingoperatorsymbol. There are also entities that are not directly declared; some of these are elements of other entities, or are allocated dynamically. Such entities can be denoted using indexedcomponent, selected_component, or dereference names (see 4.1).","sidebar":"tutorialSidebar"},"arm/AA-3.10":{"id":"arm/AA-3.10","title":"3.10  Access Types","description":"A value of an access type (an access value) provides indirect access to the object or subprogram it designates. Depending on its type, an access value can designate either subprograms, objects created by allocators (see 4.8), or more generally aliased objects of an appropriate type.","sidebar":"tutorialSidebar"},"arm/AA-3.11":{"id":"arm/AA-3.11","title":"3.11  Declarative Parts","description":"A [declarativepart contains declarativeitems (possibly none).]","sidebar":"tutorialSidebar"},"arm/AA-3.2":{"id":"arm/AA-3.2","title":"3.2  Types and Subtypes","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-3.3":{"id":"arm/AA-3.3","title":"3.3  Objects and Named Numbers","description":"Objects are created at run time and contain a value of a given type. An object can be created and initialized as part of elaborating a declaration, evaluating an [allocator, aggregate, or function_call, or passing a parameter by copy. Prior to reclaiming the storage for an object, it is finalized if necessary (see 7.6.1).]","sidebar":"tutorialSidebar"},"arm/AA-3.4":{"id":"arm/AA-3.4","title":"3.4  Derived Types and Classes","description":"{AI95-00419-01} A derivedtypedefinition defines a derived type (and its first subtype) whose characteristics are derived from those of a parent type, and possibly from progenitor types.","sidebar":"tutorialSidebar"},"arm/AA-3.5":{"id":"arm/AA-3.5","title":"3.5  Scalar Types","description":"Scalar types comprise enumeration types, integer types, and real types. Enumeration types and integer types are called discrete types; each value of a discrete type has a position number which is an integer value. Integer types and real types are called numeric types. [All scalar types are ordered, that is, all relational operators are predefined for their values.]","sidebar":"tutorialSidebar"},"arm/AA-3.6":{"id":"arm/AA-3.6","title":"3.6  Array Types","description":"An array object is a composite object consisting of components which all have the same subtype. The name for a component of an array uses one or more index values belonging to specified discrete types. The value of an array object is a composite value consisting of the values of the components.","sidebar":"tutorialSidebar"},"arm/AA-3.7":{"id":"arm/AA-3.7","title":"3.7  Discriminants","description":"{AI95-00326-01}  A composite type (other than an array or interface type) can have discriminants, which parameterize the type. A [knowndiscriminantpart specifies the discriminants of a composite type. A discriminant of an object is a component of the object, and is either of a discrete type or an access type. An unknowndiscriminantpart in the declaration of a view of a type specifies that the discriminants of the type are unknown for the given view; all subtypes of such a view are indefinite subtypes.]","sidebar":"tutorialSidebar"},"arm/AA-3.8":{"id":"arm/AA-3.8","title":"3.8  Record Types","description":"A record object is a composite object consisting of named components. The value of a record object is a composite value consisting of the values of the components.","sidebar":"tutorialSidebar"},"arm/AA-3.9":{"id":"arm/AA-3.9","title":"3.9  Tagged Types and Type Extensions","description":"[ Tagged types and type extensions support object-oriented programming, based on inheritance with extension and run-time polymorphism via dispatching operations. ]","sidebar":"tutorialSidebar"},"arm/AA-4":{"id":"arm/AA-4","title":"4 Names and Expressions","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-4.1":{"id":"arm/AA-4.1","title":"4.1  Names","description":"[Names can denote declared entities, whether declared explicitly or implicitly (see 3.1). Names can also denote objects or subprograms designated by access values; the results of typeconversions or functioncalls; subcomponents and slices of objects and values; protected subprograms, single entries, entry families, and entries in families of entries. Finally, names can denote attributes of any of the foregoing.]","sidebar":"tutorialSidebar"},"arm/AA-4.10":{"id":"arm/AA-4.10","title":"4.10  Image Attributes","description":"An image of a value is a string representing the value in display form. The attributes Image, WideImage, and WideWideImage are available to produce the image of a value as a String, WideString, or WideWideString (respectively). User-defined images for a given type can be implemented by overriding the default implementation of the attribute Put_Image.","sidebar":"tutorialSidebar"},"arm/AA-4.2":{"id":"arm/AA-4.2","title":"4.2  Literals","description":"A literal represents a value literally, that is, by means of notation suited to its kind.] A literal is either a [numericliteral, a characterliteral, the literal null, or a string_literal.","sidebar":"tutorialSidebar"},"arm/AA-4.3":{"id":"arm/AA-4.3","title":"4.3  Aggregates","description":"[ An aggregate combines component values into a composite value of an array type, record type, or record extension.]","sidebar":"tutorialSidebar"},"arm/AA-4.4":{"id":"arm/AA-4.4","title":"4.4  Expressions","description":"{AI05-0158-1} {AI05-0176-1} An expression is a formula that defines the computation or retrieval of a value. In this Reference Manual, the term \\"expression\\" refers to a construct of the syntactic category expression or of any of the following categories: choiceexpression, choicerelation, relation, simpleexpression, term, factor, primary, conditionalexpression, quantified_expression.","sidebar":"tutorialSidebar"},"arm/AA-4.5":{"id":"arm/AA-4.5","title":"4.5  Operators and Expression Evaluation","description":"The language defines the following six categories of operators (given in order of increasing precedence). The corresponding [operator_symbols, and only those, can be used as designators in declarations of functions for user-defined operators. See 6.6, \\"Overloading of Operators\\".]","sidebar":"tutorialSidebar"},"arm/AA-4.6":{"id":"arm/AA-4.6","title":"4.6  Type Conversions","description":"[Explicit type conversions, both value conversions and view conversions, are allowed between closely related types as defined below. This subclause also defines rules for value and view conversions to a particular subtype of a type, both explicit ones and those implicit in other constructs. ]","sidebar":"tutorialSidebar"},"arm/AA-4.7":{"id":"arm/AA-4.7","title":"4.7  Qualified Expressions","description":"A [qualified_expression is used to state explicitly the type, and to verify the subtype, of an operand that is either an expression or an aggregate. ]","sidebar":"tutorialSidebar"},"arm/AA-4.8":{"id":"arm/AA-4.8","title":"4.8  Allocators","description":"The evaluation of an [allocator creates an object and yields an access value that designates the object. ]","sidebar":"tutorialSidebar"},"arm/AA-4.9":{"id":"arm/AA-4.9","title":"4.9  Static Expressions and Static Subtypes","description":"Certain expressions of a scalar or string type are defined to be static. Similarly, certain discrete ranges are defined to be static, and certain scalar and string subtypes are defined to be static subtypes. [ Static means determinable at compile time, using the declared properties or values of the program entities.]","sidebar":"tutorialSidebar"},"arm/AA-5":{"id":"arm/AA-5","title":"5 Statements","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-5.1":{"id":"arm/AA-5.1","title":"5.1  Simple and Compound Statements - Sequences of Statements","description":"A [statement is either simple or compound. A simplestatement encloses no other statement. A compoundstatement can enclose simplestatements and other compoundstatements.] A parallel construct is a construct that introduces additional logical threads of control (see clause 9) without creating a new task. Parallel loops (see 5.5) and parallelblockstatements (see 5.6.1) are parallel constructs.","sidebar":"tutorialSidebar"},"arm/AA-5.2":{"id":"arm/AA-5.2","title":"5.2  Assignment Statements","description":"An [assignment_statement replaces the current value of a variable with the result of evaluating an expression.]","sidebar":"tutorialSidebar"},"arm/AA-5.3":{"id":"arm/AA-5.3","title":"5.3  If Statements","description":"An [ifstatement selects for execution at most one of the enclosed sequencesof_statements, depending on the (truth) value of one or more corresponding conditions.]","sidebar":"tutorialSidebar"},"arm/AA-5.4":{"id":"arm/AA-5.4","title":"5.4  Case Statements","description":"A [casestatement selects for execution one of a number of alternative sequencesof_statements; the chosen alternative is defined by the value of an expression.]","sidebar":"tutorialSidebar"},"arm/AA-5.5":{"id":"arm/AA-5.5","title":"5.5  Loop Statements","description":"A [loopstatement includes a sequenceof_statements that is to be executed repeatedly, zero or more times with the iterations running sequentially or concurrently with one another.]","sidebar":"tutorialSidebar"},"arm/AA-5.6":{"id":"arm/AA-5.6","title":"5.6  Block Statements","description":"A [blockstatement encloses a handledsequenceofstatements optionally preceded by a declarative_part.]","sidebar":"tutorialSidebar"},"arm/AA-5.7":{"id":"arm/AA-5.7","title":"5.7  Exit Statements","description":"An [exitstatement is used to complete the execution of an enclosing loopstatement; the completion is conditional if the exit_statement includes a condition.]","sidebar":"tutorialSidebar"},"arm/AA-5.8":{"id":"arm/AA-5.8","title":"5.8  Goto Statements","description":"A [goto_statement specifies an explicit transfer of control from this statement to a target statement with a given label.]","sidebar":"tutorialSidebar"},"arm/AA-6":{"id":"arm/AA-6","title":"6 Subprograms","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-6.1":{"id":"arm/AA-6.1","title":"6.1  Subprogram Declarations","description":"A [subprogram_declaration declares a procedure or function.]","sidebar":"tutorialSidebar"},"arm/AA-6.2":{"id":"arm/AA-6.2","title":"6.2  Formal Parameter Modes","description":"A [parameter_specification declares a formal parameter of mode in, in out, or out.]","sidebar":"tutorialSidebar"},"arm/AA-6.3":{"id":"arm/AA-6.3","title":"6.3  Subprogram Bodies","description":"A [subprogram_body specifies the execution of a subprogram.]","sidebar":"tutorialSidebar"},"arm/AA-6.4":{"id":"arm/AA-6.4","title":"6.4  Subprogram Calls","description":"A subprogram call is either a procedurecallstatement or a functioncall; it invokes the execution of the [subprogrambody. The call specifies the association of the actual parameters, if any, with formal parameters of the subprogram.]","sidebar":"tutorialSidebar"},"arm/AA-6.5":{"id":"arm/AA-6.5","title":"6.5  Return Statements","description":"A simplereturnstatement or extendedreturnstatement (collectively called a return statement)  is used to complete the execution of the innermost enclosing subprogrambody, entrybody, or accept_statement.","sidebar":"tutorialSidebar"},"arm/AA-6.6":{"id":"arm/AA-6.6","title":"6.6  Overloading of Operators","description":"An operator is a function whose designator is an operator_symbol. [Operators, like other functions, may be overloaded.]","sidebar":"tutorialSidebar"},"arm/AA-6.7":{"id":"arm/AA-6.7","title":"6.7  Null Procedures","description":"A nullproceduredeclaration provides a shorthand to declare a procedure with an empty body.","sidebar":"tutorialSidebar"},"arm/AA-6.8":{"id":"arm/AA-6.8","title":"6.8  Expression Functions","description":"An expressionfunctiondeclaration provides a shorthand to declare a function whose body consists of a single return statement.","sidebar":"tutorialSidebar"},"arm/AA-7":{"id":"arm/AA-7","title":"7 Packages","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-7.1":{"id":"arm/AA-7.1","title":"7.1  Package Specifications and Declarations","description":"A package is generally provided in two parts: a [packagespecification and a packagebody. Every package has a packagespecification, but not all packages have a packagebody.]","sidebar":"tutorialSidebar"},"arm/AA-7.2":{"id":"arm/AA-7.2","title":"7.2  Package Bodies","description":"In contrast to the entities declared in the visible part of a package, the entities declared in the [packagebody are visible only within the packagebody itself. As a consequence, a package with a package_body can be used for the construction of a group of related subprograms in which the logical operations available to clients are clearly isolated from the internal entities.]","sidebar":"tutorialSidebar"},"arm/AA-7.3":{"id":"arm/AA-7.3","title":"7.3  Private Types and Private Extensions","description":"[The declaration (in the visible part of a package) of a type as a private type or private extension serves to separate the characteristics that can be used directly by outside program units (that is, the logical properties) from other characteristics whose direct use is confined to the package (the details of the definition of the type itself). See 3.9.1 for an overview of type extensions. ]","sidebar":"tutorialSidebar"},"arm/AA-7.4":{"id":"arm/AA-7.4","title":"7.4  Deferred Constants","description":"[Deferred constant declarations may be used to declare constants in the visible part of a package, but with the value of the constant given in the private part. They may also be used to declare constants imported from other languages (see Annex B).]","sidebar":"tutorialSidebar"},"arm/AA-7.5":{"id":"arm/AA-7.5","title":"7.5  Limited Types","description":"A limited type is (a view of) a type for which copying (such as for an [assignment_statement) is not allowed. A nonlimited type is a (view of a) type for which copying is allowed.]","sidebar":"tutorialSidebar"},"arm/AA-7.6":{"id":"arm/AA-7.6","title":"7.6  Assignment and Finalization","description":"Three kinds of actions are fundamental to the manipulation of objects: initialization, finalization, and assignment. Every object is initialized, either explicitly or by default, after being created (for example, by an [objectdeclaration or allocator). Every object is finalized before being destroyed (for example, by leaving a subprogrambody containing an objectdeclaration, or by a call to an instance of UncheckedDeallocation). An assignment operation is used as part of assignment_statements, explicit initialization, parameter passing, and other operations.","sidebar":"tutorialSidebar"},"arm/AA-8":{"id":"arm/AA-8","title":"8 Visibility Rules","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-8.1":{"id":"arm/AA-8.1","title":"8.1  Declarative Region","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-8.2":{"id":"arm/AA-8.2","title":"8.2  Scope of Declarations","description":"[For each declaration, the language rules define a certain portion of the program text called the scope of the declaration. The scope of a declaration is also called the scope of any view or entity declared by the declaration. Within the scope of an entity, and only there, there are places where it is legal to refer to the declared entity. These places are defined by the rules of visibility and overloading.]","sidebar":"tutorialSidebar"},"arm/AA-8.3":{"id":"arm/AA-8.3","title":"8.3  Visibility","description":"[ The visibility rules, given below, determine which declarations are visible and directly visible at each place within a program. The visibility rules apply to both explicit and implicit declarations.]","sidebar":"tutorialSidebar"},"arm/AA-8.4":{"id":"arm/AA-8.4","title":"8.4  Use Clauses","description":"A [usepackageclause achieves direct visibility of declarations that appear in the visible part of a package; a usetypeclause achieves direct visibility of the primitive operators of a type.]","sidebar":"tutorialSidebar"},"arm/AA-8.5":{"id":"arm/AA-8.5","title":"8.5  Renaming Declarations","description":"A [renamingdeclaration declares another name for an entity, such as an object, exception, package, subprogram, entry, or generic unit. Alternatively, a subprogramrenamingdeclaration can be the completion of a previous subprogramdeclaration.]","sidebar":"tutorialSidebar"},"arm/AA-8.6":{"id":"arm/AA-8.6","title":"8.6  The Context of Overload Resolution","description":"[ Because declarations can be overloaded, it is possible for an occurrence of a usage name to have more than one possible interpretation; in most cases, ambiguity is disallowed. This subclause describes how the possible interpretations resolve to the actual interpretation.","sidebar":"tutorialSidebar"},"arm/AA-9":{"id":"arm/AA-9","title":"9 Tasks and Synchronization","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-9.1":{"id":"arm/AA-9.1","title":"9.1  Task Units and Task Objects","description":"A task unit is declared by a task declaration, which has a corresponding taskbody. A task declaration may be a tasktypedeclaration, in which case it declares a named task type; alternatively, it may be a singletask_declaration, in which case it defines an anonymous task type, as well as declaring a named task object of that type.","sidebar":"tutorialSidebar"},"arm/AA-9.10":{"id":"arm/AA-9.10","title":"9.10  Shared Variables","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-9.11":{"id":"arm/AA-9.11","title":"9.11  Example of Tasking and Synchronization","description":"Examples","sidebar":"tutorialSidebar"},"arm/AA-9.2":{"id":"arm/AA-9.2","title":"9.2  Task Execution - Task Activation","description":"Dynamic Semantics","sidebar":"tutorialSidebar"},"arm/AA-9.3":{"id":"arm/AA-9.3","title":"9.3  Task Dependence - Termination of Tasks","description":"Dynamic Semantics","sidebar":"tutorialSidebar"},"arm/AA-9.4":{"id":"arm/AA-9.4","title":"9.4  Protected Units and Protected Objects","description":"A protected object provides coordinated access to shared data, through calls on its visible protected operations, which can be protected subprograms or protected entries. A protected unit is declared by a protected declaration, which has a corresponding protectedbody. A protected declaration may be a protectedtypedeclaration, in which case it declares a named protected type; alternatively, it may be a singleprotected_declaration, in which case it defines an anonymous protected type, as well as declaring a named protected object of that type.","sidebar":"tutorialSidebar"},"arm/AA-9.5":{"id":"arm/AA-9.5","title":"9.5  Intertask Communication","description":"The primary means for intertask communication is provided by calls on entries and protected subprograms. Calls on protected subprograms allow coordinated access to shared data objects. Entry calls allow for blocking the caller until a given condition is satisfied (namely, that the corresponding entry is open - see 9.5.3), and then communicating data or control information directly with another task or indirectly via a shared protected object.","sidebar":"tutorialSidebar"},"arm/AA-9.6":{"id":"arm/AA-9.6","title":"9.6  Delay Statements, Duration, and Time","description":"A [delaystatement is used to block further execution until a specified expiration time is reached. The expiration time can be specified either as a particular point in time (in a delayuntilstatement), or in seconds from the current time (in a delayrelative_statement). The language-defined package Calendar provides definitions for a type Time and associated operations, including a function Clock that returns the current time. ]","sidebar":"tutorialSidebar"},"arm/AA-9.7":{"id":"arm/AA-9.7","title":"9.7  Select Statements","description":"There are four forms of the [selectstatement. One form provides a selective wait for one or more selectalternatives. Two provide timed and conditional entry calls. The fourth provides asynchronous transfer of control.]","sidebar":"tutorialSidebar"},"arm/AA-9.8":{"id":"arm/AA-9.8","title":"9.8  Abort of a Task - Abort of a Sequence of Statements","description":"An [abortstatement causes one or more tasks to become abnormal, thus preventing any further interaction with such tasks. The completion of the triggeringstatement of an asynchronousselect causes a sequenceof_statements to be aborted.]","sidebar":"tutorialSidebar"},"arm/AA-9.9":{"id":"arm/AA-9.9","title":"9.9  Task and Entry Attributes","description":"Dynamic Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.1":{"id":"arm/AA-A.1","title":"A.1  The Package Standard","description":"This subclause outlines the specification of the package Standard containing all predefined identifiers in the language. The corresponding package body is not specified by the language.","sidebar":"tutorialSidebar"},"arm/AA-A.10":{"id":"arm/AA-A.10","title":"A.10  Text Input-Output","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.11":{"id":"arm/AA-A.11","title":"A.11  Wide Text Input-Output and Wide Wide Text Input-Output","description":"The packages WideTextIO and WideWideText_IO provide facilities for input and output in human-readable form. Each file is read or written sequentially, as a sequence of wide characters (or wide wide characters) grouped into lines, and as a sequence of lines grouped into pages.","sidebar":"tutorialSidebar"},"arm/AA-A.12":{"id":"arm/AA-A.12","title":"A.12  Stream Input-Output","description":"The packages Streams.StreamIO, TextIO.TextStreams, WideTextIO.TextStreams, and WideWideTextIO.TextStreams provide stream-oriented operations on files.","sidebar":"tutorialSidebar"},"arm/AA-A.13":{"id":"arm/AA-A.13","title":"A.13  Exceptions in Input-Output","description":"The package IO_Exceptions defines the exceptions used by the predefined input-output packages.","sidebar":"tutorialSidebar"},"arm/AA-A.14":{"id":"arm/AA-A.14","title":"A.14  File Sharing","description":"Dynamic Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.15":{"id":"arm/AA-A.15","title":"A.15  The Package Command_Line","description":"The package Command_Line allows a program to obtain the values of its arguments and to set the exit status code to be returned on normal termination.","sidebar":"tutorialSidebar"},"arm/AA-A.16":{"id":"arm/AA-A.16","title":"A.16  The Package Directories","description":"The package Directories provides operations for manipulating files and directories, and their names.","sidebar":"tutorialSidebar"},"arm/AA-A.17":{"id":"arm/AA-A.17","title":"A.17  The Package Environment_Variables","description":"The package Environment_Variables allows a program to read or modify environment variables. Environment variables are name-value pairs, where both the name and value are strings. The definition of what constitutes an environment variable, and the meaning of the name and value, are implementation defined.","sidebar":"tutorialSidebar"},"arm/AA-A.18":{"id":"arm/AA-A.18","title":"A.18  Containers","description":"This clause presents the specifications of the package Containers and several child packages, which provide facilities for storing collections of elements.","sidebar":"tutorialSidebar"},"arm/AA-A.19":{"id":"arm/AA-A.19","title":"A.19  The Package Locales","description":"{AI05-0248-1} A locale identifies a geopolitical place or region and its associated language, which can be used to determine other internationalization-related characteristics.","sidebar":"tutorialSidebar"},"arm/AA-A.2":{"id":"arm/AA-A.2","title":"A.2  The Package Ada","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.3":{"id":"arm/AA-A.3","title":"A.3  Character Handling","description":"{AI05-0243-1} {AI05-0299-1} This subclause presents the packages related to character processing: an empty declared pure package Characters and child packages Characters.Handling and Characters.Latin1. The package Characters.Handling provides classification and conversion functions for Character data, and some simple functions for dealing with WideCharacter and WideWideCharacter data. The child package Characters.Latin_1 declares a set of constants initialized to values of type Character.","sidebar":"tutorialSidebar"},"arm/AA-A.4":{"id":"arm/AA-A.4","title":"A.4  String Handling","description":"{AI05-0299-1} This subclause presents the specifications of the package Strings and several child packages, which provide facilities for dealing with string data. Fixed-length, bounded-length, and unbounded-length strings are supported, for String, WideString, and WideWide_String. The string-handling subprograms include searches for pattern strings and for characters in program-specified sets, translation (via a character-to-character mapping), and transformation (replacing, inserting, overwriting, and deleting of substrings).","sidebar":"tutorialSidebar"},"arm/AA-A.5":{"id":"arm/AA-A.5","title":"A.5  The Numerics Packages","description":"The library package Numerics is the parent of several child units that provide facilities for mathematical computation. One child, the generic package GenericElementaryFunctions, is defined in A.5.1, together with nongeneric equivalents; two others, the package FloatRandom and the generic package DiscreteRandom, are defined in A.5.2. Additional (optional) children are defined in Annex G, \\"Numerics\\".","sidebar":"tutorialSidebar"},"arm/AA-A.6":{"id":"arm/AA-A.6","title":"A.6  Input-Output","description":"{AI12-0445-1} [ Input-output is provided through language-defined packages, each of which is a child of the root package Ada. The generic packages SequentialIO and DirectIO define input-output operations applicable to files containing elements of a given type. The generic package StorageIO supports reading from and writing to an in-memory buffer. Additional operations for text input-output are supplied in the packages TextIO, WideTextIO, and WideWideTextIO. Heterogeneous input-output is provided through the child packages Streams.StreamIO and TextIO.TextStreams (see also 13.13). The package IO_Exceptions defines the exceptions used by the predefined input-output packages.]","sidebar":"tutorialSidebar"},"arm/AA-A.7":{"id":"arm/AA-A.7","title":"A.7  External Files and File Objects","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.8":{"id":"arm/AA-A.8","title":"A.8  Sequential and Direct Files","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-A.9":{"id":"arm/AA-A.9","title":"A.9  The Generic Package Storage_IO","description":"The generic package Storage_IO provides for reading from and writing to an in-memory buffer. This generic package supports the construction of user-defined input-output packages.","sidebar":"tutorialSidebar"},"arm/AA-Annex A":{"id":"arm/AA-Annex A","title":"Annex A Predefined Language Environment","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex B":{"id":"arm/AA-Annex B","title":"Annex B Interface to Other Languages","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex C":{"id":"arm/AA-Annex C","title":"Annex C Systems Programming","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex D":{"id":"arm/AA-Annex D","title":"Annex D Real-Time Systems","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex E":{"id":"arm/AA-Annex E","title":"Annex E Distributed Systems","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex F":{"id":"arm/AA-Annex F","title":"Annex F Information Systems","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex G":{"id":"arm/AA-Annex G","title":"Annex G Numerics","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex H":{"id":"arm/AA-Annex H","title":"Annex H High Integrity Systems","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex J":{"id":"arm/AA-Annex J","title":"Annex J Obsolescent Features","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex K":{"id":"arm/AA-Annex K","title":"Annex K Language-Defined Aspects and Attributes","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex L":{"id":"arm/AA-Annex L","title":"Annex L Language-Defined Pragmas","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex M":{"id":"arm/AA-Annex M","title":"Annex M Summary of Documentation Requirements","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex N":{"id":"arm/AA-Annex N","title":"Annex N Glossary","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex P":{"id":"arm/AA-Annex P","title":"Annex P Syntax Summary","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-Annex Q":{"id":"arm/AA-Annex Q","title":"Annex Q Language-Defined Entities","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"arm/AA-B.1":{"id":"arm/AA-B.1","title":"B.1  Interfacing Aspects","description":"An interfacing aspect is a representation aspect that is one of the aspects Import, Export, LinkName, ExternalName, or Convention.","sidebar":"tutorialSidebar"},"arm/AA-B.2":{"id":"arm/AA-B.2","title":"B.2  The Package Interfaces","description":"Package Interfaces is the parent of several library packages that declare types and other entities useful for interfacing to foreign languages. It also contains some implementation-defined types that are useful across more than one language (in particular for interfacing to assembly language).","sidebar":"tutorialSidebar"},"arm/AA-B.3":{"id":"arm/AA-B.3","title":"B.3  Interfacing with C and C++","description":"{8652/0059}  {AI95-00376-01} {AI05-0229-1} {AI12-0028-1} The facilities relevant to interfacing with the C language and the corresponding subset of the C++ language are the package Interfaces.C and its children, and support for specifying the Convention aspect with conventionidentifiers C, CPassByCopy, and any of the CVariadicn conventions described below.","sidebar":"tutorialSidebar"},"arm/AA-B.4":{"id":"arm/AA-B.4","title":"B.4  Interfacing with COBOL","description":"The facilities relevant to interfacing with the COBOL language are the package Interfaces.COBOL and support for specifying the Convention aspect with convention_identifier COBOL.","sidebar":"tutorialSidebar"},"arm/AA-B.5":{"id":"arm/AA-B.5","title":"B.5  Interfacing with Fortran","description":"The facilities relevant to interfacing with the Fortran language are the package Interfaces.Fortran and support for specifying the Convention aspect with convention_identifier Fortran.","sidebar":"tutorialSidebar"},"arm/AA-C.1":{"id":"arm/AA-C.1","title":"C.1  Access to Machine Operations","description":"[This subclause specifies rules regarding access to machine instructions from within an Ada program.]","sidebar":"tutorialSidebar"},"arm/AA-C.2":{"id":"arm/AA-C.2","title":"C.2  Required Representation Support","description":"{AI05-0299-1} This subclause specifies minimal requirements on the support for representation items and related features.","sidebar":"tutorialSidebar"},"arm/AA-C.3":{"id":"arm/AA-C.3","title":"C.3  Interrupt Support","description":"[This subclause specifies the language-defined model for hardware interrupts in addition to mechanisms for handling interrupts.]","sidebar":"tutorialSidebar"},"arm/AA-C.4":{"id":"arm/AA-C.4","title":"C.4  Preelaboration Requirements","description":"{AI12-0417-1} [This subclause specifies additional implementation and documentation requirements for the Preelaborate aspect (see 10.2.1).]","sidebar":"tutorialSidebar"},"arm/AA-C.5":{"id":"arm/AA-C.5","title":"C.5  Aspect Discard_Names","description":"[Specifying the aspect Discard_Names can be used to request a reduction in storage used for the names of entities with runtime name text.]","sidebar":"tutorialSidebar"},"arm/AA-C.6":{"id":"arm/AA-C.6","title":"C.6  Shared Variable Control","description":"{AI05-0299-1} [This subclause defines representation aspects that control the use of shared variables.]","sidebar":"tutorialSidebar"},"arm/AA-C.7":{"id":"arm/AA-C.7","title":"C.7  Task Information","description":"{AI05-0299-1} [This subclause describes operations and attributes that can be used to obtain the identity of a task. In addition, a package that associates user-defined information with a task is defined. Finally, a package that associates termination procedures with a task or set of tasks is defined.]","sidebar":"tutorialSidebar"},"arm/AA-D.1":{"id":"arm/AA-D.1","title":"D.1  Task Priorities","description":"[This subclause specifies the priority model for real-time systems. In addition, the methods for specifying priorities are defined.]","sidebar":"tutorialSidebar"},"arm/AA-D.10":{"id":"arm/AA-D.10","title":"D.10  Synchronous Task Control","description":"[This subclause describes a language-defined private semaphore (suspension object), which can be used for two-stage suspend operations and as a simple building block for implementing higher-level queues.]","sidebar":"tutorialSidebar"},"arm/AA-D.11":{"id":"arm/AA-D.11","title":"D.11  Asynchronous Task Control","description":"[This subclause introduces a language-defined package to do asynchronous suspend/resume on tasks. It uses a conceptual held priority value to represent the task\'s held state.]","sidebar":"tutorialSidebar"},"arm/AA-D.12":{"id":"arm/AA-D.12","title":"D.12  Other Optimizations and Determinism Rules","description":"[This subclause describes various requirements for improving the response and determinism in a real-time system.]","sidebar":"tutorialSidebar"},"arm/AA-D.13":{"id":"arm/AA-D.13","title":"D.13  The Ravenscar and Jorvik Profiles","description":"{AI05-0246-1} {AI05-0299-1} {AI12-0291-1} [This subclause defines the Ravenscar and Jorvik profiles.]","sidebar":"tutorialSidebar"},"arm/AA-D.14":{"id":"arm/AA-D.14","title":"D.14  Execution Time","description":"{AI05-0299-1} This subclause describes a language-defined package to measure execution time.","sidebar":"tutorialSidebar"},"arm/AA-D.15":{"id":"arm/AA-D.15","title":"D.15  Timing Events","description":"{AI05-0299-1} {AI12-0445-1} This subclause describes a language-defined package to allow user-defined protected procedures to be executed at a specified time without the use of a task or a delay statement.","sidebar":"tutorialSidebar"},"arm/AA-D.16":{"id":"arm/AA-D.16","title":"D.16  Multiprocessor Implementation","description":"{AI05-0299-1} This subclause allows implementations on multiprocessor platforms to be configured.","sidebar":"tutorialSidebar"},"arm/AA-D.2":{"id":"arm/AA-D.2","title":"D.2  Priority Scheduling","description":"{AI05-0299-1} [This subclause describes the rules that determine which task is selected for execution when more than one task is ready (see 9).]","sidebar":"tutorialSidebar"},"arm/AA-D.3":{"id":"arm/AA-D.3","title":"D.3  Priority Ceiling Locking","description":"[This subclause specifies the interactions between priority task scheduling and protected object ceilings. This interaction is based on the concept of the ceiling priority of a protected object.]","sidebar":"tutorialSidebar"},"arm/AA-D.4":{"id":"arm/AA-D.4","title":"D.4  Entry Queuing Policies","description":"{8652/0074}  {AI05-0299-1} {AI12-0324-1} [ This subclause specifies a mechanism for a user to choose an entry queuing policy. It also defines three such policies. Other policies are implementation defined.]","sidebar":"tutorialSidebar"},"arm/AA-D.5":{"id":"arm/AA-D.5","title":"D.5  Dynamic Priorities","description":"{AI05-0299-1} [This subclause describes how the priority of an entity can be modified or queried at run time.]","sidebar":"tutorialSidebar"},"arm/AA-D.6":{"id":"arm/AA-D.6","title":"D.6  Preemptive Abort","description":"[This subclause specifies requirements on the immediacy with which an aborted construct is completed.]","sidebar":"tutorialSidebar"},"arm/AA-D.7":{"id":"arm/AA-D.7","title":"D.7  Tasking Restrictions","description":"[This subclause defines restrictions that can be used with a pragma Restrictions (see 13.12) to facilitate the construction of highly efficient tasking run-time systems.]","sidebar":"tutorialSidebar"},"arm/AA-D.8":{"id":"arm/AA-D.8","title":"D.8  Monotonic Time","description":"[This subclause specifies a high-resolution, monotonic clock package.]","sidebar":"tutorialSidebar"},"arm/AA-D.9":{"id":"arm/AA-D.9","title":"D.9  Delay Accuracy","description":"This subclause specifies performance requirements for the [delaystatement. The rules apply both to delayrelativestatement and to delayuntilstatement. Similarly, they apply equally to a simple delaystatement and to one which appears in a delay_alternative.]","sidebar":"tutorialSidebar"},"arm/AA-E.1":{"id":"arm/AA-E.1","title":"E.1  Partitions","description":"[The partitions of a distributed program are classified as either active or passive.]","sidebar":"tutorialSidebar"},"arm/AA-E.2":{"id":"arm/AA-E.2","title":"E.2  Categorization of Library Units","description":"[Library units can be categorized according to the role they play in a distributed program. Certain restrictions are associated with each category to ensure that the semantics of a distributed program remain close to the semantics for a nondistributed program.]","sidebar":"tutorialSidebar"},"arm/AA-E.3":{"id":"arm/AA-E.3","title":"E.3  Consistency of a Distributed System","description":"[This subclause defines attributes and rules associated with verifying the consistency of a distributed program.]","sidebar":"tutorialSidebar"},"arm/AA-E.4":{"id":"arm/AA-E.4","title":"E.4  Remote Subprogram Calls","description":"A remote subprogram call is a subprogram call that invokes the execution of a subprogram in another (active) partition. The partition that originates the remote subprogram call is the calling partition, and the partition that executes the corresponding subprogram body is the called partition. Some remote procedure calls are allowed to return prior to the completion of subprogram execution. These are called asynchronous remote procedure calls.","sidebar":"tutorialSidebar"},"arm/AA-E.5":{"id":"arm/AA-E.5","title":"E.5  Partition Communication Subsystem","description":"[The Partition Communication Subsystem (PCS) provides facilities for supporting communication between the active partitions of a distributed program. The package System.RPC is a language-defined interface to the PCS.]","sidebar":"tutorialSidebar"},"arm/AA-F.1":{"id":"arm/AA-F.1","title":"F.1  Machine_Radix Attribute Definition Clause","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-F.2":{"id":"arm/AA-F.2","title":"F.2  The Package Decimal","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-F.3":{"id":"arm/AA-F.3","title":"F.3  Edited Output for Decimal Types","description":"The child packages TextIO.Editing, WideTextIO.Editing, and WideWideTextIO.Editing provide localizable formatted text output, known as edited output, for decimal types. An edited output string is a function of a numeric value, program-specifiable locale elements, and a format control value. The numeric value is of some decimal type. The locale elements are:","sidebar":"tutorialSidebar"},"arm/AA-G.1":{"id":"arm/AA-G.1","title":"G.1  Complex Arithmetic","description":"Types and arithmetic operations for complex arithmetic are provided in GenericComplexTypes, which is defined in G.1.1. Implementation-defined approximations to the complex analogs of the mathematical functions known as the \\"elementary functions\\" are provided by the subprograms in GenericComplexElementary_Functions, which is defined in G.1.2. Both of these library units are generic children of the predefined package Numerics (see A.5). Nongeneric equivalents of these generic packages for each of the predefined floating point types are also provided as children of Numerics.","sidebar":"tutorialSidebar"},"arm/AA-G.2":{"id":"arm/AA-G.2","title":"G.2  Numeric Performance Requirements","description":"Implementation Requirements","sidebar":"tutorialSidebar"},"arm/AA-G.3":{"id":"arm/AA-G.3","title":"G.3  Vector and Matrix Manipulation","description":"Types and operations for the manipulation of real vectors and matrices are provided in GenericRealArrays, which is defined in G.3.1. Types and operations for the manipulation of complex vectors and matrices are provided in GenericComplexArrays, which is defined in G.3.2. Both of these library units are generic children of the predefined package Numerics (see A.5). Nongeneric equivalents of these packages for each of the predefined floating point types are also provided as children of Numerics.","sidebar":"tutorialSidebar"},"arm/AA-H.1":{"id":"arm/AA-H.1","title":"H.1  Pragma Normalize_Scalars","description":"This pragma ensures that an otherwise uninitialized scalar object is set to a predictable value, but out of range if possible.","sidebar":"tutorialSidebar"},"arm/AA-H.2":{"id":"arm/AA-H.2","title":"H.2  Documentation of Implementation Decisions","description":"Documentation Requirements","sidebar":"tutorialSidebar"},"arm/AA-H.3":{"id":"arm/AA-H.3","title":"H.3  Reviewable Object Code","description":"Object code review and validation are supported by pragmas Reviewable and Inspection_Point.","sidebar":"tutorialSidebar"},"arm/AA-H.4":{"id":"arm/AA-H.4","title":"H.4  High Integrity Restrictions","description":"This subclause defines restrictions that can be used with pragma Restrictions (see 13.12); these facilitate the demonstration of program correctness by allowing tailored versions of the run-time system.","sidebar":"tutorialSidebar"},"arm/AA-H.5":{"id":"arm/AA-H.5","title":"H.5  Pragma Detect_Blocking","description":"{AI12-0267-1} The following pragma requires an implementation to detect potentially blocking operations during the execution of a protected operation or a parallel construct.","sidebar":"tutorialSidebar"},"arm/AA-H.6":{"id":"arm/AA-H.6","title":"H.6  Pragma Partition_Elaboration_Policy","description":"{AI05-0299-1} This subclause defines a pragma for user control over elaboration policy.","sidebar":"tutorialSidebar"},"arm/AA-H.7":{"id":"arm/AA-H.7","title":"H.7  Extensions to Global and Global\'Class Aspects","description":"In addition to the entities specified in 6.1.2, the Global aspect may be specified for a subtype (including a formal subtype), formal package, formal subprogram, and formal object of an anonymous access-to-subprogram type.","sidebar":"tutorialSidebar"},"arm/AA-J.1":{"id":"arm/AA-J.1","title":"J.1  Renamings of Library Units","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.10":{"id":"arm/AA-J.10","title":"J.10  Specific Suppression of Checks","description":"Pragma Suppress can be used to suppress checks on specific entities.","sidebar":"tutorialSidebar"},"arm/AA-J.11":{"id":"arm/AA-J.11","title":"J.11  The Class Attribute of Untagged Incomplete Types","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.12":{"id":"arm/AA-J.12","title":"J.12  Pragma Interface","description":"Syntax","sidebar":"tutorialSidebar"},"arm/AA-J.13":{"id":"arm/AA-J.13","title":"J.13  Dependence Restriction Identifiers","description":"The following restrictions involve dependence on specific language-defined units. The more general restriction No_Dependence (see 13.12.1) should be used for this purpose.","sidebar":"tutorialSidebar"},"arm/AA-J.14":{"id":"arm/AA-J.14","title":"J.14  Character and Wide_Character Conversion Functions","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.15":{"id":"arm/AA-J.15","title":"J.15  Aspect-related Pragmas","description":"Pragmas can be used as an alternative to aspect_specifications to specify certain aspects.","sidebar":"tutorialSidebar"},"arm/AA-J.2":{"id":"arm/AA-J.2","title":"J.2  Allowed Replacements of Characters","description":"Syntax","sidebar":"tutorialSidebar"},"arm/AA-J.3":{"id":"arm/AA-J.3","title":"J.3  Reduced Accuracy Subtypes","description":"A digitsconstraint may be used to define a floating point subtype with a new value for its requested decimal precision, as reflected by its Digits attribute. Similarly, a deltaconstraint may be used to define an ordinary fixed point subtype with a new value for its delta, as reflected by its Delta attribute.","sidebar":"tutorialSidebar"},"arm/AA-J.4":{"id":"arm/AA-J.4","title":"J.4  The Constrained Attribute","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.5":{"id":"arm/AA-J.5","title":"J.5  ASCII","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.6":{"id":"arm/AA-J.6","title":"J.6  Numeric_Error","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-J.7":{"id":"arm/AA-J.7","title":"J.7  At Clauses","description":"Syntax","sidebar":"tutorialSidebar"},"arm/AA-J.8":{"id":"arm/AA-J.8","title":"J.8  Mod Clauses","description":"Syntax","sidebar":"tutorialSidebar"},"arm/AA-J.9":{"id":"arm/AA-J.9","title":"J.9  The Storage_Size Attribute","description":"Static Semantics","sidebar":"tutorialSidebar"},"arm/AA-K.1":{"id":"arm/AA-K.1","title":"K.1  Language-Defined Aspects","description":"{AI05-0299-1} This subclause summarizes the definitions given elsewhere of the language-defined aspects. Aspects are properties of entities that can be specified by the Ada program; unless otherwise specified below, aspects can be specified using an aspect_specification.","sidebar":"tutorialSidebar"},"arm/AA-K.2":{"id":"arm/AA-K.2","title":"K.2  Language-Defined Attributes","description":"{AI05-0299-1} This subclause summarizes the definitions given elsewhere of the language-defined attributes. Attributes are properties of entities that can be queried by an Ada program.","sidebar":"tutorialSidebar"},"arm/AA-M.1":{"id":"arm/AA-M.1","title":"M.1  Specific Documentation Requirements","description":"In addition to implementation-defined characteristics, each Ada implementation is required to document various properties of the implementation:","sidebar":"tutorialSidebar"},"arm/AA-M.2":{"id":"arm/AA-M.2","title":"M.2  Implementation-Defined Characteristics","description":"The Ada language allows for certain machine dependences in a controlled manner. Each Ada implementation is required to document all implementation-defined characteristics:","sidebar":"tutorialSidebar"},"arm/AA-M.3":{"id":"arm/AA-M.3","title":"M.3  Implementation Advice","description":"This Reference Manual sometimes gives advice about handling certain target machine dependences. Each Ada implementation is required to document whether that advice is followed:","sidebar":"tutorialSidebar"},"arm/AA-P.1":{"id":"arm/AA-P.1","title":"P.1  Syntax Rules","description":"This subclause lists the complete syntax of the language in the order it appears in this Reference Manual. See  for a description of the notation used.","sidebar":"tutorialSidebar"},"arm/AA-P.2":{"id":"arm/AA-P.2","title":"P.2  Syntax Cross Reference","description":"In the following syntax cross reference, each syntactic category is followed by the subclause number where it is defined. In addition, each syntactic category S is followed by a list of the categories that use S in their definitions. For example, the first listing below shows that abortstatement appears in the definition of simplestatement.","sidebar":"tutorialSidebar"},"arm/AA-Q.1":{"id":"arm/AA-Q.1","title":"Q.1  Language-Defined Packages","description":"{AI05-0299-1} This subclause lists all language-defined packages.","sidebar":"tutorialSidebar"},"arm/AA-Q.2":{"id":"arm/AA-Q.2","title":"Q.2  Language-Defined Types and Subtypes","description":"{AI05-0299-1} This subclause lists all language-defined types and subtypes.","sidebar":"tutorialSidebar"},"arm/AA-Q.3":{"id":"arm/AA-Q.3","title":"Q.3  Language-Defined Subprograms","description":"{AI05-0299-1} This subclause lists all language-defined subprograms.","sidebar":"tutorialSidebar"},"arm/AA-Q.4":{"id":"arm/AA-Q.4","title":"Q.4  Language-Defined Exceptions","description":"{AI05-0299-1} This subclause lists all language-defined exceptions.","sidebar":"tutorialSidebar"},"arm/AA-Q.5":{"id":"arm/AA-Q.5","title":"Q.5  Language-Defined Objects","description":"{AI05-0299-1} This subclause lists all language-defined constants, variables, named numbers, and enumeration literals.","sidebar":"tutorialSidebar"},"arm/AA-TOC":{"id":"arm/AA-TOC","title":"Table of Contents","description":"We\'re still working on the Reference manual output.  Internal links are broken,","sidebar":"tutorialSidebar"},"contribute":{"id":"contribute","title":"Contribute","description":"ada-lang.io is built using Docusaurus.","sidebar":"tutorialSidebar"},"glossary":{"id":"glossary","title":"Glossary","description":"Terminology","sidebar":"tutorialSidebar"},"overview/building-blocks":{"id":"overview/building-blocks","title":"Building Blocks","description":"Ada often uses different terminology than any of the languages I\'ve used. The","sidebar":"tutorialSidebar"},"overview/debunking-ada-myths":{"id":"overview/debunking-ada-myths","title":"Debunking Ada Myths","description":"These are written in the truthful form, rather than stating the myth.","sidebar":"tutorialSidebar"},"overview/five-structural-elements":{"id":"overview/five-structural-elements","title":"The Big Five Structural Elements","description":"Ada provides five major elements for program organization.","sidebar":"tutorialSidebar"},"tips/advanced-techniques":{"id":"tips/advanced-techniques","title":"Advanced Techniques","description":"RAII","sidebar":"tutorialSidebar"},"tips/being-more-terse":{"id":"tips/being-more-terse","title":"Being More Terse","description":"Ada is known for being more verbose than other languages because it prefers","sidebar":"tutorialSidebar"},"tutorial/command-line-arguments":{"id":"tutorial/command-line-arguments","title":"Lesson 2: Command Line Arguments","description":"You\'re going to write a program that prints the words you give it.","sidebar":"tutorialSidebar"},"tutorial/hello-world":{"id":"tutorial/hello-world","title":"Lesson 1: Hello, World!","description":"Welcome to Ada!","sidebar":"tutorialSidebar"},"why-ada":{"id":"why-ada","title":"Why Ada?","description":"Covering every Ada feature would be dilute the conceptual overview of Ada, so","sidebar":"tutorialSidebar"}}}')}}]);