"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3751],{4121:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>y,default:()=>b,frontMatter:()=>h,metadata:()=>f,toc:()=>g});var a=n(1716),i=n(7556),o=n(7353),l=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,m=(e,t)=>{for(var n in t||(t={}))p.call(t,n)&&u(e,n,t[n]);if(d)for(var n of d(t))c.call(t,n)&&u(e,n,t[n]);return e};const h={sidebar_position:98},y="12.5 Formal Types",f={unversionedId:"arm/AA-12/AA-12.5",id:"arm/AA-12/AA-12.5",title:"12.5 Formal Types",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-12/AA-12.5.mdx",sourceDirName:"arm/AA-12",slug:"/arm/AA-12/AA-12.5",permalink:"/docs/arm/AA-12/AA-12.5",draft:!1,tags:[],version:"current",sidebarPosition:98,frontMatter:{sidebar_position:98},sidebar:"referenceManualSidebar",previous:{title:"12.4 Formal Objects",permalink:"/docs/arm/AA-12/AA-12.4"},next:{title:"12.6 Formal Subprograms",permalink:"/docs/arm/AA-12/AA-12.6"}},k={},g=[{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"12.5.1  Formal Private and Derived Types",id:"1251--formal-private-and-derived-types",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"12.5.2  Formal Scalar Types",id:"1252--formal-scalar-types",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"12.5.3  Formal Array Types",id:"1253--formal-array-types",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-3",level:4},{value:"12.5.4  Formal Access Types",id:"1254--formal-access-types",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-4",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005-1",level:4},{value:"12.5.5  Formal Interface Types",id:"1255--formal-interface-types",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4}],A={toc:g};function b(e){var t,n=e,{components:l}=n,u=((e,t)=>{var n={};for(var a in e)p.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&d)for(var a of d(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=m(m({},A),u),r(t,s({components:l,mdxType:"MDXLayout"}))),(0,a.kt)("h1",m({},{id:"125-formal-types"}),"12.5 Formal Types"),(0,a.kt)("admonition",m({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,a.kt)("a",m({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," [A generic formal subtype can be used to pass to a generic unit a subtype whose type is in a certain category of types.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"We considered having intermediate syntactic categories ",(0,a.kt)("code",null,"formal_integer_type_definition"),", ",(0,a.kt)("code",null,"formal_real_type_definition"),", and ",(0,a.kt)("code",null,"formal_fixed_point_definition"),", to be more uniform with the syntax rules for non-generic-formal types. However, that would make the rules for formal types slightly more complicated, and it would cause confusion, since ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0326"},"formal_discrete_type_definition"))," would not fit into the scheme very well. ")),(0,a.kt)("h4",m({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ",(0,a.kt)("code",null,"formal_type_declaration"),(0,a.kt)("a",{id:"S0320"}),(0,a.kt)("code",null," ::= "),"      ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0321"},"formal_complete_type_declaration")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0322"},"formal_incomplete_type_declaration"))),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0205-1"),"}"," ",(0,a.kt)("code",null,"formal_complete_type_declaration"),(0,a.kt)("a",{id:"S0321"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("strong",null,"type")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"[",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),"] ",(0,a.kt)("strong",null,"is")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0323"},"formal_type_definition")),"        [",(0,a.kt)("strong",null,"or use")," ",(0,a.kt)("em",null,"default_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),"] [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0205-1"),"}"," ",(0,a.kt)("code",null,"formal_incomplete_type_declaration"),(0,a.kt)("a",{id:"S0322"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("strong",null,"type")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"[",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),"] [",(0,a.kt)("strong",null,"is tagged"),"]        [",(0,a.kt)("strong",null,"or use")," ",(0,a.kt)("em",null,"default_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),"];"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ",(0,a.kt)("code",null,"formal_type_definition"),(0,a.kt)("a",{id:"S0323"}),(0,a.kt)("code",null," ::= "),"      ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0324"},"formal_private_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0325"},"formal_derived_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0326"},"formal_discrete_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0327"},"formal_signed_integer_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0328"},"formal_modular_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0329"},"formal_floating_point_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0330"},"formal_ordinary_fixed_point_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0331"},"formal_decimal_fixed_point_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0332"},"formal_array_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0333"},"formal_access_type_definition")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0334"},"formal_interface_type_definition"))),(0,a.kt)("h4",m({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)("p",null,"For a generic formal subtype, the actual shall be a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),"; it denotes the ",(0,a.kt)("em",null,"(generic) actual subtype"),". "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),'When we say simply "formal" or "actual" (for a generic formal that denotes a subtype) we\'re talking about the subtype, not the type, since a name that denotes a ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0320"},"formal_type_declaration"))," denotes a subtype, and the corresponding actual also denotes a subtype. ")),(0,a.kt)("h4",m({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0320"},"formal_type_declaration"))," declares a ",(0,a.kt)("em",null,"(generic) formal type"),", and its first subtype, the ",(0,a.kt)("em",null,"(generic) formal subtype"),". "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"A subtype (other than the first subtype) of a generic formal type is not a generic formal subtype. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," The form of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0323"},"formal_type_definition"))," ",(0,a.kt)("em",null,"determines a category (of types)")," to which the formal type belongs. For a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0324"},"formal_private_type_definition"))," the reserved words ",(0,a.kt)("strong",null,"tagged")," and ",(0,a.kt)("strong",null,"limited")," indicate the category of types (see 12.5.1). The reserved word ",(0,a.kt)("strong",null,"tagged")," also plays this role in the case of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0322"},"formal_incomplete_type_declaration")),". For a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0325"},"formal_derived_type_definition"))," the category of types is the derivation class rooted at the ancestor type. For other formal types, the name of the syntactic category indicates the category of types; a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0326"},"formal_discrete_type_definition"))," defines a discrete type, and so on. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This rule is clearer with the flat syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0323"},"formal_type_definition"))," given above. Adding ",(0,a.kt)("code",null,"formal_integer_type_definition")," and others would make this rule harder to state clearly.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We use "category\' rather than "class" above, because the requirement that classes are closed under derivation is not important here. Moreover, there are interesting categories that are not closed under derivation. For instance, limited and interface are categories that do not form classes. ')),(0,a.kt)("h4",m({},{id:"legality-rules-1"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," The actual type shall be in the category determined for the formal. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," For example, if the category determined for the formal is the category of all discrete types, then the actual has to be discrete.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," Note that this rule does not require the actual to belong to every category to which the formal belongs. For example, formal private types are in the category of composite types, but the actual need not be composite. Furthermore, one can imagine an infinite number of categories that are just arbitrary sets of types (even though we don't give them names, since they are uninteresting). We don't want this rule to apply to ",(0,a.kt)("em",null,"those")," categories.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' "Limited" is not an "interesting" category, but "nonlimited" is; it is legal to pass a nonlimited type to a limited formal type, but not the other way around. The reserved word ',(0,a.kt)("strong",null,"limited"),' really represents a category containing both limited and nonlimited types. "Private" is not a category for this purpose; a generic formal private type accepts both private and nonprivate actual types.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," It is legal to pass a class-wide subtype as the actual if it is in the right category, so long as the formal has unknown discriminants. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0205-1"),"}"," The ",(0,a.kt)("em",null,"default_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),", if any, shall denote a subtype which is allowed as an actual subtype for the formal type."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI12-0205-1"),"}"," This rule is observed at compile time of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.1#S0310"},"generic_declaration")),", and is consistent with the handling of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.6#S0339"},"default_name"))," of a formal subprogram. This means that a type declared outside of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.1#S0310"},"generic_declaration"))," cannot be used as the ",(0,a.kt)("em",null,"default_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," for a formal type that depends on any other formal type. ")),(0,a.kt)("h4",m({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0037"),"}"," ","{",(0,a.kt)("em",null,"AI95-00043-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00233-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0029-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0413-1"),"}"," [The formal type also belongs to each category that contains the determined category.] The primitive subprograms of the type are as for any type in the determined category. For a formal type other than a formal derived type, these are the predefined operators of the type. For an elementary formal type, the predefined operators are implicitly declared immediately after the declaration of the formal type. For a composite formal type, the predefined operators are implicitly declared either immediately after the declaration of the formal type, or later immediately within the declarative region in which the type is declared according to the rules of 7.3.1. In an instance, the copy of such an implicit declaration declares a view of the predefined operator of the actual type, even if this operator has been overridden for the actual type and even if it is never declared for the actual type, unless the actual type is an untagged record type, in which case it declares a view of the primitive (equality) operator. [The rules specific to formal derived types are given in 12.5.1.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," All properties of the type are as for any type in the category. Some examples: The primitive operations available are as defined by the language for each category. The form of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0029"},"constraint"))," applicable to a formal type in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," depends on the category of the type as for a nonformal type. The formal type is tagged if and only if it is declared as a tagged private type, or as a type derived from a (visibly) tagged type. (Note that the actual type might be tagged even if the formal type is not.)")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0413-1"),"}"," If the primitive equality operator of the (actual) untagged record type is declared abstract, then Program_Error will be raised if the equality operator of the formal type is in fact invoked within an instance of a generic body (see 4.5.2). If the operator is invoked within an instance of the generic spec, the instance is illegal. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI05-0029-1"),"}",' The somewhat cryptic phrase "even if it is never declared" is intended to deal with the following oddity: ')),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"package Q is","\n","    type T is limited private;","\n","private","\n","    type T is range 1 .. 10;","\n","end Q;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"generic","\n","    type A is array (Positive range ","<",">",") of T;","\n","package Q.G is","\n","    A1, A2 : A (1 .. 1);","\n","private","\n","    B : Boolean := A1 = A2;","\n","end Q.G;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"with Q.G;","\n","package R is","\n","   type C is array (Positive range ","<",">",") of Q.T;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},'package I is new Q.G (C); -- Where is the predefined "=" for C?',"\n","end R;","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'An "=" is available for the formal type A in the private part of Q.G. However, no "=" operator is ever declared for type C, because its component type Q.T is limited. Still, in the instance I the name "=" declares a view of the "=" for C which exists-but-is-never-declared. ')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   Generic formal types, like all types, are not named. Instead, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," can denote a generic formal subtype. Within a generic unit, a generic formal type is considered as being distinct from all other (formal or nonformal) types. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"This follows from the fact that each ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0320"},"formal_type_declaration"))," declares a type. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part"))," is allowed only for certain kinds of types, and therefore only for certain kinds of generic formal types. See 3.7. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI12-0005-1"),"}",' The term "formal floating point type" refers to a type defined by a ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0329"},"formal_floating_point_definition")),". It does not include a formal derived type whose ancestor is a floating point type. Similar terminology applies to the other kinds of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0323"},"formal_type_definition")),". ")),(0,a.kt)("h4",m({},{id:"examples"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of generic formal types:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Item is private;","\n","type Buffer(Length : Natural) is limited private;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Enum  is (","<",">",");","\n","type Int   is range ","<",">",";","\n","type Angle is delta ","<",">",";","\n","type Mass  is digits ","<",">",";","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Table is array (Enum) of Item;","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of a generic formal part declaring a formal integer type:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"generic","\n","   type Rank is range ","<",">",";","\n","   First  : Rank := Rank'First;","\n",'   Second : Rank := First + 1;  --  the operator "+" of the type Rank  ',"\n"),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'RM83 has separate sections "Generic Formal Xs" and "Matching Rules for Formal Xs" (for various X\'s) with most of the text redundant between the two. We have combined the two in order to reduce the redundancy. In RM83, there is no "Matching Rules for Formal Types" section; nor is there a "Generic Formal Y Types" section (for Y = Private, Scalar, Array, and Access). This causes, for example, the duplication across all the "Matching Rules for Y Types" sections of the rule that the actual passed to a formal type shall be a subtype; the new organization avoids that problem.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The matching rules are stated more concisely.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We no longer consider the multiplying operators that deliver a result of type ",(0,a.kt)("em",null,"universal_fixed")," to be predefined for the various types; there is only one of each in package Standard. Therefore, we need not mention them here as RM83 had to. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0037"),"}"," ","{",(0,a.kt)("em",null,"AI95-00043-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00233-01"),"}",' Corrigendum 1 corrected the wording to properly define the location where operators are defined for formal array types. The wording here was inconsistent with that in 7.3.1, "Private Operations". For the Amendment, this wording was corrected again, because it didn\'t reflect the Corrigendum 1 revisions in 7.3.1.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}",' Formal interface types are defined; see 12.5.5, "Formal Interface Types".')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We use "determines a category" rather than class, since not all interesting properties form a class. ')),(0,a.kt)("h4",m({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0320"},"formal_type_declaration")),". This is described in 13.1.1. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0029-1"),"}"," ",(0,a.kt)("strong",null,"Correction"),": Updated the wording to acknowledge the possibility of operations that are never declared for an actual type but still can be used inside of a generic unit.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," Formal incomplete types are added; these are documented as an extension in the next subclause. ")),(0,a.kt)("h4",m({},{id:"inconsistencies-with-ada-2012"}),"Inconsistencies With Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0413-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Updated the wording to clarify that predefined record equality never reemerges in a generic instantiation. This model was presumed by 4.5.2, but the wording wasn't right for untagged record types with user-defined equality. Therefore, an implementation that strictly implemented the Ada 2012 wording would call the predefined equality for an actual type that is an untagged record type with a user-defined equality, while Ada 2022 implementations would call the primitive (user-defined) equality. This could change the runtime behavior in rare cases. ")),(0,a.kt)("h4",m({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0205-1"),"}"," Generic formal types now can include an optional default ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),". ")),(0,a.kt)("h2",m({},{id:"1251--formal-private-and-derived-types"}),"12.5.1  Formal Private and Derived Types"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0445-1"),"}"," [In its most general form, the category determined for a formal private type is all types, but the category can be restricted to only nonlimited types or to only tagged types. Similarly, the category for a formal incomplete type is all types but the category can be restricted to only tagged types; unlike other formal types, the actual type can be incompletely defined, and not ready to be frozen (see 13.14). The category determined for a formal derived type is the derivation class rooted at the ancestor type.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," The first two rules are given normatively below, and the third rule is given normatively in 12.5; they are repeated here to give a capsule summary of what this subclause is about. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," Since the actual of a formal incomplete type does not need to be able to be frozen, the actual can be an incomplete type or a partial view before its completion. ")),(0,a.kt)("h4",m({},{id:"syntax-1"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_private_type_definition"),(0,a.kt)("a",{id:"S0324"}),(0,a.kt)("code",null," ::= "),"[[",(0,a.kt)("strong",null,"abstract"),"] ",(0,a.kt)("strong",null,"tagged"),"] [",(0,a.kt)("strong",null,"limited"),"] ",(0,a.kt)("strong",null,"private")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00419-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00443-01"),"}"," ",(0,a.kt)("code",null,"formal_derived_type_definition"),(0,a.kt)("a",{id:"S0325"}),(0,a.kt)("code",null," ::= "),"     [",(0,a.kt)("strong",null,"abstract"),"] [",(0,a.kt)("strong",null,"limited")," | ",(0,a.kt)("strong",null,"synchronized"),"] ",(0,a.kt)("strong",null,"new")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," [[",(0,a.kt)("strong",null,"and")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.9#S0078"},"interface_list")),"]",(0,a.kt)("strong",null,"with")," ",(0,a.kt)("strong",null,"private"),"]"),(0,a.kt)("h4",m({},{id:"legality-rules-2"}),"Legality Rules"),(0,a.kt)("p",null,"If a generic formal type declaration has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part")),", then it shall not include a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," for a discriminant. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"Consequently, a generic formal subtype with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part"))," is an indefinite subtype, so the declaration of a stand-alone variable has to provide a constraint on such a subtype, either explicitly, or by its initial value. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00419-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00443-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0237-1"),"}"," The ",(0,a.kt)("em",null,"ancestor subtype")," of a formal derived type is the subtype denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0325"},"formal_derived_type_definition")),". For a formal derived type declaration, the reserved words ",(0,a.kt)("strong",null,"with private")," shall appear if and only if the ancestor type is a tagged type; in this case the formal derived type is a private extension of the ancestor type and the ancestor shall not be a class-wide type. [Similarly, an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.9#S0078"},"interface_list"))," or the optional reserved words ",(0,a.kt)("strong",null,"abstract")," or ",(0,a.kt)("strong",null,"synchronized")," shall appear only if the ancestor type is a tagged type]. The reserved word ",(0,a.kt)("strong",null,"limited")," or ",(0,a.kt)("strong",null,"synchronized")," shall appear only if the ancestor type [and any progenitor types] are limited types. The reserved word ",(0,a.kt)("strong",null,"synchronized")," shall appear (rather than ",(0,a.kt)("strong",null,"limited"),") if the ancestor type or any of the progenitor types are synchronized interfaces. The ancestor type shall be a limited interface if the reserved word ",(0,a.kt)("strong",null,"synchronized")," appears."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'We use the term "ancestor" here instead of "parent" because the actual can be any descendant of the ancestor, not necessarily a direct descendant.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00419-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0005-1"),"}"," We require the ancestor type to be limited when ",(0,a.kt)("strong",null,"limited")," appears so that we avoid oddities like limited integer types. Normally, ",(0,a.kt)("strong",null,"limited"),' means "match anything" for a generic formal, but it was felt that allowing limited elementary types to be declared was just too weird. Integer still matches a formal limited private type; it is only a problem when the type is known to be elementary. Note that the progenitors are required to be limited by rules in 3.9.4, thus that part of the rule is redundant.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00443-01"),"}"," We require that ",(0,a.kt)("strong",null,"synchronized")," appear if the ancestor or any of the progenitors are synchronized, so that property is explicitly given in the program text  it is not automatically inherited from the ancestors. However, it can be given even if neither the ancestor nor the progenitors are synchronized. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00443-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0087-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0036-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," The actual type for a formal derived type shall be a descendant of [the ancestor type and] every progenitor of the formal type. The actual type for a formal derived type shall be tagged if and only if the formal derived type is a private extension. If the reserved word ",(0,a.kt)("strong",null,"synchronized")," appears in the declaration of the formal derived type, the actual type shall be a synchronized tagged type. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"The actual type has to be a descendant of the ancestor type, in order that it be in the correct class. Thus, that part of the rule is redundant. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI05-0005-1"),"}",' For a nonformal private extension, we require the partial view to be synchronized if the full view is synchronized tagged. This does not apply to a formal private extension - it is OK if the formal is not synchronized. Any attempt to extend the formal type will be rechecked in the instance, where the rule disallowing extending a synchronized noninterface type will be enforced. This is consistent with the "no hidden interfaces" rule also applying only to nonformal private extensions, as well as the rule that a limited nonformal private extension implies a limited full type. Formal private extensions are exempted from all these rules to enable the construction of generics that can be used with the widest possible range of types. In particular, an indefinite tagged limited formal private type can match any "concrete" actual tagged type.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0087-1"),"}"," A type (including formal types) derived from a limited interface could be nonlimited; we do not want a limited type derived from such an interface to match a nonlimited formal derived type. Otherwise, we could assign limited objects. Thus, we have to explicitly ban this case.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0036-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0005-1"),"}"," If we allowed actual types whose kind differs from that of the formal derived type, we could allow type conversions that would not be allowed outside of the generic. That would be particularly problematical if the actual is a tagged type with extension components; we could have created an object of the type that is missing those components by converting from the ancestor type to a formal derived type that is not an extension. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," If a formal private or derived subtype is definite, then the actual subtype shall also be definite. If the formal type is nonlimited, the actual type shall be nonlimited. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"On the other hand, for an indefinite formal subtype, the actual can be either definite or indefinite. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," The rule about nonlimited formals applies to both private and derived formal types. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0322"},"formal_incomplete_type_declaration"))," declares a formal incomplete type. The only view of a formal incomplete type is an incomplete view. [Thus, a formal incomplete type is subject to the same usage restrictions as any other incomplete type - see 3.10.1.]"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0351-1"),"}"," For a generic formal derived type with no ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),", the actual subtype shall be statically compatible with the ancestor subtype. Furthermore: "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0351-1"),"}"," If the ancestor subtype is constrained, the actual subtype shall be constrained; "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI12-0351-1"),"}",' In other words, any constraint on the ancestor subtype is considered part of the "contract". Predicates are also considered part of the contract for ',(0,a.kt)("em",null,"any")," subtype, via the static compatibility requirement. ")),(0,a.kt)("p",null,"If the ancestor subtype is an unconstrained access or composite subtype, the actual subtype shall be unconstrained. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This rule ensures that if a composite constraint is allowed on the formal, one is also allowed on the actual. If the ancestor subtype is an unconstrained scalar subtype, the actual is allowed to be constrained, since a scalar constraint does not cause further constraints to be illegal. ")),(0,a.kt)("p",null,"If the ancestor subtype is an unconstrained discriminated subtype, then the actual shall have the same number of discriminants, and each discriminant of the actual shall correspond to a discriminant of the ancestor, in the sense of 3.7."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This ensures that if a discriminant constraint is given on the formal subtype, the corresponding constraint in the instance will make sense, without additional runtime checks. This is not necessary for arrays, since the bounds cannot be overridden in a type extension. An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0060"},"unknown_discriminant_part"))," may be used to relax these matching requirements. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," If the ancestor subtype is an access subtype, the actual subtype shall exclude null if and only if the ancestor subtype excludes null. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'We require that the "excludes null" property match, because it would be difficult to write a correct generic for a formal access type without knowing this property. Many typical algorithms and techniques will not work for a subtype that excludes null (setting an unused component to ',(0,a.kt)("strong",null,"null"),", default-initialized objects, and so on). We want this sort of requirement to be reflected in the contract of the generic.")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," The declaration of a formal derived type shall not have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part")),". For a generic formal private or incomplete type with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part")),": "),(0,a.kt)("p",null,"The actual type shall be a type with the same number of discriminants."),(0,a.kt)("p",null,"The actual subtype shall be unconstrained."),(0,a.kt)("p",null,"The subtype of each discriminant of the actual type shall statically match the subtype of the corresponding discriminant of the formal type. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'We considered defining the first and third rule to be called "subtype conformance" for ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),"s. We rejected that idea, because it would require implicit (inherited) ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),"s, which seemed like too much mechanism. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0444-1"),"}"," [For a generic formal type with an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0060"},"unknown_discriminant_part")),", the actual may have discriminants, though that is not required, and may be definite or indefinite.]"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0095-1"),"}"," When enforcing Legality Rules, for the purposes of determining within a generic body whether a type is unconstrained in any partial view, a discriminated subtype is considered to have a constrained partial view if it is a descendant of an untagged generic formal private or derived type."),(0,a.kt)("h4",m({},{id:"static-semantics-2"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," The category determined for a formal private type is as follows: "),(0,a.kt)("p",null,(0,a.kt)("em",null,"Type Definition")," \t",(0,a.kt)("em",null,"Determined Category"),(0,a.kt)("strong",null,"limited private")," \tthe category of all types",(0,a.kt)("strong",null,"private")," \tthe category of all nonlimited types",(0,a.kt)("strong",null,"tagged limited private")," \tthe category of all tagged types",(0,a.kt)("strong",null,"tagged private")," \tthe category of all nonlimited tagged types"),(0,a.kt)("p",null,"[The presence of the reserved word ",(0,a.kt)("strong",null,"abstract")," determines whether the actual type may be abstract.]"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," The category determined for a formal incomplete type is the category of all types, unless the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0320"},"formal_type_declaration"))," includes the reserved word ",(0,a.kt)("strong",null,"tagged"),"; in this case, it is the category of all tagged types."),(0,a.kt)("p",null,"A formal private or derived type is a private or derived type, respectively. A formal derived tagged type is a private extension. [A formal private or derived type is abstract if the reserved word ",(0,a.kt)("strong",null,"abstract")," appears in its declaration.]"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00233-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0110-1"),"}"," For a formal derived type, the characteristics (including components, but excluding discriminants if there is a new ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),"), predefined operators, and inherited user-defined primitive subprograms are determined by its ancestor type and its progenitor types (if any), in the same way that those of a derived type are determined by those of its parent type and its progenitor types (see 3.4 and 7.3.1)."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0038"),"}"," ","{",(0,a.kt)("em",null,"AI95-00202"),"}"," ","{",(0,a.kt)("em",null,"AI95-00233-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0029-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0110-1"),"}"," In an instance, the copy of an implicit declaration of a primitive subprogram of a formal derived type declares a view of the corresponding primitive subprogram of the ancestor or progenitor of the formal derived type, even if this primitive has been overridden for the actual type and even if it is never declared for the actual type. When the ancestor or progenitor of the formal derived type is itself a formal type, the copy of the implicit declaration declares a view of the corresponding copied operation of the ancestor or progenitor. [In the case of a formal private extension, however, the tag of the formal type is that of the actual type, so if the tag in a call is statically determined to be that of the formal type, the body executed will be that corresponding to the actual type.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0239-1"),"}"," The above rule defining the properties of primitive subprograms in an instance applies even if the subprogram has been overridden or hidden for the actual type. This rule is necessary for untagged types, because their primitive subprograms might have been overridden by operations that are not subtype conformant with the operations defined for the class. For tagged types, the rule still applies, but the primitive subprograms will dispatch to the appropriate implementation based on the type and tag of the operands. Even for tagged types, the formal parameter names and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),"s are determined by those of the primitive subprograms of the specified ancestor type (or progenitor type, for subprograms inherited from an interface type). ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"{",(0,a.kt)("em",null,"AI12-0030-1"),"}"," The availability of stream attributes is not formally a characteristic of a type, but it is still determined by the ancestor type for a formal derived type in the same way as the characteristics are. Availability is rechecked in the instance specification. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0419-1"),"}"," In an instance, the implicitly composed and additive aspects (see 13.1.1) of a formal type are those of the actual; for a nonoverridable aspect, a formal derived type inherits the aspect if the ancestor or any progenitor has the aspect, according to the rules given in 13.1."),(0,a.kt)("p",null,"For a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," S that denotes a formal indefinite subtype, the following attribute is defined: "),(0,a.kt)("p",null,"S'Definite","{",(0,a.kt)("em",null,"AI05-0264-1"),"}"," S'Definite yields True if the actual subtype corresponding to S is definite; otherwise, it yields False. The value of this attribute is of the predefined type Boolean. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0005-1"),"}"," Whether an actual subtype is definite or indefinite may have a major effect on the algorithm used in a generic. For example, in a generic I/O package, whether to use fixed-length or variable-length records could depend on whether the actual is definite or indefinite. This attribute is essentially a replacement for the Constrained attribute, which is now obsolescent. ")),(0,a.kt)("h4",m({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00158-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0071-1"),"}"," In the case where a formal type has unknown discriminants, and the actual type is a class-wide type ",(0,a.kt)("em",null,"T"),"'Class:"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00158-01"),"}"," For the purposes of defining the primitive operations of the formal type, each of the primitive operations of the actual type is considered to be a subprogram (with an intrinsic calling convention - see 6.3.1) whose body consists of a dispatching call upon the corresponding operation of ",(0,a.kt)("em",null,"T"),", with its formal parameters as the actual parameters. If it is a function, the result of the dispatching call is returned."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00158-01"),"}"," If the corresponding operation of ",(0,a.kt)("em",null,"T")," has no controlling formal parameters, then the controlling tag value is determined by the context of the call, according to the rules for tag-indeterminate calls (see 3.9.2 and 5.2). In the case where the tag would be statically determined to be that of the formal type, the call raises Program_Error. If such a function is renamed, any call on the renaming raises Program_Error. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"As it states in 6.3.1, the convention of an inherited subprogram of a generic formal tagged type with unknown discriminants is intrinsic.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"In the case of a corresponding primitive of T with no controlling formal parameters, the context of the call provides the controlling tag value for the dispatch. If no tag is provided by context, Program_Error is raised rather than resorting to a nondispatching call. For example:")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"generic","\n","   type NT(","<",">",") is new T with private;","\n",'    -- Assume T has operation "function Empty return T;"',"\n","package G is","\n","   procedure Test(X : in out NT);","\n","end G;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"package body G is","\n","   procedure Test(X : in out NT) is","\n","   begin","\n","      X := Empty;  -- Dispatching based on X'Tag takes","\n","                   -- place if actual is class-wide.","\n","      declare","\n","          Y : NT := Empty;","\n","                   -- If actual is class-wide, this raises Program_Error","\n","                   -- as there is no tag provided by context.","\n","      begin","\n","          X := Y;  -- We never get this far.","\n","      end;","\n","   end Test;","\n","end G;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type T1 is new T with null record;","\n","package I is new G(T1'Class);","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   The actual type can be abstract only if the formal type is abstract (see 3.9.3). ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This is necessary to avoid contract model problems, since one or more of its primitive subprograms are abstract; it is forbidden to create objects of the type, or to declare functions returning the type. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"On the other hand, it is OK to pass a nonabstract actual to an abstract formal - ",(0,a.kt)("strong",null,"abstract")," on the formal indicates that the actual might be abstract. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   If the formal has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),", the actual can be either definite or indefinite. Otherwise, the actual has to be definite. ")),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-83"}),"Incompatibilities With Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Ada 83 does not have ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0060"},"unknown_discriminant_part")),"s, so it allows indefinite subtypes to be passed to definite formals, and applies a legality rule to the instance body. This is a contract model violation. Ada 95 disallows such cases at the point of the instantiation. The workaround is to add (","<",">",") as the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part"))," of any formal subtype if it is intended to be used with indefinite actuals. If that's the intent, then there can't be anything in the generic body that would require a definite subtype.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The check for discriminant subtype matching is changed from a runtime check to a compile-time check. ")),(0,a.kt)("h4",m({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00419-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00443-01"),"}"," A generic formal derived type can include progenitors (interfaces) as well as a primary ancestor. It also may include ",(0,a.kt)("strong",null,"limited")," to indicate that it is a limited type, and ",(0,a.kt)("strong",null,"synchronized")," to indicate that it is a synchronized type. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-95-1"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0038"),"}"," ","{",(0,a.kt)("em",null,"AI95-00202-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Corrected wording to define the operations that are inherited when the ancestor of a formal type is itself a formal type to avoid anomalies.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00158-01"),"}"," Added a semantic description of the meaning of operations of an actual class-wide type, as such a type does not have primitive operations of its own.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," Added a matching rule for access subtypes that exclude null.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00233-01"),"}"," The wording for the declaration of implicit operations is corrected to be consistent with 7.3.1 as modified by Corrigendum 1.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We change to "determines a category" as that is the new terminology (it avoids confusion, since not all interesting properties form a class). ')),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-2005"}),"Incompatibilities With Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0087-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added wording to prevent a limited type from being passed to a nonlimited formal derived type. While this was allowed, it would break the contract for the limited type, so hopefully no programs actually depend on that. ")),(0,a.kt)("h4",m({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0213-1"),"}"," Formal incomplete types are a new kind of generic formal; these can be instantiated with incomplete types and unfrozen private types. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-2005-1"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0029-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Updated the wording to acknowledge the possibility of operations that are never declared for an actual type but still can be used inside of a generic unit.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0071-1"),"}"," ",(0,a.kt)("strong",null,"Correction:"),' Fixed hole that failed to define what happened for "=" for an untagged private type whose actual is class-wide.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0110-1"),"}"," ",(0,a.kt)("strong",null,"Correction:"),' Revised the wording for inheritance of characteristics and operations of formal derived types to be reuse the rules as defined for derived types; this should eliminate holes in the wording which have plagued us since Ada 95 was defined (it has been "corrected" four previous times).')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0237-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added missing rule for the ancestors of formal derived types. The added rule would formally be incompatible, but since it would be impossible to instantiate any such generic, this cannot happen outside of test suites and thus is not documented as an incompatibility. ")),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0036-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Added a requirement that a tagged type only match a formal derived type that is a private extension. This is necessary to prevent type conversions that would not be allowed outside of the generic. We expect that this will be rare, as it only can happen if the formal derived type does not accurately describe the actual type; in most such cases, extension will be desired and a private extension used so that is allowed.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0351-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," The predicates of an ancestor subtype are considered part of the contract for a formal derived type, even if the ancestor subtype is unconstrained. This means, for instance, if the ancestor subtype is a subtype of Float with a predicate, then an actual subtype with a different predicate is illegal in Ada 2022 while it would have been allowed in Ada 2012. Cases like this are quite unlikely and will be detected at compile-time if they occur. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0095-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," The assume the worst rule for determining within a generic body whether a type is unconstrained in any partial view was moved here. While AI05-0041-1 added it to 3.10.2, it's also needed (at least) in 4.6 and 6.4.1. Thus, it was moved here so that it applies generally. ")),(0,a.kt)("h2",m({},{id:"1252--formal-scalar-types"}),"12.5.2  Formal Scalar Types"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," A ",(0,a.kt)("em",null,"formal scalar type")," is one defined by any of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.5#S0323"},"formal_type_definition")),"s in this subclause. [The category determined for a formal scalar type is the category of all discrete, signed integer, modular, floating point, ordinary fixed point, or decimal types.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," The second rule follows from the rule in 12.5 that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' The "category of a type" includes any classes that the type belongs to. ')),(0,a.kt)("h4",m({},{id:"syntax-2"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_discrete_type_definition"),(0,a.kt)("a",{id:"S0326"}),(0,a.kt)("code",null," ::= "),"(","<",">",")"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_signed_integer_type_definition"),(0,a.kt)("a",{id:"S0327"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"range")," ","<",">"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_modular_type_definition"),(0,a.kt)("a",{id:"S0328"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"mod")," ","<",">"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_floating_point_definition"),(0,a.kt)("a",{id:"S0329"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"digits")," ","<",">"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_ordinary_fixed_point_definition"),(0,a.kt)("a",{id:"S0330"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"delta")," ","<",">"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_decimal_fixed_point_definition"),(0,a.kt)("a",{id:"S0331"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"delta")," ","<",">"," ",(0,a.kt)("strong",null,"digits")," ","<",">"),(0,a.kt)("h4",m({},{id:"legality-rules-3"}),"Legality Rules"),(0,a.kt)("p",null,"The actual type for a formal scalar type shall not be a nonstandard numeric type. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This restriction is necessary because nonstandard numeric types have some number of restrictions on their use, which could cause contract model problems in a generic body. Note that nonstandard numeric types can be passed to formal derived and formal private subtypes, assuming they obey all the other rules, and assuming the implementation allows it (being nonstandard means the implementation might disallow anything). ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-95-2"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We change to "determines a category" as that is the new terminology (it avoids confusion, since not all interesting properties form a class). ')),(0,a.kt)("h2",m({},{id:"1253--formal-array-types"}),"12.5.3  Formal Array Types"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," [The category determined for a formal array type is the category of all array types.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," This rule follows from the rule in 12.5 that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. ")),(0,a.kt)("h4",m({},{id:"syntax-3"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_array_type_definition"),(0,a.kt)("a",{id:"S0332"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition"))),(0,a.kt)("h4",m({},{id:"legality-rules-4"}),"Legality Rules"),(0,a.kt)("p",null,"The only form of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," that is allowed within the declaration of a generic formal (constrained) array subtype is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),". "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"The reason is the same as for forbidding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0029"},"constraint")),"s in ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),"s (see 12.1). ")),(0,a.kt)("p",null,"For a formal array subtype, the actual subtype shall satisfy the following conditions: "),(0,a.kt)("p",null,"The formal array type and the actual array type shall have the same dimensionality; the formal subtype and the actual subtype shall be either both constrained or both unconstrained."),(0,a.kt)("p",null,"For each index position, the index types shall be the same, and the index subtypes (if unconstrained), or the index ranges (if constrained), shall statically match (see 4.9.1). "),(0,a.kt)("p",null,"The component subtypes of the formal and actual array types shall statically match. "),(0,a.kt)("p",null,"If the formal type has aliased components, then so shall the actual. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"On the other hand, if the formal's components are not aliased, then the actual's components can be either aliased or not. ")),(0,a.kt)("h4",m({},{id:"examples-1"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of formal array types:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  given the generic package ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"generic","\n","   type Item   is private;","\n","   type Index  is (","<",">",");","\n","   type Vector is array (Index range ","<",">",") of Item;","\n","   type Table  is array (Index) of Item;","\n","package P is","\n","   ...","\n","end P;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  and the types ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Mix    is array (Color range ","<",">",") of Boolean;","\n","type Option is array (Color) of Boolean;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  then Mix can match Vector and Option can match Table ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"package R is new P(Item   =",">"," Boolean, Index =",">"," Color,","\n","                   Vector =",">"," Mix,     Table =",">"," Option);","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  Note that Mix cannot match Table and Option cannot match Vector","\n"),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-83-1"}),"Incompatibilities With Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The check for matching of component subtypes and index subtypes or index ranges is changed from a runtime check to a compile-time check. The Ada 83 rule that "If the component type is not a scalar type, then the component subtypes shall be either both constrained or both unconstrained" is removed, since it is subsumed by static matching. Likewise, the rules requiring that component types be the same is subsumed. ')),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-95-3"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We change to "determines a category" as that is the new terminology (it avoids confusion, since not all interesting properties form a class). ')),(0,a.kt)("h2",m({},{id:"1254--formal-access-types"}),"12.5.4  Formal Access Types"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," [The category determined for a formal access type is the category of all access types.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," This rule follows from the rule in 12.5 that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. ")),(0,a.kt)("h4",m({},{id:"syntax-4"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"formal_access_type_definition"),(0,a.kt)("a",{id:"S0333"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0079"},"access_type_definition"))),(0,a.kt)("h4",m({},{id:"legality-rules-5"}),"Legality Rules"),(0,a.kt)("p",null,"For a formal access-to-object type, the designated subtypes of the formal and actual types shall statically match. "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," If and only if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0081"},"general_access_modifier"))," ",(0,a.kt)("strong",null,"constant")," applies to the formal, the actual shall be an access-to-constant type. If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0081"},"general_access_modifier"))," ",(0,a.kt)("strong",null,"all")," applies to the formal, then the actual shall be a general access-to-variable type (see 3.10). If and only if the formal subtype excludes null, the actual subtype shall exclude null. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"If no ",(0,a.kt)("code",null,"_modifier")," applies to the formal, then the actual type may be either a pool-specific or a general access-to-variable type. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"8652/0109"),"}"," ","{",(0,a.kt)("em",null,"AI95-00025-01"),"}"," Matching an access-to-variable to a formal access-to-constant type cannot be allowed. If it were allowed, it would be possible to create an access-to-variable value designating a constant.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}",' We require that the "excludes null" property match, because it would be difficult to write a correct generic for a formal access type without knowing this property. Many typical algorithms and techniques will not work for a subtype that excludes null (setting an unused component to ',(0,a.kt)("strong",null,"null"),", default-initialized objects, and so on). Even Ada.Unchecked_Deallocation would fail for a subtype that excludes null. Most generics would end up with comments saying that they are not intended to work for subtypes that exclude null. We would rather that this sort of requirement be reflected in the contract of the generic. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0239-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0288-1"),"}"," For a formal access-to-subprogram subtype, the designated profiles of the formal and the actual shall be subtype conformant. "),(0,a.kt)("h4",m({},{id:"examples-2"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of formal access types:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  the formal types of the generic package ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"generic","\n","   type Node is private;","\n","   type Link is access Node;","\n","package P is","\n","   ...","\n","end P;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  can be matched by the actual types ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Car;","\n","type Car_Name is access Car;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"type Car is","\n","   record","\n","      Pred, Succ : Car_Name;","\n","      Number     : License_Number;","\n","      Owner      : Person;","\n","   end record;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"--  in the following generic instantiation ","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"package R is new P(Node =",">"," Car, Link =",">"," Car_Name);","\n"),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-83-2"}),"Incompatibilities With Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The check for matching of designated subtypes is changed from a runtime check to a compile-time check. The Ada 83 rule that "If the designated type is other than a scalar type, then the designated subtypes shall be either both constrained or both unconstrained" is removed, since it is subsumed by static matching. ')),(0,a.kt)("h4",m({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Formal access-to-subprogram subtypes and formal general access types are new concepts. ")),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-95-4"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," Added a matching rule for subtypes that exclude null.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00442-01"),"}",' We change to "determines a category" as that is the new terminology (it avoids confusion, since not all interesting properties form a class). ')),(0,a.kt)("h4",m({},{id:"incompatibilities-with-ada-2005-1"}),"Incompatibilities With Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0288-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Matching of formal access-to-subprogram types now uses subtype conformance rather than mode conformance, which is needed to plug a hole. This could cause some instantiations legal in Ada 95 and Ada 2005 to be rejected in Ada 2012. We believe that formal access-to-subprogram types occur rarely, and actuals that are not subtype conformant are rarer still, so this should not happen often. (In addition, one popular compiler has a bug that causes such instances to be rejected, so no code compiled with that compiler could have an incompatibility.) ")),(0,a.kt)("h2",m({},{id:"1255--formal-interface-types"}),"12.5.5  Formal Interface Types"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," [The category determined for a formal interface type is the category of all interface types.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," This rule follows from the rule in 12.5 that says that the category is determined by the one given in the name of the syntax production. The effect of the rule is repeated here to give a capsule summary of what this subclause is about. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),'Here we\'re taking advantage of our switch in terminology from "determined class" to "determined category"; by saying "category" rather than "class", we require that any actual type be an interface type, not just some type derived from an interface type. ')),(0,a.kt)("h4",m({},{id:"syntax-5"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ",(0,a.kt)("code",null,"formal_interface_type_definition"),(0,a.kt)("a",{id:"S0334"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.9#S0077"},"interface_type_definition"))),(0,a.kt)("h4",m({},{id:"legality-rules-6"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251"),"}"," ","{",(0,a.kt)("em",null,"AI95-00401"),"}"," The actual type shall be a descendant of every progenitor of the formal type."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00345"),"}"," The actual type shall be a limited, task, protected, or synchronized interface if and only if the formal type is also, respectively, a limited, task, protected, or synchronized interface. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"We require the kind of interface type to match exactly because without that it is almost impossible to properly implement the interface. ")),(0,a.kt)("h4",m({},{id:"examples-3"}),"Examples"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0429-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," ",(0,a.kt)("em",null,"Example of the use of a generic with a formal interface type, to establish a standard interface that all tasks will implement so they can be managed appropriately by an application-specific scheduler:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00433-01","}"," type Root_Work_Item is tagged private;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00433-01","}"," generic","\n","   type Managed_Task is task interface;","\n","   type Work_Item(","<",">",") is new Root_Work_Item with private;","\n","package Server_Manager is","\n","   task type Server is new Managed_Task with","\n","      entry Start(Data : in out Work_Item);","\n","   end Server;","\n","end Server_Manager;","\n"),(0,a.kt)("h4",m({},{id:"extensions-to-ada-95-1"}),"Extensions to Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00345-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00401-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00442-01"),"}"," The formal interface type is new. ")))}b.isMDXComponent=!0}}]);