"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6907],{54472:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>A,contentTitle:()=>b,default:()=>x,frontMatter:()=>k,metadata:()=>f,toc:()=>g});var n=a(91716),i=a(21256),o=a(24895),r=a(48424),l=a(82262),s=Object.defineProperty,m=Object.defineProperties,p=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,h=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,y=(e,t)=>{for(var a in t||(t={}))u.call(t,a)&&h(e,a,t[a]);if(d)for(var a of d(t))c.call(t,a)&&h(e,a,t[a]);return e};const k={sidebar_position:186},b="H.1 Pragma Normalize_Scalars",f={unversionedId:"arm/AA-H/AA-H.1",id:"arm/AA-H/AA-H.1",title:"H.1 Pragma Normalize_Scalars",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-H/AA-H.1.mdx",sourceDirName:"arm/AA-H",slug:"/arm/AA-H/AA-H.1",permalink:"/docs/arm/AA-H/AA-H.1",draft:!1,tags:[],version:"current",sidebarPosition:186,frontMatter:{sidebar_position:186},sidebar:"referenceManualSidebar",previous:{title:"Annex H High Integrity Systems",permalink:"/docs/arm/AA-H/"},next:{title:"H.2 Documentation of Implementation Decisions",permalink:"/docs/arm/AA-H/AA-H.2"}},A={},g=[{value:"Syntax",id:"syntax",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4}],T={toc:g};function x(e){var t,a=e,{components:s}=a,h=((e,t)=>{var a={};for(var n in e)u.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&d)for(var n of d(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=y(y({},T),h),m(t,p({components:s,mdxType:"MDXLayout"}))),(0,n.kt)("h1",y({},{id:"h1-pragma-normalize_scalars"}),"H.1 Pragma Normalize_Scalars"),(0,n.kt)("admonition",y({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.kt)("a",y({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)(r.Z,{mdxType:"MarginText"},"1"),(0,n.kt)("p",null,"This pragma ensures that an otherwise uninitialized scalar object is set to a predictable value, but out of range if possible. ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"1.a"),(0,n.kt)(i.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,n.kt)("strong",null),"The goal of the pragma is to reduce the impact of a bounded error that results from a reference to an uninitialized scalar object, by having such a reference violate a range check and thus raise Constraint_Error. ",(0,n.kt)("br",null))),(0,n.kt)("h4",y({},{id:"syntax"}),"Syntax"),(0,n.kt)(r.Z,{mdxType:"MarginText"},"2"),(0,n.kt)("p",null,"The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Normalize_Scalars is as follows: ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{mdxType:"MarginText"},"3"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Normalize_Scalars; ",(0,n.kt)("br",null)),(0,n.kt)("h4",y({},{id:"post-compilation-rules"}),"Post-Compilation Rules"),(0,n.kt)(r.Z,{mdxType:"MarginText"},"4"),(0,n.kt)("p",null,"Pragma Normalize_Scalars is a configuration pragma. It applies to all ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0286"},"compilation_unit")),"s included in a partition. ",(0,n.kt)("br",null)),(0,n.kt)("h4",y({},{id:"documentation-requirements"}),"Documentation Requirements"),(0,n.kt)(r.Z,{mdxType:"MarginText"},"5/2"),(0,n.kt)(l.Z,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,n.kt)("p",null,"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Normalize_Scalars applies, the implementation shall document the implicit initial values for scalar subtypes, and shall identify each case in which such a value is used and is not an invalid representation. ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"5.a/2"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,n.kt)("strong",null,"Documentation Requirement: "),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Normalize_Scalars applies, the implicit initial values of scalar subtypes shall be documented. Such a value should be an invalid representation when possible; any cases when is it not shall be documented.",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"5.b"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,n.kt)("strong",null,"To be honest: "),"It's slightly inaccurate to say that the value is a representation, but the point should be clear anyway. ",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"5.c"),(0,n.kt)(i.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,n.kt)("strong",null),"By providing a type with a size specification so that spare bits are present, it is possible to force an implementation of Normalize_Scalars to use an out of range value. This can be tested for by ensuring that Constraint_Error is raised. Similarly, for an unconstrained integer type, in which no spare bit is surely present, one can check that the initialization takes place to the value specified in the documentation of the implementation. For a floating point type, spare bits might not be available, but a range constraint can provide the ability to use an out of range value.",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"5.d"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"If it is difficult to document the general rule for the implicit initial value, the implementation might choose instead to record the value on the object code listing or similar output produced during compilation.",(0,n.kt)("br",null))),(0,n.kt)("h4",y({},{id:"implementation-advice"}),"Implementation Advice"),(0,n.kt)(r.Z,{mdxType:"MarginText"},"6/2"),(0,n.kt)(l.Z,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,n.kt)("p",null,"Whenever possible, the implicit initial values for a scalar subtype should be an invalid representation (see ",(0,n.kt)("a",{href:"../AA-13/AA-13.9#Subclause_13.9.1"},"13.9.1"),"). ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"6.a"),(0,n.kt)(i.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,n.kt)("strong",null),"When an out of range value is used for the initialization, it is likely that constraint checks will detect it. In addition, it can be detected by the Valid attribute.",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"6.b/2"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This rule is included in the documentation requirements, and thus does not need a separate summary item.",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"7"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   The initialization requirement applies to uninitialized scalar objects that are subcomponents of composite objects, to allocated objects, and to stand-alone objects. It also applies to scalar ",(0,n.kt)("strong",null,"out")," parameters. Scalar subcomponents of composite ",(0,n.kt)("strong",null,"out")," parameters are initialized to the corresponding part of the actual, by virtue of ",(0,n.kt)("a",{href:"../AA-6/AA-6.4#Subclause_6.4.1"},"6.4.1"),".",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"8"),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   The initialization requirement does not apply to a scalar for which pragma Import has been specified, since initialization of an imported object is performed solely by the foreign language environment (see ",(0,n.kt)("a",{href:"../AA-B/AA-B.1"},"B.1"),").",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"9/5"),(0,n.kt)(l.Z,{items:["AI12-0440-1"],mdxType:"MarginInfo"}),(0,n.kt)(i.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   The use of pragma Normalize_Scalars in conjunction with Pragma Restrictions(No_Exceptions) can  result in erroneous execution (see ",(0,n.kt)("a",{href:"../AA-H/AA-H.4"},"H.4"),"). ",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{mdxType:"AnnotatedOnly"},(0,n.kt)(r.Z,{mdxType:"MarginText"},"9.a"),(0,n.kt)(i.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,n.kt)("strong",null),"Since the effect of an access to an out of range value will often be to raise Constraint_Error, it is clear that suppressing the exception mechanism could result in erroneous execution. In particular, the assignment to an array, with the array index out of range, will result in a write to an arbitrary store location, having unpredictable effects.",(0,n.kt)("br",null))))}x.isMDXComponent=!0}}]);