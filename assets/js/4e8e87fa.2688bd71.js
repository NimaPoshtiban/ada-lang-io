"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2591],{68525:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var t=a(58168),i=(a(96540),a(15680));const r={title:"8.2 Robustness"},s=void 0,o={unversionedId:"style-guide/s8/02",id:"style-guide/s8/02",title:"8.2 Robustness",description:"The following guidelines improve the robustness of Ada code. It is easy",source:"@site/docs/style-guide/s8/02.mdx",sourceDirName:"style-guide/s8",slug:"/style-guide/s8/02",permalink:"/docs/style-guide/s8/02",draft:!1,tags:[],version:"current",frontMatter:{title:"8.2 Robustness"},sidebar:"styleGuideSidebar",previous:{title:"8.1 Understanding and Clarity",permalink:"/docs/style-guide/s8/01"},next:{title:"8.3 Adaptability",permalink:"/docs/style-guide/s8/03"}},l={},u=[{value:"Named Numbers",id:"named-numbers",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Unconstrained Arrays",id:"unconstrained-arrays",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Minimizing and Documenting Assumptions",id:"minimizing-and-documenting-assumptions",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes",level:4},{value:"Subtypes in Generic Specifications",id:"subtypes-in-generic-specifications",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-1",level:4},{value:"Overloading in Generic Units",id:"overloading-in-generic-units",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Hidden Tasks",id:"hidden-tasks",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"Exceptions",id:"exceptions",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-2",level:4}],c={toc:u},d="wrapper";function p(e){let{components:n,...a}=e;return(0,i.yg)(d,(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"The following guidelines improve the robustness of Ada code. It is easy\nto write code that depends on an assumption that you do not realize that\nyou are making. When such a part is reused in a different environment,\nit can break unexpectedly. The guidelines in this section show some ways\nin which Ada code can be made to automatically conform to its\nenvironment and some ways in which it can be made to check for\nviolations of assumptions. Finally, some guidelines are given to warn\nyou about errors that Ada does not catch as soon as you might like."),(0,i.yg)("h3",{id:"named-numbers"},"Named Numbers"),(0,i.yg)("h4",{id:"guideline"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use named numbers and static expressions to allow multiple\ndependencies to be linked to a small number of symbols.")),(0,i.yg)("h4",{id:"example"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\nprocedure Disk_Driver is\n   -- In this procedure, a number of important disk parameters are\n   -- linked.\n   Number_Of_Sectors  : constant :=     4;\n   Number_Of_Tracks   : constant :=   200;\n   Number_Of_Surfaces : constant :=    18;\n   Sector_Capacity    : constant := 4_096;\n   Track_Capacity   : constant := Number_Of_Sectors  * Sector_Capacity;\n   Surface_Capacity : constant := Number_Of_Tracks   * Track_Capacity;\n   Disk_Capacity    : constant := Number_Of_Surfaces * Surface_Capacity;\n   type Sector_Range  is range 1 .. Number_Of_Sectors;\n   type Track_Range   is range 1 .. Number_Of_Tracks;\n   type Surface_Range is range 1 .. Number_Of_Surfaces;\n   type Track_Map   is array (Sector_Range)  of ...;\n   type Surface_Map is array (Track_Range)   of Track_Map;\n   type Disk_Map    is array (Surface_Range) of Surface_Map;\nbegin  -- Disk_Driver\n   ...\nend Disk_Driver;\n------------------------------------------------------------------------\n")),(0,i.yg)("h4",{id:"rationale"},"rationale"),(0,i.yg)("p",null,"To reuse software that uses named numbers and static expressions\nappropriately, just one or a small number of constants need to be reset,\nand all declarations and associated code are changed automatically.\nApart from easing reuse, this reduces the number of opportunities for\nerror and documents the meanings of the types and constants without\nusing error-prone comments."),(0,i.yg)("h3",{id:"unconstrained-arrays"},"Unconstrained Arrays"),(0,i.yg)("h4",{id:"guideline-1"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use unconstrained array types for array formal parameters and array\nreturn values."),(0,i.yg)("li",{parentName:"ul"},"Make the size of local variables depend on actual parameter size,\nwhere appropriate.")),(0,i.yg)("h4",{id:"example-1"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   ...\n   type Vector is array (Vector_Index range <>) of Element;\n   type Matrix is array\n           (Vector_Index range <>, Vector_Index range <>) of Element;\n   ...\n   ---------------------------------------------------------------------\n   procedure Matrix_Operation (Data : in     Matrix) is\n      Workspace   : Matrix (Data'Range(1), Data'Range(2));\n      Temp_Vector : Vector (Data'First(1) .. 2 * Data'Last(1));\n   ...\n   ---------------------------------------------------------------------\n")),(0,i.yg)("h4",{id:"rationale-1"},"rationale"),(0,i.yg)("p",null,"Unconstrained arrays can be declared with their sizes dependent on\nformal parameter sizes. When used as local variables, their sizes change\nautomatically with the supplied actual parameters. This facility can be\nused to assist in the adaptation of a part because necessary size\nchanges in local variables are taken care of automatically."),(0,i.yg)("h3",{id:"minimizing-and-documenting-assumptions"},"Minimizing and Documenting Assumptions"),(0,i.yg)("h4",{id:"guideline-2"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Minimize the number of assumptions made by a unit."),(0,i.yg)("li",{parentName:"ul"},"For assumptions that cannot be avoided, use subtypes or constraints\nto automatically enforce conformance."),(0,i.yg)("li",{parentName:"ul"},"For assumptions that cannot be automatically enforced by subtypes,\nadd explicit checks to the code."),(0,i.yg)("li",{parentName:"ul"},"Document all assumptions."),(0,i.yg)("li",{parentName:"ul"},"If the code depends upon the implementation of a specific Special\nNeeds Annex for proper operation, document this assumption in the\ncode.")),(0,i.yg)("h4",{id:"example-2"},"example"),(0,i.yg)("p",null,"The following poorly written function documents but does not check its\nassumption:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   -- Assumption:  BCD value is less than 4 digits.\n   function Binary_To_BCD (Binary_Value : in     Natural)\n     return BCD;\n")),(0,i.yg)("p",null,"The next example enforces conformance with its assumption, making the\nchecking automatic and the comment unnecessary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   subtype Binary_Values is Natural range 0 .. 9_999;\n   function Binary_To_BCD (Binary_Value : in     Binary_Values)\n     return BCD;\n")),(0,i.yg)("p",null,"The next example explicitly checks and documents its assumption:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   ---------------------------------------------------------------------\n   -- Out_Of_Range raised when BCD value exceeds 4  digits.\n   function Binary_To_BCD (Binary_Value : in     Natural)\n     return BCD is\n      Maximum_Representable : constant Natural := 9_999;\n   begin  -- Binary_To_BCD\n      if Binary_Value > Maximum_Representable then\n         raise Out_Of_Range;\n      end if;\n      ...\n   end Binary_To_BCD;\n   ---------------------------------------------------------------------\n")),(0,i.yg)("h4",{id:"rationale-2"},"rationale"),(0,i.yg)("p",null,"Any part that is intended to be used again in another program,\nespecially if the other program is likely to be written by other people,\nshould be robust. It should defend itself against misuse by defining its\ninterface to enforce as many assumptions as possible and by adding\nexplicit defensive checks on anything that cannot be enforced by the\ninterface. By documenting dependencies on a Special Needs Annex, you\nwarn the user that he should only reuse the component in a compilation\nenvironment that provides the necessary support."),(0,i.yg)("h4",{id:"notes"},"notes"),(0,i.yg)("p",null,"You can restrict the ranges of values of the inputs by careful selection\nor construction of the subtypes of the formal parameters. When you do\nso, the compiler-generated checking code may be more efficient than any\nchecks you might write. Indeed, such checking is part of the intent of\nthe strong typing in the language. This presents a challenge, however,\nfor generic units where the user of your code selects the types of the\nparameters. Your code must be constructed to deal with any value of any\nsubtype the user may choose to select for an instantiation."),(0,i.yg)("h3",{id:"subtypes-in-generic-specifications"},"Subtypes in Generic Specifications"),(0,i.yg)("h4",{id:"guideline-3"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use first subtypes when declaring generic formal objects of mode in\nout."),(0,i.yg)("li",{parentName:"ul"},"Beware of using subtypes as subtype marks when declaring parameters\nor return values of generic formal subprograms."),(0,i.yg)("li",{parentName:"ul"},"Use attributes rather than literal values.")),(0,i.yg)("h4",{id:"example-3"},"example"),(0,i.yg)("p",null,"In the following example, it appears that any value supplied for the\ngeneric formal object Object would be constrained to the range 1..10. It\nalso appears that parameters passed at run-time to the Put routine in\nany instantiation and values returned by the Get routine would be\nsimilarly constrained:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   subtype Range_1_10 is Integer range 1 .. 10;\n   ---------------------------------------------------------------------\n   generic\n      Object : in out Range_1_10;\n      with procedure Put (Parameter : in     Range_1_10);\n      with function  Get return Range_1_10;\n   package Input_Output is\n      ...\n   end Input_Output;\n   ---------------------------------------------------------------------\n")),(0,i.yg)("p",null,"However, this is not the case. Given the following legal instantiation:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"   subtype Range_15_30 is Integer range 15 .. 30;\n   Constrained_Object : Range_15_30 := 15;\n   procedure Constrained_Put (Parameter : in     Range_15_30);\n   function  Constrained_Get return Range_15_30;\n   package Constrained_Input_Output is\n      new Input_Output (Object => Constrained_Object,\n                        Put    => Constrained_Put,\n                        Get    => Constrained_Get);\n   ...\n")),(0,i.yg)("p",null,"Object, Parameter, and the return value of Get are constrained to the\nrange 15..30. Thus, for example, if the body of the generic package\ncontains an assignment statement:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"Object := 1;\n")),(0,i.yg)("p",null,"Constraint_Error is raised when this instantiation is executed."),(0,i.yg)("h4",{id:"rationale-3"},"rationale"),(0,i.yg)("p",null,'The language specifies that when constraint checking is performed for\ngeneric formal objects and parameters and return values of generic\nformal subprograms, the constraints of the actual subtype (not the\nformal subtype) are enforced (Ada Reference Manual 1995, \xa7\xa712.4"',">"," and\n12.6).Thus, the subtype specified in a formal in out object parameter\nand the subtypes specified in the profile of a formal subprogram need\nnot match those of the actual object or subprogram."),(0,i.yg)("p",null,"Thus, even with a generic unit that has been instantiated and tested\nmany times and with an instantiation that reported no errors at\ninstantiation time, there can be a run-time error. Because the subtype\nconstraints of the generic formal are ignored, the Ada Reference Manual\n(1995, \xa7\xa712.4 and 12.6) suggests using the name of a base type in such\nplaces to avoid confusion. Even so, you must be careful not to assume\nthe freedom to use any value of the base type because the instantiation\nimposes the subtype constraints of the generic actual parameter. To be\nsafe, always refer to specific values of the type via symbolic\nexpressions containing attributes like 'First, 'Last, 'Pred, and 'Succ\nrather than via literal values."),(0,i.yg)("p",null,"For generics, attributes provide the means to maintain generality. It is\npossible to use literal values, but literals run the risk of violating\nsome constraint. For example, assuming that an array's index starts at 1\nmay cause a problem when the generic is instantiated for a zero-based\narray type."),(0,i.yg)("h4",{id:"notes-1"},"notes"),(0,i.yg)("p",null,"Adding a generic formal parameter that defines the subtype of the\ngeneric formal object does not address the ramifications of the\nconstraint checking rule discussed in the above rationale. You can\ninstantiate the generic formal type with any allowable subtype, and you\nare not guaranteed that this subtype is the first subtype:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Object_Range is range <>;\n   Objects : in out Object_Range;\n   ...\npackage X is\n   ...\nend X;\n")),(0,i.yg)("p",null,"You can instantiate the subtype Object_Range with any Integer subtype,\nfor example, Positive. However, the actual variable Object can be of\nPositive'Base, i.e., Integer and its value are not guaranteed to be\ngreater than 0."),(0,i.yg)("h3",{id:"overloading-in-generic-units"},"Overloading in Generic Units"),(0,i.yg)("h4",{id:"guideline-4"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Be careful about overloading the names of subprograms exported by\nthe same generic package.")),(0,i.yg)("h4",{id:"example-4"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\ngeneric\n   type Item is limited private;\npackage Input_Output is\n   procedure Put (Value : in     Integer);\n   procedure Put (Value : in     Item);\nend Input_Output;\n------------------------------------------------------------------------\n")),(0,i.yg)("h4",{id:"rationale-4"},"rationale"),(0,i.yg)("p",null,"If the generic package shown in the example above is instantiated with\nInteger (or any subtype of Integer) as the actual type corresponding to\ngeneric formal Item, then the two Put procedures have identical\ninterfaces, and all calls to Put are ambiguous. Therefore, this package\ncannot be used with type Integer. In such a case, it is better to give\nunambiguous names to all subprograms. See the Ada Reference Manual\n(1995, \xa712.3) for more information."),(0,i.yg)("h3",{id:"hidden-tasks"},"Hidden Tasks"),(0,i.yg)("h4",{id:"guideline-5"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Within a specification , document any tasks that would be activated\nby with'ing the specification and by using any part of the\nspecification."),(0,i.yg)("li",{parentName:"ul"},"Document which generic formal parameters are accessed from a task\nhidden inside the generic unit."),(0,i.yg)("li",{parentName:"ul"},"Document any multithreaded components.")),(0,i.yg)("h4",{id:"rationale-5"},"rationale"),(0,i.yg)("p",null,"The effects of tasking become a major factor when reusable code enters\nthe domain of real-time systems. Even though tasks may be used for other\npurposes, their effect on scheduling algorithms is still a concern and\nmust be clearly documented. With the task clearly documented, the\nreal-time programmer can then analyze performance, priorities, and so\nforth to meet timing requirements, or, if necessary, he can modify or\neven redesign the component."),(0,i.yg)("p",null,"Concurrent access to datastructures must be carefully planned to avoid\nerrors, especially for data structures that are not atomic (see Chapter\n6 for details). If a generic unit accesses one of its generic formal\nparameters (reads or writes the value of a generic formal object or\ncalls a generic formal subprogram that reads or writes data) from within\na task contained in the generic unit, then there is the possibility of\nconcurrent access for which the user may not have planned. In such a\ncase, the user should be warned by a comment in the generic\nspecification."),(0,i.yg)("h3",{id:"exceptions"},"Exceptions"),(0,i.yg)("h4",{id:"guideline-6"},"guideline"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Propagate exceptions out of reusable parts. Handle exceptions within\nreusable parts only when you are certain that the handling is\nappropriate in all circumstances."),(0,i.yg)("li",{parentName:"ul"},"Propagate exceptions raised by generic formal subprograms after\nperforming any cleanup necessary to the correct operation of future\ninvocations of the generic instantiation."),(0,i.yg)("li",{parentName:"ul"},"Leave state variables in a valid state when raising an exception."),(0,i.yg)("li",{parentName:"ul"},"Leave parameters unmodified when raising an exception.")),(0,i.yg)("h4",{id:"example-5"},"example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\ngeneric\n   type Number is limited private;\n   with procedure Get (Value :    out Number);\nprocedure Process_Numbers;\n\n------------------------------------------------------------------------\nprocedure Process_Numbers is\n   Local : Number;\n   procedure Perform_Cleanup_Necessary_For_Process_Numbers is separate;\n   ...\nbegin  -- Process_Numbers\n   ...\n   Catch_Exceptions_Generated_By_Get:\n      begin\n         Get (Local);\n      exception\n         when others =>\n            Perform_Cleanup_Necessary_For_Process_Numbers;\n            raise;\n      end Catch_Exceptions_Generated_By_Get;\n   ...\nend Process_Numbers;\n------------------------------------------------------------------------\n")),(0,i.yg)("h4",{id:"rationale-6"},"rationale"),(0,i.yg)("p",null,"On most occasions, an exception is raised because an undesired event\n(such as floating-point overflow) has occurred. Such events often need\nto be dealt with entirely differently with different uses of a\nparticular software part. It is very difficult to anticipate all the\nways that users of the part may wish to have the exceptions handled.\nPassing the exception out of the part is the safest treatment."),(0,i.yg)("p",null,"In particular, when an exception is raised by a generic formal\nsubprogram, the generic unit is in no position to understand why or to\nknow what corrective action to take. Therefore, such exceptions should\nalways be propagated back to the caller of the generic instantiation.\nHowever, the generic unit must first clean up after itself, restoring\nits internal data structures to a correct state so that future calls may\nbe made to it after the caller has dealt with the current exception. For\nthis reason, all calls to generic formal subprograms should be within\nthe scope of a when others exception handler if the internal state is\nmodified, as shown in the example above."),(0,i.yg)("p",null,"When a reusable part is invoked, the user of the part should be able to\nknow exactly what operation (at the appropriate level of abstraction)\nhas been performed. For this to be possible, a reusable part must always\ndo all or none of its specified function; it must never do half.\nTherefore, any reusable part that terminates early by raising or\npropagating an exception should return to the caller with no effect on\nthe internal or external state. The easiest way to do this is to test\nfor all possible exceptional conditions before making any state changes\n(modifying internal state variables, making calls to other reusable\nparts to modify their states, updating files, etc.). When this is not\npossible, it is best to restore all internal and external states to the\nvalues that were current when the part was invoked before raising or\npropagating the exception. Even when this is not possible, it is\nimportant to document this potentially hazardous situation in the\ncomment header of the specification of the part."),(0,i.yg)("p",null,'A similar problem arises with parameters of mode out or in out when\nexceptions are raised. The Ada language distinguishes between "by-copy"\nand "by-reference" parameter passing. In some cases, "by-copy" is\nrequired; in other cases, "by-reference" is required; and in the\nremaining cases, either mechanism is allowed. The potential problem\narises in those cases where the language does not specify the parameter\npassing mechanism to use. When an exception is raised, the copy-back\ndoes not occur, but for an Ada compiler, which passes parameters by\nreference (in those cases where a choice is allowed), the actual\nparameter has already been updated. When parameters are passed by copy,\nthe update does not occur. To reduce ambiguity, increase portability,\nand avoid situations where some but not all of the actual parameters are\nupdated when an exception is raised, it is best to treat values of out\nand in out parameters like state variables, updating them only after it\nis certain that no exception will be raised. See also Guideline 7.1.8.'),(0,i.yg)("h4",{id:"notes-2"},"notes"),(0,i.yg)("p",null,"A reusable part could range from a low-level building block (e.g., data\nstructure, sorting algorithm, math function) to a large reusable\nsubsystem. The lower level the building block, the less likely that the\nreusable part will know how to handle exceptions or produce meaningful\nresults. Thus, the low-level parts should propagate exceptions. A large\nreusable subsystem, however, should be able to handle any anticipated\nexceptions independently of the variations across which it is reused."))}p.isMDXComponent=!0}}]);