"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5987],{1914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>h,default:()=>f,frontMatter:()=>p,metadata:()=>m,toc:()=>g});var a=n(1716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,c=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&c(e,n,t[n]);if(s)for(var n of s(t))d.call(t,n)&&c(e,n,t[n]);return e};const p={title:"Concurrency",sidebar_position:6},h=void 0,m={unversionedId:"style-guide/Concurrency",id:"style-guide/Concurrency",title:"Concurrency",description:"Concurrency exists as either apparent concurrency or real concurrency.",source:"@site/docs/style-guide/Concurrency.mdx",sourceDirName:"style-guide",slug:"/style-guide/Concurrency",permalink:"/docs/style-guide/Concurrency",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Concurrency",sidebar_position:6},sidebar:"styleGuideSidebar",previous:{title:"Programming Practices",permalink:"/docs/style-guide/Programming_Practices"},next:{title:"Portability",permalink:"/docs/style-guide/Portability"}},k={},g=[{value:"Concurrency Options",id:"concurrency-options",level:2},{value:"Protected Objects",id:"protected-objects",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Tasks",id:"tasks",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Discriminants",id:"discriminants",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes",level:4},{value:"Anonymous Task Types and Protected Types",id:"anonymous-task-types-and-protected-types",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-1",level:4},{value:"Dynamic Tasks",id:"dynamic-tasks",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Priorities",id:"priorities",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4},{value:"Delay Statements",id:"delay-statements",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-3",level:4},{value:"Extensibility and Concurrent Structures",id:"extensibility-and-concurrent-structures",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"notes",id:"notes-4",level:4},{value:"Communication",id:"communication",level:2},{value:"Efficient Task Communication",id:"efficient-task-communication",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"notes",id:"notes-5",level:4},{value:"Defensive Task Communication",id:"defensive-task-communication",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"notes",id:"notes-6",level:4},{value:"Attributes &#39;Count, &#39;Callable, and &#39;Terminated",id:"attributes-count-callable-and-terminated",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"Unprotected Shared Variables",id:"unprotected-shared-variables",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Selective Accepts and Entry Calls",id:"selective-accepts-and-entry-calls",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"Communication Complexity",id:"communication-complexity",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"notes",id:"notes-7",level:4},{value:"Termination",id:"termination",level:2},{value:"Avoiding Undesired Termination",id:"avoiding-undesired-termination",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-13",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"notes",id:"notes-8",level:4},{value:"Normal Termination",id:"normal-termination",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"example",id:"example-14",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"The Abort Statement",id:"the-abort-statement",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-15",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"Abnormal Termination",id:"abnormal-termination",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"example",id:"example-16",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"Circular Task Calls",id:"circular-task-calls",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"Setting Exit Status",id:"setting-exit-status",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"Summary",id:"summary",level:2},{value:"concurrency options",id:"concurrency-options-1",level:3},{value:"communication",id:"communication-1",level:3},{value:"termination",id:"termination-1",level:3}],y={toc:g};function f(e){var t,n=e,{components:i}=n,c=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},y),c),o(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Concurrency exists as either apparent concurrency or real concurrency.\nIn a single processor environment, apparent concurrency is the result of\ninterleaved execution of concurrent activities. In a multiprocessor\nenvironment, real concurrency is the result of overlapped execution of\nconcurrent activities."),(0,a.kt)("p",null,"Concurrent programming is more difficult and error prone than sequential\nprogramming. The concurrent programming features of Ada are designed to\nmake it easier to write and maintain concurrent programs that behave\nconsistently and predictably and avoid such problems as deadlock and\nstarvation. The language features themselves cannot guarantee that\nprograms have these desirable properties. They must be used with\ndiscipline and care, a process supported by the guidelines in this\nchapter."),(0,a.kt)("p",null,"The correct usage of Ada concurrency features results in reliable,\nreusable, and portable software. Protected objects (added in Ada 95)\nencapsulate and provide synchronized access to their private data\n(Rationale 1995, \xa7II.9). Protected objects help you manage shared data\nwithout incurring a performance penalty. Tasks model concurrent\nactivities and use the rendezvous to synchronize between cooperating\nconcurrent tasks. Much of the synchronization required between tasks\ninvolves data synchronization, which can be accomplished most\nefficiently, in general, using protected objects. Misuse of language\nfeatures results in software that is unverifiable and difficult to reuse\nor port. For example, using task priorities or delays to manage\nsynchronization is not portable. It is also important that a reusable\ncomponent not make assumptions about the order or speed of task\nexecution (i.e., about the compiler's tasking implementation)."),(0,a.kt)("p",null,"Although concurrent features such as tasks and protected objects are\nsupported by the core Ada language, care should be taken when using\nthese features with implementations that do not specifically support\nAnnex D (Real-Time Systems). If Annex D is not specifically supported,\nfeatures required for real-time applications might not be implemented."),(0,a.kt)("p",null,'Guidelines in this chapter are frequently worded "consider . . ."\nbecause hard and fast rules cannot apply in all situations. The specific\nchoice you make in a given situation involves design tradeoffs. The\nrationale for these guidelines is intended to give you insight into some\nof these tradeoffs.'),(0,a.kt)("h2",u({},{id:"concurrency-options"}),"Concurrency Options"),(0,a.kt)("p",null,"Many problems map naturally to a concurrent programming solution. By\nunderstanding and correctly using the Ada language concurrency features,\nyou can produce solutions that are largely independent of target\nimplementation. Tasks provide a means, within the Ada language, of\nexpressing concurrent, asynchronous threads of control and relieving\nprogrammers from the problem of explicitly controlling multiple\nconcurrent activities. Protected objects serve as a building block to\nsupport other synchronization paradigms. Tasks cooperate to perform the\nrequired activities of the software. Synchronization and mutual\nexclusion are required between individual tasks. The Ada rendezvous and\nprotected objects provide powerful mechanisms for both synchronization\nand mutual exclusion."),(0,a.kt)("h3",u({},{id:"protected-objects"}),"Protected Objects"),(0,a.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to provide mutually exclusive\naccess to data."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to control or synchronize access to\ndata shared by multiple tasks ."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to implement synchronization, such\nas a passive resource monitor."),(0,a.kt)("li",{parentName:"ul"},"Consider encapsulating protected objects in the private part or body\nof a package."),(0,a.kt)("li",{parentName:"ul"},"Consider using a protected procedure to implement an interrupt\nhandler."),(0,a.kt)("li",{parentName:"ul"},"Do not attach a protected procedure handler to a hardware interrupt\nif that interrupt has a maximum priority greater than the ceiling\npriority assigned to the handler."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of global variables in entry barriers."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of barrier expressions with side effects.")),(0,a.kt)("h4",u({},{id:"example"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"generic\n   type Item is private;\n   Maximum_Buffer_Size : in Positive;\npackage Bounded_Buffer_Package is\n\n   subtype Buffer_Index is Positive range 1..Maximum_Buffer_Size;\n   subtype Buffer_Count is Natural  range 0..Maximum_Buffer_Size;\n   type    Buffer_Array is array (Buffer_Index) of Item;\n\n   protected type Bounded_Buffer is\n      entry Get (X : out Item);\n      entry Put (X : in Item);\n   private\n      Get_Index : Buffer_Index := 1;\n      Put_Index : Buffer_Index := 1;\n      Count     : Buffer_Count := 0;\n      Data      : Buffer_Array;\n   end Bounded_Buffer;\n\nend Bounded_Buffer_Package;\n\n------------------------------------------------------------------\npackage body Bounded_Buffer_Package is\n\n   protected body Bounded_Buffer is\n\n      entry Get (X : out Item) when Count > 0 is\n      begin\n         X := Data(Get_Index);\n         Get_Index := (Get_Index mod Maximum_Buffer_Size) + 1;\n         Count := Count - 1;\n      end Get;\n\n      entry Put (X : in Item) when Count < Maximum_Buffer_Size is\n      begin\n         Data(Put_Index) := X;\n         Put_Index  := (Put_Index mod Maximum_Buffer_Size) + 1;\n         Count := Count + 1;\n      end Put;\n\n   end Bounded_Buffer;\n\nend Bounded_Buffer_Package;\n")),(0,a.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,'Protected objects are intended to provide a "lightweight" mechanism for\nmutual exclusion and data synchronization. You should use a task only\nwhen you need to introduce explicitly a new, concurrent thread of\ncontrol (see Guideline 6.1.2).'),(0,a.kt)("p",null,"Protected objects offer a low overhead, efficient means to coordinate\naccess to shared data. A protected type declaration is similar to a\nprogram unit and consists of both a specification and a body. The data\nto be protected must be declared in the specification, as well as the\noperations that can be used to manipulate this data. If some operations\nare only allowed conditionally, entries must be provided. Ada 95 rules\nrequire that entry barriers be evaluated at the end of procedure calls\nand entry calls on protected objects. Entry barriers should avoid\nreferring to global variables so that the underlying assumptions of the\nstate of the protected object are not violated. Protected procedures and\nentries should be used to change the state of a protected object."),(0,a.kt)("p",null,"Most clients of an abstraction do not need to know how it is\nimplemented, whether it is a regular abstraction or a shared\nabstraction. A protected type is inherently a limited type, and you can\nuse protected types to implement a limited private type exported by a\npackage. As pointed out in Guideline 5.3.3, abstractions are best\nimplemented using private types (possibly derived from controlled types)\nor limited private types, providing appropriate operations that overcome\nthe restrictiveness imposed by the use of private types."),(0,a.kt)("p",null,"The Rationale (1995, \xa79.1) describes the interrupt handling features\nthat make the protected procedure the recommended building block:"),(0,a.kt)("p",null,"A protected procedure is very well suited to act as an interrupt handler\nfor a number of reasons; they both typically have a short bounded\nexecution time, do not arbitrarily block, have a limited context and\nfinally they both have to integrate with the priority model. The\nnonblocking critical region matches the needs of an interrupt handler,\nas well as the needs of non-interrupt-level code to synchronize with an\ninterrupt handler. The entry barrier construct allows an interrupt\nhandler to signal a normal task by changing the state of a component of\nthe protected object and thereby making a barrier true."),(0,a.kt)("p",null,"When using protected procedures for interrupt handling, you must ensure\nthat the ceiling priority of the handler is at least as high as the\nmaximum possible priority of the interrupt to be handled. With\npriority-ceiling locking, the delivery of an interrupt with a higher\npriority than the ceiling priority of the handler will result in\nerroneous execution (Ada Reference Manual 1995, \xa7C.3.1)."),(0,a.kt)("p",null,"A global variable could be changed by another task or even by a call of\na protected function. These changes will not be acted upon promptly.\nTherefore, you should not use a global variable in an entry barrier."),(0,a.kt)("p",null,"Side effects in barrier expressions can cause undesirable dependencies.\nTherefore, you should avoid the use of barrier expressions that can\ncause side effects."),(0,a.kt)("p",null,"See also Guideline ."),(0,a.kt)("h4",u({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"If the client of the abstraction containing the protected object must\nuse a select statement with an entry call, you must expose the protected\nobject on the package interface."),(0,a.kt)("h3",u({},{id:"tasks"}),"Tasks"),(0,a.kt)("h4",u({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use tasks to model selected asynchronous threads of control within\nthe problem domain."),(0,a.kt)("li",{parentName:"ul"},"Consider using tasks to define concurrent algorithms."),(0,a.kt)("li",{parentName:"ul"},"Consider using rendezvous when your application requires synchronous\nunbuffered communication.")),(0,a.kt)("h4",u({},{id:"example-1"}),"example"),(0,a.kt)("p",null,"The naturally concurrent objects within the problem domain can be\nmodeled as Ada tasks."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"-- The following example of a stock exchange simulation shows how naturally\n-- concurrent objects within the problem domain can be modeled as Ada tasks.\n\n-------------------------------------------------------------------------\n\n-- Protected objects are used for the Display and for the Transaction_Queue\n-- because they only need a mutual exclusion mechanism.\n\nprotected Display is\n   entry Shift_Tape_Left;\n   entry Put_Character_On_Tape (C : in Character);\nend Display;\n\nprotected Transaction_Queue is\n   entry Put (T : in     Transaction);\n   entry Get (T :    out Transaction);\n   function Is_Empty return Boolean;\nend Transaction_Queue;\n\n-------------------------------------------------------------------------\n\n-- A task is needed for the Ticker_Tape because it has independent cyclic\n-- activity.  The Specialist and the Investor are best modeled with tasks\n-- since they perform different actions simultaneously, and should be\n-- asynchronous threads of control.\n\ntask Ticker_Tape;\n\ntask Specialist is\n   entry Buy  (Order : in Order_Type);\n   entry Sell (Order : in Order_Type);\nend Specialist;\n\ntask Investor;\n-------------------------------------------------------------------------\ntask body Ticker_Tape is\n   ...\nbegin\n   loop\n      Display.Shift_Tape_Left;\n\n      if not More_To_Send (Current_Tape_String) and then\n         not Transaction_Queue.Is_Empty\n      then\n         Transaction_Queue.Get (Current_Tape_Transaction);\n         ... -- convert Transaction to string\n      end if;\n\n      if More_To_Send (Current_Tape_String) then\n         Display.Put_Character_On_Tape (Next_Char);\n      end if;\n\n      delay until Time_To_Shift_Tape;\n      Time_To_Shift_Tape := Time_To_Shift_Tape + Shift_Interval;\n   end loop;\nend Ticker_Tape;\n\ntask body Specialist is \n   ...\n\n   loop\n      select\n         accept Buy  (Order : in Order_Type) do\n            ...\n         end Buy;\n         ...\n      or\n         accept Sell (Order : in Order_Type) do\n            ...\n         end Sell;\n         ...\n      else\n         -- match orders\n         ...\n         Transaction_Queue.Put (New_Transaction);\n         ...\n      end select;\n   end loop;\n\nend Specialist;\n\ntask body Investor is\n   ...\nbegin\n\n   loop\n      -- some algorithm that determines whether the investor\n      -- buys or sells, quantity, price, etc\n\n      ...\n\n      if ... then\n         Specialist.Buy (Order);\n      end if;\n\n      if ... then\n         Specialist.Sell (Order);\n      end if;\n   end loop;\n\nend Investor;\n")),(0,a.kt)("p",null,"Multiple tasks that implement the decomposition of a large, matrix\nmultiplication algorithm are an example of an opportunity for real\nconcurrency in a multiprocessor target environment. In a single\nprocessor target environment, this approach may not be justified due to\nthe overhead incurred from context switching and the sharing of system\nresources."),(0,a.kt)("p",null,"A task that updates a radar display every 30 milliseconds is an example\nof a cyclic activity supported by a task."),(0,a.kt)("p",null,"A task that detects an over-temperature condition in a nuclear reactor\nand performs an emergency shutdown of the systems is an example of a\ntask to support a high-priority activity."),(0,a.kt)("h4",u({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"These guidelines reflect the intended uses of tasks. They all revolve\naround the fact that a task has its own thread of control separate from\nthe main subprogram (or environment task) of a partition. The conceptual\nmodel for a task is a separate program with its own virtual processor.\nThis provides the opportunity to model entities from the problem domain\nin terms more closely resembling those entities and the opportunity to\nhandle physical devices as a separate concern from the main algorithm of\nthe application. Tasks also allow naturally concurrent activities that\ncan be mapped to multiple processors within a partition when available."),(0,a.kt)("p",null,"You should use tasks for separate threads of control. When you\nsynchronize tasks, you should use the rendezvous mechanism only when you\nare trying to synchronize actual processes (e.g., specify a\ntime-sensitive ordering relationship or tightly coupled interprocess\ncommunication). For most synchronization needs, however, you should use\nprotected objects (see Guideline 6.1.1), which are more flexible and can\nminimize unnecessary bottlenecks. Additionally, passive tasks are\nprobably better modeled through protected objects than active tasks."),(0,a.kt)("p",null,"Resources shared between multiple tasks, such as devices, require\ncontrol and synchronization because their operations are not atomic.\nDrawing a circle on a display might require that many low-level\noperations be performed without interruption by another task. A display\nmanager would ensure that no other task accesses the display until all\nthese operations are complete."),(0,a.kt)("h3",u({},{id:"discriminants"}),"Discriminants"),(0,a.kt)("h4",u({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using discriminants to minimize the need for an explicit\ninitialization operation (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using discriminants to control composite components of the\nprotected objects, including setting the size of an entry family\n(Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using a discriminant to set the priority of a protected\nobject (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using a discriminant to identify an interrupt to a\nprotected object (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider declaring a task type with a discriminant to indicate\n(Rationale 1995, \xa79.6):",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Priority, storage size, and size of entry families of individual\ntasks of a type"),(0,a.kt)("li",{parentName:"ul"},"Data associated with a task (through an access discriminant)")))),(0,a.kt)("h4",u({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"The following code fragment shows how a task type with discriminant can\nbe used to associate data with a task (Rationale 1995, \xa79.6):"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"type Task_Data is\n   record\n      ...  -- data for task to work on\n   end record;\ntask type Worker (D : access Task_Data) is\n   ...\nend;\n-- When you declare a task object of type Worker, you explicitly associate this task with\n-- its data through the discriminant D\nData_for_Worker_X : aliased Task_Data := ...;\nX : Worker (Data_for_Worker_X'Access);\n")),(0,a.kt)("p",null,"The following example shows how to use discriminants to associate data\nwith tasks, thus allowing the tasks to be parameterized when they are\ndeclared and eliminating the need for an initial rendezvous with the\ntask:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task type Producer (Channel : Channel_Number; ID : ID_Number);\n\ntask body Producer is\nbegin\n\n   loop\n\n      ... -- generate an item\n\n      Buffer.Put (New_Item);\n\n   end loop;\nend Producer;\n\n...\n\nKeyboard : Producer (Channel => Keyboard_Channel, ID => 1);\nMouse    : Producer (Channel => Mouse_Channel,    ID => 2);\n")),(0,a.kt)("p",null,"The next example shows how an initial rendezvous can be used to\nassociate data with tasks. This is more complicated and more error prone\nthan the previous example. This method is no longer needed in Ada 95 due\nto the availability of discriminants with task types and protected\ntypes:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task type Producer is\n   entry Initialize (Channel : in Channel_Number; ID : in ID_Number);\nend Producer;\n\ntask body Producer is\n   IO_Channel  : Channel_Number;\n   Producer_ID : ID_Number;\nbegin\n\n   accept Initialize (Channel : in Channel_Number; ID : in ID_Number) do\n      IO_Channel  := Channel;\n      Producer_ID := ID;\n   end;\n\n   loop\n\n      ... -- generate an item\n\n      Buffer.Put (New_Item);\n\n   end loop;\nend Producer;\n\n...\n\nKeyboard : Producer;\nMouse    : Producer;\n\n...\n\nbegin\n   ...\n   Keyboard.Initialize (Channel => Keyboard_Channel, ID => 1);\n   Mouse.Initialize    (Channel => Mouse_Channel,    ID => 2);\n   ...\n")),(0,a.kt)("h4",u({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Using discriminants to parameterize protected objects provides a\nlow-overhead way of specializing the protected object. You avoid having\nto declare and call special subprograms solely for the purpose of\npassing this information to the protected object."),(0,a.kt)("p",null,"Task discriminants provide a way for you to identify or parameterize a\ntask without the overhead of an initial rendezvous. For example, you can\nuse this discriminant to initialize a task or tell it who it is (from\namong an array of tasks) (Rationale 1995, \xa7II.9). More importantly, you\ncan associate the discriminant with specific data. When you use an\naccess discriminant, you can bind the data securely to the task because\nthe access discriminant is constant and cannot be detached from the task\n(Rationale 1995, \xa79.6). This reduces and might eliminate bottlenecks in\nthe parallel activation of tasks (Rationale 1995, \xa79.6)."),(0,a.kt)("h4",u({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"Using an access discriminant to initialize a task has a potential danger\nin that the data being referenced could change after the rendezvous.\nThis possibility and its effects should be considered and, if necessary,\nappropriate actions taken (e.g., copy the referenced data and not rely\non the data pointed to by the discriminant after initialization)."),(0,a.kt)("h3",u({},{id:"anonymous-task-types-and-protected-types"}),"Anonymous Task Types and Protected Types"),(0,a.kt)("h4",u({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using single task declarations to declare unique instances\nof concurrent tasks."),(0,a.kt)("li",{parentName:"ul"},"Consider using single protected declarations to declare unique\ninstances of protected objects.")),(0,a.kt)("h4",u({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"The following example illustrates the syntactic differences between the\nkinds of tasks and protected objects discussed here. Buffer is static,\nbut its type is anonymous. No type name is declared to enable you to\ndeclare further objects of the same type."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task      Buffer;\n")),(0,a.kt)("p",null,"Because it is declared explicitly, the task type Buffer","_","Manager is not\nanonymous. Channel is static and has a name, and its type is not\nanonymous."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task type Buffer_Manager;\nChannel : Buffer_Manager;\n")),(0,a.kt)("h4",u({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"The use of anonymous tasks and protected objects of anonymous type\navoids a proliferation of task and protected types that are only used\nonce, and the practice communicates to maintainers that there are no\nother tasks or protected objects of that type. If the need arises later\nto have additional tasks or protected objects of the same type, then the\nwork required to convert an anonymous task to a task type or an\nanonymous protected object to a protected type is minimal."),(0,a.kt)("p",null,"The consistent and logical use of task and protected types, when\nnecessary, contributes to understandability. Identical tasks can be\ndeclared using a common task type. Identical protected objects can be\ndeclared using a common protected type. Dynamically allocated task or\nprotected structures are necessary when you must create and destroy\ntasks or protected objects dynamically or when you must reference them\nby different names."),(0,a.kt)("h4",u({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"Though changing the task or protected object from an anonymous type to a\ndeclared type is trivial, structural changes to the software\narchitecture might not be trivial. Introduction of multiple tasks or\nprotected objects of the declared type might require the scope of the\ntype to change and might change the behavior of the network of\nsynchronizing tasks and protected objects."),(0,a.kt)("h3",u({},{id:"dynamic-tasks"}),"Dynamic Tasks"),(0,a.kt)("h4",u({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize dynamic creation of tasks because of the potentially high\nstartup overhead; reuse tasks by having them wait for new work on\nsome appropriate entry queue.")),(0,a.kt)("h4",u({},{id:"example-4"}),"example"),(0,a.kt)("p",null,"The approach used in the following example is not recommended. The\nexample shows why caution is required with dynamically allocated task\nand protected objects. It illustrates how a dynamic task can be\ndisassociated from its name:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task type Radar_Track;\ntype      Radar_Track_Pointer is access Radar_Track;\nCurrent_Track : Radar_Track_Pointer;\n---------------------------------------------------------------------\ntask body Radar_Track is\nbegin\n   loop\n      -- update tracking information\n      ...\n      -- exit when out of range\n      delay 1.0;\n   end loop;\n...\nend Radar_Track;\n---------------------------------------------------------------------\n...\nloop\n   ...\n   -- Radar_Track tasks created in previous passes through the loop\n   -- cannot be accessed from Current_Track after it is updated.\n   -- Unless some code deals with non-null values of Current_Track,\n   -- (such as an array of existing tasks)\n   -- this assignment leaves the existing Radar_Track task running with\n   -- no way to signal it to abort or to instruct the system to\n   -- reclaim its resources.\n\n   Current_Track := new Radar_Track;\n   ...\nend loop;\n")),(0,a.kt)("h4",u({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"Starting up a task has significant overhead in many implementations. If\nan application has a need for dynamically created tasks, the tasks\nshould be implemented with a top-level loop so that after such a task\ncompletes its given job, it can cycle back and wait for a new job."),(0,a.kt)("p",null,"You can use dynamically allocated tasks and protected objects when you\nneed to allow the number of tasks and protected objects to vary during\nexecution. When you must ensure that tasks are activated in a particular\norder, you should use dynamically allocated tasks because the Ada\nlanguage does not define an activation order for statically allocated\ntask objects. In using dynamically allocated tasks and protected\nobjects, you face the same issues as with any use of the heap."),(0,a.kt)("h3",u({},{id:"priorities"}),"Priorities"),(0,a.kt)("h4",u({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not rely on pragma Priority unless your compiler supports the\nReal-Time Annex (Ada Reference Manual 1995, Annex D) and priority\nscheduling."),(0,a.kt)("li",{parentName:"ul"},"Minimize risk of priority inversion by use of protected objects and\nceiling priority."),(0,a.kt)("li",{parentName:"ul"},"Do not rely upon task priorities to achieve a particular sequence of\ntask execution.")),(0,a.kt)("h4",u({},{id:"example-5"}),"example"),(0,a.kt)("p",null,"For example, let the tasks have the following priorities:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task T1 is\n   pragma Priority (High);\nend T1;\n\ntask T2 is\n   pragma Priority (Medium);\nend T2;\n\ntask Server is\n   entry Operation (...);\nend Server;\n\n----------------------------\ntask body T1 is\nbegin\n   ...\n   Server.Operation (...);\n   ...\nend T1;\ntask body T2 is\nbegin\n   ...\n   Server.Operation (...);\n   ...\nend T2;\n\ntask body Server is\nbegin\n   ...\n   accept Operation (...);\n   ...\nend Server;\n")),(0,a.kt)("p",null,"At some point in its execution, T1 is blocked. Otherwise, T2 and Server\nmight never execute. If T1 is blocked, it is possible for T2 to reach\nits call to Server's entry (Operation) before T1. Suppose this has\nhappened and that T1 now makes its entry call before Server has a chance\nto accept T2's call."),(0,a.kt)("p",null,"This is the timeline of events so far:"),(0,a.kt)("p",null,"T1 blocks T2 calls Server.Operation T1 unblocks T1 calls\nServer.Operation\u2014Does Server accept the call from T1 or from T2?"),(0,a.kt)("p",null,"You might expect that, due to its higher priority, T1's call would be\naccepted by Server before that of T2. However, entry calls are queued in\nfirst-in-first-out (FIFO) order and not queued in order of priority\n(unless pragma Queueing","_","Policy is used). Therefore, the synchronization\nbetween T1 and Server is not affected by T1's priority. As a result, the\ncall from T2 is accepted first. This is a form of priority inversion.\n(Annex D can change the default policy of FIFO queues.)"),(0,a.kt)("p",null,"A solution might be to provide an entry for a High priority user and an\nentry for a Medium priority user."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"---------------------------------------------------------------------\ntask Server is\n   entry Operation_High_Priority;\n   entry Operation_Medium_Priority;\n   ...\nend Server;\n---------------------------------------------------------------------\ntask body Server is\nbegin\n   loop\n      select\n         accept Operation_High_Priority do\n            Operation;\n         end Operation_High_Priority;\n      else  -- accept any priority\n         select\n            accept Operation_High_Priority do\n               Operation;\n            end Operation_High_Priority;\n         or\n            accept Operation_Medium_Priority do\n               Operation;\n            end Operation_Medium_Priority;\n         or\n            terminate;\n         end select;\n      end select;\n   end loop;\n...\nend Server;\n---------------------------------------------------------------------\n")),(0,a.kt)("p",null,"However, in this approach, T1 still waits for one execution of Operation\nwhen T2 has already gained control of the task Server. In addition, the\napproach increases the communication complexity (see Guideline 6.2.6)."),(0,a.kt)("h4",u({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"The pragma Priority allows relative priorities to be placed on tasks to\naccomplish scheduling. Precision becomes a critical issue with\nhard-deadline scheduling. However, there are certain problems associated\nwith using priorities that warrant caution."),(0,a.kt)("p",null,"Priority inversion occurs when lower priority tasks are given service\nwhile higher priority tasks remain blocked. In the first example, this\noccurred because entry queues are serviced in FIFO order, not by\npriority. There is another situation referred to as a race condition . A\nprogram like the one in the first example might often behave as expected\nas long as T1 calls Server.Operation only when T2 is not already using\nServer.Operation or waiting. You cannot rely on T1 always winning the\nrace because that behavior would be due more to fate than to the\nprogrammed priorities. Race conditions change when either adding code to\nan unrelated task or porting this code to a new target."),(0,a.kt)("p",null,"You should not rely upon task priorities to achieve an exact sequence of\nexecution or rely upon them to achieve mutual exclusion. Although the\nunderlying dispatching model is common to all Ada 95 implementations,\nthere might be differences in dispatching, queuing, and locking policies\nfor tasks and protected objects. All of these factors might lead to\ndifferent sequences of execution. If you need to ensure a sequence of\nexecution, you should make use of Ada's synchronization mechanisms,\ni.e., protected objects or rendezvous."),(0,a.kt)("h4",u({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"Work is being done to minimize these problems, including the\nintroduction of a scheduling algorithm known as the priority ceiling\nprotocol (Goodenough and Sha 1988). The priority ceiling protocol\nreduces the blocking time that causes priority inversion to only one\ncritical region (defined by the entries in a task). The protocol also\neliminates deadlock (unless a task recursively tries to access a\ncritical region) by giving a ceiling priority to each task accessing a\nresource that is as high as the priority of any task that ever accesses\nthat resource. This protocol is based on priority inheritance and, thus,\ndeviates from the standard Ada tasking paradigm, which supports priority\nceiling emulation instead of the priority ceiling blocking that occurs\nwith priority inheritance."),(0,a.kt)("p",null,"Priorities are used to control when tasks run relative to one another.\nWhen both tasks are not blocked waiting at an entry, the highest\npriority task is given precedence. However, the most critical tasks in\nan application do not always have the highest priority. For example,\nsupport tasks or tasks with small periods might have higher priorities\nbecause they need to run frequently."),(0,a.kt)("p",null,"All production-quality validated Ada 95 compilers will probably support\npragma Priority. However, you should use caution unless (Annex D is\nspecifically supported."),(0,a.kt)("p",null,"There is currently no universal consensus on how to apply the basic\nprinciples of rate monotonic scheduling (RMS) to the Ada 95 concurrency\nmodel. One basic principle of RMS is to arrange all periodic tasks so\nthat tasks with shorter periods have higher priorities than tasks with\nlonger periods. However, with Ada 95, it might be faster to raise the\npriorities of tasks whose jobs suddenly become critical than to wait for\nan executive task to reschedule them. In this case, priority inversion\ncan be minimized using a protected object with pragma\nLocking","_","Policy(Ceiling","_","Locking) as the server instead of a task."),(0,a.kt)("h3",u({},{id:"delay-statements"}),"Delay Statements"),(0,a.kt)("h4",u({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on a particular delay being achievable (Nissen and\nWallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Use a delay until not a delay statement to delay until a specific\ntime has been reached."),(0,a.kt)("li",{parentName:"ul"},"Avoid using a busy waiting loop instead of a delay.")),(0,a.kt)("h4",u({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"The phase of a periodic task is the fraction of a complete cycle elapsed\nas measured from a specified reference point. In the following example,\nan inaccurate delay causes the phase of the periodic task to drift over\ntime (i.e., the task starts later and later in the cycle):"),(0,a.kt)("p",null,"Periodic:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"   loop\n      delay Interval;\n      ...\n   end loop Periodic;\n")),(0,a.kt)("p",null,"To avoid an inaccurate delay drift, you should use the delay until\nstatement. The following example (Rationale 1995, \xa79.3) shows how to\nsatisfy a periodic requirement with an average period:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Poll_Device is\n   use type Ada.Real_Time.Time;\n   use type Ada.Real_Time.Time_Span;\n\n   Poll_Time :          Ada.Real_Time.Time := ...; -- time to start polling\n   Period    : constant Ada.Real_Time.Time_Span := Ada.Real_Time.Milliseconds (10);\nbegin\n   loop\n      delay until Poll_Time;\n      ... -- Poll the device\n      Poll_Time := Poll_Time + Period;\n   end loop;\nend Poll_Device;\n")),(0,a.kt)("h4",u({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"There are two forms of delay statement. The delay will cause a delay for\nat least a specified time interval. The delay until causes a delay until\nan absolute wake-up time. You should choose the form appropriate to your\napplication."),(0,a.kt)("p",null,"The Ada language definition only guarantees that the delay time is a\nminimum. The meaning of a delay or delay until statement is that the\ntask is not scheduled for execution before the interval has expired. In\nother words, a task becomes eligible to resume execution as soon as the\namount of time has passed. However, there is no guarantee of when (or\nif) it is scheduled after that time because the required resources for\nthat task might not be available at the expiration of the delay ."),(0,a.kt)("p",null,"A busy wait can interfere with processing by other tasks. It can consume\nthe very processor resource necessary for completion of the activity for\nwhich it is waiting. Even a loop with a delay can have the impact of\nbusy waiting if the planned wait is significantly longer than the delay\ninterval. If a task has nothing to do, it should be blocked at an accept\nor select statement, an entry call, or an appropriate delay."),(0,a.kt)("p",null,"The expiration time for a relative delay is rounded up to the nearest\nclock tick. If you use the real-time clock features provided by (Annex\nD, however, clock ticks are guaranteed to be no greater than one\nmillisecond (Ada Reference Manual 1995, \xa7D.8)."),(0,a.kt)("h4",u({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"You need to ensure the arithmetic precision of the calculation\nPoll","_","Time := Poll","_","Time + Period; to avoid drift."),(0,a.kt)("h3",u({},{id:"extensibility-and-concurrent-structures"}),"Extensibility and Concurrent Structures"),(0,a.kt)("h4",u({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Carefully consider the placement of components of protected types\nwithin a tagged type inheritance hierarchy."),(0,a.kt)("li",{parentName:"ul"},"Consider using generics to provide extensibility of data types\nrequiring the restrictions provided by protected objects.")),(0,a.kt)("h4",u({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"Once a component of a protected type is added to an inheritance\nhierarchy of an abstract data type, further extensibility of that data\ntype is impaired. When you constrain the concurrent behavior of a type\n(i.e., introduce a protected type component), you lose the ability to\nmodify that behavior in subsequent derivations. Therefore, when the need\narises for a version of an abstract data type to impose the restrictions\nprovided by protected objects, the opportunity for reuse is maximized by\nadding the protected objects at the leaves of the inheritance hierarchy."),(0,a.kt)("p",null,"The reusability of common protected operations (e.g., mutually exclusive\nread/write operations) can be maximized by using generic implementations\nof abstract data types. These generic implementations then provide\ntemplates that can be instantiated with data types specific to\nindividual applications."),(0,a.kt)("h4",u({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"You can address synchronization within an inheritance hierarchy in one\nof three ways:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You can declare the root as a limited tagged type with a component\nthat belongs to a protected type and give the tagged type primitive\noperations that work by invoking the protected operations of that\ncomponent."),(0,a.kt)("li",{parentName:"ul"},"Given a tagged type implementing an abstract data type (perhaps\nresulting from several extensions), you can declare a protected type\nwith a component belonging to the tagged type. The body of each\nprotected operation would then invoke the corresponding operation of\nthe abstract data type. The protected operations provide mutual\nexclusion."),(0,a.kt)("li",{parentName:"ul"},"You can use a hybrid approach where you declare a protected type\nwith a component of some tagged type. You then use this protected\ntype to implement a new root tagged type (not a descendant of the\noriginal tagged type).")),(0,a.kt)("h2",u({},{id:"communication"}),"Communication"),(0,a.kt)("p",null,"The need for tasks to communicate gives rise to most of the problems\nthat make concurrent programming so difficult. Used properly, Ada's\nintertask communication features can improve the reliability of\nconcurrent programs; used thoughtlessly, they can introduce subtle\nerrors that can be difficult to detect and correct."),(0,a.kt)("h3",u({},{id:"efficient-task-communication"}),"Efficient Task Communication"),(0,a.kt)("h4",u({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the work performed during a rendezvous."),(0,a.kt)("li",{parentName:"ul"},"Minimize the work performed in the selective accept loop of a task."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects for data synchronization and\ncommunication.")),(0,a.kt)("h4",u({},{id:"example-7"}),"example"),(0,a.kt)("p",null,"In the following example, the statements in the accept body are\nperformed as part of the execution of both the caller task and the task\nServer, which contains Operation and Operation2. The statements after\nthe accept body are executed before Server can accept additional calls\nto Operation or Operation2."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"   ...\n   loop\n      select\n         accept Operation do\n            -- These statements are executed during rendezvous.\n            -- Both caller and server are blocked during this time.\n            ...\n         end Operation;\n         ...\n         -- These statements are not executed during rendezvous.\n         -- The execution of these statements increases the time required\n         --   to get back to the accept and might be a candidate for another task.\n\n      or\n         accept Operation_2 do\n            -- These statements are executed during rendezvous.\n            -- Both caller and server are blocked during this time.\n            ...\n         end Operation_2;\n      end select;\n      -- These statements are also not executed during rendezvous,\n      -- The execution of these statements increases the time required\n      --   to get back to the accept and might be a candidate for another task.\n\n   end loop;\n")),(0,a.kt)("h4",u({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"To minimize the time required to rendezvous, only work that needs to be\nperformed during a rendezvous, such as saving or generating parameters,\nshould be allowed in the accept bodies."),(0,a.kt)("p",null,"When work is removed from the accept body and placed later in the\nselective accept loop, the additional work might still suspend the\ncaller task. If the caller task calls entry Operation again before the\nserver task completes its additional work, the caller is delayed until\nthe server completes the additional work. If the potential delay is\nunacceptable and the additional work does not need to be completed\nbefore the next service of the caller task, the additional work can form\nthe basis of a new task that will not block the caller task."),(0,a.kt)("p",null,"Operations on protected objects incur less execution overhead than tasks\nand are more efficient for data synchronization and communication than\nthe rendezvous. You must design protected operations to be bounded,\nshort, and not potentially blocking."),(0,a.kt)("h4",u({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"In some cases, additional functions can be added to a task. For example,\na task controlling a communication device might be responsible for a\nperiodic function to ensure that the device is operating correctly. This\ntype of addition should be done with care, realizing that the response\ntime of the task might be impacted (see the above rationale)."),(0,a.kt)("p",null,"Minimizing the work performed during a rendezvous or selective accept\nloop of a task can increase the rate of execution only when it results\nin additional overlaps in processing between the caller and callee or\nwhen other tasks can be scheduled due to the shorter period of\nexecution. Therefore, the largest increases in execution rates will be\nseen in multiprocessor environments. In single-processor environments,\nthe increased execution rate will not be as significant and there might\neven be a small net loss. The guideline is still applicable, however, if\nthe application could ever be ported to a multiprocessor environment."),(0,a.kt)("h3",u({},{id:"defensive-task-communication"}),"Defensive Task Communication"),(0,a.kt)("h4",u({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide a handler for exception Program","_","Error whenever you cannot\navoid a selective accept statement whose alternatives can all be\nclosed (Honeywell 1986)."),(0,a.kt)("li",{parentName:"ul"},"Make systematic use of handlers for Tasking","_","Error."),(0,a.kt)("li",{parentName:"ul"},"Be prepared to handle exceptions during a rendezvous ."),(0,a.kt)("li",{parentName:"ul"},"Consider using a when others exception handler.")),(0,a.kt)("h4",u({},{id:"example-8"}),"example"),(0,a.kt)("p",null,"This block allows recovery from exceptions raised while attempting to\ncommunicate a command to another task:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"Accelerate:\n   begin\n      Throttle.Increase(Step);\n   exception\n      when Tasking_Error     =>     ...\n      when Constraint_Error  =>     ...\n      when Throttle_Too_Wide =>     ...\n      ...\n   end Accelerate;\n")),(0,a.kt)("p",null,"In this select statement, if all the guards happen to be closed, the\nprogram can continue by executing the else part. There is no need for a\nhandler for Program","_","Error. Other exceptions can still be raised while\nevaluating the guards or attempting to communicate. You will also need\nto include an exception handler in the task Throttle so that it can\ncontinue to execute after an exception is raised during the rendezvous:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"...\nGuarded:\n   begin\n      select\n         when Condition_1 =>\n            accept Entry_1;\n      or\n         when Condition_2 =>\n            accept Entry_2;\n      else  -- all alternatives closed\n         ...\n      end select;\n   exception\n      when Constraint_Error =>\n         ...\n   end Guarded;\n")),(0,a.kt)("p",null,"In this select statement, if all the guards happen to be closed,\nexception Program","_","Error will be raised. Other exceptions can still be\nraised while evaluating the guards or attempting to communicate:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"Guarded:\n   begin\n      select\n         when Condition_1 =>\n            accept Entry_1;\n      or\n         when Condition_2 =>\n            delay Fraction_Of_A_Second;\n      end select;\n   exception\n      when Program_Error     =>  ...\n      when Constraint_Error  =>  ...\n   end Guarded;\n...\n")),(0,a.kt)("h4",u({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"The exception Program","_","Error is raised if a selective accept statement\n(select statement containing accepts) is reached, all of whose\nalternatives are closed (i.e., the guards evaluate to False and there\nare no alternatives without guards), unless there is an else part. When\nall alternatives are closed, the task can never again progress, so there\nis by definition an error in its programming. You must be prepared to\nhandle this error should it occur."),(0,a.kt)("p",null,"Because an else part cannot have a guard, it can never be closed off as\nan alternative action; thus, its presence prevents Program","_","Error.\nHowever, an else part, a delay alternative, and a terminate alternative\nare all mutually exclusive, so you will not always be able to provide an\nelse part. In these cases, you must be prepared to handle\nProgram","_","Error."),(0,a.kt)("p",null,"The exception Tasking","_","Error can be raised in the calling task whenever\nit attempts to communicate. There are many situations permitting this.\nFew of them are preventable by the calling task."),(0,a.kt)("p",null,"If an exception is raised during a rendezvous and not handled in the\naccept statement, it is propagated to both tasks and must be handled in\ntwo places (see Guideline 5.8). The handling of the others exception can\nbe used to avoid propagating unexpected exceptions to callers (when this\nis the desired effect) and to localize the logic for dealing with\nunexpected exceptions in the rendezvous. After handling, an unknown\nexception should normally be raised again because the final decision of\nhow to deal with it might need to be made at the outermost scope of the\ntask body."),(0,a.kt)("h4",u({},{id:"notes-6"}),"notes"),(0,a.kt)("p",null,"There are other ways to prevent Program","_","Error at a selective accept.\nThese involve leaving at least one alternative unguarded or proving that\nat least one guard will evaluate True under all circumstances. The point\nhere is that you or your successors will make mistakes in trying to do\nthis, so you should prepare to handle the inevitable exception."),(0,a.kt)("h3",u({},{id:"attributes-count-callable-and-terminated"}),"Attributes 'Count, 'Callable, and 'Terminated"),(0,a.kt)("h4",u({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the values of the task attributes 'Callable or\n'Terminated ( Nissen and Wallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on attributes to avoid Tasking","_","Error on an entry\ncall."),(0,a.kt)("li",{parentName:"ul"},"For tasks, do not depend on the value of the entry attribute 'Count."),(0,a.kt)("li",{parentName:"ul"},"Using the 'Count attribute with protected entries is more reliable\nthan using the 'Count attribute with task entries.")),(0,a.kt)("h4",u({},{id:"example-9"}),"example"),(0,a.kt)("p",null,"In the following examples, Dispatch'Callable is a Boolean expression,\nindicating whether a call can be made to the task Intercept without\nraising the exception Tasking","_","Error. Dispatch'Count indicates the\nnumber of callers currently waiting at entry Transmit.\nDispatch'Terminated is a Boolean expression, indicating whether the task\nDispatch is in a terminated state."),(0,a.kt)("p",null,"This task is badly programmed because it relies upon the values of the\n'Count attributes not changing between evaluating and acting upon them:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"---------------------------------------------------------------------\ntask body Dispatch is\n...\n   select\n      when Transmit'Count > 0 and Receive'Count = 0 =>\n         accept Transmit;\n         ...\n   or\n      accept Receive;\n      ...\n   end select;\n...\nend Dispatch;\n---------------------------------------------------------------------\n")),(0,a.kt)("p",null,"If the following code is preempted between evaluating the condition and\ninitiating the call, the assumption that the task is still callable\nmight no longer be valid:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"...\nif Dispatch'Callable then\n   Dispatch.Receive;\nend if;\n...\n")),(0,a.kt)("h4",u({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,"Attributes 'Callable, 'Terminated, and 'Count are all subject to race\nconditions. Between the time you reference an attribute and the time you\ntake action, the value of the attribute might change. Attributes\n'Callable and 'Terminated convey reliable information once they become\nFalse and True, respectively. If 'Callable is False, you can expect the\ncallable state to remain constant. If 'Terminated is True, you can\nexpect the task to remain terminated. Otherwise, 'Terminated and\n'Callable can change between the time your code tests them and the time\nit responds to the result."),(0,a.kt)("p",null,"The Ada Reference Manual (1995, \xa79.9) itself warns about the\nasynchronous increase and decrease of the value of 'Count. A task can be\nremoved from an entry queue due to execution of an abort statement as\nwell as expiration of a timed entry call. The use of this attribute in\nguards of a selective accept statement might result in the opening of\nalternatives that should not be opened under a changed value of 'Count."),(0,a.kt)("p",null,"The value of the attribute 'Count is stable for protected units because\nany change to an entry queue is itself a protected action, which will\nnot occur while any other protected action is already proceeding.\nNevertheless, when you use 'Count within an entry barrier of a protected\nunit, you should remember that the condition of the barrier is evaluated\nboth before and after queueing a given caller."),(0,a.kt)("h3",u({},{id:"unprotected-shared-variables"}),"Unprotected Shared Variables"),(0,a.kt)("h4",u({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use calls on protected subprograms or entries to pass data between\ntasks rather than unprotected shared variables."),(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables as a task synchronization\ndevice."),(0,a.kt)("li",{parentName:"ul"},"Do not reference nonlocal variables in a guard ."),(0,a.kt)("li",{parentName:"ul"},"If an unprotected shared variable is necessary, use the pragma\nVolatile or Atomic.")),(0,a.kt)("h4",u({},{id:"example-10"}),"example"),(0,a.kt)("p",null,"This code will either print the same line more than once, fail to print\nsome lines, or print garbled lines (part of one line followed by part of\nanother) nondeterministically. This is because there is no\nsynchronization or mutual exclusion between the task that reads a\ncommand and the one that acts on it. Without knowledge about their\nrelative scheduling, the actual results cannot be predicted:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"-----------------------------------------------------------------------\ntask body Line_Printer_Driver is\n   ...\nbegin\n   loop\n      Current_Line := Line_Buffer;\n      -- send to device\n   end loop;\nend Line_Printer_Driver;\n-----------------------------------------------------------------------\ntask body Spool_Server is\n   ...\nbegin\n   loop\n      Disk_Read (Spool_File, Line_Buffer);\n   end loop;\nend Spool_Server;\n-----------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The following example shows a vending machine that dispenses the amount\nrequested into an appropriately sized container. The guards reference\nthe global variables Num","_","Requested and Item","_","Count, leading to a\npotential problem in the wrong amount being dispensed into an\ninappropriately sized container:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),'Num_Requested : Natural;\nItem_Count    : Natural := 1000;\ntask type Request_Manager (Personal_Limit : Natural := 1) is\n   entry Make_Request (Num : Natural);\n   entry Get_Container;\n   entry Dispense;\nend Request_Manager;\n\ntask body Request_Manager is\nbegin\n   loop\n      select\n         accept Make_Request (Num : Natural) do\n            Num_Requested := Num;\n         end Make_Request;\n      or\n         when Num_Requested < Item_Count =>\n            accept Get_Container;\n            ...\n      or\n         when Num_Requested < Item_Count =>\n            accept Dispense do\n               if Num_Requested <= Personal_Limit then\n                  Ada.Text_IO.Put_Line ("Please pick up items.");\n               else\n                  Ada.Text_IO.Put_Line ("Sorry! Requesting too many items.");\n               end if;\n            end Dispense;\n      end select;\n   end loop;\nend Request_Manager;\nR1 : Request_Manager (Personal_Limit => 10);\nR2 : Request_Manager (Personal_Limit => 2);  \n')),(0,a.kt)("p",null,"The interleaving of the execution of R1 and R2 can lead to\nNum","_","Requested being changed before the entry call to Dispense is\naccepted. Thus, R1 might receive fewer items than requested or R2's\nrequest might be bounced because the request manager thinks that what R2\nis requesting exceeds R2's personal limit. By using the local variable,\nyou will dispense the correct amount. Furthermore, by using the pragma\nVolatile (Ada Reference Manual 1995, \xa7C.6), you ensure that the\nItem","_","Count is reevaluated when the guards are evaluated. Given that the\nvariable Item","_","Count is not updated in this task body, the compiler\nmight otherwise have optimized the code and not generated code to\nreevaluate Item","_","Count every time it is read:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"Item_Count : Natural := 1000;\npragma Volatile (Item_Count);\ntask body Request_Manager is\n   Local_Num_Requested : Natural := 0;\nbegin\n   loop\n      select\n         accept Make_Request (Num : Natural) do\n            Local_Num_Requested := Num;\n         end Make_Request;\n      or\n         when Local_Num_Requested <= Personal_Limit =>\n            accept Get_Container;\n            ...\n      or\n         when Local_Num_Requested < Item_Count =>\n            accept Dispense do\n               ... -- output appropriate message if couldn't service request\n            end Dispense;\n            Item_Count := Item_Count - Local_Num_Requested; \n      end select;\n   end loop;\nend Request_Manager;\n")),(0,a.kt)("h4",u({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,"There are many techniques for protecting and synchronizing data access.\nYou must program most of them yourself to use them. It is difficult to\nwrite a program that shares unprotected data correctly. If it is not\ndone correctly, the reliability of the program suffers."),(0,a.kt)("p",null,"Ada provides protected objects that encapsulate and provide synchronized\naccess to protected data that is shared between tasks. Protected objects\nare expected to provide better performance than the rendezvous that\nusually requires introduction of an additional task to manage the shared\ndata. The use of unprotected shared variables is more error-prone than\nthe protected objects or rendezvous because the programmer must ensure\nthat the unprotected shared variables are independently addressable and\nthat the actions of reading or updating the same unprotected shared\nvariable are sequential (Ada Reference Manual 1995, \xa79.10; Rationale\n1995, \xa7II.9)."),(0,a.kt)("p",null,"The first example above has a race condition requiring perfect\ninterleaving of execution. This code can be made more reliable by\nintroducing a flag that is set by Spool","_","Server and reset by\nLine","_","Printer","_","Driver. An if (condition flag) then delay ... else would\nbe added to each task loop in order to ensure that the interleaving is\nsatisfied. However, notice that this approach requires a delay and the\nassociated rescheduling. Presumably, this rescheduling overhead is what\nis being avoided by not using the rendezvous."),(0,a.kt)("p",null,"You might need to use an object in shared memory to communicate data\nbetween (Rationale 1995, \xa7C.5):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Ada tasks"),(0,a.kt)("li",{parentName:"ul"},"An Ada program and concurrent non-Ada processes"),(0,a.kt)("li",{parentName:"ul"},"An Ada program and hardware devices")),(0,a.kt)("p",null,"If your environment supports the Systems Programming Annex (Ada\nReference Manual 1995, Annex C), you should indicate whether loads and\nstores to the shared object must be indivisible. If you specify the\npragma Atomic, make sure that the object meets the underlying hardware\nrequirements for size and alignment. Multiple tasks sharing the\npredefined random number generator and certain input/output subprograms\ncan lead to problems with unprotected updates to shared state. The Ada\nReference Manual (1995, \xa7A.5.2) points out the need for tasks to\nsynchronize their access to the random number generators (packages\nAda.Numerics.Float","_","Random and Ada.Numerics.Discrete","_","Random). See\nGuideline 7.7.5 for the I/O issue."),(0,a.kt)("h3",u({},{id:"selective-accepts-and-entry-calls"}),"Selective Accepts and Entry Calls"),(0,a.kt)("h4",u({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use caution with conditional entry calls to task entries."),(0,a.kt)("li",{parentName:"ul"},"Use caution with selective accept with else parts."),(0,a.kt)("li",{parentName:"ul"},"Do not depend upon a particular delay in timed entry calls to task\nentries."),(0,a.kt)("li",{parentName:"ul"},"Do not depend upon a particular delay in selective accepts with\ndelay alternatives."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects instead of the rendezvous for\ndata-oriented synchronization.")),(0,a.kt)("h4",u({},{id:"example-11"}),"example"),(0,a.kt)("p",null,"The conditional entry call in the following code results in a potential\nrace condition that might degenerate into a busy waiting loop (i.e.,\nperform the same calculation over and over). The task Current","_","Position\ncontaining entry Request","_","New","_","Coordinates might never execute if the\nloop-containing task (shown in the following code fragment) has a higher\npriority than Current","_","Position because it does not release the\nprocessing resource:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Calculate_Flightpath is\nbegin\n   ...\n   loop\n  \n      select\n         Current_Position.Request_New_Coordinates (X, Y);\n         -- calculate projected location based on new coordinates\n         ...\n  \n      else\n         -- calculate projected location based on last locations\n         ...\n      end select;\n  \n   end loop;\n   ...\nend Calculate_Flightpath;\n")),(0,a.kt)("p",null,"The addition of a delay, as shown, may allow Current","_","Position to\nexecute until it reaches an accept for Request","_","New","_","Coordinates:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Calculate_Flightpath is\nbegin\n   ...\n   loop\n  \n      select\n         Current_Position.Request_New_Coordinates(X, Y);\n         -- calculate projected location based on new coordinates\n         ...\n  \n      else\n         -- calculate projected location based on last locations\n         ...\n  \n         delay until Time_To_Execute;\n         Time_To_Execute := Time_To_Execute + Period;\n      end select;\n  \n   end loop;\n   ...\nend Calculate_Flightpath;\n")),(0,a.kt)("p",null,"The following selective accept with else again does not degenerate into\na busy wait loop only because of the addition of a delay statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Buffer_Messages is\n\n   ...\n\nbegin\n\n   ...\n\n   loop\n      delay until Time_To_Execute;\n\n      select\n         accept Get_New_Message (Message : in     String) do\n            -- copy message to parameters\n            ...\n         end Get_New_Message;\n      else  -- Don't wait for rendezvous\n         -- perform built in test Functions\n         ...\n      end select;\n\n      Time_To_Execute := Time_To_Execute + Period;\n   end loop;\n\n   ...\n\nend Buffer_Messages;\n")),(0,a.kt)("p",null,"The following timed entry call might be considered an unacceptable\nimplementation if lost communications with the reactor for over 25\nmilliseconds results in a critical situation:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Monitor_Reactor is\n   ...\nbegin\n   ...\n   loop\n  \n      select\n         Reactor.Status(OK);\n  \n      or\n         delay 0.025;\n         -- lost communication for more that 25 milliseconds\n         Emergency_Shutdown;\n      end select;\n  \n      -- process reactor status\n      ...\n   end loop;\n   ...\nend Monitor_Reactor;\n")),(0,a.kt)("p",null,'In the following "selective accept with delay" example, the accuracy of\nthe coordinate calculation function is bounded by time. For example, the\nrequired accuracy cannot be obtained unless Period is within + or -\n0.005 seconds. This period cannot be guaranteed because of the\ninaccuracy of the delay statement:'),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task body Current_Position is\nbegin\n   ...\n   loop\n  \n      select\n         accept Request_New_Coordinates (X :    out Integer;\n                                         Y :    out Integer) do\n            -- copy coordinates to parameters\n            ...\n         end Request_New_Coordinates;\n  \n      or\n         delay until Time_To_Execute;\n      end select;\n  \n      Time_To_Execute := Time_To_Execute + Period;\n      -- Read Sensors\n      -- execute coordinate transformations\n   end loop;\n   ...\nend Current_Position;\n")),(0,a.kt)("h4",u({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"Use of these constructs always poses a risk of race conditions. Using\nthem in loops, particularly with poorly chosen task priorities , can\nhave the effect of busy waiting."),(0,a.kt)("p",null,'These constructs are very much implementation dependent. For conditional\nentry calls and selective accepts with else parts, the Ada Reference\nManual (1995, \xa79.7) does not define "immediately." For timed entry calls\nand selective accepts with delay alternatives, implementors might have\nideas of time that differ from each other and from your own. Like the\ndelay statement, the delay alternative on the select construct might\nwait longer than the time required (see Guideline 6.1.7).'),(0,a.kt)("p",null,"Protected objects offer an efficient means for providing data-oriented\nsynchronization. Operations on protected objects incur less execution\noverhead than tasks and are more efficient for data synchronization and\ncommunication than the rendezvous. See Guideline 6.1.1 for an example of\nthis use of protected objects."),(0,a.kt)("h3",u({},{id:"communication-complexity"}),"Communication Complexity"),(0,a.kt)("h4",u({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the number of accept and select statements per task ."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of accept statements per entry.")),(0,a.kt)("h4",u({},{id:"example-12"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"accept A;\nif Mode_1 then\n   -- do one thing\nelse  -- Mode_2\n   -- do something different\nend if;\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"if Mode_1 then\n   accept A;\n   -- do one thing\nelse  -- Mode_2\n   accept A;\n   -- do something different\nend if;\n")),(0,a.kt)("h4",u({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"This guideline reduces conceptual complexity. Only entries necessary to\nunderstand externally observable task behavior should be introduced. If\nthere are several different accept and select statements that do not\nmodify task behavior in a way important to the user of the task, there\nis unnecessary complexity introduced by the proliferation of\nselect/accept statements. Externally observable behavior important to\nthe task user includes task timing behavior, task rendezvous initiated\nby the entry calls, prioritization of entries, or data updates (where\ndata is shared between tasks)."),(0,a.kt)("h4",u({},{id:"notes-7"}),"notes"),(0,a.kt)("p",null,"Sanden (1994) argues that you need to trade off the complexity of the\nguards associated with the accept statements against the number of\nselect/accept statements. Sanden (1994) shows an example of a queue\ncontroller for bank tellers where there are two modes, open and closed.\nYou can implement this scenario with one loop and two select statements,\none for the open mode and the other for the closed mode. Although you\nare using more select/accept statements, Sanden (1994) argues that the\nresulting program is easier to understand and verify."),(0,a.kt)("h2",u({},{id:"termination"}),"Termination"),(0,a.kt)("p",null,"The ability of tasks to interact with each other using Ada's intertask\ncommunication features makes it especially important to manage planned\nor unplanned (e.g., in response to a catastrophic exception condition)\ntermination in a disciplined way. To do otherwise can lead to a\nproliferation of undesired and unpredictable side effects as a result of\nthe termination of a single task. The guidelines on termination focus on\nthe termination of tasks. Wherever possible, you should use protected\nobjects (see Guideline 6.1.1), thus avoiding the termination problems\nassociated with tasks."),(0,a.kt)("h3",u({},{id:"avoiding-undesired-termination"}),"Avoiding Undesired Termination"),(0,a.kt)("h4",u({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using an exception handler for a rendezvous within the main\nloop inside each task.")),(0,a.kt)("h4",u({},{id:"example-13"}),"example"),(0,a.kt)("p",null,"In the following example, an exception raised using the primary sensor\nis used to change Mode to Degraded still allowing execution of the\nsystem:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"...\nloop\n\n   Recognize_Degraded_Mode:\n      begin\n\n         case Mode is\n            when Primary =>\n               select\n                  Current_Position_Primary.Request_New_Coordinates (X, Y);\n               or\n                  delay 0.25;\n                  -- Decide whether to switch modes;\n               end select;\n\n            when Degraded =>\n\n               Current_Position_Backup.Request_New_Coordinates (X, Y);\n\n         end case;\n\n         ...\n      exception\n         when Tasking_Error | Program_Error =>\n            Mode := Degraded;\n      end Recognize_Degraded_Mode;\n\nend loop;\n...\n")),(0,a.kt)("h4",u({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"Allowing a task to terminate might not support the requirements of the\nsystem. Without an exception handler for the rendezvous within the main\ntask loop, the functions of the task might not be performed."),(0,a.kt)("h4",u({},{id:"notes-8"}),"notes"),(0,a.kt)("p",null,"The use of an exception handler is the only way to guarantee recovery\nfrom an entry call to an abnormal task. Use of the 'Terminated attribute\nto test a task's availability before making the entry call can introduce\na race condition where the tested task fails after the test but before\nthe entry call (see Guideline 6.2.3)."),(0,a.kt)("h3",u({},{id:"normal-termination"}),"Normal Termination"),(0,a.kt)("h4",u({},{id:"guideline-15"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not create nonterminating tasks unintentionally."),(0,a.kt)("li",{parentName:"ul"},"Explicitly shut down tasks that depend on library packages."),(0,a.kt)("li",{parentName:"ul"},"Confirm that a task is terminated before freeing it with\nAda.Unchecked","_","Deallocation."),(0,a.kt)("li",{parentName:"ul"},"Consider using a select statement with a terminate alternative\nrather than an accept statement alone."),(0,a.kt)("li",{parentName:"ul"},"Consider providing a terminate alternative for every selective\naccept that does not require an else part or a delay ."),(0,a.kt)("li",{parentName:"ul"},"Do not declare or create a task within a user-defined Finalize\nprocedure after the environment task has finished waiting for other\ntasks.")),(0,a.kt)("h4",u({},{id:"example-14"}),"example"),(0,a.kt)("p",null,"This task will never terminate:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"---------------------------------------------------------------------\ntask body Message_Buffer is\n   ...\nbegin  -- Message_Buffer\n   loop\n      select\n         when Head /= Tail => -- Circular buffer not empty\n            accept Retrieve (Value :    out Element) do\n               ...\n            end Retrieve;\n              \n      or\n         when not ((Head  = Index'First and then\n                    Tail  = Index'Last) or else\n                   (Head /= Index'First and then\n                    Tail  = Index'Pred(Head))    )\n                 => -- Circular buffer not full\n            accept Store (Value : in     Element);\n      end select;\n   end loop;\n...\nend Message_Buffer;\n---------------------------------------------------------------------\n")),(0,a.kt)("h4",u({},{id:"rationale-15"}),"rationale"),(0,a.kt)("p",null,"The implicit environment task does not terminate until all other tasks\nhave terminated. The environment task serves as a master for all other\ntasks created as part of the execution of the partition; it awaits\ntermination of all such tasks in order to perform finalization of any\nremaining objects of the partition. Thus, a partition will exist until\nall library tasks are terminated."),(0,a.kt)("p",null,"A nonterminating task is a task whose body consists of a nonterminating\nloop with no selective accept with terminate or a task that depends on a\nlibrary package. Execution of a subprogram or block containing a task\ncannot complete until the task terminates. Any task that calls a\nsubprogram containing a nonterminating task will be delayed\nindefinitely."),(0,a.kt)("p",null,"A task that depends on a library package cannot be forced to terminate\nusing a selective accept construct with alternative and should be\nterminated explicitly during program shutdown. One way to explicitly\nshut down tasks that depend on library packages is to provide them with\nexit entries and have the main subprogram call the exit entry just\nbefore it terminates."),(0,a.kt)("p",null,"The Ada Reference Manual (1995, \xa713.11.2) states that a bounded error\nresults from freeing a discriminated, unterminated task object. The\ndanger lies in deallocating the discriminants as a result of freeing the\ntask object. The effect of unterminated tasks containing bounded errors\nat the end of program execution is undefined."),(0,a.kt)("p",null,'Execution of an accept statement or of a selective accept statement\nwithout an else part, a delay, or a terminate alternative cannot proceed\nif no task ever calls the entry(s) associated with that statement. This\ncould result in deadlock. Following the guideline to provide a terminate\nalternative for every selective accept without an else or a delay\nentails programming multiple termination points in the task body. A\nreader can easily "know where to look" for the normal termination points\nin a task body. The termination points are the end of the body\'s\nsequence of statements and alternatives to select statements.'),(0,a.kt)("p",null,"When the environment task has been terminated, either normally or\nabnormally, the language does not specify whether to await a task\nactivated during finalization of the controlled objects in a partition.\nWhile the environment task is waiting for all other tasks in the\npartition to complete, starting up a new task during finalization\nresults in a bounded error (Ada Reference Manual 1995, \xa710.2). The\nexception Program","_","Error can be raised during creation or activation of\nsuch a task."),(0,a.kt)("h4",u({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"If you are implementing a cyclic executive, you might need a scheduling\ntask that does not terminate. It has been said that no real-time system\nshould be programmed to terminate. This is extreme. Systematic shutdown\nof many real-time systems is a desirable safety feature."),(0,a.kt)("p",null,"If you are considering programming a task not to terminate, be certain\nthat it is not a dependent of a block or subprogram from which the\ntask's caller(s) will ever expect to return. Because entire programs can\nbe candidates for reuse (see Chapter 8), note that the task (and\nwhatever it depends upon) will not terminate. Also be certain that for\nany other task that you do wish to terminate, its termination does not\nawait this task's termination. Reread and fully understand the Ada\nReference Manual (1995, \xa79.3) on \"Task Dependence-Termination of Tasks.\""),(0,a.kt)("h3",u({},{id:"the-abort-statement"}),"The Abort Statement"),(0,a.kt)("h4",u({},{id:"guideline-16"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using the abort statement."),(0,a.kt)("li",{parentName:"ul"},"Consider using the asynchronous select statement rather than the\nabort statement."),(0,a.kt)("li",{parentName:"ul"},"Minimize uses of the asynchronous select statement."),(0,a.kt)("li",{parentName:"ul"},"Avoid assigning nonatomic global objects from a task or from the\nabortable part of an asynchronous select statement.")),(0,a.kt)("h4",u({},{id:"example-15"}),"example"),(0,a.kt)("p",null,"If required in the application, provide a task entry for orderly\nshutdown."),(0,a.kt)("p",null,"The following example of asynchronous transfer of control shows a\ndatabase transaction. The database operation may be cancelled (through a\nspecial input key) unless the commit transaction has begun. The code is\nextracted from the Rationale (1995, \xa79.4):"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),'with Ada.Finalization;\npackage Txn_Pkg is\n   type Txn_Status is (Incomplete, Failed, Succeeded);\n   type Transaction is new Ada.Finalization.Limited_Controlled with private;\n   procedure Finalize (Txn : in out transaction);\n   procedure Set_Status (Txn    : in out Transaction;\n                         Status : in     Txn_Status);\nprivate\n   type Transaction is new Ada.Finalization.Limited_Controlled with\n      record\n         Status : Txn_Status := Incomplete;\n         pragma Atomic (Status);\n         . . . -- More components\n      end record;\nend Txn_Pkg;\n-----------------------------------------------------------------------------\npackage body Txn_Pkg is\n   procedure Finalize (Txn : in out Transaction) is\n   begin\n      -- Finalization runs with abort and ATC deferred\n      if Txn.Status = Succeeded then\n         Commit (Txn);\n      else\n         Rollback (Txn);\n      end if;\n   end Finalize;\n   . . . -- body of procedure Set_Status\nend Txn_Pkg;\n----------------------------------------------------------------------------\n-- sample code block showing how Txn_Pkg could be used:\ndeclare\n   Database_Txn : Transaction;\n   -- declare a transaction, will commit or abort during finalization\nbegin\n   select  -- wait for a cancel key from the input device\n      Input_Device.Wait_For_Cancel;\n      -- the Status remains Incomplete, so that the transaction will not commit\n   then abort  -- do the transaction\n      begin\n         Read (Database_Txn, . . .);\n         Write (Database_Txn, . . .);\n         . . .\n         Set_Status (Database_Txn, Succeeded);\n         -- set status to ensure the transaction is committed\n      exception\n         when others =>\n            Ada.Text_IO.Put_Line ("Operation failed with unhandled exception:");\n            Set_Status (Database_Txn, Failed);\n      end;\n   end select;\n   -- Finalize on Database_Txn will be called here and, based on the recorded\n   -- status, will either commit or abort the transaction.\nend;\n')),(0,a.kt)("h4",u({},{id:"rationale-16"}),"rationale"),(0,a.kt)("p",null,"When an abort statement is executed, there is no way to know what the\ntargeted task was doing beforehand. Data for which the target task is\nresponsible might be left in an inconsistent state. The overall effect\non the system of aborting a task in such an uncontrolled way requires\ncareful analysis. The system design must ensure that all tasks depending\non the aborted task can detect the termination and respond\nappropriately."),(0,a.kt)("p",null,"Tasks are not aborted until they reach an abort completion point such as\nbeginning or end of elaboration, a delay statement, an accept statement,\nan entry call, a select statement, task allocation, or the execution of\nan exception handler. Consequently, the abort statement might not\nrelease processor resources as soon as you might expect. It also might\nnot stop a runaway task because the task might be executing an infinite\nloop containing no abort completion points. There is no guarantee that a\ntask will not abort until an abort completion point in multiprocessor\nsystems, but the task will almost always stop running right away."),(0,a.kt)("p",null,"An asynchronous select statement allows an external event to cause a\ntask to begin execution at a new point, without having to abort and\nrestart the task (Rationale 1995, \xa79.3). Because the triggering\nstatement and the abortable statement execute in parallel until one of\nthem completes and forces the other to be abandoned, you need only one\nthread of control. The asynchronous select statement improves\nmaintainability because the abortable statements are clearly delimited\nand the transfer cannot be mistakenly redirected."),(0,a.kt)("p",null,"In task bodies and in the abortable part of an asynchronous select, you\nshould avoid assigning to nonatomic global objects, primarily because of\nthe risk of an abort occurring before the nonatomic assignment\ncompletes. If you have one or more abort statements in your application\nand the assignment is disrupted, the target object can become abnormal,\nand subsequent uses of the object lead to erroneous execution (Ada\nReference Manual 1995, \xa79.8). In the case of scalar objects, you can use\nthe attribute 'Valid, but there is no equivalent attribute for nonscalar\nobjects. (See Guideline 5.9.1 for a discussion of the 'Valid attribute.)\nYou also can still safely assign to local objects and call operations of\nglobal protected objects."),(0,a.kt)("h3",u({},{id:"abnormal-termination"}),"Abnormal Termination"),(0,a.kt)("h4",u({},{id:"guideline-17"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Place an exception handler for others at the end of a task body."),(0,a.kt)("li",{parentName:"ul"},"Consider having each exception handler at the end of a task body\nreport the task's demise."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on the task status to determine whether a rendezvous can\nbe made with the task.")),(0,a.kt)("h4",u({},{id:"example-16"}),"example"),(0,a.kt)("p",null,"This is one of many tasks updating the positions of blips on a radar\nscreen. When started, it is given part of the name by which its parent\nknows it. Should it terminate due to an exception, it signals the fact\nin one of its parent's data structures:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"task type Track (My_Index : Track_Index) is\n   ...\nend Track;\n---------------------------------------------------------------------\ntask body Track is\n     Neutral : Boolean := True;\nbegin  -- Track\n   select\n      accept ...\n      ...\n   or\n      terminate;\n   end select;\n   ...\nexception\n   when others =>\n      if not Neutral then\n         Station(My_Index).Status := Dead;\n      end if;\nend Track;\n---------------------------------------------------------------------\n")),(0,a.kt)("h4",u({},{id:"rationale-17"}),"rationale"),(0,a.kt)("p",null,"A task will terminate if an exception is raised within it for which it\nhas no handler. In such a case, the exception is not propagated outside\nof the task (unless it occurs during a rendezvous). The task simply dies\nwith no notification to other tasks in the program. Therefore, providing\nexception handlers within the task, and especially a handler for others,\nensures that a task can regain control after an exception occurs. If the\ntask cannot proceed normally after handling an exception, this affords\nit the opportunity to shut itself down cleanly and to notify tasks\nresponsible for error recovery necessitated by the abnormal termination\nof the task."),(0,a.kt)("p",null,"You should not use the task status to determine whether a rendezvous can\nbe made with the task. If Task A depends on Task B and Task A checks the\nstatus flag before it rendezvouses with Task B, there is a potential\nthat Task B fails between the status test and the rendezvous. In this\ncase, Task A must provide an exception handler to handle the\nTasking","_","Error exception raised by the call to an entry of an abnormal\ntask (see Guideline 6.3.1)."),(0,a.kt)("h3",u({},{id:"circular-task-calls"}),"Circular Task Calls"),(0,a.kt)("h4",u({},{id:"guideline-18"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not call a task entry that directly or indirectly results in a\ncall to an entry of the original calling task.")),(0,a.kt)("h4",u({},{id:"rationale-18"}),"rationale"),(0,a.kt)("p",null,"A software failure known as task deadlock will occur if a task calls one\nof its own entries directly or indirectly via a circular chain of calls."),(0,a.kt)("h3",u({},{id:"setting-exit-status"}),"Setting Exit Status"),(0,a.kt)("h4",u({},{id:"guideline-19"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid race conditions in setting an exit status code from the main\nprogram when using the procedure\nAda.Command","_","Line.Set","_","Exit","_","Status."),(0,a.kt)("li",{parentName:"ul"},"In a program with multiple tasks, encapsulate, serialize, and check\ncalls to the procedure Ada.Command","_","Line.Set","_","Exit","_","Status.")),(0,a.kt)("h4",u({},{id:"rationale-19"}),"rationale"),(0,a.kt)("p",null,"In accordance with the rules of Ada, tasks in library-level packages may\nterminate after the main program task. If the program permits multiple\ntasks to use Set","_","Exit","_","Status, then there can be no guarantee that any\nparticular status value is the one actually returned."),(0,a.kt)("h2",u({},{id:"summary"}),"Summary"),(0,a.kt)("h3",u({},{id:"concurrency-options-1"}),"concurrency options"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to provide mutually exclusive\naccess to data."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to control or synchronize access to\ndata shared by multiple tasks ."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to implement synchronization, such\nas a passive resource monitor."),(0,a.kt)("li",{parentName:"ul"},"Consider encapsulating protected objects in the private part or body\nof a package."),(0,a.kt)("li",{parentName:"ul"},"Consider using a protected procedure to implement an interrupt\nhandler."),(0,a.kt)("li",{parentName:"ul"},"Do not attach a protected procedure handler to a hardware interrupt\nif that interrupt has a maximum priority greater than the ceiling\npriority assigned to the handler."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of global variables in entry barriers."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of barrier expressions with side effects."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to model selected asynchronous threads of control within\nthe problem domain."),(0,a.kt)("li",{parentName:"ul"},"Consider using tasks to define concurrent algorithms."),(0,a.kt)("li",{parentName:"ul"},"Consider using rendezvous when your application requires synchronous\nunbuffered communication."),(0,a.kt)("li",{parentName:"ul"},"Consider using discriminants to minimize the need for an explicit\ninitialization operation (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using discriminants to control composite components of the\nprotected objects, including setting the size of an entry family\n(Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using a discriminant to set the priority of a protected\nobject (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider using a discriminant to identify an interrupt to a\nprotected object (Rationale 1995, \xa79.1)."),(0,a.kt)("li",{parentName:"ul"},"Consider declaring a task type with a discriminant to indicate\n(Rationale 1995, \xa79.6):",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Priority, storage size, and size of entry families of individual\ntasks of a type"),(0,a.kt)("li",{parentName:"ul"},"Data associated with a task (through an access discriminant)"))),(0,a.kt)("li",{parentName:"ul"},"Consider using single task declarations to declare unique instances\nof concurrent tasks."),(0,a.kt)("li",{parentName:"ul"},"Consider using single protected declarations to declare unique\ninstances of protected objects."),(0,a.kt)("li",{parentName:"ul"},"Minimize dynamic creation of tasks because of the potentially high\nstartup overhead; reuse tasks by having them wait for new work on\nsome appropriate entry queue."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on pragma Priority unless your compiler supports the\nReal-Time Annex (Ada Reference Manual 1995, Annex D) and priority\nscheduling."),(0,a.kt)("li",{parentName:"ul"},"Minimize risk of priority inversion by use of protected objects and\nceiling priority."),(0,a.kt)("li",{parentName:"ul"},"Do not rely upon task priorities to achieve a particular sequence of\ntask execution."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on a particular delay being achievable (Nissen and\nWallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Use a delay until not a delay statement to delay until a specific\ntime has been reached."),(0,a.kt)("li",{parentName:"ul"},"Avoid using a busy waiting loop instead of a delay."),(0,a.kt)("li",{parentName:"ul"},"Carefully consider the placement of components of protected types\nwithin a tagged type inheritance hierarchy."),(0,a.kt)("li",{parentName:"ul"},"Consider using generics to provide extensibility of data types\nrequiring the restrictions provided by protected objects.")),(0,a.kt)("h3",u({},{id:"communication-1"}),"communication"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the work performed during a rendezvous ."),(0,a.kt)("li",{parentName:"ul"},"Minimize the work performed in the selective accept loop of a task."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects for data synchronization and\ncommunication."),(0,a.kt)("li",{parentName:"ul"},"Provide a handler for exception Program","_","Error whenever you cannot\navoid a selectiveaccept statement whose alternatives can all be\nclosed (Honeywell 1986)."),(0,a.kt)("li",{parentName:"ul"},"Make systematic use of handlers for Tasking","_","Error."),(0,a.kt)("li",{parentName:"ul"},"Be prepared to handle exceptions during a rendezvous ."),(0,a.kt)("li",{parentName:"ul"},"Consider using a when others exception handler."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on the values of the task attributes 'Callable or\n'Terminated (Nissen and Wallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on attributes to avoid Tasking","_","Error on an entry\ncall."),(0,a.kt)("li",{parentName:"ul"},"For tasks, do not depend on the value of the entry attribute 'Count."),(0,a.kt)("li",{parentName:"ul"},"Using the 'Count attribute with protected entries is more reliable\nthan using the 'Count attribute with task entries."),(0,a.kt)("li",{parentName:"ul"},"Use calls on protected subprograms or entries to pass data between\ntasks rather than unprotected shared variables."),(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables as a task synchronization\ndevice."),(0,a.kt)("li",{parentName:"ul"},"Do not reference nonlocal variables in a guard ."),(0,a.kt)("li",{parentName:"ul"},"If an unprotected shared variable is necessary, use the pragma\nVolatile or Atomic."),(0,a.kt)("li",{parentName:"ul"},"Use caution with conditional entry calls to task entries."),(0,a.kt)("li",{parentName:"ul"},"Use caution with selective accepts with else parts."),(0,a.kt)("li",{parentName:"ul"},"Do not depend upon a particular delay in timed entry calls to task\nentries."),(0,a.kt)("li",{parentName:"ul"},"Do not depend upon a particular delay in selective accepts with\ndelay alternatives."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects instead of the rendezvous for\ndata-oriented synchronization."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of accept and select statements per task ."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of accept statements per entry.")),(0,a.kt)("h3",u({},{id:"termination-1"}),"termination"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using an exception handler for a rendezvous within the main\nloop inside each task."),(0,a.kt)("li",{parentName:"ul"},"Do not create nonterminating tasks unintentionally."),(0,a.kt)("li",{parentName:"ul"},"Explicitly shut down tasks that depend on library packages."),(0,a.kt)("li",{parentName:"ul"},"Confirm that a task is terminated before freeing it with\nAda.Unchecked","_","Deallocation."),(0,a.kt)("li",{parentName:"ul"},"Consider using a select statement with a terminate alternative\nrather than an accept statement alone."),(0,a.kt)("li",{parentName:"ul"},"Consider providing a terminate alternative for every selective\naccept that does not require an else part or a delay."),(0,a.kt)("li",{parentName:"ul"},"Do not declare or create a task within a user-defined Finalize\nprocedure after the environment task has finished waiting for other\ntasks."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the abort statement."),(0,a.kt)("li",{parentName:"ul"},"Consider using the asynchronous select statement rather than the\nabort statement."),(0,a.kt)("li",{parentName:"ul"},"Minimize uses of the asynchronous select statement."),(0,a.kt)("li",{parentName:"ul"},"Avoid assigning nonatomic global objects from a task or from the\nabortable part of an asynchronous select statement."),(0,a.kt)("li",{parentName:"ul"},"Place an exception handler for others at the end of a task body."),(0,a.kt)("li",{parentName:"ul"},"Consider having each exception handler at the end of a task body\nreport the task's demise."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on the task status to determine whether a rendezvous can\nbe made with the task."),(0,a.kt)("li",{parentName:"ul"},"Do not call a task entry that directly or indirectly results in a\ncall to an entry of the original calling task."),(0,a.kt)("li",{parentName:"ul"},"Avoid race conditions in setting an exit status code from the main\nprogram when using the procedure\nAda.Command","_","Line.Set","_","Exit","_","Status."),(0,a.kt)("li",{parentName:"ul"},"In a program with multiple tasks, encapsulate, serialize, and check\ncalls to the procedure Ada.Command","_","Line.Set","_","Exit","_","Status.\n:::note")),(0,a.kt)("p",null,'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",u({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",u({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply.  Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work."),(0,a.kt)("p",null,":::"))}f.isMDXComponent=!0}}]);