"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2464],{6880:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>k,default:()=>b,frontMatter:()=>h,metadata:()=>f,toc:()=>y});var o=n(1716),i=n(7556),a=n(7353),l=Object.defineProperty,s=Object.defineProperties,r=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))m.call(t,n)&&u(e,n,t[n]);if(p)for(var n of p(t))d.call(t,n)&&u(e,n,t[n]);return e};const h={sidebar_position:138},k="B.1 Interfacing Aspects",f={unversionedId:"arm/AA-B/AA-B.1",id:"arm/AA-B/AA-B.1",title:"B.1 Interfacing Aspects",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-B/AA-B.1.mdx",sourceDirName:"arm/AA-B",slug:"/arm/AA-B/AA-B.1",permalink:"/docs/arm/AA-B/AA-B.1",draft:!1,tags:[],version:"current",sidebarPosition:138,frontMatter:{sidebar_position:138},sidebar:"referenceManualSidebar",previous:{title:"Annex B Interface to Other Languages",permalink:"/docs/arm/AA-B/"},next:{title:"B.2 The Package Interfaces",permalink:"/docs/arm/AA-B/AA-B.2"}},g={},y=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],A={toc:y};function b(e){var t,n=e,{components:l}=n,u=((e,t)=>{var n={};for(var o in e)m.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&p)for(var o of p(e))t.indexOf(o)<0&&d.call(e,o)&&(n[o]=e[o]);return n})(n,["components"]);return(0,o.kt)("wrapper",(t=c(c({},A),u),s(t,r({components:l,mdxType:"MDXLayout"}))),(0,o.kt)("h1",c({},{id:"b1-interfacing-aspects"}),"B.1 Interfacing Aspects"),(0,o.kt)("admonition",c({},{type:"warning"}),(0,o.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,o.kt)("a",c({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," An ",(0,o.kt)("em",null,"interfacing")," aspect is a representation aspect that is one of the aspects Import, Export, Link_Name, External_Name, or Convention."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0269-1"),"}"," Specifying the Import aspect  to have the value True is used to import an entity defined in a foreign language into an Ada program, thus allowing a foreign-language subprogram to be called from Ada, or a foreign-language variable to be accessed from Ada. In contrast, specifying the Export aspect to have the value True is used to export an Ada entity to a foreign language, thus allowing an Ada subprogram to be called from a foreign language, or an Ada object to be accessed from a foreign language. The Import and Export aspects are intended primarily for objects and subprograms, although implementations are allowed to support other entities. The Link_Name and External_Name aspects are used to specify the link name and external name, respectively, to be used to identify imported or exported entities in the external environment. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Import: "),"Entity is imported from another language.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Export: "),"Entity is exported to another language.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"External_Name: "),"Name used to identify an imported or exported entity.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Link_Name: "),"Linker symbol used to identify an imported or exported entity.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}",' The Convention aspect is used to indicate that an Ada entity should use the conventions of another language. It is intended primarily for types and "callback" subprograms. For example, "',(0,o.kt)("strong",null,"with")," Convention =",">",' Fortran" on the declaration of an array type Matrix implies that Matrix should be represented according to the conventions of the supported Fortran implementation, namely column-major order.'),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Convention: "),"Calling convention or other convention used for interfacing to other languages.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0445-1"),"}"," A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Linker_Options is used to specify the system linker parameters necessary when a given compilation unit is included in a partition."),(0,o.kt)("h4",c({},{id:"syntax"}),"Syntax"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Linker_Options is as follows: "),(0,o.kt)("p",null,(0,o.kt)("em",null,'Paragraphs 5 through 7 were moved to Annex J, "Obsolescent Features".')," "),(0,o.kt)("p",null,"  ",(0,o.kt)("strong",null,"pragma")," Linker_Options(",(0,o.kt)("em",null,"string_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),");"),(0,o.kt)("p",null,"A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Linker_Options is allowed only at the place of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.11#S0087"},"declarative_item")),"."),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"8652/0058"),"}"," ","{",(0,o.kt)("em",null,"AI95-00036-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," "),(0,o.kt)("h4",c({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The Import and Export aspects are of type Boolean."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The Link_Name and External_Name aspects are of type String. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"There is no language-defined support for external or link names of type Wide_String, or of other string types. Implementations may, of course, have additional aspects for that purpose. Note that allowing both String and Wide_String in the same ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," would cause ambiguities. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The expected type for the ",(0,o.kt)("em",null,"string_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," in pragma Linker_Options is String."),(0,o.kt)("h4",c({},{id:"legality-rules"}),"Legality Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The aspect Convention shall be specified by a ",(0,o.kt)("em",null,"convention_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," which shall be the name of a ",(0,o.kt)("em",null,"convention"),'. The convention names are implementation defined, except for certain language-defined ones, such as Ada and Intrinsic, as explained in 6.3.1, "Conformance Rules". [Additional convention names generally represent the calling conventions of foreign languages, language implementations, or specific run-time models.] The convention of a callable entity is its ',(0,o.kt)("em",null,"calling convention"),". "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation defined: "),"Implementation-defined convention names.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"We considered representing the convention names using an enumeration type declared in System. Then, ",(0,o.kt)("em",null,"convention_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," would be changed to ",(0,o.kt)("em",null,"convention_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", and we would make its expected type be the enumeration type. We didn't do this because it seems to introduce extra complexity, and because the list of available languages is better represented as the list of children of package Interfaces - a more open-ended sort of list. ")),(0,o.kt)("p",null,"If ",(0,o.kt)("em",null,"L")," is a ",(0,o.kt)("em",null,"convention_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for a language, then a type T is said to be ",(0,o.kt)("em",null,"compatible with convention L"),", (alternatively, is said to be an ",(0,o.kt)("em",null,"L-compatible type"),") if any of the following conditions are met: "),(0,o.kt)("p",null,"T is declared in a language interface package corresponding to ",(0,o.kt)("em",null,"L")," and is defined to be ",(0,o.kt)("em",null,"L"),"-compatible (see B.3, B.3.1, B.3.2, B.4, B.5),"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," Convention ",(0,o.kt)("em",null,"L")," has been specified for T, and T is ",(0,o.kt)("em",null,"eligible for convention L"),"; that is: "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0135-1"),"}"," T is an enumeration type such that all internal codes (whether assigned by default or explicitly) are within an implementation-defined range that includes at least the range of values 0 .. 2**151;"),(0,o.kt)("p",null,"T is an array type with either an unconstrained or statically-constrained first subtype, and its component type is ",(0,o.kt)("em",null,"L"),"-compatible,"),(0,o.kt)("p",null,"T is a record type that has no discriminants and that only has components with statically-constrained subtypes, and each component type is ",(0,o.kt)("em",null,"L"),"-compatible,"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0002-1"),"}"," T is an access-to-object type, its designated type is ",(0,o.kt)("em",null,"L"),"-compatible, and its designated subtype is not an unconstrained array subtype,"),(0,o.kt)("p",null,"T is an access-to-subprogram type, and its designated profile's parameter and result types are all ",(0,o.kt)("em",null,"L"),"-compatible. "),(0,o.kt)("p",null,"T is derived from an ",(0,o.kt)("em",null,"L"),"-compatible type,"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0207-1"),"}"," T is an anonymous access type, and T is eligible for convention ",(0,o.kt)("em",null,"L"),","),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We say this so that the presence of an anonymous access component does not necessarily prevent a type from being eligible for convention ",(0,o.kt)("em",null,"L"),". We want the anonymous access type to take the convention from the enclosing type, but if we only said that, the definition would be circular (one can only portably apply the convention ",(0,o.kt)("em",null,"L")," to a record type R if the components of R already have convention ",(0,o.kt)("em",null,"L"),"; but the anonymous components of R have to take the convention from R). We include the part of about T being eligible for convention ",(0,o.kt)("em",null,"L")," so that we don't force convention ",(0,o.kt)("em",null,"L")," on some type that is incompatible with it. ")),(0,o.kt)("p",null,"The implementation permits T as an ",(0,o.kt)("em",null,"L"),"-compatible type."),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"For example, an implementation might permit Integer as a C-compatible type, though the C type to which it corresponds might be different in different environments. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," If the Convention aspect is specified for a type, then the type shall either be compatible with or eligible for the specified convention. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," If a type is derived from an ",(0,o.kt)("em",null,"L"),"-compatible type, the derived type is by default ",(0,o.kt)("em",null,"L"),"-compatible, but it is also permitted to specify the Convention aspect for the derived type.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," It is permitted to specify the Convention aspect for an incomplete type, but in the complete declaration each component must be ",(0,o.kt)("em",null,"L"),"-compatible.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," If each component of a record type is ",(0,o.kt)("em",null,"L"),"-compatible, then the record type itself is only ",(0,o.kt)("em",null,"L"),"-compatible if it has a specified Convention. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0207-1"),"}"," If convention ",(0,o.kt)("em",null,"L")," is specified for a type T, for each component of T that has an anonymous access type, the convention of the anonymous access type is ",(0,o.kt)("em",null,"L"),". If convention ",(0,o.kt)("em",null,"L")," is specified for an object that has an anonymous access type, the convention of the anonymous access type is ",(0,o.kt)("em",null,"L"),"."),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This applies to both anonymous access-to-object and anonymous access-to-subprogram types. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," Notwithstanding any rule to the contrary, a declaration with a True Import aspect shall not have a completion. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," For declarations of deferred constants and subprograms, we explicitly mention that no completion is allowed when aspect Import is True. For other declarations that require completions, we ignore the possibility of the aspect Import being True. Nevertheless, if an implementation chooses to allow specifying aspect Import to be True for the declaration of a task, protected type, incomplete type, private type, etc., it may do so, and the normal completion is then not allowed for that declaration. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}","  An entity with a True Import aspect (or Export aspect) is said to be ",(0,o.kt)("em",null,"imported")," (respectively, ",(0,o.kt)("em",null,"exported"),"). An entity shall not be both imported and exported."),(0,o.kt)("p",null,"The declaration of an imported object shall not include an explicit initialization expression. [Default initializations are not performed.] "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),'This follows from the "Notwithstanding ..." wording in the Dynamics Semantics paragraphs below. ')),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The type of an imported or exported object shall be compatible with the specified Convention aspect, if any. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This implies, for example, that importing an Integer object might be illegal, whereas importing an object of type Interfaces.C.int would be permitted. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," For an imported or exported subprogram, the result and parameter types shall each be compatible with the specified Convention aspect, if any."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," (if any) used to directly specify an Import, Export, External_Name, or Link_Name aspect shall be a static expression. The ",(0,o.kt)("em",null,"string_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Linker_Options shall be static. An External_Name or Link_Name aspect shall be specified only for an entity that is either imported or exported."),(0,o.kt)("h4",c({},{id:"static-semantics"}),"Static Semantics"),(0,o.kt)("p",null,(0,o.kt)("em",null,"Paragraphs 28 and 29 were deleted.")," "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The Convention aspect represents the calling convention or representation convention of the entity. For an access-to-subprogram type, it represents the calling convention of designated subprograms. In addition: "),(0,o.kt)("p",null,"A True Import aspect indicates that the entity is defined externally (that is, outside the Ada program). This aspect is never inherited; if not directly specified, the Import aspect is False."),(0,o.kt)("p",null,"A True Export aspect indicates that the entity is used externally. This aspect is never inherited; if not directly specified, the Export aspect is False."),(0,o.kt)("p",null,"For an entity with a True Import or Export aspect, an external name, link name, or both may also be specified. "),(0,o.kt)("p",null,"An ",(0,o.kt)("em",null,"external name")," is a string value for the name used by a foreign language program either for an entity that an Ada program imports, or for referring to an entity that an Ada program exports."),(0,o.kt)("p",null,"A ",(0,o.kt)("em",null,"link name")," is a string value for the name of an exported or imported entity, based on the conventions of the foreign language's compiler in interfacing with the system's linker tool."),(0,o.kt)("p",null,"The meaning of link names is implementation defined. If neither a link name nor the Address attribute of an imported or exported entity is specified, then a link name is chosen in an implementation-defined manner, based on the external name if one is specified. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation defined: "),"The meaning of link names.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),'For example, an implementation might always prepend "_", and then pass it to the system linker. ')),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation defined: "),"The manner of choosing link names when neither the link name nor the address of an imported or exported entity is specified.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Normally, this will be the entity's defining name, or some simple transformation thereof. ")),(0,o.kt)("p",null,"Pragma Linker_Options has the effect of passing its string argument as a parameter to the system linker (if one exists), if the immediately enclosing compilation unit is included in the partition being linked. The interpretation of the string argument, and the way in which the string arguments from multiple Linker_Options pragmas are combined, is implementation defined. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation defined: "),"The effect of pragma Linker_Options.")),(0,o.kt)("h4",c({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," Notwithstanding what this document says elsewhere, the elaboration of a declaration with a True Import aspect does not create the entity. Such an elaboration has no other effect than to allow the defining name to denote the external entity. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This implies that default initializations are skipped. (Explicit initializations are illegal.) For example, an imported access object is ",(0,o.kt)("em",null,"not")," initialized to ",(0,o.kt)("strong",null,"null"),".")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}",' This "notwithstanding" wording is better than saying "unless aspect Import is True" on every definition of elaboration. It says we recognize the contradiction, and this rule takes precedence. ')),(0,o.kt)("h4",c({},{id:"erroneous-execution"}),"Erroneous Execution"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00320-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0219-1"),"}"," It is the programmer's responsibility to ensure that the use of interfacing aspects does not violate Ada semantics; otherwise, program execution is erroneous. For example, passing an object with mode ",(0,o.kt)("strong",null,"in")," to imported code that modifies it causes erroneous execution. Similarly, calling an imported subprogram that is not pure from a pure package causes erroneous execution. "),(0,o.kt)("h4",c({},{id:"implementation-advice"}),"Implementation Advice"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}",' If an implementation supports Export for a given language, then it should also allow the main subprogram to be written in that language. It should support some mechanism for invoking the elaboration of the Ada library units included in the system, and for invoking the finalization of the environment task. On typical systems, the recommended mechanism is to provide two subprograms whose link names are "adainit" and "adafinal". Adainit should contain the elaboration code for library units. Adafinal should contain the finalization code. These subprograms should have no effect the second and subsequent time they are called. '),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Advice: "),'If  Export is supported for a language, the main program should be able to be written in that language. Subprograms named "adainit" and "adafinal" should be provided for elaboration and finalization of the environment task.')),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"For example, if the main subprogram is written in C, it can call adainit before the first call to an Ada subprogram, and adafinal after the last. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0269-1"),"}"," Automatic elaboration of preelaborated packages should be provided when specifying the Export aspect as True is supported. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Advice: "),"Automatic elaboration of preelaborated packages should be provided when specifying the Export aspect as True is supported.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0135-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0444-1"),"}"," For each supported convention ",(0,o.kt)("em",null,"L")," other than Intrinsic, an implementation should support specifying the Import and Export aspects for objects of ",(0,o.kt)("em",null,"L"),"-compatible types and for subprograms, and the Convention aspect for ",(0,o.kt)("em",null,"L"),"-eligible types and for subprograms, presuming the other language has corresponding features. Specifying the  Convention aspect should be supported for enumeration types whose internal codes fall within the range 0 .. 2**151, but no recommendation is made for other scalar types. "),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Advice: "),"For each supported convention ",(0,o.kt)("em",null,"L")," other than Intrinsic, specifying the aspects Import and Export should be supported for objects of ",(0,o.kt)("em",null,"L"),"-compatible types and for subprograms, and aspect Convention should be supported for ",(0,o.kt)("em",null,"L"),"-eligible types and for subprograms.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," Specifying aspect Convention is not necessary for scalar types, since the language interface packages declare scalar types corresponding to those provided by the respective foreign languages. ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," If an implementation supports interfacing to the C++ entities not supported by B.3, it should do so via the convention identifier C_Plus_Plus (in additional to any C++-implementation-specific ones). ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," The reason for giving the advice about C++ is to encourage uniformity among implementations, given that the name of the language is not syntactically legal as an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),". ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 1   ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0440-1"),"}"," Implementations can place restrictions on interfacing aspects; for example, requiring each exported entity to be declared at the library level. ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),"Arbitrary restrictions are allowed by 13.1. ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Such a restriction might be to disallow them altogether. Alternatively, the implementation might allow them only for certain kinds of entities, or only for certain conventions. ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 2   ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," The Convention aspect in combination with the Import aspect indicates the conventions for accessing external entities. It is possible that the actual entity is written in assembly language, but reflects the conventions of a particular language. For example, ",(0,o.kt)("strong",null,"with")," Convention =",">"," Ada can be used to interface to an assembly language routine that obeys the Ada compiler's calling conventions.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 3   ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0440-1"),"}",' To obtain "call-back" to an Ada subprogram from a foreign language environment, the Convention aspect can be specified both for the access-to-subprogram type and the specific subprogram(s) to which \'Access is applied.')),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("em",null,"Paragraphs 45 and 46 were deleted.")," ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,'NOTE 4   See also 13.8, "Machine Code Insertions". ')),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}",' The Intrinsic convention (see 6.3.1) implies that the entity is somehow "built in" to the implementation. Thus, it generally does not make sense for users to specify Intrinsic along with specifying that the entity is imported. The intention is that only implementations will specify Intrinsic for an imported entity. The language also defines certain subprograms to be Intrinsic. ')),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," There are many imaginable interfacing aspects that don't make any sense. For example, setting the Convention of a protected procedure to Ada is probably wrong. Rather than enumerating all such cases, however, we leave it up to implementations to decide what is sensible. ")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 5   ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," If both External_Name and Link_Name are specified for a given entity, then the External_Name is ignored.")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00320-01"),"}"," ")),(0,o.kt)("h4",c({},{id:"examples"}),"Examples"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0080-1"),"}"," ",(0,o.kt)("em",null,"Example of interfacing aspects:")," "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0229-1","}"," ","{","AI05-0269-1","}"," package Fortran_Library is","\n","  function Sqrt (X : Float) return Float","\n","    with Import =",">"," True, Convention =",">"," Fortran;","\n","  type Matrix is array (Natural range ","<",">",", Natural range ","<",">",") of Float","\n","    with Convention =",">"," Fortran;","\n","  function Invert (M : Matrix) return Matrix","\n","    with Import =",">"," True, Convention =",">"," Fortran;","\n","end Fortran_Library;","\n"),(0,o.kt)("h4",c({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"Interfacing pragmas are new to Ada 95. Pragma Import replaces Ada 83's pragma Interface. Existing implementations can continue to support pragma Interface for upward compatibility. ")),(0,o.kt)("h4",c({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0058"),"}"," ","{",(0,o.kt)("em",null,"AI95-00036-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Clarified that ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s Import and Export work like a subprogram call; parameters cannot be omitted unless named notation is used. (Reordering is still not permitted, however.)")),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00320-01"),"}"," Added wording to say all bets are off if foreign code doesn't follow the semantics promised by the Ada specifications. ")),(0,o.kt)("h4",c({},{id:"incompatibilities-with-ada-2005"}),"Incompatibilities With Ada 2005"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0002-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Access types that designate unconstrained arrays are no longer defined to be ",(0,o.kt)("em",null,"L"),"-compatible. Such access-to-arrays require bounds information, which is likely to be incompatible with a foreign language. The change will allow (but not require) compilers to reject bad uses, which probably will not work anyway. Note that implementations can still support any type that it wants as ",(0,o.kt)("em",null,"L"),"-compatible; such uses will not be portable, however. As such, there should be little existing code that will be impacted (compilers probably already rejected cases that could not be translated, whether or not the language allowed doing so formally). ")),(0,o.kt)("h4",c({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," Aspects Convention, Import, Export, Link_Name, and External_Name are new; ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s Convention, Import, and Export are now obsolescent. ")),(0,o.kt)("h4",c({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0207-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," The convention of anonymous access components is that of the enclosing type (in Ada 2012, it was Ada). Similarly, the convention of the anonymous access type of an object is that of the object (again, in Ada 2012 it was Ada). While this is formally incompatible, it should be more useful in portable code; it makes little sense to have a component of an Ada access type in a record with a C convention. For most implementations, this will have no real effect as convention Ada anonymous access types were allowed as C-compatible anyway. But such code was not portable, as this was not required in Ada 2012. ")),(0,o.kt)("h4",c({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0135-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Added a suggestion that convention be supported for enumeration types. This will make the use of enumeration types portable for implementations that support interfacing to a particular language. ")),(0,o.kt)("h4",c({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,o.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0219-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Added some examples to the erroneous execution text; this is a very important rule as it means that Ada compilers can assume that provided interfacing declarations reflect the actual foreign code. ")))}b.isMDXComponent=!0}}]);