"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9014],{53511:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>u,contentTitle:()=>d,default:()=>A,frontMatter:()=>l,metadata:()=>y,toc:()=>m});var n=t(58168),s=(t(96540),t(15680)),r=t(20793),i=t(91435),o=(t(21432),t(79162)),c=t(34421);const l={sidebar_position:114},d="13.10 Unchecked Access Value Creation",y={unversionedId:"arm/AA-13/AA-13.10",id:"arm/AA-13/AA-13.10",title:"13.10 Unchecked Access Value Creation",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-13/AA-13.10.mdx",sourceDirName:"arm/AA-13",slug:"/arm/AA-13/AA-13.10",permalink:"/docs/arm/AA-13/AA-13.10",draft:!1,tags:[],version:"current",sidebarPosition:114,frontMatter:{sidebar_position:114},sidebar:"referenceManualSidebar",previous:{title:"13.9 Unchecked Type Conversions",permalink:"/docs/arm/AA-13/AA-13.9"},next:{title:"13.11 Storage Management",permalink:"/docs/arm/AA-13/AA-13.11"}},u={},m=[{value:"Static Semantics",id:"static-semantics",level:4}],g={toc:m},p="wrapper";function A(e){let{components:a,...t}=e;return(0,s.yg)(p,(0,n.A)({},g,t,{components:a,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"1310-unchecked-access-value-creation"},"13.10 Unchecked Access Value Creation"),(0,s.yg)("admonition",{type:"warning"},(0,s.yg)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,s.yg)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,s.yg)(o.A,{mdxType:"MarginText"},"1"),(0,s.yg)("p",null,"[The attribute Unchecked_Access is used to create access values in an unsafe manner \u2014 the programmer is responsible for preventing \u201cdangling references\u201d.] ",(0,s.yg)("br",null)),(0,s.yg)("h4",{id:"static-semantics"},"Static Semantics"),(0,s.yg)(o.A,{mdxType:"MarginText"},"2"),(0,s.yg)("p",null,"The following attribute is defined for a ",(0,s.yg)("code",null,(0,s.yg)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," X that denotes an aliased view of an object: ",(0,s.yg)("br",null)),(0,s.yg)(o.A,{mdxType:"MarginText"},"3"),(0,s.yg)("dt",null,(0,s.yg)("br",null),"X'Unchecked_Access"),(0,s.yg)("dl",null,(0,s.yg)("dd",null,"All rules and semantics that apply to X'Access (see ",(0,s.yg)("a",{href:"../AA-3/AA-3.10#Subclause_3.10.2"},"3.10.2"),") apply also to X'Unchecked_Access, except that, for the purposes of accessibility rules and checks, it is as if X were declared immediately within a library package. ",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"3.a/3"),(0,s.yg)(c.A,{items:["AI05-0005-1"],mdxType:"MarginInfo"}),(0,s.yg)(r.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,s.yg)("strong",null),"We say \u201crules and semantics\u201d here so that library-level accessibility applies to the value created by X'Unchecked_Access as well as to the checks needed for the attribute itself. This means that any anonymous access values that inherit the accessibility of this attribute (such as access parameters) also act as if they have library-level accessibility. We don't want the \"real\" accessibility of the created value re-emerging at a later point \u2013 that would create hard-to-understand bugs. ",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"4/5"),(0,s.yg)(c.A,{items:["AI12-0449-1"],mdxType:"MarginInfo"}),(0,s.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   This attribute is provided to support the situation where a local object is to be inserted into a global linked data structure, when the programmer knows that it will always be removed from the data structure prior to exiting the object's scope. The Access attribute would be illegal in this case (see ",(0,s.yg)("a",{href:"../AA-3/AA-3.10#Subclause_3.10.2"},"3.10.2"),"). ",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"4.a"),(0,s.yg)(r.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,s.yg)("strong",null),"The expected type for X'Unchecked_Access is as for X'Access.",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"4.b"),(0,s.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"If an ",(0,s.yg)("code",null,(0,s.yg)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," with Unchecked_Access is used as the actual parameter for an access parameter, an Accessibility_Check can never fail on that access parameter. ",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"5"),(0,s.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   There is no Unchecked_Access attribute for subprograms. ",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"5.a/2"),(0,s.yg)(c.A,{items:["AI95-00254-01"],mdxType:"MarginInfo"}),(0,s.yg)(r.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,s.yg)("strong",null),"Such an attribute would allow unsafe \u201cdownward closures\u201d, where an access value designating a more nested subprogram is passed to a less nested subprogram. (Anonymous access-to-subprogram parameters provide safe \u201cdownward closures\u201d.) This requires some means of reconstructing the global environment for the more nested subprogram, so that it can do up-level references to objects. The two methods of implementing up-level references are displays and static links. If unsafe downward closures were supported, each access-to-subprogram value would have to carry the static link or display with it. We don't want to require the space and time overhead of requiring the extra information for all access-to-subprogram types, especially as including it would make interfacing to other languages (like C) harder.",(0,s.yg)("br",null))),(0,s.yg)(i.A,{mdxType:"AnnotatedOnly"},(0,s.yg)(o.A,{mdxType:"MarginText"},"5.b"),(0,s.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"If desired, an instance of Unchecked_Conversion can be used to create an access value of a global access-to-subprogram type that designates a local subprogram. The semantics of using such a value are not specified by the language. In particular, it is not specified what happens if such subprograms make up-level references; even if the frame being referenced still exists, the up-level reference might go awry if the representation of a value of a global access-to-subprogram type doesn't include a static link. ",(0,s.yg)("br",null))))}A.isMDXComponent=!0}}]);