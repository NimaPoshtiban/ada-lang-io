"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1956],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(a),h=i,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,s=new Array(o);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1492:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const o={sidebar_position:14},s="13 Representation Issues",r={unversionedId:"arm/AA-13",id:"arm/AA-13",title:"13 Representation Issues",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-13.md",sourceDirName:"arm",slug:"/arm/AA-13",permalink:"/docs/arm/AA-13",draft:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"12 Generic Units",permalink:"/docs/arm/AA-12"},next:{title:"Annex A Predefined Language Environment",permalink:"/docs/arm/AA-Annex A"}},l={},c=[{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"13.1  Representation Items",id:"131--representation-items",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"13.2  Pragma Pack",id:"132--pragma-pack",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"13.3  Representation Attributes",id:"133--representation-attributes",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Advice",id:"implementation-advice-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Language Design Principles",id:"language-design-principles-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Implementation Advice",id:"implementation-advice-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Implementation Advice",id:"implementation-advice-4",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice-5",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"Implementation Advice",id:"implementation-advice-6",level:4},{value:"Static Semantics",id:"static-semantics-9",level:4},{value:"Static Semantics",id:"static-semantics-10",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"13.4  Enumeration Representation Clauses",id:"134--enumeration-representation-clauses",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-11",level:4},{value:"Implementation Requirements",id:"implementation-requirements-2",level:4},{value:"Implementation Advice",id:"implementation-advice-7",level:4},{value:"Static Semantics",id:"static-semantics-12",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"13.5  Record Layout",id:"135--record-layout",level:2},{value:"13.5.1  Record Representation Clauses",id:"1351--record-representation-clauses",level:3},{value:"Language Design Principles",id:"language-design-principles-2",level:4},{value:"Syntax",id:"syntax-5",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-13",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice-8",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4},{value:"13.5.2  Storage Place Attributes",id:"1352--storage-place-attributes",level:3},{value:"Static Semantics",id:"static-semantics-14",level:4},{value:"Implementation Advice",id:"implementation-advice-9",level:4},{value:"13.5.3  Bit Ordering",id:"1353--bit-ordering",level:3},{value:"Static Semantics",id:"static-semantics-15",level:4},{value:"Implementation Advice",id:"implementation-advice-10",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"13.6  Change of Representation",id:"136--change-of-representation",level:2},{value:"Examples",id:"examples-3",level:4},{value:"13.7  The Package System",id:"137--the-package-system",level:2},{value:"Static Semantics",id:"static-semantics-16",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Implementation Advice",id:"implementation-advice-11",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-7",level:4},{value:"13.7.1  The Package System.Storage_Elements",id:"1371--the-package-systemstorage_elements",level:3},{value:"Static Semantics",id:"static-semantics-17",level:4},{value:"Implementation Requirements",id:"implementation-requirements-3",level:4},{value:"Implementation Permissions",id:"implementation-permissions-3",level:4},{value:"Implementation Advice",id:"implementation-advice-12",level:4},{value:"13.7.2  The Package System.Address_To_Access_Conversions",id:"1372--the-package-systemaddress_to_access_conversions",level:3},{value:"Static Semantics",id:"static-semantics-18",level:4},{value:"Implementation Permissions",id:"implementation-permissions-4",level:4},{value:"13.8  Machine Code Insertions",id:"138--machine-code-insertions",level:2},{value:"Syntax",id:"syntax-6",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-5",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-19",level:4},{value:"Implementation Permissions",id:"implementation-permissions-5",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-8",level:4},{value:"13.9  Unchecked Type Conversions",id:"139--unchecked-type-conversions",level:2},{value:"Static Semantics",id:"static-semantics-20",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-6",level:4},{value:"Implementation Advice",id:"implementation-advice-13",level:4},{value:"13.9.1  Data Validity",id:"1391--data-validity",level:3},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Erroneous Execution",id:"erroneous-execution-2",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Erroneous Execution",id:"erroneous-execution-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-9",level:4},{value:"13.9.2  The Valid Attribute",id:"1392--the-valid-attribute",level:3},{value:"Static Semantics",id:"static-semantics-21",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-5",level:4},{value:"13.10  Unchecked Access Value Creation",id:"1310--unchecked-access-value-creation",level:2},{value:"Static Semantics",id:"static-semantics-22",level:4},{value:"13.11  Storage Management",id:"1311--storage-management",level:2},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Static Semantics",id:"static-semantics-23",level:4},{value:"Erroneous Execution",id:"erroneous-execution-4",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice-14",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-6",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-10",level:4},{value:"13.11.1  The Max_Size_In_Storage_Elements Attribute",id:"13111--the-max_size_in_storage_elements-attribute",level:3},{value:"Static Semantics",id:"static-semantics-24",level:4},{value:"13.11.2  Unchecked Storage Deallocation",id:"13112--unchecked-storage-deallocation",level:3},{value:"Static Semantics",id:"static-semantics-25",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution-5",level:4},{value:"Implementation Advice",id:"implementation-advice-15",level:4},{value:"13.11.3  Pragma Controlled",id:"13113--pragma-controlled",level:3},{value:"Syntax",id:"syntax-7",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Static Semantics",id:"static-semantics-26",level:4},{value:"Implementation Permissions",id:"implementation-permissions-7",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-11",level:4},{value:"Erroneous Execution",id:"erroneous-execution-6",level:4},{value:"13.12  Pragma Restrictions",id:"1312--pragma-restrictions",level:2},{value:"Syntax",id:"syntax-8",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-6",level:4},{value:"Legality Rules",id:"legality-rules-8",level:4},{value:"Static Semantics",id:"static-semantics-27",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules",level:4},{value:"Implementation Permissions",id:"implementation-permissions-8",level:4},{value:"Syntax",id:"syntax-9",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-7",level:4},{value:"13.13  Streams",id:"1313--streams",level:2},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-8",level:4},{value:"13.13.1  The Package Streams",id:"13131--the-package-streams",level:3},{value:"Static Semantics",id:"static-semantics-28",level:4},{value:"13.13.2  Stream-Oriented Attributes",id:"13132--stream-oriented-attributes",level:3},{value:"Static Semantics",id:"static-semantics-29",level:4},{value:"Static Semantics",id:"static-semantics-30",level:4},{value:"Implementation Advice",id:"implementation-advice-16",level:4},{value:"Static Semantics",id:"static-semantics-31",level:4},{value:"Examples",id:"examples-6",level:4},{value:"13.14  Freezing Rules",id:"1314--freezing-rules",level:2},{value:"Language Design Principles",id:"language-design-principles-3",level:4},{value:"Legality Rules",id:"legality-rules-9",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-9",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-12",level:4}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"13-representation-issues"},"13 Representation Issues"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"[This section describes features for querying and controlling aspects of representation and for interfacing to hardware.]"," "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The clauses of this section have been reorganized. This was necessary to preserve a logical order, given the new Ada 95 semantics given in this section. "),(0,i.kt)("h2",{id:"131--representation-items"},"13.1  Representation Items"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[operational aspect]",", Def=","[an aspect that indicates a logical property of an entity, such as the precondition of a subprogram, or the procedure used to write a given type of object to a stream]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[representation aspect]",", Def=","[an aspect that indicates how an entity is mapped onto the underlying hardware, for example the size or alignment of an object]"),(0,i.kt)("p",null,"There are three kinds of representation items: representation_clauses, component_clauses, and representation pragmas. ","[Representation items specify how the types and other entities of the language are to be mapped onto the underlying machine. They can be provided to give more efficient representation or to interface with features that are outside the domain of the language (for example, peripheral hardware). Representation items also specify other specifiable properties of entities. A representation item applies to an entity identified by a local_name, which denotes an entity declared local to the current declarative region, or a library unit declared immediately preceding a representation pragma in a compilation.]"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[aspect]",", Def=","[a specifiable property of an entity]",", Note1=","[An aspect can be specified by an aspect_specification on the declaration of the entity. Some aspects can be queried via attributes.]"," "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"representation_clause ::= attribute_definition_clause\n| enumeration_representation_clause\n| record_representation_clause\n| at_clause"),(0,i.kt)("p",null,"local_name ::= direct_name\n| direct_name'attribute_designator\n| library_unit_name"),(0,i.kt)("p",null,"A representation pragma is allowed only at places where a representation_clause or compilation_unit is allowed. "),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"In a representation item, if the local_name is a direct_name, then it shall resolve to denote a declaration (or, in the case of a pragma, one or more declarations) that occurs immediately within the same declarative region as the representation item. If the local_name has an attribute_designator, then it shall resolve to denote an implementation-defined component (see 13.5.1) or a class-wide type implicitly declared immediately within the same declarative region as the representation item. A local_name that is a library_unit_name (only permitted in a representation pragma) shall resolve to denote the library_item that immediately precedes (except for other pragmas) the representation pragma. "),(0,i.kt)("p",null,"Reason: This is a Name Resolution Rule, because we don't want a representation item for X to be ambiguous just because there's another X declared in an outer declarative region. It doesn't make much difference, since most representation items are for types or subtypes, and type and subtype names can't be overloaded. "),(0,i.kt)("p",null,"Ramification: The visibility rules imply that the declaration has to occur before the representation item."),(0,i.kt)("p",null,"For objects, this implies that representation items can be applied only to stand-alone objects. "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"The local_name of a representation_clause or representation pragma shall statically denote an entity (or, in the case of a pragma, one or more entities) declared immediately preceding it in a compilation, or within the same declarative_part, package_specification, task_definition, protected_definition, or record_definition as the representation item. If a local_name denotes a ","[local]"," callable entity, it may do so through a ","[local]"," subprogram_renaming_declaration ","[(as a way to resolve ambiguity in the presence of overloading)]","; otherwise, the local_name shall not denote a renaming_declaration. "),(0,i.kt)("p",null,'Ramification: The "statically denote" part implies that it is impossible to specify the representation of an object that is not a stand-alone object, except in the case of a representation item like pragma Atomic that is allowed inside a component_list (in which case the representation item specifies the representation of components of all objects of the type). It also prevents the problem of renamings of things like "P.all" (where P is an access-to-subprogram value) or "E(I)" (where E is an entry family).'),(0,i.kt)("p",null,"The part about where the denoted entity has to have been declared appears twice - once as a Name Resolution Rule, and once as a Legality Rule. Suppose P renames Q, and we have a representation item in a declarative_part whose local_name is P. The fact that the representation item has to appear in the same declarative_part as P is a Name Resolution Rule, whereas the fact that the representation item has to appear in the same declarative_part as Q is a Legality Rule. This is subtle, but it seems like the least confusing set of rules. "),(0,i.kt)("p",null,'Discussion: A separate Legality Rule applies for component_clauses. See 13.5.1, "Record Representation Clauses". '),(0,i.kt)("p",null,"The representation of an object consists of a certain number of bits (the size of the object). These are the bits that are normally read or updated by the machine code when loading, storing, or operating-on the value of the object. This includes some padding bits, when the size of the object is greater than the size of its subtype. Such padding bits are considered to be part of the representation of the object, rather than being gaps between objects, if these bits are normally read and updated."),(0,i.kt)("p",null,"To be honest: Discontiguous representations are allowed, but the ones we're interested in here are generally contiguous sequences of bits. "),(0,i.kt)("p",null,"Ramification: Two objects with the same value do not necessarily have the same representation. For example, an implementation might represent False as zero and True as any odd value. Similarly, two objects (of the same type) with the same sequence of bits do not necessarily have the same value. For example, an implementation might use a biased representation in some cases but not others: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype S is Integer range 1..256;\ntype A is array(Natural range 1..4) of S;\npragma Pack(A);\nX : S := 3;\nY : A := (1, 2, 3, 4);\n\n")),(0,i.kt)("p",null,"The implementation might use a biased-by-1 representation for the array elements, but not for X. X and Y(3) have the same value, but different representation: the representation of X is a sequence of (say) 32 bits: 0...011, whereas the representation of Y(3) is a sequence of 8 bits: 00000010 (assuming a two's complement representation)."),(0,i.kt)("p",null,"Such tricks are not required, but are allowed. "),(0,i.kt)("p",null,"Discussion: The value of any padding bits is not specified by the language, though for a numeric type, it will be much harder to properly implement the predefined operations if the padding bits are not either all zero, or a sign extension. "),(0,i.kt)("p",null,"Ramification: For example, suppose S'Size = 2, and an object X is of subtype S. If the machine code typically uses a 32-bit load instruction to load the value of X, then X'Size should be 32, even though 30 bits of the value are just zeros or sign-extension bits. On the other hand, if the machine code typically masks out those 30 bits, then X'Size should be 2. Usually, such masking only happens for components of a composite type for which packing, Component_Size, or record layout is specified."),(0,i.kt)("p",null,"Note, however, that the formal parameter of an instance of Unchecked_Conversion is a special case. Its Size is required to be the same as that of its subtype."),(0,i.kt)("p",null,"Note that we don't generally talk about the representation of a value. A value is considered to be an amorphous blob without any particular representation. An object is considered to be more concrete. "),(0,i.kt)("p",null,"A representation item directly specifies an aspect of representation of the entity denoted by the local_name, except in the case of a type-related representation item, whose local_name shall denote a first subtype, and which directly specifies an aspect of the subtype's type. A representation item that names a subtype is either subtype-specific (Size and Alignment clauses) or type-related (all others). ","[Subtype-specific aspects may differ for different subtypes of the same type.]"),(0,i.kt)("p",null,"To be honest: Type-related and subtype-specific are defined likewise for the corresponding aspects of representation. "),(0,i.kt)("p",null,"To be honest: Some representation items directly specify more than one aspect. "),(0,i.kt)("p",null,"Discussion: For example, a pragma Export specifies the convention of an entity, and also specifies that it is exported. "),(0,i.kt)("p",null,"Ramification: Each specifiable attribute constitutes a separate aspect. An enumeration_representation_clause specifies the coding aspect. A record_representation_clause (without the mod_clause) specifies the record layout aspect. Each representation pragma specifies a separate aspect. "),(0,i.kt)("p",null,'Reason: We don\'t need to say that an at_clause or a mod_clause specify separate aspects, because these are equivalent to attribute_definition_clauses. See J.7, "At Clauses", and J.8, "Mod Clauses".'),(0,i.kt)("p",null,"Ramification: The following representation items are type-related: "),(0,i.kt)("p",null,"enumeration_representation_clause"),(0,i.kt)("p",null,"record_representation_clause"),(0,i.kt)("p",null,"Component_Size clause"),(0,i.kt)("p",null,"External_Tag clause"),(0,i.kt)("p",null,"Small clause"),(0,i.kt)("p",null,"Bit_Order clause"),(0,i.kt)("p",null,"Storage_Pool clause"),(0,i.kt)("p",null,"Storage_Size clause"),(0,i.kt)("p",null,"Read clause"),(0,i.kt)("p",null,"Write clause"),(0,i.kt)("p",null,"Input clause"),(0,i.kt)("p",null,"Output clause"),(0,i.kt)("p",null,"Machine_Radix clause"),(0,i.kt)("p",null,"pragma Pack"),(0,i.kt)("p",null,"pragmas Import, Export, and Convention (when applied to a type)"),(0,i.kt)("p",null,"pragmas Atomic and Volatile (when applied to a type)"),(0,i.kt)("p",null,"pragmas Atomic_Components and Volatile_Components (when applied to an array type)"),(0,i.kt)("p",null,"pragma Discard_Names (when applied to an enumeration or tagged type)"),(0,i.kt)("p",null,"The following representation items are subtype-specific: "),(0,i.kt)("p",null,"Alignment clause (when applied to a first subtype)"),(0,i.kt)("p",null,"Size clause (when applied to a first subtype) "),(0,i.kt)("p",null,"The following representation items do not apply to subtypes, so they are neither type-related nor subtype-specific: "),(0,i.kt)("p",null,"Address clause (applies to objects and program units)"),(0,i.kt)("p",null,"Alignment clause (when applied to an object)"),(0,i.kt)("p",null,"Size clause (when applied to an object)"),(0,i.kt)("p",null,"pragmas Import, Export, and Convention (when applied to anything other than a type)"),(0,i.kt)("p",null,"pragmas Atomic and Volatile (when applied to an object or a component)"),(0,i.kt)("p",null,"pragmas Atomic_Components and Volatile_Components (when applied to an array object)"),(0,i.kt)("p",null,"pragma Discard_Names (when applied to an exception)"),(0,i.kt)("p",null,"pragma Asynchronous (applies to procedures)"),(0,i.kt)("p",null,"A representation item that directly specifies an aspect of a subtype or type shall appear after the type is completely defined (see 3.11.1) and before the subtype or type is frozen (see 13.14). If a representation item is given that directly specifies an aspect of an entity, then it is illegal to give another representation item that directly specifies the same aspect of the entity. "),(0,i.kt)("p",null,"Ramification: The fact that a representation item that directly specifies an aspect of an entity is required to appear before the entity is frozen prevents changing the representation of an entity after using the entity in ways that require the representation to be known. "),(0,i.kt)("p",null,"For an untagged derived typeno type-related representation items are allowed if the parent type is a by-reference type, or has any user-defined primitive subprograms."),(0,i.kt)("p",null,"Ramification: On the other hand, subtype-specific representation items may be given for the first subtype of such a type. "),(0,i.kt)("p",null,"Reason: The reason for forbidding type-related representation items on untagged by-reference types is because a change of representation is impossible when passing by reference (to an inherited subprogram). The reason for forbidding type-related representation items on untagged types with user-defined primitive subprograms was to prevent implicit change of representation for type-related aspects of representation upon calling inherited subprograms, because such changes of representation are likely to be expensive at run time. Changes of subtype-specific representation attributes, however, are likely to be cheap. This rule is not needed for tagged types, because other rules prevent a type-related representation item from changing the representation of the parent part; we want to allow a type-related representation item on a type extension to specify aspects of the extension part. For example, a pragma Pack will cause packing of the extension part, but not of the parent part. "),(0,i.kt)("p",null,"Representation aspects of a generic formal parameter are the same as those of the actual. A type-related representation item is not allowed for a descendant of a generic formal untagged type. "),(0,i.kt)("p",null,"Ramification: Representation items are allowed for types whose subcomponent types or index subtypes are generic formal types. "),(0,i.kt)("p",null,"Reason: Since it is not known whether a formal type has user-defined primitive subprograms, specifying type-related representation items for them is not allowed, unless they are tagged (in which case only the extension part is affected in any case). "),(0,i.kt)("p",null,"A representation item that specifies the Size for a given subtype, or the size or storage place for an object (including a component) of a given subtype, shall allow for enough storage space to accommodate any value of the subtype."),(0,i.kt)("p",null,"A representation item that is not supported by the implementationis illegal, or raises an exception at run time."),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"If two subtypes statically match, then their subtype-specific aspects (Size and Alignment) are the same. "),(0,i.kt)("p",null,"Reason: This is necessary because we allow (for example) conversion between access types whose designated subtypes statically match. Note that it is illegal to specify an aspect (including a subtype-specific one) for a nonfirst subtype."),(0,i.kt)("p",null,"Consider, for example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P1 is\n   subtype S1 is Integer range 0..2**16-1;\n   for S1'Size use 16; -- Illegal!\n      -- S1'Size would be 16 by default.\n   type A1 is access S1;\n   X1: A1;\nend P1;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P2 is\n   subtype S2 is Integer range 0..2**16-1;\n   for S2'Size use 32; -- Illegal!\n   type A2 is access S2;\n   X2: A2;\nend P2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Q is\n   use P1, P2;\n   type Array1 is array(Integer range &lt&gt) of aliased S1;\n   pragma Pack(Array1);\n   Obj1: Array1(1..100);\n   type Array2 is array(Integer range &lt&gt) of aliased S2;\n   pragma Pack(Array2);\n   Obj2: Array2(1..100);\nbegin\n   X1 := Obj2(17)'Access;\n   X2 := Obj1(17)'Access;\nend Q;\n\n")),(0,i.kt)("p",null,"Loads and stores through X1 would read and write 16 bits, but X1 points to a 32-bit location. Depending on the endianness of the machine, loads might load the wrong 16 bits. Stores would fail to zero the other half in any case."),(0,i.kt)("p",null,"Loads and stores through X2 would read and write 32 bits, but X2 points to a 16-bit location. Thus, adjacent memory locations would be trashed."),(0,i.kt)("p",null,"Hence, the above is illegal. Furthermore, the compiler is forbidden from choosing different Sizes by default, for the same reason."),(0,i.kt)("p",null,"The same issues apply to Alignment."),(0,i.kt)("p",null,"A derived type inherits each type-related aspect of its parent type that was directly specified before the declaration of the derived type, or (in the case where the parent is derived) that was inherited by the parent type from the grandparent type. A derived subtype inherits each subtype-specific aspect of its parent subtype that was directly specified before the declaration of the derived type, or (in the case where the parent is derived) that was inherited by the parent subtype from the grandparent subtype, but only if the parent subtype statically matches the first subtype of the parent type. An inherited aspect of representation is overridden by a subsequent representation item that specifies the same aspect of the type or subtype. "),(0,i.kt)("p",null,"To be honest: A record_representation_clause for a record extension does not override the layout of the parent part; if the layout was specified for the parent type, it is inherited by the record extension. "),(0,i.kt)("p",null,"Ramification: If a representation item for the parent appears after the derived_type_definition, then inheritance does not happen for that representation item."),(0,i.kt)("p",null,"Each aspect of representation of an entity is as follows: "),(0,i.kt)("p",null,"If the aspect is specified for the entity, meaning that it is either directly specified or inherited, then that aspect of the entity is as specified, except in the case of Storage_Size, which specifies a minimum. "),(0,i.kt)("p",null,"Ramification: This rule implies that queries of the aspect return the specified value. For example, if the user writes \"for X'Size use 32;\", then a query of X'Size will return 32. "),(0,i.kt)("p",null,"If an aspect of representation of an entity is not specified, it is chosen by default in an unspecified manner. "),(0,i.kt)("p",null,"Ramification: Note that representation_clauses can affect the semantics of the entity."),(0,i.kt)("p",null,'The rules forbid things like "for S\'Base\'Alignment use ..." and "for S\'Base use record ...". '),(0,i.kt)("p",null,"Discussion: The intent is that implementations will represent the components of a composite value in the same way for all subtypes of a given composite type. Hence, Component_Size and record layout are type-related aspects. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"For the elaboration of a representation_clause, any evaluable constructs within it are evaluated. "),(0,i.kt)("p",null,"Ramification: Elaboration of representation pragmas is covered by the general rules for pragmas in Section 2. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,'An implementation may interpret aspects of representation in an implementation-defined manner. An implementation may place implementation-defined restrictions on representation items. A recommended level of support is specified for representation items and related features in each subclause. These recommendations are changed to requirements for implementations that support the Systems Programming Annex (see C.2, "Required Representation Support").'),(0,i.kt)("p",null,"Implementation defined: The interpretation of each aspect of representation."),(0,i.kt)("p",null,"Implementation defined: Any restrictions placed upon representation items."),(0,i.kt)("p",null,"Ramification: Implementation-defined restrictions may be enforced either at compile time or at run time. There is no requirement that an implementation justify any such restrictions. They can be based on avoiding implementation complexity, or on avoiding excessive inefficiency, for example."),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for all representation items is qualified as follows: "),(0,i.kt)("p",null,"An implementation need not support representation items containing nonstatic expressions, except that an implementation should support a representation item for a given entity if each nonstatic expression in the representation item is a name that statically denotes a constant declared before the entity. "),(0,i.kt)("p",null,"Reason: This is to avoid the following sort of thing: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"X : Integer := F(...);\nY : Address := G(...);\nfor X'Address use Y;\n\n")),(0,i.kt)("p",null,"In the above, we have to evaluate the initialization expression for X before we know where to put the result. This seems like an unreasonable implementation burden."),(0,i.kt)("p",null,"The above code should instead be written like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Y : constant Address := G(...);\nX : Integer := F(...);\nfor X'Address use Y;\n\n")),(0,i.kt)("p",null,'This allows the expression "Y" to be safely evaluated before X is created.'),(0,i.kt)("p",null,"The constant could be a formal parameter of mode in."),(0,i.kt)("p",null,"An implementation can support other nonstatic expressions if it wants to. Expressions of type Address are hardly ever static, but their value might be known at compile time anyway in many cases. "),(0,i.kt)("p",null,"An implementation need not support a specification for the Size for a given composite subtype, nor the size or storage place for an object (including a component) of a given composite subtype, unless the constraints on the subtype and its composite subcomponents (if any) are all static constraints."),(0,i.kt)("p",null,"An aliased component, or a component whose type is by-reference, should always be allocated at an addressable location. "),(0,i.kt)("p",null,"Reason: The intent is that access types, type System.Address, and the pointer used for a by-reference parameter should be implementable as a single machine address - bit-field pointers should not be required. (There is no requirement that this implementation be used - we just want to make sure its feasible.) "),(0,i.kt)("p",null,"Implementation Note: Note that the above rule does not apply to types that merely allow by-reference parameter passing; for such types, a copy typically needs to be made at the call site when a bit-aligned component is passed as a parameter. "),(0,i.kt)("p",null,'Ramification: A pragma Pack will typically not pack so tightly as to disobey the above rule. A Component_Size clause or record_representation_clause will typically by illegal if it disobeys the above rule. Atomic components have similar restrictions (see C.6, "Shared Variable Control"). '),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"It is now illegal for a representation item to cause a derived by-reference type to have a different record layout from its parent. This is necessary for by-reference parameter passing to be feasible. This only affects programs that specify the representation of types derived from types containing tasks; most by-reference types are new to Ada 95. For example, if A1 is an array of tasks, and A2 is derived from A1, it is illegal to apply a pragma Pack to A2. "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Ada 95 allows additional representation_clauses for objects. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The syntax rule for type_representation_clause is removed; the right-hand side of that rule is moved up to where it was used, in representation_clause. There are two references to "type representation clause" in RM83, both in Section 13; these have been reworded. '),(0,i.kt)("p",null,'We have defined a new term "representation item", which includes representation_clauses and representation pragmas, as well as component_clauses. This is convenient because the rules are almost identical for all three. '),(0,i.kt)("p",null,'All of the forcing occurrence stuff has been moved into its own subclause (see 13.14), and rewritten to use the term "freezing".'),(0,i.kt)("p",null,'RM83-13.1(10) requires implementation-defined restrictions on representation items to be enforced at compile time. However, that is impossible in some cases. If the user specifies a junk (nonstatic) address in an address clause, and the implementation chooses to detect the error (for example, using hardware memory management with protected pages), then it\'s clearly going to be a run-time error. It seems silly to call that "semantics" rather than "a restriction".'),(0,i.kt)("p",null,"RM83-13.1(10) tries to pretend that representation_clauses don't affect the semantics of the program. One counter-example is the Small clause. Ada 95 has more counter-examples. We have noted the opposite above."),(0,i.kt)("p",null,'Some of the more stringent requirements are moved to C.2, "Required Representation Support". '),(0,i.kt)("h2",{id:"132--pragma-pack"},"13.2  Pragma Pack"),(0,i.kt)("p",null,"[A pragma Pack specifies that storage minimization should be the main criterion when selecting the representation of a composite type.]"," "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Pack is as follows: "),(0,i.kt)("p",null,"  pragma Pack(first_subtype_local_name); "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"The first_subtype_local_name of a pragma Pack shall denote a composite subtype. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"A pragma Pack specifies the packing aspect of representation; the type (or the extension part) is said to be packed. For a type extension, the parent part is packed as for the parent type, and a pragma Pack causes packing only of the extension part."),(0,i.kt)("p",null,'Ramification: The only high level semantic effect of a pragma Pack is independent addressability (see 9.10, "Shared Variables").] '),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"If a type is packed, then the implementation should try to minimize storage allocated to objects of the type, possibly at the expense of speed of accessing components, subject to reasonable complexity in addressing calculations. "),(0,i.kt)("p",null,"Ramification: A pragma Pack is for gaining space efficiency, possibly at the expense of time. If more explicit control over representation is desired, then a record_representation_clause, a Component_Size clause, or a Size clause should be used instead of, or in addition to, a pragma Pack. "),(0,i.kt)("p",null,"The recommended level of support for pragma Pack is: "),(0,i.kt)("p",null,"For a packed record type, the components should be packed as tightly as possible subject to the Sizes of the component subtypes, and subject to any record_representation_clause that applies to the type; the implementation may, but need not, reorder components or cross aligned word boundaries to improve the packing. A component whose Size is greater than the word size may be allocated an integral number of words."),(0,i.kt)("p",null,"Ramification: The implementation can always allocate an integral number of words for a component that will not fit in a word. The rule also allows small component sizes to be rounded up if such rounding does not waste space. For example, if Storage_Unit = 8, then a component of size 8 is probably more efficient than a component of size 7 plus a 1-bit gap (assuming the gap is needed anyway). "),(0,i.kt)("p",null,"For a packed array type, if the component subtype's Size is less than or equal to the word size, and Component_Size is not specified for the type, Component_Size should be less than or equal to the Size of the component subtype, rounded up to the nearest factor of the word size."),(0,i.kt)("p",null,"Ramification: If a component subtype is aliased, its Size will generally be a multiple of Storage_Unit, so it probably won't get packed very tightly. "),(0,i.kt)("p",null,"Implementation Advice: "),(0,i.kt)("h2",{id:"133--representation-attributes"},"13.3  Representation Attributes"),(0,i.kt)("p",null,"[ The values of certain implementation-dependent characteristics can be obtained by interrogating appropriate representation attributes. Some of these attributes are specifiable via an attribute_definition_clause.]"," "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,"In general, the meaning of a given attribute should not depend on whether the attribute was specified via an attribute_definition_clause, or chosen by default by the implementation. "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"attribute_definition_clause ::=\nfor local_name'attribute_designator use expression;\n| for local_name'attribute_designator use name;"),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"For an attribute_definition_clause that specifies an attribute that denotes a value, the form with an expression shall be used. Otherwise, the form with a name shall be used."),(0,i.kt)("p",null,"For an attribute_definition_clause that specifies an attribute that denotes a value or an object, the expected type for the expression or name is that of the attribute. For an attribute_definition_clause that specifies an attribute that denotes a subprogram, the expected profile for the name is the profile required for the attribute. For an attribute_definition_clause that specifies an attribute that denotes some other kind of entity, the name shall resolve to denote an entity of the appropriate kind. "),(0,i.kt)("p",null,'Ramification: For example, the Size attribute is of type universal_integer. Therefore, the expected type for Y in "for X\'Size use Y;" is universal_integer, which means that Y can be of any integer type. '),(0,i.kt)("p",null,"Discussion: For attributes that denote subprograms, the required profile is indicated separately for the individual attributes. "),(0,i.kt)("p",null,"Ramification: For an attribute_definition_clause with a name, the name need not statically denote the entity it denotes. For example, the following kinds of things are allowed: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Some_Access_Type'Storage_Pool use Storage_Pool_Array(I);\nfor Some_Type'Read use Subprogram_Pointer.all;\n\n")),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"An attribute_designator is allowed in an attribute_definition_clause only if this Reference Manual explicitly allows it, or for an implementation-defined attribute if the implementation allows it. Each specifiable attribute constitutes an aspect of representation. "),(0,i.kt)("p",null,'Discussion: For each specifiable attribute, we generally say something like, "The ... attribute may be specified for ... via an attribute_definition_clause."'),(0,i.kt)("p",null,"The above wording allows for T'Class'Alignment, T'Class'Size, T'Class'Input, and T'Class'Output to be specifiable."),(0,i.kt)("p",null,"A specifiable attribute is not necessarily specifiable for all entities for which it is defined. For example, one is allowed to ask T'Component_Size for an array subtype T, but \"for T'Component_Size use ...\" is only allowed if T is a first subtype, because Component_Size is a type-related aspect. "),(0,i.kt)("p",null,"For an attribute_definition_clause that specifies an attribute that denotes a subprogram, the profile shall be mode conformant with the one required for the attribute, and the convention shall be Ada. Additional requirements are defined for particular attributes. "),(0,i.kt)("p",null,"Ramification: This implies, for example, that if one writes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for T'Read use R;\n\n")),(0,i.kt)("p",null,"R has to be a procedure with two parameters with the appropriate subtypes and modes as shown in 13.13.2. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"A Size clause is an attribute_definition_clause whose attribute_designator is Size. Similar definitions apply to the other specifiable attributes. "),(0,i.kt)("p",null,"To be honest: An attribute_definition_clause is type-related or subtype-specific if the attribute_designator denotes a type-related or subtype-specific attribute, respectively. "),(0,i.kt)("p",null,"A storage element is an addressable element of storage in the machine. A word is the largest amount of storage that can be conveniently and efficiently manipulated by the hardware, given the implementation's run-time model. A word consists of an integral number of storage elements. "),(0,i.kt)("p",null,"Discussion: A storage element is not intended to be a single bit, unless the machine can efficiently address individual bits. "),(0,i.kt)("p",null,"Ramification: For example, on a machine with 8-bit storage elements, if there exist 32-bit integer registers, with a full set of arithmetic and logical instructions to manipulate those registers, a word ought to be 4 storage elements - that is, 32 bits. "),(0,i.kt)("p",null,'Discussion: The "given the implementation\'s run-time model" part is intended to imply that, for example, on an 80386 running MS-DOS, the word might be 16 bits, even though the hardware can support 32 bits.'),(0,i.kt)("p",null,'A word is what ACID refers to as a "natural hardware boundary".'),(0,i.kt)("p",null,'Storage elements may, but need not be, independently addressable (see 9.10, "Shared Variables"). Words are expected to be independently addressable. '),(0,i.kt)("p",null,"The following attributes are defined:"),(0,i.kt)("p",null,"For a prefix X that denotes an object, program unit, or label: "),(0,i.kt)("p",null,"X'AddressDenotes the address of the first of the storage elements allocated to X. For a program unit or label, this value refers to the machine code associated with the corresponding body or statement. The value of this attribute is of type System.Address."),(0,i.kt)("p",null,'Ramification: Here, the "first of the storage elements" is intended to mean the one with the lowest address; the endianness of the machine doesn\'t matter. '),(0,i.kt)("p",null,"Address may be specified for stand-alone objects and for program units via an attribute_definition_clause. "),(0,i.kt)("p",null,"Ramification: Address is not allowed for enumeration literals, predefined operators, derived task types, or derived protected types, since they are not program units."),(0,i.kt)("p",null,"The validity of a given address depends on the run-time model; thus, in order to use Address clauses correctly, one needs intimate knowledge of the run-time model."),(0,i.kt)("p",null,"If the Address of an object is specified, any explicit or implicit initialization takes place as usual, unless a pragma Import is also specified for the object (in which case any necessary initialization is presumably done in the foreign language)."),(0,i.kt)("p",null,"Any compilation unit containing an attribute_reference of a given type depends semantically on the declaration of the package in which the type is declared, even if not mentioned in an applicable with_clause - see 10.1.1. In this case, it means that if a compilation unit contains X'Address, then it depends on the declaration of System. Otherwise, the fact that the value of Address is of a type in System wouldn't make sense; it would violate the \"legality determinable via semantic dependences\" Language Design Principle."),(0,i.kt)("p",null,"AI83-00305 - If X is a task type, then within the body of X, X denotes the current task object; thus, X'Address denotes the object's address."),(0,i.kt)("p",null,'Interrupt entries and their addresses are described in J.7.1, "Interrupt Entries".'),(0,i.kt)("p",null,"If X is not allocated on a storage element boundary, X'Address points at the first of the storage elements that contains any part of X. This is important for the definition of the Position attribute to be sensible. "),(0,i.kt)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,i.kt)("p",null,"If an Address is specified, it is the programmer's responsibility to ensure that the address is valid; otherwise, program execution is erroneous."),(0,i.kt)("h4",{id:"implementation-advice-2"},"Implementation Advice"),(0,i.kt)("p",null,"For an array X, X'Address should point at the first component of the array, and not at the array bounds. "),(0,i.kt)("p",null,"Ramification: On the other hand, we have no advice to offer about discriminants and tag fields; whether or not the address points at them is not specified by the language. If discriminants are stored separately, then the Position of a discriminant might be negative, or might raise an exception. "),(0,i.kt)("p",null,"The recommended level of support for the Address attribute is: "),(0,i.kt)("p",null,"X'Address should produce a useful result if X is an object that is aliased or of a by-reference type, or is an entity whose Address has been specified. "),(0,i.kt)("p",null,"Reason: Aliased objects are the ones for which the Unchecked_Access attribute is allowed; hence, these have to be allocated on an addressable boundary anyway. Similar considerations apply to objects of a by-reference type."),(0,i.kt)("p",null,"An implementation need not go to any trouble to make Address work in other cases. For example, if an object X is not aliased and not of a by-reference type, and the implementation chooses to store it in a register, X'Address might return System.Null_Address (assuming registers are not addressable). For a subprogram whose calling convention is Intrinsic, or for a package, the implementation need not generate an out-of-line piece of code for it. "),(0,i.kt)("p",null,"An implementation should support Address clauses for imported subprograms."),(0,i.kt)("p",null,"Objects (including subcomponents) that are aliased or of a by-reference type should be allocated on storage element boundaries. "),(0,i.kt)("p",null,"Reason: This is necessary for the Address attribute to be useful (since First_Bit and Last_Bit apply only to components). Implementations generally need to do this anyway, for tasking to work properly. "),(0,i.kt)("p",null,"If the Address of an object is specified, or it is imported or exported, then the implementation should not perform optimizations based on assumptions of no aliases. "),(0,i.kt)("p",null,"NOTE 1   The specification of a link name in a pragma Export (see B.1) for a subprogram or object is an alternative to explicit specification of its link-time address, allowing a link-time directive to place the subprogram or object within memory."),(0,i.kt)("p",null,"NOTE 2   The rules for the Size attribute imply, for an aliased object X, that if X'Size = Storage_Unit, then X'Address points at a storage element containing all of the bits of X, and only the bits of X. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The intended meaning of the various attributes, and their attribute_definition_clauses, is more explicit."),(0,i.kt)("p",null,'The address_clause has been renamed to at_clause and moved to Annex J, "Obsolescent Features". One can use an Address clause ("for T\'Address use ...;") instead.'),(0,i.kt)("p",null,"The attributes defined in RM83-13.7.3 are moved to Annex G, A.5.3, and A.5.4. "),(0,i.kt)("h4",{id:"language-design-principles-1"},"Language Design Principles"),(0,i.kt)("p",null,'By default, the Alignment of a subtype should reflect the "natural" alignment for objects of the subtype on the machine. The Alignment, whether specified or default, should be known at compile time, even though Addresses are generally not known at compile time. (The generated code should never need to check at run time the number of zero bits at the end of an address to determine an alignment).'),(0,i.kt)("p",null,"There are two symmetric purposes of Alignment clauses, depending on whether or not the implementation has control over object allocation. If the implementation allocates an object, the implementation should ensure that the Address and Alignment are consistent with each other. If something outside the implementation allocates an object, the implementation should be allowed to assume that the Address and Alignment are consistent, but should not assume stricter alignments than that. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix X that denotes a subtype or object: "),(0,i.kt)("p",null,"X'AlignmentThe Address of an object that is allocated under control of the implementation is an integral multiple of the Alignment of the object (that is, the Address modulo the Alignment is zero).The offset of a record component is a multiple of the Alignment of the component. For an object that is not allocated under control of the implementation (that is, one that is imported, that is allocated by a user-defined allocator, whose Address has been specified, or is designated by an access value returned by an instance of Unchecked_Conversion), the implementation may assume that the Address is an integral multiple of its Alignment. The implementation shall not assume a stricter alignment."),(0,i.kt)("p",null,"The value of this attribute is of type universal_integer, and nonnegative; zero means that the object is not necessarily aligned on a storage element boundary. "),(0,i.kt)("p",null,"Ramification: The Alignment is passed by an allocator to the Allocate operation; the implementation has to choose a value such that if the address returned by Allocate is aligned as requested, the generated code can correctly access the object."),(0,i.kt)("p",null,'The above mention of "modulo" is referring to the "mod" operator declared in System.Storage_Elements; if X mod N = 0, then X is by definition aligned on an N-storage-element boundary. '),(0,i.kt)("p",null,"Alignment may be specified for first subtypes and ","[stand-alone]"," objects via an attribute_definition_clause; the expression of such a clause shall be static, and its value nonnegative.If the Alignment of a subtype is specified, then the Alignment of an object of the subtype is at least as strict, unless the object's Alignment is also specified. The Alignment of an object created by an allocator is that of the designated subtype."),(0,i.kt)("p",null,"If an Alignment is specified for a composite subtype or object, this Alignment shall be equal to the least common multiple of any specified Alignments of the subcomponent subtypes, or an integer multiple thereof. "),(0,i.kt)("h4",{id:"erroneous-execution-1"},"Erroneous Execution"),(0,i.kt)("p",null,"Program execution is erroneous if an Address clause is given that conflicts with the Alignment. "),(0,i.kt)("p",null,"Ramification: The user has to either give an Alignment clause also, or else know what Alignment the implementation will choose by default. "),(0,i.kt)("p",null,"If the Alignment is specified for an object that is not allocated under control of the implementation, execution is erroneous if the object is not aligned according to the Alignment."),(0,i.kt)("h4",{id:"implementation-advice-3"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for the Alignment attribute for subtypes is: "),(0,i.kt)("p",null,"An implementation should support specified Alignments that are factors and multiples of the number of storage elements per word, subject to the following:"),(0,i.kt)("p",null,"An implementation need not support specified Alignments for combinations of Sizes and Alignments that cannot be easily loaded and stored by available machine instructions."),(0,i.kt)("p",null,"An implementation need not support specified Alignments that are greater than the maximum Alignment the implementation ever returns by default."),(0,i.kt)("p",null,"The recommended level of support for the Alignment attribute for objects is: "),(0,i.kt)("p",null,"Same as above, for subtypes, but in addition:"),(0,i.kt)("p",null,"For stand-alone library-level objects of statically constrained subtypes, the implementation should support all Alignments supported by the target linker. For example, page alignment is likely to be supported for such objects, but not for subtypes."),(0,i.kt)("p",null,"NOTE 3   Alignment is a subtype-specific attribute."),(0,i.kt)("p",null,"NOTE 4   The Alignment of a composite object is always equal to the least common multiple of the Alignments of its components, or a multiple thereof. "),(0,i.kt)("p",null,"Discussion: For default Alignments, this follows from the semantics of Alignment. For specified Alignments, it follows from a Legality Rule stated above. "),(0,i.kt)("p",null,"NOTE 5   A component_clause, Component_Size clause, or a pragma Pack can override a specified Alignment. "),(0,i.kt)("p",null,"Discussion: Most objects are allocated by the implementation; for these, the implementation obeys the Alignment. The implementation is of course allowed to make an object more aligned than its Alignment requires - an object whose Alignment is 4 might just happen to land at an address that's a multiple of 4096. For formal parameters, the implementation might want to force an Alignment stricter than the parameter's subtype. For example, on some systems, it is customary to always align parameters to 4 storage elements."),(0,i.kt)("p",null,"Hence, one might initially assume that the implementation could evilly make all Alignments 1 by default, even though integers, say, are normally aligned on a 4-storage-element boundary. However, the implementation cannot get away with that - if the Alignment is 1, the generated code cannot assume an Alignment of 4, at least not for objects allocated outside the control of the implementation."),(0,i.kt)("p",null,'Of course implementations can assume anything they can prove, but typically an implementation will be unable to prove much about the alignment of, say, an imported object. Furthermore, the information about where an address "came from" can be lost to the compiler due to separate compilation.'),(0,i.kt)("p",null,"The Alignment of an object that is a component of a packed composite object will usually be 0, to indicate that the component is not necessarily aligned on a storage element boundary. For a subtype, an Alignment of 0 means that objects of the subtype are not normally aligned on a storage element boundary at all. For example, an implementation might choose to make Component_Size be 0 for an array of Booleans, even when pragma Pack has not been specified for the array. In this case, Boolean'Alignment would be 0. (In the presence of tasking, this would in general be feasible only on a machine that had atomic test-bit and set-bit instructions.)"),(0,i.kt)("p",null,"If the machine has no particular natural alignments, then all subtype Alignments will probably be 1 by default."),(0,i.kt)("p",null,"Specifying an Alignment of 0 in an attribute_definition_clause does not require the implementation to do anything (except return 0 when the Alignment is queried). However, it might be taken as advice on some implementations."),(0,i.kt)("p",null,"It is an error for an Address clause to disobey the object's Alignment. The error cannot be detected at compile time, in general, because the Address is not necessarily known at compile time (and is almost certainly not static). We do not require a runtime check, since efficiency seems paramount here, and Address clauses are treading on thin ice anyway. Hence, this misuse of Address clauses is just like any other misuse of Address clauses - it's erroneous."),(0,i.kt)("p",null,"A type extension can have a stricter Alignment than its parent. This can happen, for example, if the Alignment of the parent is 4, but the extension contains a component with Alignment 8. The Alignment of a class-wide type or object will have to be the maximum possible Alignment of any extension."),(0,i.kt)("p",null,"The recommended level of support for the Alignment attribute is intended to reflect a minimum useful set of capabilities. An implementation can assume that all Alignments are multiples of each other - 1, 2, 4, and 8 might be the only supported Alignments for subtypes. An Alignment of 3 or 6 is unlikely to be useful. For objects that can be allocated statically, we recommend that the implementation support larger alignments, such as 4096. We do not recommend such large alignments for subtypes, because the maximum subtype alignment will also have to be used as the alignment of stack frames, heap objects, and class-wide objects. Similarly, we do not recommend such large alignments for stack-allocated objects."),(0,i.kt)("p",null,"If the maximum default Alignment is 8 (say, Long_Float'Alignment = 8), then the implementation can refuse to accept stricter alignments for subtypes. This simplifies the generated code, since the compiler can align the stack and class-wide types to this maximum without a substantial waste of space (or time)."),(0,i.kt)("p",null,"Note that the recommended level of support takes into account interactions between Size and Alignment. For example, on a 32-bit machine with 8-bit storage elements, where load and store instructions have to be aligned according to the size of the thing being loaded or stored, the implementation might accept an Alignment of 1 if the Size is 8, but might reject an Alignment of 1 if the Size is 32. On a machine where unaligned loads and stores are merely inefficient (as opposed to causing hardware traps), we would expect an Alignment of 1 to be supported for any Size. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The nonnegative part is missing from RM83 (for mod_clauses, nee alignment_clauses, which are an obsolete version of Alignment clauses). "),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix X that denotes an object: "),(0,i.kt)("p",null,"X'SizeDenotes the size in bits of the representation of the object. The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"Ramification: Note that Size is in bits even if Machine_Radix is 10. Each decimal digit (and the sign) is presumably represented as some number of bits. "),(0,i.kt)("p",null,"Size may be specified for ","[stand-alone]"," objects via an attribute_definition_clause; the expression of such a clause shall be static and its value nonnegative."),(0,i.kt)("h4",{id:"implementation-advice-4"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for the Size attribute of objects is: "),(0,i.kt)("p",null,"A Size clause should be supported for an object if the specified Size is at least as large as its subtype's Size, and corresponds to a size in storage elements that is a multiple of the object's Alignment (if the Alignment is nonzero). "),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S: "),(0,i.kt)("p",null,"S'SizeIf S is definite, denotes the size ","[(in bits)]"," that the implementation would choose for the following objects of subtype S: "),(0,i.kt)("p",null,"A record component of subtype S when the record type is packed."),(0,i.kt)("p",null,"The formal parameter of an instance of Unchecked_Conversion that converts from subtype S to some other subtype. "),(0,i.kt)("p",null,"If S is indefinite, the meaning is implementation defined. The value of this attribute is of the type universal_integer. The Size of an object is at least as large as that of its subtype, unless the object's Size is determined by a Size clause, a component_clause, or a Component_Size clause. Size may be specified for first subtypes via an attribute_definition_clause; the expression of such a clause shall be static and its value nonnegative. "),(0,i.kt)("p",null,"Implementation defined: The meaning of Size for indefinite subtypes."),(0,i.kt)("p",null,"Reason: The effects of specifying the Size of a subtype are: "),(0,i.kt)("p",null,"Unchecked_Conversion works in a predictable manner."),(0,i.kt)("p",null,"A composite type cannot be packed so tightly as to override the specified Size of a component's subtype."),(0,i.kt)("p",null,"Assuming the Implementation Advice is obeyed, if the specified Size allows independent addressability, then the Size of certain objects of the subtype should be equal to the subtype's Size. This applies to stand-alone objects and to components (unless a component_clause or a Component_Size clause applies). "),(0,i.kt)("p",null,"A component_clause or a Component_Size clause can cause an object to be smaller than its subtype's specified size. A pragma Pack cannot; if a component subtype's size is specified, this limits how tightly the composite object can be packed."),(0,i.kt)("p",null,"The Size of a class-wide (tagged) subtype is unspecified, because it's not clear what it should mean; it should certainly not depend on all of the descendants that happen to exist in a given program. Note that this cannot be detected at compile time, because in a generic unit, it is not necessarily known whether a given subtype is class-wide. It might raise an exception on some implementations. "),(0,i.kt)("p",null,"Ramification: A Size clause for a numeric subtype need not affect the underlying numeric type. For example, if I say: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type S is range 1..2;\nfor S'Size use 64;\n  \n\n")),(0,i.kt)("p",null,"I am not guaranteed that S'Base'Last ",">","= 2**631, nor that intermediate results will be represented in 64 bits. "),(0,i.kt)("p",null,"Reason: There is no need to complicate implementations for this sort of thing, because the right way to affect the base range of a type is to use the normal way of declaring the base range: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Big is range -2**63 .. 2**63 - 1;\nsubtype Small is Big range 1..1000;\n  \n\n")),(0,i.kt)("p",null,"Ramification: The Size of a large unconstrained subtype (e.g. String'Size) is likely to raise Constraint_Error, since it is a nonstatic expression of type universal_integer that might overflow the largest signed integer type. There is no requirement that the largest integer type be able to represent the size in bits of the largest possible object. "),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation, Boolean'Size shall be 1. "),(0,i.kt)("h4",{id:"implementation-advice-5"},"Implementation Advice"),(0,i.kt)("p",null,"If the Size of a subtype is specified, and allows for efficient independent addressability (see 9.10) on the target architecture, then the Size of the following objects of the subtype should equal the Size of the subtype: "),(0,i.kt)("p",null,"Aliased objects (including components)."),(0,i.kt)("p",null,"Unaliased components, unless the Size of the component is determined by a component_clause or Component_Size clause. "),(0,i.kt)("p",null,"Implementation Advice: "),(0,i.kt)("p",null,'Ramification: Thus, on a typical 32-bit machine, "for S\'Size use 32;" will guarantee that aliased objects of subtype S, and components whose subtype is S, will have Size = 32 (assuming the implementation chooses to obey this Implementation Advice). On the other hand, if one writes, "for S2\'Size use 5;" then stand-alone objects of subtype S2 will typically have their Size rounded up to ensure independent addressability.'),(0,i.kt)("p",null,'Note that "for S\'Size use 32;" does not cause things like formal parameters to have Size = 32 - the implementation is allowed to make all parameters be at least 64 bits, for example.'),(0,i.kt)("p",null,'Note that "for S2\'Size use 5;" requires record components whose subtype is S2 to be exactly 5 bits if the record type is packed. The same is not true of array components; their Size may be rounded up to the nearest factor of the word size. '),(0,i.kt)("p",null,"Implementation Note: On most machines, arrays don't contain gaps between components; if the Component_Size is greater than the Size of the component subtype, the extra bits are generally considered part of each component, rather than gaps between components. On the other hand, a record might contain gaps between components, depending on what sorts of loads, stores, and masking operations are generally done by the generated code."),(0,i.kt)("p",null,"For an array, any extra bits stored for each component will generally be part of the component - the whole point of storing extra bits is to make loads and stores more efficient by avoiding the need to mask out extra bits. The PDP-10 is one counter-example; since the hardware supports byte strings with a gap at the end of each word, one would want to pack in that manner. "),(0,i.kt)("p",null,"A Size clause on a composite subtype should not affect the internal layout of components. "),(0,i.kt)("p",null,"Reason: That's what Pack pragmas, record_representation_clauses, and Component_Size clauses are for. "),(0,i.kt)("p",null,"The recommended level of support for the Size attribute of subtypes is: "),(0,i.kt)("p",null,"The Size (if not specified) of a static discrete or fixed point subtype should be the number of bits needed to represent each value belonging to the subtype using an unbiased representation, leaving space for a sign bit only if the subtype contains negative values. If such a subtype is a first subtype, then an implementation should support a specified Size for it that reflects this representation."),(0,i.kt)("p",null,"Implementation Note: This applies to static enumeration subtypes, using the internal codes used to represent the values."),(0,i.kt)("p",null,"For a two's-complement machine, this implies that for a static signed integer subtype S, if all values of S are in the range 0 .. 2n1, or all values of S are in the range 2n1 .. 2n11, for some n less than or equal to the word size, then S'Size should be ","<",'= the smallest such n. For a one\'s-complement machine, it is the same except that in the second range, the lower bound "2n1" is replaced by "2n1+1".'),(0,i.kt)("p",null,"If an integer subtype (whether signed or unsigned) contains no negative values, the Size should not include space for a sign bit."),(0,i.kt)("p",null,"Typically, the implementation will choose to make the Size of a subtype be exactly the smallest such n. However, it might, for example, choose a biased representation, in which case it could choose a smaller value."),(0,i.kt)("p",null,"On most machines, it is in general not a good idea to pack (parts of) multiple stand-alone objects into the same storage element, because (1) it usually doesn't save much space, and (2) it requires locking to prevent tasks from interfering with each other, since separate stand-alone objects are independently addressable. Therefore, if S'Size = 2 on a machine with 8-bit storage elements, the size of a stand-alone object of subtype S will probably not be 2. It might, for example, be 8, 16 or 32, depending on the availability and efficiency of various machine instructions. The same applies to components of composite types, unless packing, Component_Size, or record layout is specified."),(0,i.kt)("p",null,"For an unconstrained discriminated object, if the implementation allocates the maximum possible size, then the Size attribute should return that maximum possible size. "),(0,i.kt)("p",null,"Ramification: The Size of an object X is not usually the same as that of its subtype S. If X is a stand-alone object or a parameter, for example, most implementations will round X'Size up to a storage element boundary, or more, so X'Size might be greater than S'Size. On the other hand, X'Size cannot be less than S'Size, even if the implementation can prove, for example, that the range of values actually taken on by X during execution is smaller than the range of S."),(0,i.kt)("p",null,"For example, if S is a first integer subtype whose range is 0..3, S'Size will be probably be 2 bits, and components of packed composite types of this subtype will be 2 bits (assuming Storage_Unit is a multiple of 2), but stand-alone objects and parameters will probably not have a size of 2 bits; they might be rounded up to 32 bits, for example. On the other hand, Unchecked_Conversion will use the 2-bit size, even when converting a stand-alone object, as one would expect."),(0,i.kt)("p",null,"Another reason for making the Size of an object bigger than its subtype's Size is to support the run-time detection of uninitialized variables. The implementation might add an extra value to a discrete subtype that represents the uninitialized state, and check for this value on use. In some cases, the extra value will require an extra bit in the representation of the object. Such detection is not required by the language. If it is provided, the implementation has to be able to turn it off. For example, if the programmer gives a record_representation_clause or Component_Size clause that makes a component too small to allow the extra bit, then the implementation will not be able to perform the checking (not using this method, anyway)."),(0,i.kt)("p",null,"The fact that the size of an object is not necessarily the same as its subtype can be confusing: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Device_Register is range 0..2**8 - 1;\nfor Device_Register'Size use 8; -- Confusing!\nMy_Device : Device_Register;\nfor My_Device'Address use To_Address(16#FF00#);\n  \n\n")),(0,i.kt)("p",null,"The programmer might think that My_Device'Size is 8, and that My_Device'Address points at an 8-bit location. However, this is not true. In Ada 83 (and in Ada 95), My_Device'Size might well be 32, and My_Device'Address might well point at the high-order 8 bits of the 32-bit object, which are always all zero bits. If My_Device'Address is passed to an assembly language subprogram, based on the programmer's assumption, the program will not work properly. "),(0,i.kt)("p",null,"Reason: It is not reasonable to require that an implementation allocate exactly 8 bits to all objects of subtype Device_Register. For example, in many run-time models, stand-alone objects and parameters are always aligned to a word boundary. Such run-time models are generally based on hardware considerations that are beyond the control of the implementer. (It is reasonable to require that an implementation allocate exactly 8 bits to all components of subtype Device_Register, if packed.) "),(0,i.kt)("p",null,"Ramification: The correct way to write the above code is like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Device_Register is range 0..2**8 - 1;\nMy_Device : Device_Register;\nfor My_Device'Size use 8;\nfor My_Device'Address use To_Address(16#FF00#);\n  \n\n")),(0,i.kt)("p",null,"If the implementation cannot accept 8-bit stand-alone objects, then this will be illegal. However, on a machine where an 8-bit device register exists, the implementation will probably be able to accept 8-bit stand-alone objects. Therefore, My_Device'Size will be 8, and My_Device'Address will point at those 8 bits, as desired."),(0,i.kt)("p",null,"If an object of subtype Device_Register is passed to a foreign language subprogram, it will be passed according to that subprogram's conventions. Most foreign language implementations have similar run-time model restrictions. For example, when passing to a C function, where the argument is of the C type char* (that is, pointer to char), the C compiler will generally expect a full word value, either on the stack, or in a register. It will not expect a single byte. Thus, Size clauses for subtypes really have nothing to do with passing parameters to foreign language subprograms. "),(0,i.kt)("p",null,"For a subtype implemented with levels of indirection, the Size should include the size of the pointers, but not the size of what they point at. "),(0,i.kt)("p",null,"Ramification: For example, if a task object is represented as a pointer to some information (including a task stack), then the size of the object should be the size of the pointer. The Storage_Size, on the other hand, should include the size of the stack. "),(0,i.kt)("p",null,"NOTE 6   Size is a subtype-specific attribute."),(0,i.kt)("p",null,"NOTE 7   A component_clause or Component_Size clause can override a specified Size. A pragma Pack cannot. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The requirement for a nonnegative value in a Size clause was not in RM83, but it's hard to see how it would make sense. For uniformity, we forbid negative sizes, rather than letting implementations define their meaning. "),(0,i.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,i.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix T that denotes a task object ","[(after any implicit dereference)]",": "),(0,i.kt)("p",null,"If a pragma Storage_Size is given, the value of the Storage_Size attribute is at least the value specified in the pragma. "),(0,i.kt)("p",null,'Ramification: The value of this attribute is never negative, since it is impossible to "reserve" a negative number of storage elements.'),(0,i.kt)("p",null,'If the implementation chooses to allocate an initial amount of storage, and then increase this as needed, the Storage_Size cannot include the additional amounts (assuming the allocation of the additional amounts can raise Storage_Error); this is inherent in the meaning of "reserved".'),(0,i.kt)("p",null,"The implementation is allowed to allocate different amounts of storage for different tasks of the same subtype."),(0,i.kt)("p",null,"Storage_Size is also defined for access subtypes - see 13.11. "),(0,i.kt)("p",null,"[ A pragma Storage_Size specifies the amount of storage to be reserved for the execution of a task.]"," "),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Storage_Size is as follows: "),(0,i.kt)("p",null,"  pragma Storage_Size(expression);"),(0,i.kt)("p",null,"A pragma Storage_Size is allowed only immediately within a task_definition. "),(0,i.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expression of a pragma Storage_Size is expected to be of any integer type. "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"A pragma Storage_Size is elaborated when an object of the type defined by the immediately enclosing task_definition is created. For the elaboration of a pragma Storage_Size, the expression is evaluated; the Storage_Size attribute of the newly created task object is at least the value of the expression."),(0,i.kt)("p",null,"Ramification: The implementation is allowed to round up a specified Storage_Size amount. For example, if the implementation always allocates in chunks of 4096 bytes, the number 200 might be rounded up to 4096. Also, if the user specifies a negative number, the implementation has to normalize this to 0, or perhaps to a positive number."),(0,i.kt)("p",null,"At the point of task object creation, or upon task activation, Storage_Error is raised if there is insufficient free storage to accommodate the requested Storage_Size. "),(0,i.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix X that denotes an array subtype or array object ","[(after any implicit dereference)]",": "),(0,i.kt)("p",null,"X'Component_SizeDenotes the size in bits of components of the type of X. The value of this attribute is of type universal_integer. "),(0,i.kt)("p",null,"Component_Size may be specified for array types via an attribute_definition_clause; the expression of such a clause shall be static, and its value nonnegative."),(0,i.kt)("p",null,"Implementation Note: The intent is that the value of X'Component_Size is always nonnegative. If the array is stored \"backwards\" in memory (which might be caused by an implementation-defined pragma), X'Component_Size is still positive. "),(0,i.kt)("p",null,"Ramification: For an array object A, A'Component_Size = A(I)'Size for any index I. "),(0,i.kt)("h4",{id:"implementation-advice-6"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for the Component_Size attribute is: "),(0,i.kt)("p",null,"An implementation need not support specified Component_Sizes that are less than the Size of the component subtype."),(0,i.kt)("p",null,"An implementation should support specified Component_Sizes that are factors and multiples of the word size. For such Component_Sizes, the array should contain no gaps between components. For other Component_Sizes (if supported), the array should contain no gaps between components when packing is also specified; the implementation should forbid this combination in cases where it cannot support a no-gaps representation. "),(0,i.kt)("p",null,"Ramification: For example, if Storage_Unit = 8, and Word_Size = 32, then the user is allowed to specify a Component_Size of 1, 2, 4, 8, 16, and 32, with no gaps. In addition, n*32 is allowed for positive integers n, again with no gaps. If the implementation accepts Component_Size = 3, then it might allocate 10 components per word, with a 2-bit gap at the end of each word (unless packing is also specified), or it might not have any internal gaps at all. (There can be gaps at either end of the array.) "),(0,i.kt)("h4",{id:"static-semantics-9"},"Static Semantics"),(0,i.kt)("h4",{id:"static-semantics-10"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S of a tagged type T (specific or class-wide), the following attribute is defined:"),(0,i.kt)("p",null,"S'External_TagS'External_Tag denotes an external string representation for S'Tag; it is of the predefined type String. External_Tag may be specified for a specific tagged type via an attribute_definition_clause; the expression of such a clause shall be static. The default external tag representation is implementation defined. See 3.9.2 and 13.13.2. "),(0,i.kt)("p",null,"Implementation defined: The default external representation for a type tag."),(0,i.kt)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation, the default external tag for each specific tagged type declared in a partition shall be distinct, so long as the type is declared outside an instance of a generic body. If the compilation unit in which a given tagged type is declared, and all compilation units on which it semantically depends, are the same in two different partitions, then the external tag for the type shall be the same in the two partitions. What it means for a compilation unit to be the same in two different partitions is implementation defined. At a minimum, if the compilation unit is not recompiled between building the two different partitions that include it, the compilation unit is considered the same in the two partitions. "),(0,i.kt)("p",null,"Implementation defined: What determines whether a compilation unit is the same in two different partitions."),(0,i.kt)("p",null,"Reason: These requirements are important because external tags are used for input/output of class-wide types. These requirements ensure that what is written by one program can be read back by some other program so long as they share the same declaration for the type (and everything it depends on)."),(0,i.kt)("p",null,"The user may specify the external tag if (s)he wishes its value to be stable even across changes to the compilation unit in which the type is declared (or changes in some unit on which it depends)."),(0,i.kt)("p",null,"We use a String rather than a Storage_Array to represent an external tag for portability. "),(0,i.kt)("p",null,"Ramification: Note that the characters of an external tag need not all be graphic characters. In other words, the external tag can be a sequence of arbitrary 8-bit bytes. "),(0,i.kt)("p",null,"NOTE 8   The following language-defined attributes are specifiable, at least for some of the kinds of entities to which they apply: Address, Size, Component_Size, Alignment, External_Tag, Small, Bit_Order, Storage_Pool, Storage_Size, Write, Output, Read, Input, and Machine_Radix."),(0,i.kt)("p",null,"NOTE 9   It follows from the general rules in 13.1 that if one writes \"for X'Size use Y;\" then the X'Size attribute_reference will return Y (assuming the implementation allows the Size clause). The same is true for all of the specifiable attributes except Storage_Size. "),(0,i.kt)("p",null,"Ramification: An implementation may specify that an implementation-defined attribute is specifiable for certain entities. This follows from the fact that the semantics of implementation-defined attributes is implementation defined. An implementation is not allowed to make a language-defined attribute specifiable if it isn't. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of attribute definition clauses: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Byte : constant := 8;\nPage : constant := 2**12;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Medium is range 0 .. 65_000;\nfor Medium'Size use 2*Byte;\nfor Medium'Alignment use 2;\nDevice_Register : Medium;\nfor Device_Register'Size use Medium'Size;\nfor Device_Register'Address use \n   System.Storage_Elements.To_Address(16#FFFF_0020#);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Short is delta 0.01 range -100.0 .. 100.0;\nfor Short'Size use 15;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Car_Name'Storage_Size use -- specify access type's storage pool size\n        2000*((Car'Size/System.Storage_Unit) +1); -- approximately 2000 cars\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function My_Read(Stream : access Ada.Streams.Root_Stream_Type'Class)\n   return T;\nfor T'Read use My_Read; -- see 13.13.2\n\n")),(0,i.kt)("p",null,"NOTE 10   Notes on the examples: In the Size clause for Short, fifteen bits is the minimum necessary, since the type definition requires Short'Small ","<","= 2**(7). "),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for length_clause is replaced with the new syntax rule for attribute_definition_clause, and it is modified to allow a name (as well as an expression). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for attribute_definition_clause now requires that the prefix of the attribute be a local_name; in Ada 83 this rule was stated in the text."),(0,i.kt)("p",null,"In Ada 83, the relationship between a representation_clause specifying a certain aspect and an attribute that queried that aspect was unclear. In Ada 95, they are the same, except for certain explicit exceptions. "),(0,i.kt)("h2",{id:"134--enumeration-representation-clauses"},"13.4  Enumeration Representation Clauses"),(0,i.kt)("p",null,"[An enumeration_representation_clause specifies the internal codes for enumeration literals.]"," "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"enumeration_representation_clause ::=\nfor first_subtype_local_name use enumeration_aggregate;"),(0,i.kt)("p",null,"enumeration_aggregate ::= array_aggregate"),(0,i.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,i.kt)("p",null,"The enumeration_aggregate shall be written as a one-dimensional array_aggregate, for which the index subtype is the unconstrained subtype of the enumeration type, and each component expression is expected to be of any integer type. "),(0,i.kt)("p",null,'Ramification: The "full coverage rules" for aggregates applies. An others is not allowed - there is no applicable index constraint in this context. '),(0,i.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,i.kt)("p",null,"The first_subtype_local_name of an enumeration_representation_clause shall denote an enumeration subtype. "),(0,i.kt)("p",null,"Ramification: As for all type-related representation items, the local_name is required to denote a first subtype. "),(0,i.kt)("p",null,"The expressions given in the array_aggregate shall be static, and shall specify distinct integer codes for each value of the enumeration type; the associated integer codes shall satisfy the predefined ordering relation of the type. "),(0,i.kt)("p",null,"Reason: Each value of the enumeration type has to be given an internal code, even if the first subtype of the enumeration type is constrained to only a subrange (this is only possible if the enumeration type is a derived type). This \"full coverage\" requirement is important because one may refer to Enum'Base'First and Enum'Base'Last, which need to have defined representations. "),(0,i.kt)("h4",{id:"static-semantics-11"},"Static Semantics"),(0,i.kt)("p",null,"An enumeration_representation_clause specifies the coding aspect of representation. The coding consists of the internal code for each enumeration literal, that is, the integral value used internally to represent each literal."),(0,i.kt)("h4",{id:"implementation-requirements-2"},"Implementation Requirements"),(0,i.kt)("p",null,"For nonboolean enumeration types, if the coding is not specified for the type, then for each value of the type, the internal code shall be equal to its position number. "),(0,i.kt)("p",null,"Reason: This default representation is already used by all known Ada compilers for nonboolean enumeration types. Therefore, we make it a requirement so users can depend on it, rather than feeling obliged to supply for every enumeration type an enumeration representation clause that is equivalent to this default rule. "),(0,i.kt)("p",null,"Discussion: For boolean types, it is relatively common to use all ones for True, and all zeros for False, since some hardware supports that directly. Of course, for a one-bit Boolean object (like in a packed array), False is presumably zero and True is presumably one (choosing the reverse would be extremely unfriendly!). "),(0,i.kt)("h4",{id:"implementation-advice-7"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for enumeration_representation_clauses is: "),(0,i.kt)("p",null,"An implementation should support at least the internal codes in the range System.Min_Int .. System.Max_Int. An implementation need not support enumeration_representation_clauses for boolean types. "),(0,i.kt)("p",null,"Ramification: The implementation may support numbers outside the above range, such as numbers greater than System.Max_Int. See AI83-00564. "),(0,i.kt)("p",null,"Reason: The benefits of specifying the internal coding of a boolean type do not outweigh the implementation costs. Consider, for example, the implementation of the logical operators on a packed array of booleans with strange internal codes. It's implementable, but not worth it. "),(0,i.kt)("h4",{id:"static-semantics-12"},"Static Semantics"),(0,i.kt)("p",null,"NOTE   Unchecked_Conversion may be used to query the internal codes used for an enumeration type. The attributes of the type, such as Succ, Pred, and Pos, are unaffected by the representation_clause. For example, Pos always returns the position number, not the internal integer code that might have been specified in a representation_clause}. "),(0,i.kt)("p",null,"Discussion: Suppose the enumeration type in question is derived: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T1 is (Red, Green, Blue);\nsubtype S1 is T1 range Red .. Green;\ntype S2 is new S1;\nfor S2 use (Red =&gt 10, Green =&gt 20, Blue =&gt 30);\n\n")),(0,i.kt)("p",null,"The representation_clause has to specify values for all enumerals, even ones that are not in S2 (such as Blue). The Base attribute can be used to get at these values. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for I in S2'Base loop\n    ... -- When I equals Blue, the internal code is 30.\nend loop;\n\n")),(0,i.kt)("p",null,"We considered allowing or requiring \"for S2'Base use ...\" in cases like this, but it didn't seem worth the trouble. "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Example of an enumeration representation clause: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Mix_Code use\n   (ADD =&gt 1, SUB =&gt 2, MUL =&gt 3, LDA =&gt 8, STA =&gt 24, STZ =&gt33);\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"As in other similar contexts, Ada 95 allows expressions of any integer type, not just expressions of type universal_integer, for the component expressions in the enumeration_aggregate. The preference rules for the predefined operators of root_integer eliminate any ambiguity."),(0,i.kt)("p",null,'For portability, we now require that the default coding for an enumeration type be the "obvious" coding using position numbers. This is satisfied by all known implementations. '),(0,i.kt)("h2",{id:"135--record-layout"},"13.5  Record Layout"),(0,i.kt)("p",null,"The (record) layout aspect of representation consists of the storage places for some or all components, that is, storage place attributes of the components. The layout can be specified with a record_representation_clause. "),(0,i.kt)("h3",{id:"1351--record-representation-clauses"},"13.5.1  Record Representation Clauses"),(0,i.kt)("p",null,"[A record_representation_clause specifies the storage representation of records and record extensions, that is, the order, position, and size of components (including discriminants, if any). ]"),(0,i.kt)("h4",{id:"language-design-principles-2"},"Language Design Principles"),(0,i.kt)("p",null,"It should be feasible for an implementation to use negative offsets in the representation of composite types. However, no implementation should be forced to support negative offsets. Therefore, negative offsets should be disallowed in record_representation_clauses. "),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("p",null,"record_representation_clause ::=\nfor first_subtype_local_name use\nrecord ","[mod_clause]","\n{component_clause}\nend record;"),(0,i.kt)("p",null,"component_clause ::=\ncomponent_local_name at position range first_bit .. last_bit;"),(0,i.kt)("p",null,"position ::= static_expression"),(0,i.kt)("p",null,"first_bit ::= static_simple_expression"),(0,i.kt)("p",null,"last_bit ::= static_simple_expression"),(0,i.kt)("p",null,'Reason: First_bit and last_bit need to be simple_expression instead of expression for the same reason as in range (see 3.5, "Scalar Types"). '),(0,i.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,i.kt)("p",null,"Each position, first_bit, and last_bit is expected to be of any integer type. "),(0,i.kt)("p",null,"Ramification: These need not have the same integer type. "),(0,i.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,i.kt)("p",null,"The first_subtype_local_name of a record_representation_clause shall denote a specific nonlimited record or record extension subtype. "),(0,i.kt)("p",null,"Ramification: As for all type-related representation items, the local_name is required to denote a first subtype. "),(0,i.kt)("p",null,"If the component_local_name is a direct_name, the local_name shall denote a component of the type. For a record extension, the component shall not be inherited, and shall not be a discriminant that corresponds to a discriminant of the parent type. If the component_local_name has an attribute_designator, the direct_name of the local_name shall denote either the declaration of the type or a component of the type, and the attribute_designator shall denote an implementation-defined implicit component of the type."),(0,i.kt)("p",null,"The position, first_bit, and last_bit shall be static expressions. The value of position and first_bit shall be nonnegative. The value of last_bit shall be no less than first_bit  1. "),(0,i.kt)("p",null,'Ramification: A component_clause such as "X at 4 range 0..1;" is allowed if X can fit in zero bits. '),(0,i.kt)("p",null,"At most one component_clause is allowed for each component of the type, including for each discriminant (component_clauses may be given for some, all, or none of the components). Storage places within a component_list shall not overlap, unless they are for components in distinct variants of the same variant_part."),(0,i.kt)("p",null,"A name that denotes a component of a type is not allowed within a record_representation_clause for the type, except as the component_local_name of a component_clause. "),(0,i.kt)("p",null,"Reason: It might seem strange to make the record_representation_clause part of the declarative region, and then disallow mentions of the components within almost all of the record_representation_clause. The alternative would be to treat the component_local_name like a formal parameter name in a subprogram call (in terms of visibility). However, this rule would imply slightly different semantics, because (given the actual rule) the components can hide other declarations. This was the rule in Ada 83, and we see no reason to change it. The following, for example, was and is illegal: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T is\n    record\n        X : Integer;\n    end record;\nX : constant := 31; -- Same defining name as the component.\nfor T use\n    record\n        X at 0 range 0..X; -- Illegal!\n    end record;\n    \n\n")),(0,i.kt)("p",null,"The component X hides the named number X throughout the record_representation_clause. "),(0,i.kt)("h4",{id:"static-semantics-13"},"Static Semantics"),(0,i.kt)("p",null,"A record_representation_clause (without the mod_clause) specifies the layout. The storage place attributes (see 13.5.2) are taken from the values of the position, first_bit, and last_bit expressions after normalizing those values so that first_bit is less than Storage_Unit."),(0,i.kt)("p",null,"Ramification: For example, if Storage_Unit is 8, then \"C at 0 range 24..31;\" defines C'Position = 3, C'First_Bit = 0, and C'Last_Bit = 7. This is true of machines with either bit ordering."),(0,i.kt)("p",null,"A component_clause also determines the value of the Size attribute of the component, since this attribute is related to First_Bit and Last_Bit. "),(0,i.kt)("p",null,"[A record_representation_clause for a record extension does not override the layout of the parent part;]"," if the layout was specified for the parent type, it is inherited by the record extension. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may generate implementation-defined components (for example, one containing the offset of another component). An implementation may generate names that denote such implementation-defined components; such names shall be implementation-defined attribute_references. An implementation may allow such implementation-defined names to be used in record_representation_clauses. An implementation can restrict such component_clauses in any manner it sees fit. "),(0,i.kt)("p",null,"Implementation defined: Implementation-defined components."),(0,i.kt)("p",null,"Ramification: Of course, since the semantics of implementation-defined attributes is implementation defined, the implementation need not support these names in all situations. They might be purely for the purpose of component_clauses, for example. The visibility rules for such names are up to the implementation."),(0,i.kt)("p",null,"We do not allow such component names to be normal identifiers - that would constitute blanket permission to do all kinds of evil things. "),(0,i.kt)("p",null,'Discussion: Such implementation-defined components are known in the vernacular as "dope". Their main purpose is for storing offsets of components that depend on discriminants. '),(0,i.kt)("p",null,"If a record_representation_clause is given for an untagged derived type, the storage place attributes for all of the components of the derived type may differ from those of the corresponding components of the parent type, even for components whose storage place is not specified explicitly in the record_representation_clause. "),(0,i.kt)("p",null,"Reason: This is clearly necessary, since the whole record may need to be laid out differently. "),(0,i.kt)("h4",{id:"implementation-advice-8"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for record_representation_clauses is: "),(0,i.kt)("p",null,"An implementation should support storage places that can be extracted with a load, mask, shift sequence of machine code, and set with a load, shift, mask, store sequence, given the available machine instructions and run-time model."),(0,i.kt)("p",null,"A storage place should be supported if its size is equal to the Size of the component subtype, and it starts and ends on a boundary that obeys the Alignment of the component subtype."),(0,i.kt)("p",null,"If the default bit ordering applies to the declaration of a given type, then for a component whose subtype's Size is less than the word size, any storage place that does not cross an aligned word boundary should be supported."),(0,i.kt)("p",null,"Reason: The above recommendations are sufficient to define interfaces to most interesting hardware. This causes less implementation burden than the definition in ACID, which requires arbitrary bit alignments of arbitrarily large components. Since the ACID definition is neither enforced by the ACVC, nor supported by all implementations, it seems OK for us to weaken it. "),(0,i.kt)("p",null,"An implementation may reserve a storage place for the tag field of a tagged type, and disallow other components from overlapping that place. "),(0,i.kt)("p",null,"Ramification: Similar permission for other dope is not granted. "),(0,i.kt)("p",null,"An implementation need not support a component_clause for a component of an extension part if the storage place is not after the storage places of all components of the parent type, whether or not those storage places had been specified. "),(0,i.kt)("p",null,'Reason: These restrictions are probably necessary if block equality operations are to be feasible for class-wide types. For block comparison to work, the implementation typically has to fill in any gaps with zero (or one) bits. If a "gap" in the parent type is filled in with a component in a type extension, then this won\'t work when a class-wide object is passed by reference, as is required. '),(0,i.kt)("p",null,"NOTE   If no component_clause is given for a component, then the choice of the storage place for the component is left to the implementation. If component_clauses are given for all components, the record_representation_clause completely specifies the representation of the type and will be obeyed exactly by the implementation. "),(0,i.kt)("p",null,"Ramification: The visibility rules prevent the name of a component of the type from appearing in a record_representation_clause at any place except for the component_local_name of a component_clause. However, since the record_representation_clause is part of the declarative region of the type declaration, the component names hide outer homographs throughout."),(0,i.kt)("p",null,"A record_representation_clause cannot be given for a protected type, even though protected types, like record types, have components. The primary reason for this rule is that there is likely to be too much dope in a protected type - entry queues, bit maps for barrier values, etc. In order to control the representation of the user-defined components, simply declare a record type, give it a representation_clause, and give the protected type one component whose type is the record type. Alternatively, if the protected object is protecting something like a device register, it makes more sense to keep the thing being protected outside the protected object (possibly with a pointer to it in the protected object), in order to keep implementation-defined components out of the way. "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Example of specifying the layout of a record type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Word : constant := 4;  --  storage element is byte, 4 bytes per word\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type State         is (A,M,W,P);\ntype Mode          is (Fix, Dec, Exp, Signif);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Byte_Mask     is array (0..7)  of Boolean;\ntype State_Mask    is array (State) of Boolean;\ntype Mode_Mask     is array (Mode)  of Boolean;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Program_Status_Word is\n  record\n      System_Mask        : Byte_Mask;\n      Protection_Key     : Integer range 0 .. 3;\n      Machine_State      : State_Mask;\n      Interrupt_Cause    : Interruption_Code;\n      Ilc                : Integer range 0 .. 3;\n      Cc                 : Integer range 0 .. 3;\n      Program_Mask       : Mode_Mask;\n      Inst_Address       : Address;\nend record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Program_Status_Word use\n  record\n      System_Mask      at 0*Word range 0  .. 7;\n      Protection_Key   at 0*Word range 10 .. 11; -- bits 8,9 unused\n      Machine_State    at 0*Word range 12 .. 15;\n      Interrupt_Cause  at 0*Word range 16 .. 31;\n      Ilc              at 1*Word range 0  .. 1;  -- second word\n      Cc               at 1*Word range 2  .. 3;\n      Program_Mask     at 1*Word range 4  .. 7;\n      Inst_Address     at 1*Word range 8  .. 31;\n  end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Program_Status_Word'Size use 8*System.Storage_Unit;\nfor Program_Status_Word'Alignment use 8;\n\n")),(0,i.kt)("p",null,"NOTE 1   Note on the example: The record_representation_clause defines the record layout. The Size clause guarantees that (at least) eight storage elements are used for objects of the type. The Alignment clause guarantees that aliased, imported, or exported objects of the type will have addresses divisible by eight. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The alignment_clause has been renamed to mod_clause and moved to Annex J, "Obsolescent Features".'),(0,i.kt)("p",null,"We have clarified that implementation-defined component names have to be in the form of an attribute_reference of a component or of the first subtype itself; surely Ada 83 did not intend to allow arbitrary identifiers."),(0,i.kt)("p",null,"The RM83-13.4(7) wording incorrectly allows components in nonvariant records to overlap. We have corrected that oversight. "),(0,i.kt)("h3",{id:"1352--storage-place-attributes"},"13.5.2  Storage Place Attributes"),(0,i.kt)("h4",{id:"static-semantics-14"},"Static Semantics"),(0,i.kt)("p",null,"For a component C of a composite, non-array object R, the storage place attributes are defined: "),(0,i.kt)("p",null,"Ramification: The storage place attributes are not (individually) specifiable, but the user may control their values by giving a record_representation_clause. "),(0,i.kt)("p",null,"R.C'PositionDenotes the same value as R.C'Address  R'Address. The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"Ramification: Thus, R.C'Position is the offset of C in storage elements from the beginning of the object, where the first storage element of an object is numbered zero. R'Address + R.C'Position = R.C'Address. For record extensions, the offset is not measured from the beginning of the extension part, but from the beginning of the whole object, as usual."),(0,i.kt)("p",null,'In "R.C\'Address  R\'Address", the "" operator is the one in System.Storage_Elements that takes two Addresses and returns a Storage_Offset. '),(0,i.kt)("p",null,"R.C'First_BitDenotes the offset, from the start of the first of the storage elements occupied by C, of the first bit occupied by C. This offset is measured in bits. The first bit of a storage element is numbered zero. The value of this attribute is of the type universal_integer."),(0,i.kt)("p",null,"R.C'Last_BitDenotes the offset, from the start of the first of the storage elements occupied by C, of the last bit occupied by C. This offset is measured in bits. The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,'Ramification: The ordering of bits in a storage element is is defined in 13.5.3, "Bit Ordering".'),(0,i.kt)("p",null,"R.C'Size = R.C'Last_Bit  R.C'First_Bit + 1. (Unless the implementation chooses an indirection representation.)"),(0,i.kt)("p",null,"If a component_clause applies to a component, then that component will be at the same relative storage place in all objects of the type. Otherwise, there is no such requirement. "),(0,i.kt)("h4",{id:"implementation-advice-9"},"Implementation Advice"),(0,i.kt)("p",null,"If a component is represented using some form of pointer (such as an offset) to the actual data of the component, and this data is contiguous with the rest of the object, then the storage place attributes should reflect the place of the actual data, not the pointer. If a component is allocated discontiguously from the rest of the object, then a warning should be generated upon reference to one of its storage place attributes. "),(0,i.kt)("p",null,"Reason: For discontiguous components, these attributes make no sense. For example, an implementation might allocate dynamic-sized components on the heap. For another example, an implementation might allocate the discriminants separately from the other components, so that multiple objects of the same subtype can share discriminants. Such representations cannot happen if there is a component_clause for that component. "),(0,i.kt)("h3",{id:"1353--bit-ordering"},"13.5.3  Bit Ordering"),(0,i.kt)("p",null,"[The Bit_Order attribute specifies the interpretation of the storage place attributes.]"," "),(0,i.kt)("p",null,"Reason: The intention is to provide uniformity in the interpretation of storage places across implementations on a particular machine by allowing the user to specify the Bit_Order. It is not intended to fully support data interoperability across different machines, although it can be used for that purpose in some situations."),(0,i.kt)("p",null,"We can't require all implementations on a given machine to use the same bit ordering by default; if the user cares, a pragma Bit_Order can be used to force all implementations to use the same bit ordering. "),(0,i.kt)("h4",{id:"static-semantics-15"},"Static Semantics"),(0,i.kt)("p",null,"A bit ordering is a method of interpreting the meaning of the storage place attributes. High_Order_First ",'[(known in the vernacular as "big endian")]'," means that the first bit of a storage element (bit 0) is the most significant bit (interpreting the sequence of bits that represent a component as an unsigned integer value). Low_Order_First ",'[(known in the vernacular as "little endian")]'," means the opposite: the first bit is the least significant."),(0,i.kt)("p",null,"For every specific record subtype S, the following attribute is defined: "),(0,i.kt)("p",null,"S'Bit_OrderDenotes the bit ordering for the type of S. The value of this attribute is of type System.Bit_Order. Bit_Order may be specified for specific record types via an attribute_definition_clause; the expression of such a clause shall be static."),(0,i.kt)("p",null,"If Word_Size = Storage_Unit, the default bit ordering is implementation defined. If Word_Size ",">"," Storage_Unit, the default bit ordering is the same as the ordering of storage elements in a word, when interpreted as an integer. "),(0,i.kt)("p",null,"Implementation defined: If Word_Size = Storage_Unit, the default bit ordering."),(0,i.kt)("p",null,"Ramification: Consider machines whose Word_Size = 32, and whose Storage_Unit = 8. Assume the default bit ordering applies. On a machine with big-endian addresses, the most significant storage element of an integer is at the address of the integer. Therefore, bit zero of a storage element is the most significant bit. On a machine with little-endian addresses, the least significant storage element of an integer is at the address of the integer. Therefore, bit zero of a storage element is the least significant bit. "),(0,i.kt)("p",null,"The storage place attributes of a component of a type are interpreted according to the bit ordering of the type. "),(0,i.kt)("p",null,"Ramification: This implies that the interpretation of the position, first_bit, and last_bit of a component_clause of a record_representation_clause obey the bit ordering given in a representation item. "),(0,i.kt)("h4",{id:"implementation-advice-10"},"Implementation Advice"),(0,i.kt)("p",null,"The recommended level of support for the nondefault bit ordering is: "),(0,i.kt)("p",null,"If Word_Size = Storage_Unit, then the implementation should support the nondefault bit ordering in addition to the default bit ordering. "),(0,i.kt)("p",null,"Ramification: If Word_Size = Storage_Unit, the implementation should support both bit orderings. We don't push for support of the nondefault bit ordering when Word_Size ",">"," Storage_Unit (except of course for upward compatibility with a preexisting implementation whose Ada 83 bit order did not correspond to the required Ada 95 default bit order), because implementations are required to support storage positions that cross storage element boundaries when Word_Size ",">"," Storage_Unit. Such storage positions will be split into two or three pieces if the nondefault bit ordering is used, which could be onerous to support. However, if Word_Size = Storage_Unit, there might not be a natural bit ordering, but the splitting problem need not occur. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The Bit_Order attribute is new to Ada 95. "),(0,i.kt)("h2",{id:"136--change-of-representation"},"13.6  Change of Representation"),(0,i.kt)("p",null,"[ A type_conversion (see 4.6) can be used to convert between two different representations of the same array or record. To convert an array from one representation to another, two array types need to be declared with matching component subtypes, and convertible index types. If one type has packing specified and the other does not, then explicit conversion can be used to pack or unpack an array."),(0,i.kt)("p",null,"To convert a record from one representation to another, two record types with a common ancestor type need to be declared, with no inherited subprograms. Distinct representations can then be specified for the record types, and explicit conversion between the types can be used to effect a change in representation.] "),(0,i.kt)("p",null,"Ramification: This technique does not work if the first type is an untagged type with user-defined primitive subprograms. It does not work at all for tagged types. "),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Example of change of representation: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-- Packed_Descriptor and Descriptor are two different types\n-- with identical characteristics, apart from their\n-- representation\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Descriptor is\n    record\n      -- components of a descriptor\n    end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Packed_Descriptor is new Descriptor;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for Packed_Descriptor use\n    record\n      -- component clauses for some or for all components\n    end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-- Change of representation can now be accomplished by explicit type conversions:\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"D : Descriptor;\nP : Packed_Descriptor;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"P := Packed_Descriptor(D);  -- pack D\nD := Descriptor(P);         -- unpack P\n\n")),(0,i.kt)("h2",{id:"137--the-package-system"},"13.7  The Package System"),(0,i.kt)("p",null,"[For each implementation there is a library package called System which includes the definitions of certain configuration-dependent characteristics.]"," "),(0,i.kt)("h4",{id:"static-semantics-16"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("p",null,"Implementation defined: The contents of the visible part of package Systemand its language-defined children."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package System is\n   pragma Preelaborate(System);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Name is implementation-defined-enumeration-type;\n   System_Name : constant Name := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- System-Dependent Named Numbers:\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Min_Int               : constant := root_integer'First;\n   Max_Int               : constant := root_integer'Last;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Max_Binary_Modulus    : constant := implementation-defined;\n   Max_Nonbinary_Modulus : constant := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Max_Base_Digits       : constant := root_real'Digits;\n   Max_Digits            : constant := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Max_Mantissa          : constant := implementation-defined;\n   Fine_Delta            : constant := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Tick                  : constant := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Storage-related Declarations:\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Address is implementation-defined;\n   Null_Address : constant Address;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Storage_Unit : constant := implementation-defined;\n   Word_Size    : constant := implementation-defined * Storage_Unit;\n   Memory_Size  : constant := implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   -- Address Comparison:\n   function "&lt" (Left, Right : Address) return Boolean;\n   function "&lt="(Left, Right : Address) return Boolean;\n   function "&gt" (Left, Right : Address) return Boolean;\n   function "&gt="(Left, Right : Address) return Boolean;\n   function "=" (Left, Right : Address) return Boolean;\n-- function "/=" (Left, Right : Address) return Boolean;\n   -- "/=" is implicitly defined\n   pragma Convention(Intrinsic, "&lt");\n   ... -- and so on for all language-defined subprograms in this package\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Other System-Dependent Declarations:\n   type Bit_Order is (High_Order_First, Low_Order_First);\n   Default_Bit_Order : constant Bit_Order;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Priority-related declarations (see D.1):\n   subtype Any_Priority is Integer range implementation-defined;\n   subtype Priority is Any_Priority range Any_Priority'First ..\n             implementation-defined;\n   subtype Interrupt_Priority is Any_Priority range Priority'Last+1 ..\n             Any_Priority'Last;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Default_Priority : constant Priority :=\n             (Priority'First + Priority'Last)/2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend System;\n\n")),(0,i.kt)("p",null,"Name is an enumeration subtype. Values of type Name are the names of alternative machine configurations handled by the implementation. System_Name represents the current machine configuration."),(0,i.kt)("p",null,"The named numbers Fine_Delta and Tick are of the type universal_real; the others are of the type universal_integer."),(0,i.kt)("p",null,"The meanings of the named numbers are: "),(0,i.kt)("p",null,"[ Min_Int The smallest (most negative) value allowed for the expressions of a signed_integer_type_definition."),(0,i.kt)("p",null,"Max_Int The largest (most positive) value allowed for the expressions of a signed_integer_type_definition."),(0,i.kt)("p",null,"Max_Binary_Modulus A power of two such that it, and all lesser positive powers of two, are allowed as the modulus of a modular_type_definition."),(0,i.kt)("p",null,"Max_Nonbinary_Modulus A value such that it, and all lesser positive integers, are allowed as the modulus of a modular_type_definition. "),(0,i.kt)("p",null,"Ramification: There is no requirement that Max_Nonbinary_Modulus be less than or equal to Max_Binary_Modulus, although that's what makes most sense. On a typical 32-bit machine, for example, Max_Binary_Modulus will be 2",(0,i.kt)("strong",{parentName:"p"},"32 and Max_Nonbinary_Modulus will be 2"),"31, because supporting nonbinary moduli in above 2**31 causes implementation difficulties. "),(0,i.kt)("p",null,"Max_Base_Digits The largest value allowed for the requested decimal precision in a floating_point_definition."),(0,i.kt)("p",null,"Max_Digits The largest value allowed for the requested decimal precision in a floating_point_definition that has no real_range_specification. Max_Digits is less than or equal to Max_Base_Digits."),(0,i.kt)("p",null,"Max_Mantissa The largest possible number of binary digits in the mantissa of machine numbers of a user-defined ordinary fixed point type. (The mantissa is defined in Annex G.)"),(0,i.kt)("p",null,"Fine_Delta The smallest delta allowed in an ordinary_fixed_point_definition that has the real_range_specification range 1.0 .. 1.0. ]"),(0,i.kt)("p",null,"Tick A period in seconds approximating the real time interval during which the value of Calendar.Clock remains constant. "),(0,i.kt)("p",null,"Ramification: There is no required relationship between System.Tick and Duration'Small, other than the one described here."),(0,i.kt)("p",null,"The inaccuracy of the delay_statement has no relation to Tick. In particular, it is possible that the clock used for the delay_statement is less accurate than Calendar.Clock."),(0,i.kt)("p",null,'We considered making Tick a run-time-determined quantity, to allow for easier configurability. However, this would not be upward compatible, and the desired configurability can be achieved using functionality defined in Annex D, "Real-Time Systems". '),(0,i.kt)("p",null,"Storage_Unit The number of bits per storage element."),(0,i.kt)("p",null,"Word_Size The number of bits per word."),(0,i.kt)("p",null,"Memory_Size An implementation-defined value ","[that is intended to reflect the memory size of the configuration in storage elements.]"," "),(0,i.kt)("p",null,'Discussion: It is unspecified whether this refers to the size of the address space, the amount of physical memory on the machine, or perhaps some other interpretation of "memory size". In any case, the value has to be given by a static expression, even though the amount of memory on many modern machines is a dynamic quantity in several ways. Thus, Memory_Size is not very useful. '),(0,i.kt)("p",null,"Address is of a definite, nonlimited type. Address represents machine addresses capable of addressing individual storage elements. Null_Address is an address that is distinct from the address of any object or program unit. "),(0,i.kt)("p",null,"Ramification: The implementation has to ensure that there is at least one address that nothing will be allocated to; Null_Address will be one such address. "),(0,i.kt)("p",null,"Ramification: Address is the type of the result of the attribute Address. "),(0,i.kt)("p",null,"Reason: Address is required to be nonlimited and definite because it is important to be able to assign addresses, and to declare uninitialized address variables. "),(0,i.kt)("p",null,"See 13.5.3 for an explanation of Bit_Order and Default_Bit_Order. "),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may add additional implementation-defined declarations to package System and its children. ","[However, it is usually better for the implementation to provide additional functionality via implementation-defined children of System.]"," Package System may be declared pure. "),(0,i.kt)("p",null,'Ramification: The declarations in package System and its children can be implicit. For example, since Address is not limited, the predefined "=" and "/=" operations are probably sufficient. However, the implementation is not required to use the predefined "=". '),(0,i.kt)("h4",{id:"implementation-advice-11"},"Implementation Advice"),(0,i.kt)("p",null,"Address should be of a private type. "),(0,i.kt)("p",null,"Reason: This promotes uniformity by avoiding having implementation-defined predefined operations for the type. We don't require it, because implementations may want to stick with what they have. "),(0,i.kt)("p",null,"Implementation Note: It is not necessary for Address to be able to point at individual bits within a storage element. Nor is it necessary for it to be able to point at machine registers. It is intended as a memory address that matches the hardware's notion of an address."),(0,i.kt)("p",null,"The representation of the null value of a general access type should be the same as that of Null_Address; instantiations of Unchecked_Conversion should work accordingly. If the implementation supports interfaces to other languages, the representation of the null value of a general access type should be the same as in those other languages, if appropriate."),(0,i.kt)("p",null,"Note that the children of the Interfaces package will generally provide foreign-language-specific null values where appropriate. See UI-0065 regarding Null_Address. "),(0,i.kt)("p",null,"NOTE 1   There are also some language-defined child packages of System defined elsewhere. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-7"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Much of the content of System is standardized, to provide more uniformity across implementations. Implementations can still add their own declarations to System, but are encouraged to do so via children of System."),(0,i.kt)("p",null,"Some of the named numbers are defined more explicitly in terms of the standard numeric types."),(0,i.kt)("p",null,"The pragmas System_Name, Storage_Unit, and Memory_Size are no longer defined by the language. However, the corresponding declarations in package System still exist. Existing implementations may continue to support the three pragmas as implementation-defined pragmas, if they so desire."),(0,i.kt)("p",null,"Priority semantics, including subtype Priority, have been moved to the Real Time Annex. "),(0,i.kt)("h3",{id:"1371--the-package-systemstorage_elements"},"13.7.1  The Package System.Storage_Elements"),(0,i.kt)("h4",{id:"static-semantics-17"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package System.Storage_Elements is\n   pragma Preelaborate(System.Storage_Elements);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Storage_Offset is range implementation-defined;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   subtype Storage_Count is Storage_Offset range 0..Storage_Offset'Last;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Storage_Element is mod implementation-defined;\n   for Storage_Element'Size use Storage_Unit;\n   type Storage_Array is array\n     (Storage_Offset range &lt&gt) of aliased Storage_Element;\n   for Storage_Array'Component_Size use Storage_Unit;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Address Arithmetic:\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "+"(Left : Address; Right : Storage_Offset)\n      return Address;\n   function "+"(Left : Storage_Offset; Right : Address)\n      return Address;\n   function "-"(Left : Address; Right : Storage_Offset)\n      return Address;\n   function "-"(Left, Right : Address)\n      return Storage_Offset;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "mod"(Left : Address; Right : Storage_Offset)\n      return Storage_Offset;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Conversion to/from integers:\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Integer_Address is implementation-defined;\n   function To_Address(Value : Integer_Address) return Address;\n   function To_Integer(Value : Address) return Integer_Address;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   pragma Convention(Intrinsic, "+");\n      -- ...and so on for all language-defined subprograms declared in this package.\nend System.Storage_Elements;\n\n')),(0,i.kt)("p",null,"Reason: The Convention pragmas imply that the attribute Access is not allowed for those operations."),(0,i.kt)("p",null,"The mod function is needed so that the definition of Alignment makes sense. "),(0,i.kt)("p",null,"Storage_Element represents a storage element. Storage_Offset represents an offset in storage elements. Storage_Count represents a number of storage elements. Storage_Array represents a contiguous sequence of storage elements. "),(0,i.kt)("p",null,"Reason: The index subtype of Storage_Array is Storage_Offset because we wish to allow maximum flexibility. Most Storage_Arrays will probably have a lower bound of 0 or 1, but other lower bounds, including negative ones, make sense in some situations."),(0,i.kt)("p",null,"Note that there are some language-defined subprograms that fill part of a Storage_Array, and return the index of the last element filled as a Storage_Offset. The Read procedures in Streams (see 13.13.1), Streams.Stream_IO (see A.12.1), and System.RPC (see E.5) behave in this manner. These will raise Constraint_Error if the resulting Last value is not in Storage_Offset. This implies that the Storage_Array passed to these subprograms should not have a lower bound of Storage_Offset'First, because then a read of 0 elements would always raise Constraint_Error. A better choice of lower bound is 1. "),(0,i.kt)("p",null,"Integer_Address is a ","[(signed or modular)]"," integer subtype. To_Address and To_Integer convert back and forth between this type and Address. "),(0,i.kt)("h4",{id:"implementation-requirements-3"},"Implementation Requirements"),(0,i.kt)("p",null,"Storage_Offset'Last shall be greater than or equal to Integer'Last or the largest possible storage offset, whichever is smaller. Storage_Offset'First shall be ","<","= (Storage_Offset'Last). "),(0,i.kt)("h4",{id:"implementation-permissions-3"},"Implementation Permissions"),(0,i.kt)("p",null,"Package System.Storage_Elements may be declared pure. "),(0,i.kt)("h4",{id:"implementation-advice-12"},"Implementation Advice"),(0,i.kt)("p",null,'Operations in System and its children should reflect the target environment semantics as closely as is reasonable. For example, on most machines, it makes sense for address arithmetic to "wrap around". Operations that do not make sense should raise Program_Error. '),(0,i.kt)("p",null,"Discussion: For example, on a segmented architecture, X ","<"," Y might raise Program_Error if X and Y do not point at the same segment (assuming segments are unordered). Similarly, on a segmented architecture, the conversions between Integer_Address and Address might not make sense for some values, and so might raise Program_Error. "),(0,i.kt)("p",null,"Reason: We considered making Storage_Element a private type. However, it is better to declare it as a modular type in the visible part, since code that uses it is already low level, and might as well have access to the underlying representation. We also considered allowing Storage_Element to be any integer type, signed integer or modular, but it is better to have uniformity across implementations in this regard, and viewing storage elements as unsigned seemed to make the most sense. "),(0,i.kt)("p",null,"Implementation Note: To_Address is intended for use in Address clauses. Implementations should overload To_Address if appropriate. For example, on a segmented architecture, it might make sense to have a record type representing a segment/offset pair, and have a To_Address conversion that converts from that record type to type Address. "),(0,i.kt)("h3",{id:"1372--the-package-systemaddress_to_access_conversions"},"13.7.2  The Package System.Address_To_Access_Conversions"),(0,i.kt)("h4",{id:"static-semantics-18"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined generic library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Object(&lt&gt) is limited private;\npackage System.Address_To_Access_Conversions  is\n   pragma Preelaborate(Address_To_Access_Conversions);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Object_Pointer is access all Object;\n   function To_Pointer(Value : Address) return Object_Pointer;\n   function To_Address(Value : Object_Pointer) return Address;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   pragma Convention(Intrinsic, To_Pointer);\n   pragma Convention(Intrinsic, To_Address);\nend System.Address_To_Access_Conversions;\n\n")),(0,i.kt)("p",null,"The To_Pointer and To_Address subprograms convert back and forth between values of types Object_Pointer and Address. To_Pointer(X'Address) is equal to X'Unchecked_Access for any X that allows Unchecked_Access. To_Pointer(Null_Address) returns null. For other addresses, the behavior is unspecified. To_Address(null) returns Null_Address (for null of the appropriate type). To_Address(Y), where Y /= null, returns Y.all'Address. "),(0,i.kt)("p",null,"Discussion: The programmer should ensure that the address passed to To_Pointer is either Null_Address, or the address of an object of type Object. Otherwise, the behavior of the program is unspecified; it might raise an exception or crash, for example. "),(0,i.kt)("p",null,"Reason: Unspecified is almost the same thing as erroneous; they both allow arbitrarily bad behavior. We don't say erroneous here, because the implementation might allow the address passed to To_Pointer to point at some memory that just happens to \"look like\" an object of type Object. That's not necessarily an error; it's just not portable. However, if the actual type passed to Object is (for example) an array type, the programmer would need to be aware of any dope that the implementation expects to exist, when passing an address that did not come from the Address attribute of an object of type Object."),(0,i.kt)("p",null,"One might wonder why To_Pointer and To_Address are any better than unchecked conversions. The answer is that Address does not necessarily have the same representation as an access type. For example, an access value might point at the bounds of an array when an address would point at the first element. Or an access value might be an offset in words from someplace, whereas an address might be an offset in bytes from the beginning of memory. "),(0,i.kt)("h4",{id:"implementation-permissions-4"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may place restrictions on instantiations of Address_To_Access_Conversions. "),(0,i.kt)("p",null,"Ramification: For example, if the hardware requires aligned loads and stores, then dereferencing an access value that is not properly aligned might raise an exception."),(0,i.kt)("p",null,'For another example, if the implementation has chosen to use negative component offsets (from an access value), it might not be possible to preserve the semantics, since negative offsets from the Address are not allowed. (The Address attribute always points at "the first of the storage elements...".) Note that while the implementation knows how to convert an access value into an address, it might not be able to do the reverse. To avoid generic contract model violations, the restriction might have to be detected at run time in some cases. '),(0,i.kt)("h2",{id:"138--machine-code-insertions"},"13.8  Machine Code Insertions"),(0,i.kt)("p",null,"[ A machine code insertion can be achieved by a call to a subprogram whose sequence_of_statements contains code_statements.]"," "),(0,i.kt)("h4",{id:"syntax-6"},"Syntax"),(0,i.kt)("p",null,"code_statement ::= qualified_expression;"),(0,i.kt)("p",null,"A code_statement is only allowed in the handled_sequence_of_statements of a subprogram_body. If a subprogram_body contains any code_statements, then within this subprogram_body the only allowed form of statement is a code_statement (labeled or not), the only allowed declarative_items are use_clauses, and no exception_handler is allowed (comments and pragmas are allowed as usual). "),(0,i.kt)("h4",{id:"name-resolution-rules-5"},"Name Resolution Rules"),(0,i.kt)("p",null,"The qualified_expression is expected to be of any type. "),(0,i.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,i.kt)("p",null,"The qualified_expression shall be of a type declared in package System.Machine_Code. "),(0,i.kt)("p",null,"Ramification: This includes types declared in children of System.Machine_Code. "),(0,i.kt)("p",null,"A code_statement shall appear only within the scope of a with_clause that mentions package System.Machine_Code. "),(0,i.kt)("p",null,"Ramification: Note that this is not a note; without this rule, it would be possible to write machine code in compilation units which depend on System.Machine_Code only indirectly. "),(0,i.kt)("h4",{id:"static-semantics-19"},"Static Semantics"),(0,i.kt)("p",null,"The contents of the library package System.Machine_Code (if provided) are implementation defined. The meaning of code_statements is implementation defined. ","[Typically, each qualified_expression represents a machine instruction or assembly directive.]"," "),(0,i.kt)("p",null,"Discussion: For example, an instruction might be a record with an Op_Code component and other components for the operands. "),(0,i.kt)("p",null,"Implementation defined: The contents of the visible part of package System.Machine_Code, and the meaning of code_statements."),(0,i.kt)("h4",{id:"implementation-permissions-5"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may place restrictions on code_statements. An implementation is not required to provide package System.Machine_Code. "),(0,i.kt)("p",null,"NOTE 1   An implementation may provide implementation-defined pragmas specifying register conventions and calling conventions."),(0,i.kt)("p",null,"NOTE 2   Machine code functions are exempt from the rule that a return_statement is required. In fact, return_statements are forbidden, since only code_statements are allowed. "),(0,i.kt)("p",null,'Discussion: The idea is that the author of a machine code subprogram knows the calling conventions, and refers to parameters and results accordingly. The implementation should document where to put the result of a machine code function, for example, "Scalar results are returned in register 0". '),(0,i.kt)("p",null,'NOTE 3   Intrinsic subprograms (see 6.3.1, "Conformance Rules") can also be used to achieve machine code insertions. Interface to assembly language can be achieved using the features in Annex B, "Interface to Other Languages". '),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Example of a code statement: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"M : Mask;\nprocedure Set_Mask; pragma Inline(Set_Mask);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Set_Mask is\n  use System.Machine_Code; -- assume \"with System.Machine_Code;\" appears somewhere above\nbegin\n  SI_Format'(Code =&gt SSM, B =&gt M'Base_Reg, D =&gt M'Disp);\n  --  Base_Reg and Disp are implementation-defined attributes\nend Set_Mask;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Machine code functions are allowed in Ada 95; in Ada 83, only procedures were allowed. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-8"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The syntax for code_statement is changed to say "qualified_expression" instead of "subtype_mark\'record_aggregate". Requiring the type of each instruction to be a record type is overspecification. '),(0,i.kt)("h2",{id:"139--unchecked-type-conversions"},"13.9  Unchecked Type Conversions"),(0,i.kt)("p",null,"[ An unchecked type conversion can be achieved by a call to an instance of the generic function Unchecked_Conversion.]"," "),(0,i.kt)("h4",{id:"static-semantics-20"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined generic library function exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Source(&lt&gt) is limited private;\n   type Target(&lt&gt) is limited private;\nfunction Ada.Unchecked_Conversion(S : Source) return Target;\npragma Convention(Intrinsic, Ada.Unchecked_Conversion);\npragma Pure(Ada.Unchecked_Conversion);\n\n")),(0,i.kt)("p",null,"Reason: The pragma Convention implies that the attribute Access is not allowed for instances of Unchecked_Conversion. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"The size of the formal parameter S in an instance of Unchecked_Conversion is that of its subtype. ","[This is the actual subtype passed to Source, except when the actual is an unconstrained composite subtype, in which case the subtype is constrained by the bounds or discriminants of the value of the actual expression passed to S.]"),(0,i.kt)("p",null,"If all of the following are true, the effect of an unchecked conversion is to return the value of an object of the target subtype whose representation is the same as that of the source object S: "),(0,i.kt)("p",null,"S'Size = Target'Size. "),(0,i.kt)("p",null,"Ramification: Note that there is no requirement that the Sizes be known at compile time. "),(0,i.kt)("p",null,"S'Alignment = Target'Alignment."),(0,i.kt)("p",null,"The target subtype is not an unconstrained composite subtype."),(0,i.kt)("p",null,"S and the target subtype both have a contiguous representation."),(0,i.kt)("p",null,"The representation of S is a representation of an object of the target subtype. "),(0,i.kt)("p",null,"Otherwise, the effect is implementation defined; in particular, the result can be abnormal (see 13.9.1)."),(0,i.kt)("p",null,"Implementation defined: The effect of unchecked conversion."),(0,i.kt)("p",null,"Ramification: Whenever unchecked conversions are used, it is the programmer's responsibility to ensure that these conversions maintain the properties that are guaranteed by the language for objects of the target type. This requires the user to understand the underlying run-time model of  the implementation. The execution of a program that violates these properties by means of unchecked conversions is erroneous."),(0,i.kt)("p",null,"An instance of Unchecked_Conversion can be applied to an object of a private type, assuming the implementation allows it. "),(0,i.kt)("h4",{id:"implementation-permissions-6"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may return the result of an unchecked conversion by reference, if the Source type is not a by-copy type. ","[In this case, the result of the unchecked conversion represents simply a different (read-only) view of the operand of the conversion.]"," "),(0,i.kt)("p",null,"Ramification: In other words, the result object of a call on an instance of Unchecked_Conversion can occupy the same storage as the formal parameter S. "),(0,i.kt)("p",null,"An implementation may place restrictions on Unchecked_Conversion. "),(0,i.kt)("p",null,"Ramification: For example, an instantiation of Unchecked_Conversion for types for which unchecked conversion doesn't make sense may be disallowed. "),(0,i.kt)("h4",{id:"implementation-advice-13"},"Implementation Advice"),(0,i.kt)("p",null,"The Size of an array object should not include its bounds; hence, the bounds should not be part of the converted data. "),(0,i.kt)("p",null,"Ramification: On the other hand, we have no advice to offer about discriminants and tag fields. "),(0,i.kt)("p",null,"The implementation should not generate unnecessary runtime checks to ensure that the representation of S is a representation of the target type. It should take advantage of the permission to return by reference when possible. Restrictions on unchecked conversions should be avoided unless required by the target environment. "),(0,i.kt)("p",null,"Implementation Note: As an example of an unnecessary runtime check, consider a record type with gaps between components. The compiler might assume that such gaps are always zero bits. If a value is produced that does not obey that assumption, then the program might misbehave. The implementation should not generate extra code to check for zero bits (except, perhaps, in a special error-checking mode). "),(0,i.kt)("p",null,"The recommended level of support for unchecked conversions is: "),(0,i.kt)("p",null,"Unchecked conversions should be supported and should be reversible in the cases where this clause defines the result. To enable meaningful use of unchecked conversion, a contiguous representation should be used for elementary subtypes, for statically constrained array subtypes whose component subtype is one of the subtypes described in this paragraph, and for record subtypes without discriminants whose component subtypes are described in this paragraph. "),(0,i.kt)("h3",{id:"1391--data-validity"},"13.9.1  Data Validity"),(0,i.kt)("p",null,"Certain actions that can potentially lead to erroneous execution are not directly erroneous, but instead can cause objects to become abnormal. Subsequent uses of abnormal objects can be erroneous."),(0,i.kt)("p",null,"A scalar object can have an invalid representation, which means that the object's representation does not represent any value of the object's subtype. The primary cause of invalid representations is uninitialized variables."),(0,i.kt)("p",null,"Abnormal objects and invalid representations are explained in this subclause. "),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"When an object is first created, and any explicit or default initializations have been performed, the object and all of its parts are in the normal state. Subsequent operations generally leave them normal. However, an object or part of an object can become abnormal in the following ways: "),(0,i.kt)("p",null,"An assignment to the object is disrupted due to an abort (see 9.8) or due to the failure of a language-defined check (see 11.6)."),(0,i.kt)("p",null,"The object is not scalar, and is passed to an in out or out parameter of an imported procedure or language-defined input procedure, if after return from the procedure the representation of the parameter does not represent a value of the parameter's subtype."),(0,i.kt)("p",null,"Whether or not an object actually becomes abnormal in these cases is not specified. An abnormal object becomes normal again upon successful completion of an assignment to the object as a whole. "),(0,i.kt)("h4",{id:"erroneous-execution-2"},"Erroneous Execution"),(0,i.kt)("p",null,"It is erroneous to evaluate a primary that is a name denoting an abnormal object, or to evaluate a prefix that denotes an abnormal object. "),(0,i.kt)("p",null,"Ramification: Although a composite object with no subcomponents of an access type, and with static constraints all the way down cannot become abnormal, a scalar subcomponent of such an object can become abnormal."),(0,i.kt)("p",null,"The in out or out parameter case does not apply to scalars; bad scalars are merely invalid representations, rather than abnormal, in this case. "),(0,i.kt)("p",null,"Reason: The reason we allow access objects, and objects containing subcomponents of an access type, to become abnormal is because the correctness of an access value cannot necessarily be determined merely by looking at the bits of the object. The reason we allow scalar objects to become abnormal is that we wish to allow the compiler to optimize assuming that the value of a scalar object belongs to the object's subtype, if the compiler can prove that the object is initialized with a value that belongs to the subtype. The reason we allow composite objects to become abnormal if some constraints are nonstatic is that such object might be represented with implicit levels of indirection; if those are corrupted, then even assigning into a component of the object, or simply asking for its Address, might have an unpredictable effect. The same is true if the discriminants have been destroyed. "),(0,i.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,i.kt)("p",null,"If the representation of a scalar object does not represent a value of the object's subtype (perhaps because the object was not initialized), the object is said to have an invalid representation. It is a bounded error to evaluate the value of such an object. If the error is detected, either Constraint_Error or Program_Error is raised. Otherwise, execution continues using the invalid representation. The rules of the language outside this subclause assume that all objects have valid representations. The semantics of operations on invalid representations are as follows:"),(0,i.kt)("p",null,"Discussion: The AARM is more explicit about what happens when the value of the case expression is an invalid representation."),(0,i.kt)("p",null,"If the representation of the object represents a value of the object's type, the value of the type is used."),(0,i.kt)("p",null,"If the representation of the object does not represent a value of the object's type, the semantics of operations on such representations is implementation-defined, but does not by itself lead to erroneous or unpredictable execution, or to other objects becoming abnormal. "),(0,i.kt)("h4",{id:"erroneous-execution-3"},"Erroneous Execution"),(0,i.kt)("p",null,"A call to an imported function or an instance of Unchecked_Conversion is erroneous if the result is scalar, and the result object has an invalid representation. "),(0,i.kt)("p",null,"Ramification: In a typical implementation, every bit pattern that fits in an object of an integer subtype will represent a value of the type, if not of the subtype. However, for an enumeration or floating point type, there are typically bit patterns that do not represent any value of the type. In such cases, the implementation ought to define the semantics of operations on the invalid representations in the obvious manner (assuming the bounded error is not detected): a given representation should be equal to itself, a representation that is in between the internal codes of two enumeration literals should behave accordingly when passed to comparison operators and membership tests, etc. We considered requiring such sensible behavior, but it resulted in too much arcane verbiage, and since implementations have little incentive to behave irrationally, such verbiage is not important to have."),(0,i.kt)("p",null,"If a stand-alone scalar object is initialized to a an in-range value, then the implementation can take advantage of the fact that any out-of-range value has to be abnormal. Such an out-of-range value can be produced only by things like unchecked conversion, input, and disruption of an assignment due to abort or to failure of a language-defined check. This depends on out-of-range values being checked before assignment (that is, checks are not optimized away unless they are proven redundant)."),(0,i.kt)("p",null,"Consider the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type My_Int is range 0..99;\nfunction Safe_Convert is new Unchecked_Conversion(My_Int, Integer);\nfunction Unsafe_Convert is new Unchecked_Conversion(My_Int, Positive);\nX : Positive := Safe_Convert(0); -- Raises Constraint_Error.\nY : Positive := Unsafe_Convert(0); -- Erroneous.\n\n")),(0,i.kt)("p",null,"The call to Unsafe_Convert causes erroneous execution. The call to Safe_Convert is not erroneous. The result object is an object of subtype Integer containing the value 0. The assignment to X is required to do a constraint check; the fact that the conversion is unchecked does not obviate the need for subsequent checks required by the language rules."),(0,i.kt)("p",null,'Implementation Note: If an implementation wants to have a "friendly" mode, it might always assign an uninitialized scalar a default initial value that is outside the object\'s subtype (if there is one), and check for this value on some or all reads of the object, so as to help detect references to uninitialized scalars. Alternatively, an implementation might want to provide an "unsafe" mode where it presumed even uninitialized scalars were always within their subtype. '),(0,i.kt)("p",null,"Ramification: The above rules imply that it is a bounded error to apply a predefined operator to an object with a scalar subcomponent having an invalid representation, since this implies reading the value of each subcomponent. Either Program_Error or Constraint_Error is raised, or some result is produced, which if composite, might have a corresponding scalar subcomponent still with an invalid representation."),(0,i.kt)("p",null,"Note that it is not an error to assign, convert, or pass as a parameter a composite object with an uninitialized scalar subcomponent. In the other hand, it is a (bounded) error to apply a predefined operator such as =, ","<",", and xor to a composite operand with an invalid scalar subcomponent. "),(0,i.kt)("p",null,"The dereference of an access value is erroneous if it does not designate an object of an appropriate type or a subprogram with an appropriate profile, if it designates a nonexistent object, or if it is an access-to-variable value that designates a constant object. ","[Such an access value can exist, for example, because of Unchecked_Deallocation, Unchecked_Access, or Unchecked_Conversion.]"),(0,i.kt)("p",null,"Ramification: The above mentioned Unchecked_... features are not the only causes of such access values. For example, interfacing to other languages can also cause the problem."),(0,i.kt)("p",null,"One obscure example is if the Adjust subprogram of a controlled type uses Unchecked_Access to create an access-to-variable value designating a subcomponent of its controlled parameter, and saves this access value in a global object. When Adjust is called during the initialization of a constant object of the type, the end result will be an access-to-variable value that designates a constant object. "),(0,i.kt)("p",null,"NOTE 1   Objects can become abnormal due to other kinds of actions that directly update the object's representation; such actions are generally considered directly erroneous, however. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-9"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"In order to reduce the amount of erroneousness, we separate the concept of an undefined value into objects with invalid representation (scalars only) and abnormal objects."),(0,i.kt)("p",null,"Reading an object with an invalid representation is a bounded error rather than erroneous; reading an abnormal object is still erroneous. In fact, the only safe thing to do to an abnormal object is to assign to the object as a whole. "),(0,i.kt)("h3",{id:"1392--the-valid-attribute"},"13.9.2  The Valid Attribute"),(0,i.kt)("p",null,"The Valid attribute can be used to check the validity of data produced by unchecked conversion, input, interface to foreign languages, and the like. "),(0,i.kt)("h4",{id:"static-semantics-21"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix X that denotes a scalar object ","[(after any implicit dereference)]",", the following attribute is defined: "),(0,i.kt)("p",null,"X'ValidYields True if and only if the object denoted by X is normal and has a valid representation. The value of this attribute is of the predefined type Boolean. "),(0,i.kt)("p",null,"Ramification: Having checked that X'Valid is True, it is safe to read the value of X without fear of erroneous execution caused by abnormality, or a bounded error caused by an invalid representation. Such a read will produce a value in the subtype of X. "),(0,i.kt)("p",null,"NOTE 1   Invalid data can be created in the following cases (not counting erroneous or unpredictable execution): "),(0,i.kt)("p",null,"an uninitialized scalar object,"),(0,i.kt)("p",null,"the result of an unchecked conversion,"),(0,i.kt)("p",null,"input,"),(0,i.kt)("p",null,"interface to another language (including machine code),"),(0,i.kt)("p",null,"aborting an assignment,"),(0,i.kt)("p",null,"disrupting an assignment due to the failure of a language-defined check (see 11.6), and"),(0,i.kt)("p",null,"use of an object whose Address has been specified. "),(0,i.kt)("p",null,"NOTE 2   X'Valid is not considered to be a read of X; hence, it is not an error to check the validity of invalid data."),(0,i.kt)("p",null,"Ramification: If X is of an enumeration type with a representation clause, then X'Valid checks that the value of X when viewed as an integer is one of the specified internal codes. "),(0,i.kt)("p",null,"Reason: Valid is defined only for scalar objects because the implementation and description burden would be too high for other types. For example, given a typical run-time model, it is impossible to check the validity of an access value. The same applies to composite types implemented with internal pointers. One can check the validity of a composite object by checking the validity of each of its scalar subcomponents. The user should ensure that any composite types that need to be checked for validity are represented in a way that does not involve implementation-defined components, or gaps between components. Furthermore, such types should not contain access subcomponents."),(0,i.kt)("p",null,"Note that one can safely check the validity of a composite object with an abnormal value only if the constraints on the object and all of its subcomponents are static. Otherwise, evaluation of the prefix of the attribute_reference causes erroneous execution (see 4.1). "),(0,i.kt)("h4",{id:"extensions-to-ada-83-5"},"Extensions to Ada 83"),(0,i.kt)("p",null,"X'Valid is new in Ada 95. "),(0,i.kt)("h2",{id:"1310--unchecked-access-value-creation"},"13.10  Unchecked Access Value Creation"),(0,i.kt)("p",null,'[The attribute Unchecked_Access is used to create access values in an unsafe manner - the programmer is responsible for preventing "dangling references".]'," "),(0,i.kt)("h4",{id:"static-semantics-22"},"Static Semantics"),(0,i.kt)("p",null,"The following attribute is defined for a prefix X that denotes an aliased view of an object: "),(0,i.kt)("p",null,"X'Unchecked_AccessAll rules and semantics that apply to X'Access (see 3.10.2) apply also to X'Unchecked_Access, except that, for the purposes of accessibility rules and checks, it is as if X were declared immediately within a library package. "),(0,i.kt)("p",null,'NOTE 1   This attribute is provided to support the situation where a local object is to be inserted into a global linked data structure, when the programmer knows that it will always be removed from the data structure prior to exiting the object\'s scope. The Access attribute would be illegal in this case (see 3.10.2, "Operations of Access Types"). '),(0,i.kt)("p",null,"Ramification: The expected type for X'Unchecked_Access is as for X'Access."),(0,i.kt)("p",null,"If an attribute_reference with Unchecked_Access is used as the actual parameter for an access parameter, an Accessibility_Check can never fail on that access parameter. "),(0,i.kt)("p",null,"NOTE 2   There is no Unchecked_Access attribute for subprograms. "),(0,i.kt)("p",null,'Reason: Such an attribute would allow "downward closures", where an access value designating a more nested subprogram is passed to a less nested subprogram. This requires some means of reconstructing the global environment for the more nested subprogram, so that it can do up-level references to objects. The two methods of implementing up-level references are displays and static links. If downward closures were supported, each access-to-subprogram value would have to carry the static link or display with it. In the case of displays, this was judged to be infeasible, and we don\'t want to disrupt implementations by forcing them to use static links if they already use displays.'),(0,i.kt)("p",null,"If desired, an instance of Unchecked_Conversion can be used to create an access value of a global access-to-subprogram type that designates a local subprogram. The semantics of using such a value are not specified by the language. In particular, it is not specified what happens if such subprograms make up-level references; even if the frame being referenced still exists, the up-level reference might go awry if the representation of a value of a global access-to-subprogram type doesn't include a static link. "),(0,i.kt)("h2",{id:"1311--storage-management"},"13.11  Storage Management"),(0,i.kt)("p",null,"[ Each access-to-object type has an associated storage pool. The storage allocated by an allocator comes from the pool; instances of Unchecked_Deallocation return storage to the pool. Several access types can share the same pool.]"),(0,i.kt)("p",null,"[A storage pool is a variable of a type in the class rooted at Root_Storage_Pool, which is an abstract limited controlled type. By default, the implementation chooses a standard storage pool for each access type. The user may define new pool types, and may override the choice of pool for an access type by specifying Storage_Pool for the type.]"," "),(0,i.kt)("p",null,"Ramification: By default, the implementation might choose to have a single global storage pool, which is used (by default) by all access types, which might mean that storage is reclaimed automatically only upon partition completion. Alternatively, it might choose to create a new pool at each accessibility level, which might mean that storage is reclaimed for an access type when leaving the appropriate scope. Other schemes are possible. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[storage pool object]",", Def=","[an object associated with one or more access types from which the storage for objects created by allocators of the access type(s) is obtained]",", Note1=","[Some storage pools can be partitioned into subpools in order to support finer-grained storage management.]"," "),(0,i.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,i.kt)("p",null,"If Storage_Pool is specified for a given access type, Storage_Size shall not be specified for it. "),(0,i.kt)("p",null,'Reason: The Storage_Pool determines the Storage_Size; hence it would not make sense to specify both. Note that this rule is simplified by the fact that the aspects in question cannot be specified for derived types, nor for nonfirst subtypes, so we don\'t have to worry about whether, say, Storage_Pool on a derived type overrides Storage_Size on the parent type. For the same reason, "specified" means the same thing as "directly specified" here. '),(0,i.kt)("h4",{id:"static-semantics-23"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Finalization;\nwith System.Storage_Elements;\npackage System.Storage_Pools is\n    pragma Preelaborate(System.Storage_Pools);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Root_Storage_Pool is\n        abstract new Ada.Finalization.Limited_Controlled with private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Allocate(\n      Pool : in out Root_Storage_Pool;\n      Storage_Address : out Address;\n      Size_In_Storage_Elements : in Storage_Elements.Storage_Count;\n      Alignment : in Storage_Elements.Storage_Count) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Deallocate(\n      Pool : in out Root_Storage_Pool;\n      Storage_Address : in Address;\n      Size_In_Storage_Elements : in Storage_Elements.Storage_Count;\n      Alignment : in Storage_Elements.Storage_Count) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    function Storage_Size(Pool : Root_Storage_Pool)\n        return Storage_Elements.Storage_Count is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend System.Storage_Pools;\n\n")),(0,i.kt)("p",null,"Reason: The Alignment parameter is provided to Deallocate because some allocation strategies require it. If it is not needed, it can be ignored. "),(0,i.kt)("p",null,"A storage pool type (or pool type) is a descendant of Root_Storage_Pool. The elements of a storage pool are the objects allocated in the pool by allocators. "),(0,i.kt)("p",null,"Discussion: In most cases, an element corresponds to a single memory block allocated by Allocate. However, in some cases the implementation may choose to associate more than one memory block with a given pool element. "),(0,i.kt)("p",null,"For every access subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'Storage_PoolDenotes the storage pool of the type of S. The type of this attribute is Root_Storage_Pool'Class."),(0,i.kt)("p",null,"S'Storage_SizeYields the result of calling Storage_Size(S'Storage_Pool)","[, which is intended to be a measure of the number of storage elements reserved for the pool.]"," The type of this attribute is universal_integer. "),(0,i.kt)("p",null,"Ramification: Storage_Size is also defined for task subtypes and objects - see 13.3."),(0,i.kt)("p",null,"Storage_Size is not a measure of how much un-allocated space is left in the pool. That is, it includes both allocated and unallocated space. Implementations and users may provide a Storage_Available function for their pools, if so desired. "),(0,i.kt)("p",null,"Storage_Size or Storage_Pool may be specified for a nonderived access-to-object type via an attribute_definition_clause; the name in a Storage_Pool clause shall denote a variable."),(0,i.kt)("p",null,"An allocator of type T allocates storage from T's storage pool. If the storage pool is a user-defined object, then the storage is allocated by calling Allocate, passing T'Storage_Pool as the Pool parameter. The Size_In_Storage_Elements parameter indicates the number of storage elements to be allocated, and is no more than D'Max_Size_In_Storage_Elements, where D is the designated subtype. The Alignment parameter is D'Alignment. The result returned in the Storage_Address parameter is used by the allocator as the address of the allocated storage, which is a contiguous block of memory of Size_In_Storage_Elements storage elements. ","[Any exception propagated by Allocate is propagated by the allocator.]"," "),(0,i.kt)("p",null,"Ramification: If the implementation chooses to represent the designated subtype in multiple pieces, one allocator evaluation might result in more than one call upon Allocate. In any case, allocators for the access type obtain all the required storage for an object of the designated type by calling the specified Allocate procedure."),(0,i.kt)("p",null,"Note that the implementation does not turn other exceptions into Storage_Error."),(0,i.kt)("p",null,"If Storage_Pool is not specified for a type defined by an access_to_object_definition, then the implementation chooses a standard storage pool for it in an implementation-defined manner. In this case, the exception Storage_Error is raised by an allocator if there is not enough storage. It is implementation defined whether or not the implementation provides user-accessible names for the standard pool type(s). "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: The manner of choosing a storage pool for an access type when Storage_Pool is not specified for the type."),(0,i.kt)("p",null,"Implementation defined: Whether or not the implementation provides user-accessible names for the standard pool type(s)."),(0,i.kt)("p",null,'Ramification: An anonymous access type has no pool. An access-to-object type defined by a derived_type_definition inherits its pool from its parent type, so all access-to-object types in the same derivation class share the same pool. Hence the "defined by an access_to_object_definition" wording above.'),(0,i.kt)("p",null,"There is no requirement that all storage pools be implemented using a contiguous block of memory (although each allocation returns a pointer to a contiguous block of memory). "),(0,i.kt)("p",null,"If Storage_Size is specified for an access type, then the Storage_Size of this pool is at least that requested, and the storage for the pool is reclaimed when the master containing the declaration of the access type is left. If the implementation cannot satisfy the request, Storage_Error is raised at the point of the attribute_definition_clause. If neither Storage_Pool nor Storage_Size are specified, then the meaning of Storage_Size is implementation defined."),(0,i.kt)("p",null,"Implementation defined: The meaning of Storage_Size."),(0,i.kt)("p",null,"Ramification: The Storage_Size function and attribute will return the actual size, rather than the requested size. Comments about rounding up, zero, and negative on task Storage_Size apply here, as well. See also AI83-00557, AI83-00558, and AI83-00608."),(0,i.kt)("p",null,"The expression in a Storage_Size clause need not be static."),(0,i.kt)("p",null,"The reclamation happens after the master is finalized. "),(0,i.kt)("p",null,"Implementation Note: For a pool allocated on the stack, normal stack cut-back can accomplish the reclamation. For a library-level pool, normal partition termination actions can accomplish the reclamation. "),(0,i.kt)("p",null,"If Storage_Pool is specified for an access type, then the specified pool is used."),(0,i.kt)("p",null,"The effect of calling Allocate and Deallocate for a standard storage pool directly (rather than implicitly via an allocator or an instance of Unchecked_Deallocation) is unspecified. "),(0,i.kt)("p",null,"Ramification: For example, an allocator might put the pool element on a finalization list. If the user directly Deallocates it, instead of calling an instance of Unchecked_Deallocation, then the implementation would probably try to finalize the object upon master completion, which would be bad news. Therefore, the implementation should define such situations as erroneous. "),(0,i.kt)("h4",{id:"erroneous-execution-4"},"Erroneous Execution"),(0,i.kt)("p",null,"If Storage_Pool is specified for an access type, then if Allocate can satisfy the request, it should allocate a contiguous block of memory, and return the address of the first storage element in Storage_Address. The block should contain Size_In_Storage_Elements storage elements, and should be aligned according to Alignment. The allocated storage should not be used for any other purpose while the pool element remains in existence. If the request cannot be satisfied, then Allocate should propagate an exception ","[(such as Storage_Error)]",". If Allocate behaves in any other manner, then the program execution is erroneous. "),(0,i.kt)("h4",{id:"documentation-requirements"},"Documentation Requirements"),(0,i.kt)("p",null,"An implementation shall document the set of values that a user-defined Allocate procedure needs to accept for the Alignment parameter. An implementation shall document how the standard storage pool is chosen, and how storage is allocated by standard storage pools. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: Implementation-defined aspects of storage pools."),(0,i.kt)("h4",{id:"implementation-advice-14"},"Implementation Advice"),(0,i.kt)("p",null,"An implementation should document any cases in which it dynamically allocates heap storage for a purpose other than the evaluation of an allocator. "),(0,i.kt)("p",null,'Reason: This is "Implementation Advice" because the term "heap storage" is not formally definable; therefore, it is not testable whether the implementation obeys this advice. '),(0,i.kt)("p",null,"A default (implementation-provided) storage pool for an access-to-constant type should not have overhead to support deallocation of individual objects. "),(0,i.kt)("p",null,"Ramification: Unchecked_Deallocation is not defined for such types. If the access-to-constant type is library-level, then no deallocation (other than at partition completion) will ever be necessary, so if the size needed by an allocator of the type is known at link-time, then the allocation should be performed statically. If, in addition, the initial value of the designated object is known at compile time, the object can be allocated to read-only memory. "),(0,i.kt)("p",null,"Implementation Note: If the Storage_Size for an access type is specified, the storage pool should consist of a contiguous block of memory, possibly allocated on the stack. The pool should contain approximately this number of storage elements. These storage elements should be reserved at the place of the Storage_Size clause, so that allocators cannot raise Storage_Error due to running out of pool space until the appropriate number of storage elements has been used up. This approximate (possibly rounded-up) value should be used as a maximum; the implementation should not increase the size of the pool on the fly. If the Storage_Size for an access type is specified as zero, then the pool should not take up any storage space, and any allocator for the type should raise Storage_Error. "),(0,i.kt)("p",null,"Ramification: Note that most of this is approximate, and so cannot be (portably) tested. That's why we make it an Implementation Note. There is no particular number of allocations that is guaranteed to succeed, and there is no particular number of allocations that is guaranteed to fail. "),(0,i.kt)("p",null,"A storage pool for an anonymous access type should be created at the point of an allocator for the type, and be reclaimed when the designated object becomes inaccessible;"),(0,i.kt)("p",null,'Implementation Note: Normally the "storage pool" for an anonymous access type would not exist as a separate entity. Instead, the designated object of the allocator would be allocated, in the case of an access parameter, as a local aliased variable at the call site, and in the case of an access discriminant, contiguous with the object containing the discriminant. This is similar to the way storage for aggregates is typically managed.'),(0,i.kt)("p",null,"NOTE 1   A user-defined storage pool type can be obtained by extending the Root_Storage_Pool type, and overriding the primitive subprograms Allocate, Deallocate, and Storage_Size. A user-defined storage pool can then be obtained by declaring an object of the type extension. The user can override Initialize and Finalize if there is any need for nontrivial initialization and finalization for a user-defined pool type. For example, Finalize might reclaim blocks of storage that are allocated separately from the pool object itself."),(0,i.kt)("p",null,"NOTE 2   The writer of the user-defined allocation and deallocation procedures, and users of allocators for the associated access type, are responsible for dealing with any interactions with tasking. In particular: "),(0,i.kt)("p",null,"If the allocators are used in different tasks, they require mutual exclusion."),(0,i.kt)("p",null,"If they are used inside protected objects, they cannot block."),(0,i.kt)("p",null,'If they are used by interrupt handlers (see C.3, "Interrupt Support"), the mutual exclusion mechanism has to work properly in that context. '),(0,i.kt)("p",null,"NOTE 3   The primitives Allocate, Deallocate, and Storage_Size are declared as abstract (see 3.9.3), and therefore they have to be overridden when a new (nonabstract) storage pool type is declared. "),(0,i.kt)("p",null,"Ramification: Note that the Storage_Pool attribute denotes an object, rather than a value, which is somewhat unusual for attributes."),(0,i.kt)("p",null,"The calls to Allocate, Deallocate, and Storage_Size are dispatching calls - this follows from the fact that the actual parameter for Pool is T'Storage_Pool, which is of type Root_Storage_Pool'Class. In many cases (including all cases in which Storage_Pool is not specified), the compiler can determine the tag statically. However, it is possible to construct cases where it cannot."),(0,i.kt)("p",null,"All access types in the same derivation class share the same pool, whether implementation defined or user defined. This is necessary because we allow type conversions among them (even if they are pool-specific), and we want pool-specific access values to always designate an element of the right pool. "),(0,i.kt)("p",null,"Implementation Note: If an access type has a standard storage pool, then the implementation doesn't actually have to follow the pool interface described here, since this would be semantically invisible. For example, the allocator could conceivably be implemented with inline code. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"To associate an access type with a storage pool object, the user first declares a pool object of some type derived from Root_Storage_Pool. Then, the user defines its Storage_Pool attribute, as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Pool_Object : Some_Storage_Pool_Type;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T is access Designated;\nfor T'Storage_Pool use Pool_Object;\n\n")),(0,i.kt)("p",null,"Another access type may be added to an existing storage pool, via: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"for T2'Storage_Pool use T'Storage_Pool;\n\n")),(0,i.kt)("p",null,"The semantics of this is implementation defined for a standard storage pool. "),(0,i.kt)("p",null,"Reason: For example, the implementation is allowed to choose a storage pool for T that takes advantage of the fact that T is of a certain size. If T2 is not of that size, then the above will probably not work. "),(0,i.kt)("p",null,"As usual, a derivative of Root_Storage_Pool may define additional operations. For example, presuming that Mark_Release_Pool_Type has two additional operations, Mark and Release, the following is a possible use: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Mark_Release_Pool_Type\n   (Pool_Size : Storage_Elements.Storage_Count;\n    Block_Size : Storage_Elements.Storage_Count)\n        is new Root_Storage_Pool with limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"MR_Pool : Mark_Release_Pool_Type (Pool_Size =&gt 2000,\n                                  Block_Size =&gt 100);\n\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Acc is access ...;\nfor Acc'Storage_Pool use MR_Pool;\n...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Mark(MR_Pool);\n... -- Allocate objects using "new Designated(...)".\nRelease(MR_Pool); -- Reclaim the storage.\n\n')),(0,i.kt)("h4",{id:"extensions-to-ada-83-6"},"Extensions to Ada 83"),(0,i.kt)("p",null,"User-defined storage pools are new to Ada 95. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-10"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Ada 83 had a concept called a "collection", which is similar to what we call a storage pool. All access types in the same derivation class shared the same collection. In Ada 95, all access types in the same derivation class share the same storage pool, but other (unrelated) access types can also share the same storage pool, either by default, or as specified by the user. A collection was an amorphous collection of objects; a storage pool is a more concrete concept - hence the different name.'),(0,i.kt)("p",null,"RM83 states the erroneousness of reading or updating deallocated objects incorrectly by missing various cases. "),(0,i.kt)("h3",{id:"13111--the-max_size_in_storage_elements-attribute"},"13.11.1  The Max_Size_In_Storage_Elements Attribute"),(0,i.kt)("p",null,"[The Max_Size_In_Storage_Elements attribute is useful in writing user-defined pool types.]"," "),(0,i.kt)("h4",{id:"static-semantics-24"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S, the following attribute is defined: "),(0,i.kt)("p",null,"S'Max_Size_In_Storage_ElementsDenotes the maximum value for Size_In_Storage_Elements that will be requested via Allocate for an access type whose designated subtype is S. The value of this attribute is of type universal_integer. "),(0,i.kt)("p",null,"Ramification: If S is an unconstrained array subtype, or an unconstrained subtype with discriminants, S'Max_Size_In_Storage_Elements might be very large. "),(0,i.kt)("h3",{id:"13112--unchecked-storage-deallocation"},"13.11.2  Unchecked Storage Deallocation"),(0,i.kt)("p",null,"[ Unchecked storage deallocation of an object designated by a value of an access type is achieved by a call to an instance of the generic procedure Unchecked_Deallocation.]"," "),(0,i.kt)("h4",{id:"static-semantics-25"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined generic library procedure exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Object(&lt&gt) is limited private;\n   type Name   is access  Object;\nprocedure Ada.Unchecked_Deallocation(X : in out Name);\npragma Convention(Intrinsic, Ada.Unchecked_Deallocation);\npragma Preelaborate(Ada.Unchecked_Deallocation);\n\n")),(0,i.kt)("p",null,"Reason: The pragma Convention implies that the attribute Access is not allowed for instances of Unchecked_Deallocation. "),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"Given an instance of Unchecked_Deallocation declared as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Free is\n    new Ada.Unchecked_Deallocation(\n        object_subtype_name, access_to_variable_subtype_name);\n\n")),(0,i.kt)("p",null,"Procedure Free has the following effect: "),(0,i.kt)("p",null,"a)After executing Free(X), the value of X is null."),(0,i.kt)("p",null,"b)Free(X), when X is already equal to null, has no effect."),(0,i.kt)("p",null,"c)Free(X), when X is not equal to null first performs finalization, as described in 7.6. It then deallocates the storage occupied by the object designated by X. If the storage pool is a user-defined object, then the storage is deallocated by calling Deallocate, passing access_to_variable_subtype_name'Storage_Pool as the Pool parameter. Storage_Address is the value returned in the Storage_Address parameter of the corresponding Allocate call. Size_In_Storage_Elements and Alignment are the same values passed to the corresponding Allocate call. There is one exception: if the object being freed contains tasks, the object might not be deallocated. "),(0,i.kt)("p",null,"Ramification: Free calls only the specified Deallocate procedure to do deallocation. For any given object deallocation, the number of calls to Free (usually one) will be equal to the number of Allocate calls it took to allocate the object. We do not define the relative order of multiple calls used to deallocate the same object - that is, if the allocator allocated two pieces x and y, then Free might deallocate x and then y, or it might deallocate y and then x. "),(0,i.kt)("p",null,"After Free(X), the object designated by X, and any subcomponents thereof, no longer exist; their storage can be reused for other purposes. "),(0,i.kt)("h4",{id:"bounded-run-time-errors-1"},"Bounded (Run-Time) Errors"),(0,i.kt)("p",null,"It is a bounded error to free a discriminated, unterminated task object. The possible consequences are: "),(0,i.kt)("p",null,"Reason: This is an error because the task might refer to its discriminants, and the discriminants might be deallocated by freeing the task object. "),(0,i.kt)("p",null,"No exception is raised."),(0,i.kt)("p",null,"Program_Error or Tasking_Error is raised at the point of the deallocation. "),(0,i.kt)("p",null,"Program_Error or Tasking_Error is raised in the task the next time it references any of the discriminants. "),(0,i.kt)("p",null,"Implementation Note: This last case presumes an implementation where the task references its discriminants indirectly, and the pointer is nulled out when the task object is deallocated. "),(0,i.kt)("p",null,"In the first two cases, the storage for the discriminants (and for any enclosing object if it is designated by an access discriminant of the task) is not reclaimed prior to task termination. "),(0,i.kt)("p",null,"Ramification: The storage might never be reclaimed. "),(0,i.kt)("h4",{id:"erroneous-execution-5"},"Erroneous Execution"),(0,i.kt)("p",null,"Evaluating a name that denotes a nonexistent objectis erroneous. The execution of a call to an instance of Unchecked_Deallocation is erroneous if the object was created other than by an allocator for an access type whose pool is Name'Storage_Pool."),(0,i.kt)("h4",{id:"implementation-advice-15"},"Implementation Advice"),(0,i.kt)("p",null,"For a standard storage pool, Free should actually reclaim the storage. "),(0,i.kt)("p",null,"Ramification: This is not a testable property, since we do not how much storage is used by a given pool element, nor whether fragmentation can occur. "),(0,i.kt)("p",null,"NOTE 1   The rules here that refer to Free apply to any instance of Unchecked_Deallocation."),(0,i.kt)("p",null,"NOTE 2   Unchecked_Deallocation cannot be instantiated for an access-to-constant type. This is implied by the rules of 12.5.4. "),(0,i.kt)("h3",{id:"13113--pragma-controlled"},"13.11.3  Pragma Controlled"),(0,i.kt)("p",null,"[Pragma Controlled is used to prevent any automatic reclamation of storage (garbage collection) for the objects created by allocators of a given access type.]"," "),(0,i.kt)("h4",{id:"syntax-7"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Controlled is as follows: "),(0,i.kt)("p",null,"  pragma Controlled(first_subtype_local_name);"),(0,i.kt)("p",null,"Discussion: Not to be confused with type Finalization.Controlled. "),(0,i.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,i.kt)("p",null,"The first_subtype_local_name of a pragma Controlled shall denote a nonderived access subtype."),(0,i.kt)("h4",{id:"static-semantics-26"},"Static Semantics"),(0,i.kt)("p",null,"A pragma Controlled is a representation pragma that specifies the controlled aspect of representation."),(0,i.kt)("p",null,"Garbage collection is a process that automatically reclaims storage, or moves objects to a different address, while the objects still exist."),(0,i.kt)("p",null,"Ramification: Storage reclamation upon leaving a master is not considered garbage collection."),(0,i.kt)("p",null,'Note that garbage collection includes compaction of a pool ("moved to a different Address"), even if storage reclamation is not done.'),(0,i.kt)("p",null,"Reason: Programs that will be damaged by automatic storage reclamation are just as likely to be damaged by having objects moved to different locations in memory. A pragma Controlled should turn off both flavors of garbage collection. "),(0,i.kt)("p",null,"Implementation Note: If garbage collection reclaims the storage of a controlled object, it should first finalize it. Finalization is not done when moving an object; any self-relative pointers will have to be updated by the garbage collector. If an implementation provides garbage collection for a storage pool containing controlled objects (see 7.6), then it should provide a means for deferring garbage collection of those controlled objects. "),(0,i.kt)("p",null,"Reason: This allows the manager of a resource released by a Finalize operation to defer garbage collection during its critical regions; it is up to the author of the Finalize operation to do so. Garbage collection, at least in some systems, can happen asynchronously with respect to normal user code. Note that it is not enough to defer garbage collection during Initialize, Adjust, and Finalize, because the resource in question might be used in other situations as well. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Finalization;\npackage P is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type My_Controlled is\n        new Ada.Finalization.Limited_Controlled with private;\n    procedure Finalize(Object : in out My_Controlled);\n    type My_Controlled_Access is access My_Controlled;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Non_Reentrant;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n    ...\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body P is\n    X : Integer := 0;\n    A : array(Integer range 1..10) of Integer;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Non_Reentrant is\n    begin\n        X := X + 1;\n        -- If the system decides to do a garbage collection here,\n        -- then we're in trouble, because it will call Finalize on\n        -- the collected objects; we essentially have two threads\n        -- of control erroneously accessing shared variables.\n        -- The garbage collector behaves like a separate thread\n        -- of control, even though the user hasn't declared\n        -- any tasks.\n        A(X) := ...;\n    end Non_Reentrant;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Finalize(Object : in out My_Controlled) is\n    begin\n        Non_Reentrant;\n    end Finalize;\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with P; use P;\nprocedure Main is\nbegin\n    ... new My_Controlled ... -- allocate some objects\n    ...  forget the pointers to some of them, so they become garbage\n    Non_Reentrant;\nend Main;\n\n")),(0,i.kt)("p",null,"It is the user's responsibility to protect against this sort of thing, and the implementation's responsibility to provide the necessary operations."),(0,i.kt)("p",null,"We do not give these operations names, nor explain their exact semantics, because different implementations of garbage collection might have different needs, and because garbage collection is not supported by most Ada implementations, so portability is not important here. Another reason not to turn off garbage collection during each entire Finalize operation is that it would create a serial bottleneck; it might be only part of the Finalize operation that conflicts with some other resource. It is the intention that the mechanisms provided be finer-grained than pragma Controlled. "),(0,i.kt)("p",null,"If a pragma Controlled is specified for an access type with a standard storage pool, then garbage collection is not performed for objects in that pool. "),(0,i.kt)("p",null,"Ramification: If Controlled is not specified, the implementation may, but need not, perform garbage collection. If Storage_Pool is specified, then a pragma Controlled for that type is ignored. "),(0,i.kt)("p",null,"Reason: Controlled means that implementation-provided garbage collection is turned off; if the Storage_Pool is specified, the pool controls whether garbage collection is done. "),(0,i.kt)("h4",{id:"implementation-permissions-7"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation need not support garbage collection, in which case, a pragma Controlled has no effect. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-11"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Ada 83 used the term "automatic storage reclamation" to refer to what is known traditionally as "garbage collection". Because of the existence of storage pools (see 13.11), we need to distinguish this from the storage reclamation that might happen upon leaving a master. Therefore, we now use the term "garbage collection" in its normal computer-science sense. This has the additional advantage of making our terminology more accessible to people outside the Ada world. '),(0,i.kt)("h4",{id:"erroneous-execution-6"},"Erroneous Execution"),(0,i.kt)("h2",{id:"1312--pragma-restrictions"},"13.12  Pragma Restrictions"),(0,i.kt)("p",null,"[A pragma Restrictions expresses the user's intent to abide by certain restrictions. This may facilitate the construction of simpler run-time environments.]"," "),(0,i.kt)("h4",{id:"syntax-8"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Restrictions is as follows: "),(0,i.kt)("p",null,"  pragma Restrictions(restriction{, restriction});"),(0,i.kt)("p",null,"restriction ::= restriction_identifier\n| restriction_parameter_identifier =",">"," expression"),(0,i.kt)("h4",{id:"name-resolution-rules-6"},"Name Resolution Rules"),(0,i.kt)("p",null,"Unless otherwise specified for a particular restriction, the expression is expected to be of any integer type. "),(0,i.kt)("h4",{id:"legality-rules-8"},"Legality Rules"),(0,i.kt)("p",null,"Unless otherwise specified for a particular restriction, the expression shall be static, and its value shall be nonnegative. "),(0,i.kt)("h4",{id:"static-semantics-27"},"Static Semantics"),(0,i.kt)("p",null,"The set of restrictions is implementation defined. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: The set of restrictions allowed in a pragma Restrictions."),(0,i.kt)("h4",{id:"post-compilation-rules"},"Post-Compilation Rules"),(0,i.kt)("p",null,"A pragma Restrictions is a configuration pragma; unless otherwise specified for a particular restriction, a partition shall obey the restriction if a pragma Restrictions applies to any compilation unit included in the partition."),(0,i.kt)("h4",{id:"implementation-permissions-8"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may place limitations on the values of the expression that are supported, and limitations on the supported combinations of restrictions. The consequences of violating such limitations are implementation defined. "),(0,i.kt)("p",null,"Implementation defined: The consequences of violating limitations on Restrictions pragmas."),(0,i.kt)("p",null,"Ramification: Such limitations may be enforced at compile time or at run time. Alternatively, the implementation is allowed to declare violations of the restrictions to be erroneous, and not enforce them at all. "),(0,i.kt)("h4",{id:"syntax-9"},"Syntax"),(0,i.kt)("p",null,"NOTE 1   Restrictions intended to facilitate the construction of efficient tasking run-time systems are defined in D.7. Safety- and security-related restrictions are defined in H.4."),(0,i.kt)("p",null,"NOTE 2   An implementation has to enforce the restrictions in cases where enforcement is required, even if it chooses not to take advantage of the restrictions in terms of efficiency. "),(0,i.kt)("p",null,"Discussion: It is not the intent that an implementation will support a different run-time system for every possible combination of restrictions. An implementation might support only two run-time systems, and document a set of restrictions that is sufficient to allow use of the more efficient and safe one. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-7"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Pragma Restrictions is new to Ada 95. "),(0,i.kt)("h2",{id:"1313--streams"},"13.13  Streams"),(0,i.kt)("p",null,"A stream is a sequence of elements comprising values from possibly different types and allowing sequential access to these values. A stream type is a type in the class whose root type is Streams.Root_Stream_Type. A stream type may be implemented in various ways, such as an external sequential file, an internal buffer, or a network channel. "),(0,i.kt)("p",null,"Discussion: A stream element will often be the same size as a storage element, but that is not required. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[stream]",", Def=","[a sequence of elements that can be used, along with the stream-oriented attributes, to support marshalling and unmarshalling of values of most types]"," "),(0,i.kt)("h4",{id:"extensions-to-ada-83-8"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Streams are new in Ada 95. "),(0,i.kt)("h3",{id:"13131--the-package-streams"},"13.13.1  The Package Streams"),(0,i.kt)("h4",{id:"static-semantics-28"},"Static Semantics"),(0,i.kt)("p",null,"The abstract type Root_Stream_Type is the root type of the class of stream types. The types in this class represent different kinds of streams. A new stream type is defined by extending the root type (or some other stream type), overriding the Read and Write operations, and optionally defining additional primitive subprograms, according to the requirements of the particular kind of stream. The predefined stream-oriented attributes like T'Read and T'Write make dispatching calls on the Read and Write procedures of the Root_Stream_Type. (User-defined T'Read and T'Write attributes can also make such calls, or can call the Read and Write attributes of other types.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Streams is\n    pragma Pure(Streams);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Root_Stream_Type is abstract tagged limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Stream_Element is mod implementation-defined;\n    type Stream_Element_Offset is range implementation-defined;\n    subtype Stream_Element_Count is\n        Stream_Element_Offset range 0..Stream_Element_Offset'Last;\n    type Stream_Element_Array is\n        array(Stream_Element_Offset range &lt&gt) of Stream_Element;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Read(\n      Stream : in out Root_Stream_Type;\n      Item   : out Stream_Element_Array;\n      Last   : out Stream_Element_Offset) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Write(\n      Stream : in out Root_Stream_Type;\n      Item   : in Stream_Element_Array) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Streams;\n\n")),(0,i.kt)("p",null,"The Read operation transfers Item'Length stream elements from the specified stream to fill the array Item. The index of the last stream element transferred is returned in Last. Last is less than Item'Last only if the end of the stream is reached."),(0,i.kt)("p",null,"The Write operation appends Item to the specified stream."),(0,i.kt)("p",null,'NOTE 1   See A.12.1, "The Package Streams.Stream_IO" for an example of extending type Root_Stream_Type.'),(0,i.kt)("h3",{id:"13132--stream-oriented-attributes"},"13.13.2  Stream-Oriented Attributes"),(0,i.kt)("p",null,"The Write, Read, Output, and Input attributes convert values to a stream of elements and reconstruct values from a stream. "),(0,i.kt)("h4",{id:"static-semantics-29"},"Static Semantics"),(0,i.kt)("h4",{id:"static-semantics-30"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S of a specific type T, the following attributes are defined. "),(0,i.kt)("p",null,"S'WriteS'Write denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Write(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item : in T)\n\n")),(0,i.kt)("p",null,"S'Write writes the value of Item to Stream."),(0,i.kt)("p",null,"S'ReadS'Read denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Read(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item : out T)\n\n")),(0,i.kt)("p",null,"S'Read reads the value of Item from Stream. "),(0,i.kt)("p",null,"For elementary types,  the representation in terms of stream elements is implementation defined. For composite types, the Write or Read attribute for each component is called in a canonical order. The canonical order of components is last dimension varying fastest for an array, and positional aggregate order for a record. Bounds are not included in the stream if T is an array type. If T is a discriminated type, discriminants are included only if they have defaults. If T is a tagged type, the tag is not included. "),(0,i.kt)("p",null,"Implementation defined: The representation used by the Read and Write attributes of elementary types in terms of stream elements."),(0,i.kt)("p",null,'Reason: A discriminant with a default value is treated simply as a component of the object. On the other hand, an array bound or a discriminant without a default value, is treated as "descriptor" or "dope" that must be provided in order to create the object and thus is logically separate from the regular components. Such "descriptor" data are written by \'Output and produced as part of the delivered result by the \'Input function, but they are not written by \'Write nor read by \'Read. A tag is like a discriminant without a default.'),(0,i.kt)("p",null,"Ramification: For a composite object, the subprogram denoted by the Write or Read attribute of each component is called, whether it is the default or is user-specified. "),(0,i.kt)("p",null,"For every subtype S'Class of a class-wide type T'Class: "),(0,i.kt)("p",null,"S'Class'WriteS'Class'Write denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Class'Write(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item   : in T'Class)\n\n")),(0,i.kt)("p",null,"Dispatches to the subprogram denoted by the Write attribute of the specific type identified by the tag of Item."),(0,i.kt)("p",null,"S'Class'ReadS'Class'Read denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Class'Read(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item : out T'Class)\n\n")),(0,i.kt)("p",null,"Dispatches to the subprogram denoted by the Read attribute of the specific type identified by the tag of Item. "),(0,i.kt)("p",null,"Reason: It is necessary to have class-wide versions of Read and Write in order to avoid generic contract model violations; in a generic, we don't necessarily know at compile time whether a given type is specific or class-wide. "),(0,i.kt)("h4",{id:"implementation-advice-16"},"Implementation Advice"),(0,i.kt)("p",null,"If a stream element is the same size as a storage element, then the normal in-memory representation should be used by Read and Write for scalar objects. Otherwise, Read and Write should use the smallest number of stream elements needed to represent all values in the base range of the scalar type. "),(0,i.kt)("h4",{id:"static-semantics-31"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S of a specific type T, the following attributes are defined. "),(0,i.kt)("p",null,"S'OutputS'Output denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Output(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item : in T)\n\n")),(0,i.kt)("p",null,"S'Output writes the value of Item to Stream, including any bounds or discriminants. "),(0,i.kt)("p",null,"Ramification: Note that the bounds are included even for an array type whose first subtype is constrained. "),(0,i.kt)("p",null,"S'InputS'Input denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Input(\n   Stream : access Ada.Streams.Root_Stream_Type'Class)\n   return T\n\n")),(0,i.kt)("p",null,"S'Input reads and returns one value from Stream, using any bounds or discriminants written by a corresponding S'Output to determine how much to read. "),(0,i.kt)("p",null,"Unless overridden by an attribute_definition_clause, these subprograms execute as follows:"),(0,i.kt)("p",null,"If T is an array type, S'Output first writes the bounds, and S'Input first reads the bounds. If T has discriminants without defaults, S'Output first writes the discriminants (using S'Write for each), and S'Input first reads the discriminants (using S'Read for each)."),(0,i.kt)("p",null,"S'Output then calls S'Write to write the value of Item to the stream. S'Input then creates an object (with the bounds or discriminants, if any, taken from the stream), initializes it with S'Read, and returns the value of the object. "),(0,i.kt)("p",null,"For every subtype S'Class of a class-wide type T'Class: "),(0,i.kt)("p",null,"S'Class'OutputS'Class'Output denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure S'Class'Output(\n   Stream : access Ada.Streams.Root_Stream_Type'Class;\n   Item   : in T'Class)\n\n")),(0,i.kt)("p",null,"First writes the external tag of Item to Stream (by calling String'Output(Tags.External_Tag(Item'Tag) - see 3.9) and then dispatches to the subprogram denoted by the Output attribute of the specific type identified by the tag. "),(0,i.kt)("p",null,"S'Class'InputS'Class'Input denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Class'Input(\n   Stream : access Ada.Streams.Root_Stream_Type'Class)\n   return T'Class\n\n")),(0,i.kt)("p",null,"First reads the external tag from Stream and determines the corresponding internal tag (by calling Tags.Internal_Tag(String'Input(Stream)) - see 3.9) and then dispatches to the subprogram denoted by the Input attribute of the specific type identified by the internal tag; returns that result."),(0,i.kt)("p",null,"In the default implementation of Read and Input for a composite type, for each scalar component that is a discriminant or whose component_declaration includes a default_expression, a check is made that the value returned by Read for the component belongs to its subtype. Constraint_Error is raised if this check fails. For other scalar components, no check is made. For each component that is of an access type, if the implementation can detect that the value returned by Read for the component is not a value of its subtype, Constraint_Error is raised. If the value is not a value of its subtype and this error is not detected, the component has an abnormal value, and erroneous execution can result (see 13.9.1)."),(0,i.kt)("p",null,"The stream-oriented attributes may be specified for any type via an attribute_definition_clause. All nonlimited types have default implementations for these operations. An attribute_reference for one of these attributes is illegal if the type is limited, unless the attribute has been specified by an attribute_definition_clause. For an attribute_definition_clause specifying one of these attributes, the subtype of the Item parameter shall be the base subtype if scalar, and the first subtype otherwise. The same rule applies to the result of the Input function. "),(0,i.kt)("p",null,"Reason: This is to simplify implementation. "),(0,i.kt)("p",null,"NOTE 1   For a definite subtype S of a type T, only T'Write and T'Read are needed to pass an arbitrary value of the subtype through a stream. For an indefinite subtype S of a type T, T'Output and T'Input will normally be needed, since T'Write and T'Read do not pass bounds, discriminants, or tags."),(0,i.kt)("p",null,"NOTE 2   User-specified attributes of S'Class are not inherited by other class-wide types descended from S. "),(0,i.kt)("h4",{id:"examples-6"},"Examples"),(0,i.kt)("p",null,"Example of user-defined Write attribute: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure My_Write(\n  Stream : access Ada.Streams.Root_Stream_Type'Class;Item : My_Integer'Base);\nfor My_Integer'Write use My_Write;\n\n")),(0,i.kt)("p",null,"Discussion: Example of network input/output using input output attributes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Streams; use Ada.Streams;\ngeneric\n    type Msg_Type(&lt&gt) is private;\npackage Network_IO is\n    -- Connect/Disconnect are used to establish the stream\n    procedure Connect(...);\n    procedure Disconnect(...);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    -- Send/Receive transfer messages across the network\n    procedure Send(X : in Msg_Type);\n    function Receive return Msg_Type;\nprivate\n    type Network_Stream is new Root_Stream_Type with ...\n    procedure Read(...);  -- define Read/Write for Network_Stream\n    procedure Write(...);\nend Network_IO;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Streams; use Ada.Streams;\npackage body Network_IO is\n    Current_Stream : aliased Network_Stream;\n    . . .\n    procedure Connect(...) is ...;\n    procedure Disconnect(...) is ...;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Send(X : in Msg_Type) is\n    begin\n        Msg_Type'Output(Current_Stream'Access, X);\n    end Send;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    function Receive return Msg_Type is\n    begin\n        return Msg_Type'Input(Current_Stream'Access);\n    end Receive;\nend Network_IO;\n\n")),(0,i.kt)("h2",{id:"1314--freezing-rules"},"13.14  Freezing Rules"),(0,i.kt)("p",null,'[This clause defines a place in the program text where each declared entity becomes "frozen". A use of an entity, such as a reference to it by name, or (for a type) an expression of the type, causes freezing of the entity in some contexts, as described below. The Legality Rules forbid certain kinds of uses of an entity in the region of text where it is frozen.]'," "),(0,i.kt)("p",null,"Reason: This concept has two purposes: a compile-time one and a run-time one."),(0,i.kt)("p",null,"The compile-time purpose of the freezing rules comes from the fact that the evaluation of static expressions depends on overload resolution, and overload resolution sometimes depends on the value of a static expression. (The dependence of static evaluation upon overload resolution is obvious. The dependence in the other direction is more subtle. There are three rules that require static expressions in contexts that can appear in declarative places: The expression in an attribute_designator shall be static. In a record aggregate, variant-controlling discriminants shall be static. In an array aggregate with more than one named association, the choices shall be static. The compiler needs to know the value of these expressions in order to perform overload resolution and legality checking.) We wish to allow a compiler to evaluate static expressions when it sees them in a single pass over the compilation_unit. The freezing rules ensure that."),(0,i.kt)("p",null,'The run-time purpose of the freezing rules is called the "linear elaboration model". This means that declarations are elaborated in the order in which they appear in the program text, and later elaborations can depend on the results of earlier ones. The elaboration of the declarations of certain entities requires run-time information about the implementation details of other entities. The freezing rules ensure that this information has been calculated by the time it is used. For example, suppose the initial value of a constant is the result of a function call that takes a parameter of type T. In order to pass that parameter, the size of type T has to be known. If T is composite, that size might be known only at run time.'),(0,i.kt)("p",null,'(Note that in these discussions, words like "before" and "after" generally refer to places in the program text, as opposed to times at run time.) '),(0,i.kt)("p",null,'Discussion: The "implementation details" we\'re talking about above are: '),(0,i.kt)("p",null,"For a tagged type, the implementations of all the primitive subprograms of the type - that is (in the canonical implementation model), the contents of the type descriptor, which contains pointers to the code for each primitive subprogram."),(0,i.kt)("p",null,"For a type, the full type declaration of any parts (including the type itself) that are private."),(0,i.kt)("p",null,"For a deferred constant, the full constant declaration, which gives the constant's value. (Since this information necessarily comes after the constant's type and subtype are fully known, there's no need to worry about its type or subtype.)"),(0,i.kt)("p",null,"For any entity, representation information specified by the user via representation items. Most representation items are for types or subtypes; however, various other kinds of entities, such as objects and subprograms, are possible. "),(0,i.kt)("p",null,"Similar issues arise for incomplete types. However, we do not use freezing there; incomplete types have different, more severe, restrictions. Similar issues also arise for subprograms, protected operations, tasks and generic units. However, we do not use freezing there either; 3.11 prevents problems with run-time Elaboration_Checks. "),(0,i.kt)("h4",{id:"language-design-principles-3"},"Language Design Principles"),(0,i.kt)("p",null,"An evaluable construct should freeze anything that's needed to evaluate it."),(0,i.kt)("p",null,"However, if the construct is not evaluated where it appears, let it cause freezing later, when it is evaluated. This is the case for default_expressions and default_names. (Formal parameters, generic formal parameters, and components can have default_expressions or default_names.)"),(0,i.kt)("p",null,"The compiler should be allowed to evaluate static expressions without knowledge of their context. (I.e. there should not be any special rules for static expressions that happen to occur in a context that requires a static expression.)"),(0,i.kt)("p",null,"Compilers should be allowed to evaluate static expressions (and record the results) using the run-time representation of the type. For example, suppose Color'Pos(Red) = 1, but the internal code for Red is 37. If the value of a static expression is Red, some compilers might store 1 in their symbol table, and other compilers might store 37. Either compiler design should be feasible."),(0,i.kt)("p",null,"Compilers should never be required to detect erroneousness or exceptions at compile time (although it's very nice if they do). This implies that we should not require code-generation for a nonstatic expression of type T too early, even if we can prove that that expression will be erroneous, or will raise an exception."),(0,i.kt)("p",null,"Here's an example (modified from AI83-00039, Example 3): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T is\n    record\n        ...\n    end record;\nfunction F return T;\nfunction G(X : T) return Boolean;\nY : Boolean := G(F); -- doesn't force T in Ada 83\nfor T use\n    record\n        ...\n    end record;\n\n")),(0,i.kt)("p",null,"AI83-00039 says this is legal. Of course, it raises Program_Error because the function bodies aren't elaborated yet. A one-pass compiler has to generate code for an expression of type T before it knows the representation of T. Here's a similar example, which AI83-00039 also says is legal: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T is private;\n    function F return T;\n    function G(X : T) return Boolean;\n    Y : Boolean := G(F); -- doesn't force T in Ada 83\nprivate\n    type T is\n        record\n            ...\n        end record;\nend P;\n\n")),(0,i.kt)("p",null,"If T's size were dynamic, that size would be stored in some compiler-generated dope; this dope would be initialized at the place of the full type declaration. However, the generated code for the function calls would most likely allocate a temp of the size specified by the dope before checking for Program_Error. That dope would contain uninitialized junk, resulting in disaster. To avoid doing that, the compiler would have to determine, at compile time, that the expression will raise Program_Error."),(0,i.kt)("p",null,"This is silly. If we're going to require compilers to detect the exception at compile time, we might as well formulate the rule as a legality rule."),(0,i.kt)("p",null,"Compilers should not be required to generate code to load the value of a variable before the address of the variable has been determined."),(0,i.kt)("p",null,"After an entity has been frozen, no further requirements may be placed on its representation (such as by a representation item or a full_type_declaration). "),(0,i.kt)("p",null,"The freezing of an entity occurs at one or more places (freezing points) in the program text where the representation for the entity has to be fully determined. Each entity is frozen from its first freezing point to the end of the program text (given the ordering of compilation units defined in 10.1.4). "),(0,i.kt)("p",null,'Ramification: The "representation" for a subprogram includes its calling convention and means for referencing the subprogram body, either a "link-name" or specified address. It does not include the code for the subprogram body itself, nor its address if a link-name is used to reference the body. '),(0,i.kt)("p",null,"The end of a declarative_part, protected_body, or a declaration of a library package or generic library package, causes freezing of each entity declared within it except for incomplete types. A noninstance body causes freezing of each entity declared before it within the same declarative_part. "),(0,i.kt)("p",null,"Discussion: This is worded carefully to handle nested packages and private types. Entities declared in a nested package_specification will be frozen by some containing construct."),(0,i.kt)("p",null,"An incomplete type declared in the private part of a library package_specification can be completed in the body."),(0,i.kt)("p",null,"Ramification: The part about bodies does not say immediately within. A renaming-as-body does not have this property. Nor does a pragma Import. "),(0,i.kt)("p",null,"Reason: The reason bodies cause freezing is because we want proper_bodies and body_stubs to be interchangeable - one should be able to move a proper_body to a subunit, and vice-versa, without changing the semantics. Clearly, anything that should cause freezing should do so even if it's inside a proper_body. However, if we make it a body_stub, then the compiler can't see that thing that should cause freezing. So we make body_stubs cause freezing, just in case they contain something that should cause freezing. But that means we need to do the same for proper_bodies."),(0,i.kt)("p",null,"Another reason for bodies to cause freezing, there could be an added implementation burden if an entity declared in an enclosing declarative_part is frozen within a nested body, since some compilers look at bodies after looking at the containing declarative_part."),(0,i.kt)("p",null,"A construct that (explicitly or implicitly) references an entity can cause the freezing of the entity, as defined by subsequent paragraphs. At the place where a construct causes freezing, each name, expression","[, or range]"," within the construct causes freezing: "),(0,i.kt)("p",null,'Ramification: Note that in the sense of this paragraph, a subtype_mark "references" the denoted subtype, but not the type. '),(0,i.kt)("p",null,"The occurrence of a generic_instantiation causes freezing; also, if a parameter of the instantiation is defaulted, the default_expression or default_name for that parameter causes freezing."),(0,i.kt)("p",null,"The occurrence of an object_declaration that has no corresponding completion causes freezing. "),(0,i.kt)("p",null,"Ramification: Note that this does not include a formal_object_declaration. "),(0,i.kt)("p",null,"The declaration of a record extension causes freezing of the parent subtype. "),(0,i.kt)("p",null,"Ramification: This combined with another rule specifying that primitive subprogram declarations shall precede freezing ensures that all descendants of a tagged type implement all of its dispatching operations."),(0,i.kt)("p",null,"The declaration of a private extension does not cause freezing. The freezing is deferred until the full type declaration, which will necessarily be for a record extension. "),(0,i.kt)("p",null,"A static expression causes freezing where it occurs. A nonstatic expression causes freezing where it occurs, unless the expression is part of a default_expression, a default_name, or a per-object expression of a component's constraint, in which case, the freezing occurs later as part of another construct."),(0,i.kt)("p",null,"The following rules define which entities are frozen at the place where a construct causes freezing: "),(0,i.kt)("p",null,"At the place where an expression causes freezing, the type of the expression is frozen, unless the expression is an enumeration literal used as a discrete_choice of the array_aggregate of an enumeration_representation_clause. "),(0,i.kt)("p",null,"Reason: We considered making enumeration literals never cause freezing, which would be more upward compatible, but examples like the variant record aggregate (Discrim =",">"," Red, ...) caused us to change our mind. Furthermore, an enumeration literal is a static expression, so the implementation should be allowed to represent it using its representation."),(0,i.kt)("p",null,"Ramification: The following pathological example was legal in Ada 83, but is illegal in Ada 95: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package P1 is\n    type T is private;\n    package P2 is\n        type Composite(D : Boolean) is\n            record\n                case D is\n                    when False =&gt Cf : Integer;\n                    when True  =&gt Ct : T;\n                end case;\n            end record;\n    end P2;\n    X : Boolean := P2."="( (False,1), (False,1) );\nprivate\n    type T is array(1..Func_Call) of Integer;\nend;\n\n')),(0,i.kt)("p",null,"In Ada 95, the declaration of X freezes Composite (because it contains an expression of that type), which in turn freezes T (even though Ct does not exist in this particular case). But type T is not completely defined at that point, violating the rule that a type shall be completely defined before it is frozen. In Ada 83, on the other hand, there is no occurrence of the name T, hence no forcing occurrence of T. "),(0,i.kt)("p",null,"At the place where a name causes freezing, the entity denoted by the name is frozen, unless the name is a prefix of an expanded name; at the place where an object name causes freezing, the nominal subtype associated with the name is frozen. "),(0,i.kt)("p",null,"Ramification: This only matters in the presence of deferred constants or access types; an object_declaration other than a deferred_constant_declaration causes freezing of the nominal subtype, plus all component junk."),(0,i.kt)("p",null,"Implicit_dereferences are covered by expression. "),(0,i.kt)("p",null,"[ At the place where a range causes freezing, the type of the range is frozen.]"," "),(0,i.kt)("p",null,'Proof: This is consequence of the facts that expressions freeze their type, and the Range attribute is defined to be equivalent to a pair of expressions separated by "..".} '),(0,i.kt)("p",null,"At the place where an allocator causes freezing, the designated subtype of its type is frozen. If the type of the allocator is a derived type, then all ancestor types are also frozen. "),(0,i.kt)("p",null,"Ramification: Allocators also freeze the named subtype, as a consequence of other rules."),(0,i.kt)("p",null,"The ancestor types are frozen to prevent things like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Pool_Ptr is access System.Storage_Pools.Root_Storage_Pool'Class;\nfunction F return Pool_Ptr;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type A1 is access Boolean;\n    type A2 is new A1;\n    type A3 is new A2;\n    X : A3 := new Boolean; -- Don't know what pool yet!\n    for A1'Storage_Pool use F.all;\nend P;\n\n")),(0,i.kt)("p",null,"This is necessary because derived access types share their parent's pool. "),(0,i.kt)("p",null,"At the place where a callable entity is frozen, each subtype of its profile is frozen. If the callable entity is a member of an entry family, the index subtype of the family is frozen. At the place where a function call causes freezing, if a parameter of the call is defaulted, the default_expression for that parameter causes freezing. "),(0,i.kt)("p",null,"Discussion: We don't worry about freezing for procedure calls or entry calls, since a body freezes everything that precedes it, and the end of a declarative part freezes everything in the declarative part. "),(0,i.kt)("p",null,"At the place where a subtype is frozen, its type is frozen. At the place where a type is frozen, any expressions or names within the full type definition cause freezing; the first subtype, and any component subtypes, index subtypes, and parent subtype of the type are frozen as well. For a specific tagged type, the corresponding class-wide type is frozen as well. For a class-wide type, the corresponding specific type is frozen as well. "),(0,i.kt)("p",null,"Ramification: Freezing a type needs to freeze its first subtype in order to preserve the property that the subtype-specific aspects of statically matching subtypes are the same."),(0,i.kt)("p",null,"Freezing an access type does not freeze its designated subtype. "),(0,i.kt)("h4",{id:"legality-rules-9"},"Legality Rules"),(0,i.kt)("p",null,"[The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen (see 3.9.2).]"," "),(0,i.kt)("p",null,"Reason: This rule is needed because (1) we don't want people dispatching to things that haven't been declared yet, and (2) we want to allow tagged type descriptors to be static (allocated statically, and initialized to link-time-known symbols). Suppose T2 inherits primitive P from T1, and then overrides P. Suppose P is called before the declaration of the overriding P. What should it dispatch to? If the answer is the new P, we've violated the first principle above. If the answer is the old P, we've violated the second principle. (A call to the new one necessarily raises Program_Error, but that's beside the point.)"),(0,i.kt)("p",null,"Note that a call upon a dispatching operation of type T will freeze T."),(0,i.kt)("p",null,"We considered applying this rule to all derived types, for uniformity. However, that would be upward incompatible, so we rejected the idea. As in Ada 83, for an untagged type, the above call upon P will call the old P (which is arguably confusing). "),(0,i.kt)("p",null,"[A type shall be completely defined before it is frozen (see 3.11.1 and 7.3).]"),(0,i.kt)("p",null,"[The completion of a deferred constant declaration shall occur before the constant is frozen (see 7.4).]"),(0,i.kt)("p",null,"[A representation item that directly specifies an aspect of an entity shall appear before the entity is frozen (see 13.1).]"," "),(0,i.kt)("p",null,"Discussion: From RM83-13.1(7). The wording here forbids freezing within the representation_clause itself, which was not true of the Ada 83 wording. The wording of this rule is carefully written to work properly for type-related representation items. For example, an enumeration_representation_clause is illegal after the type is frozen, even though the _clause refers to the first subtype."),(0,i.kt)("p",null,'Proof: The above Legality Rules are stated "officially" in the referenced clauses. '),(0,i.kt)("p",null,"Discussion: Here's an example that illustrates when freezing occurs in the presence of defaults: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T is ...;\nfunction F return T;\ntype R is\n    record\n        C : T := F;\n        D : Boolean := F = F;\n    end record;\nX : R;\n\n")),(0,i.kt)("p",null,"Since the elaboration of R's declaration does not allocate component C, there is no need to freeze C's subtype at that place. Similarly, since the elaboration of R does not evaluate the default_expression \"F = F\", there is no need to freeze the types involved at that point. However, the declaration of X does need to freeze these things. Note that even if component C did not exist, the elaboration of the declaration of X would still need information about T - even though D is not of type T, its default_expression requires that information. "),(0,i.kt)("p",null,"Ramification: Although we define freezing in terms of the program text as a whole (i.e. after applying the rules of Section 10), the freezing rules actually have no effect beyond compilation unit boundaries. "),(0,i.kt)("p",null,"Reason: That is important, because Section 10 allows some implementation definedness in the order of things, and we don't want the freezing rules to be implementation defined. "),(0,i.kt)("p",null,"Ramification: These rules also have no effect in statements - they only apply within a single declarative_part, package_specification, task_definition, protected_definition, or protected_body. "),(0,i.kt)("p",null,"Implementation Note: An implementation may choose to generate code for default_expressions and default_names in line at the place of use. Alternatively, an implementation may choose to generate thunks (subprograms implicitly generated by the compiler) for evaluation of defaults. Thunk generation cannot, in general, be done at the place of the declaration that includes the default. Instead, they can be generated at the first freezing point of the type(s) involved. (It is impossible to write a purely one-pass Ada compiler, for various reasons. This is one of them - the compiler needs to store a representation of defaults in its symbol table, and then walk that representation later, no earlier than the first freezing point.)"),(0,i.kt)("p",null,"In implementation terms, the linear elaboration model can be thought of as preventing uninitialized dope. For example, the implementation might generate dope to contain the size of a private type. This dope is initialized at the place where the type becomes completely defined. It cannot be initialized earlier, because of the order-of-elaboration rules. The freezing rules prevent elaboration of earlier declarations from accessing the size dope for a private type before it is initialized."),(0,i.kt)("p",null,"2.8 overrides the freezing rules in the case of unrecognized pragmas."),(0,i.kt)("p",null,"A representation_clause for an entity should most certainly not be a freezing point for the entity. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,'RM83 defines a forcing occurrence of a type as follows: "A forcing occurrence is any occurrence ',"[of the name of the type, subtypes of the type, or types or subtypes with subcomponents of the type]",' other than in a type or subtype declaration, a subprogram specification, an entry declaration, a deferred constant declaration, a pragma, or a representation_clause for the type itself. In any case, an occurrence within an expression is always forcing."'),(0,i.kt)("p",null,"It seems like the wording allows things like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type A is array(Integer range 1..10) of Boolean;\nsubtype S is Integer range A'Range;\n    -- not forcing for A\n\n")),(0,i.kt)("p",null,"Occurrences within pragmas can cause freezing in Ada 95. (Since such pragmas are ignored in Ada 83, this will probably fix more bugs than it causes.) "),(0,i.kt)("h4",{id:"extensions-to-ada-83-9"},"Extensions to Ada 83"),(0,i.kt)("p",null,"In Ada 95, generic_formal_parameter_declarations do not normally freeze the entities from which they are defined. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Outer is\n    type T is tagged limited private;\n    generic\n        type T2 is\n            new T with private; -- Does not freeze T\n                                -- in Ada 95.\n    package Inner is\n        ...\n    end Inner;\nprivate\n    type T is ...;\nend Outer;\n\n")),(0,i.kt)("p",null,"This is important for the usability of generics. The above example uses the Ada 95 feature of formal derived types. Examples using the kinds of formal parameters already allowed in Ada 83 are well known. See, for example, comments 83-00627 and 83-00688. The extensive use expected for formal derived types makes this issue even more compelling than described by those comments. Unfortunately, we are unable to solve the problem that explicit_generic_actual_parameters cause freezing, even though a package equivalent to the instance would not cause freezing. This is primarily because such an equivalent package would have its body in the body of the containing program unit, whereas an instance has its body right there. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-12"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The concept of freezing is based on Ada 83\'s concept of "forcing occurrences". The first freezing point of an entity corresponds roughly to the place of the first forcing occurrence, in Ada 83 terms. The reason for changing the terminology is that the new rules do not refer to any particular "occurrence" of a name of an entity. Instead, we refer to "uses" of an entity, which are sometimes implicit.'),(0,i.kt)("p",null,"In Ada 83, forcing occurrences were used only in rules about representation_clauses. We have expanded the concept to cover private types, because the rules stated in RM83-7.4.1(4) are almost identical to the forcing occurrence rules."),(0,i.kt)("p",null,"The Ada 83 rules are changed in Ada 95 for the following reasons: "),(0,i.kt)("p",null,"The Ada 83 rules do not work right for subtype-specific aspects. In an earlier version of Ada 9X, we considered allowing representation items to apply to subtypes other than the first subtype. This was part of the reason for changing the Ada 83 rules. However, now that we have dropped that functionality, we still need the rules to be different from the Ada 83 rules."),(0,i.kt)("p",null,"The Ada 83 rules do not achieve the intended effect. In Ada 83, either with or without the AIs, it is possible to force the compiler to generate code that references uninitialized dope, or force it to detect erroneousness and exception raising at compile time."),(0,i.kt)("p",null,"It was a goal of Ada 83 to avoid uninitialized access values. However, in the case of deferred constants, this goal was not achieved."),(0,i.kt)("p",null,"The Ada 83 rules are not only too weak - they are also too strong. They allow loopholes (as described above), but they also prevent certain kinds of default_expressions that are harmless, and certain kinds of generic_declarations that are both harmless and very useful."),(0,i.kt)("p",null,"Ada 83 had a case where a representation_clause had a strong effect on the semantics of the program - 'Small. This caused certain semantic anomalies. There are more cases in Ada 95, because the attribute_representation_clause has been generalized."))}d.isMDXComponent=!0}}]);