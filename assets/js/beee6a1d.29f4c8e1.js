"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7605],{24010:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>y,contentTitle:()=>m,default:()=>b,frontMatter:()=>p,metadata:()=>h,toc:()=>f});var n=i(91716),o=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,a=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,c=(e,t,i)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,u=(e,t)=>{for(var i in t||(t={}))d.call(t,i)&&c(e,i,t[i]);if(a)for(var i of a(t))l.call(t,i)&&c(e,i,t[i]);return e};const p={title:"10. Improving Performance",sidebar_position:10},m=void 0,h={unversionedId:"style-guide/s10/s10",id:"style-guide/s10/s10",title:"10. Improving Performance",description:"In many ways, performance is at odds with maintainability and",source:"@site/docs/style-guide/s10/s10.mdx",sourceDirName:"style-guide/s10",slug:"/style-guide/s10/",permalink:"/docs/style-guide/s10/",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"10. Improving Performance",sidebar_position:10},sidebar:"styleGuideSidebar",previous:{title:"9.6 Summary",permalink:"/docs/style-guide/s9/06"},next:{title:"10.1 Performance Issues",permalink:"/docs/style-guide/s10/01"}},y={},f=[],g={toc:f};function b(e){var t,i=e,{components:o}=i,c=((e,t)=>{var i={};for(var n in e)d.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(null!=e&&a)for(var n of a(e))t.indexOf(n)<0&&l.call(e,n)&&(i[n]=e[n]);return i})(i,["components"]);return(0,n.kt)("wrapper",(t=u(u({},g),c),r(t,s({components:o,mdxType:"MDXLayout"}))),(0,n.kt)("p",null,"In many ways, performance is at odds with maintainability and\nportability. To achieve improved speed or memory usage, the most clear\nalgorithm sometimes gives way to confusing code. To exploit special\npurpose hardware or operating system services, non-portable\nimplementation dependencies are introduced. When concerned about\nperformance, you must decide how well each algorithm meets its\nperformance and maintainability goals. Use the guidelines in this\nchapter with care; they may be hazardous to your software."),(0,n.kt)("p",null,"The best way to build a system that satisfies its performance\nrequirements is through good design. You should not assume that speeding\nup your code will result in a visible increase in system execution. In\nmost applications, the overall throughput of the system is not defined\nby the execution speed of the code but by the interaction between\nconcurrent processes and the response time of the system peripherals."),(0,n.kt)("p",null,'Most of the guidelines in this chapter read "... when measured\nperformance indicates." "Indicates" means that you have determined that\nthe benefit in increased performance to your application in your\nenvironment outweighs the negative side effects on understandability,\nmaintainability, and portability of the resulting code. Many of the\nguideline examples show the alternatives that you will need to measure\nin order to determine if the guideline is indicated.'))}b.isMDXComponent=!0}}]);