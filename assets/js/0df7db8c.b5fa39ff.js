"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7180],{9616:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>f,contentTitle:()=>m,default:()=>v,frontMatter:()=>c,metadata:()=>h,toc:()=>g});var a=t(1716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,u=(e,n,t)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,p=(e,n)=>{for(var t in n||(n={}))l.call(n,t)&&u(e,t,n[t]);if(s)for(var t of s(n))d.call(n,t)&&u(e,t,n[t]);return e};const c={title:"Portability",sidebar_position:7},m=void 0,h={unversionedId:"style-guide/Portability",id:"style-guide/Portability",title:"Portability",description:"Discussions concerning portability usually concentrate on the",source:"@site/docs/style-guide/Portability.mdx",sourceDirName:"style-guide",slug:"/style-guide/Portability",permalink:"/docs/style-guide/Portability",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Portability",sidebar_position:7},sidebar:"styleGuideSidebar",previous:{title:"Concurrency",permalink:"/docs/style-guide/Concurrency"},next:{title:"Reusability",permalink:"/docs/style-guide/Reusability"}},f={},g=[{value:"Fundamentals",id:"fundamentals",level:2},{value:"Obsolescent Features",id:"obsolescent-features",level:3},{value:"guideline",id:"guideline",level:4},{value:"rationale",id:"rationale",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Global Assumptions",id:"global-assumptions",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"instantiation",id:"instantiation",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Comments",id:"comments",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Main Subprogram",id:"main-subprogram",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-1",level:4},{value:"Encapsulating Implementation Dependencies",id:"encapsulating-implementation-dependencies",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"notes",id:"notes-2",level:4},{value:"Implementation-Added Features",id:"implementation-added-features",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Specialized Needs Annexes",id:"specialized-needs-annexes",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"Dependence on Parameter Passing Mechanism",id:"dependence-on-parameter-passing-mechanism",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Arbitrary Order Dependencies",id:"arbitrary-order-dependencies",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Numeric Types and Expressions",id:"numeric-types-and-expressions",level:2},{value:"Predefined Numeric Types",id:"predefined-numeric-types",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"notes",id:"notes-3",level:4},{value:"Accuracy Model",id:"accuracy-model",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"Accuracy Analysis",id:"accuracy-analysis",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Accuracy Constraints",id:"accuracy-constraints",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"Comments",id:"comments-1",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"Subexpression Evaluation",id:"subexpression-evaluation",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"Relational Tests",id:"relational-tests",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"notes",id:"notes-4",level:4},{value:"Decimal Types and the Information Systems Annex",id:"decimal-types-and-the-information-systems-annex",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"Storage Control",id:"storage-control",level:3},{value:"Representation Clause",id:"representation-clause",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"notes",id:"notes-5",level:4},{value:"Access-to-Subprogram Values",id:"access-to-subprogram-values",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"exceptions",id:"exceptions-3",level:4},{value:"Storage Pool Mechanisms",id:"storage-pool-mechanisms",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"example",id:"example-9",level:4},{value:"Tasking",id:"tasking",level:2},{value:"Task Activation Order",id:"task-activation-order",level:3},{value:"guideline",id:"guideline-20",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"Delay Statements",id:"delay-statements",level:3},{value:"guideline",id:"guideline-21",level:4},{value:"rationale",id:"rationale-20",level:4},{value:"Package Calendar, Type Duration, and System.Tick",id:"package-calendar-type-duration-and-systemtick",level:3},{value:"guideline",id:"guideline-22",level:4},{value:"rationale",id:"rationale-21",level:4},{value:"Select Statement Evaluation Order",id:"select-statement-evaluation-order",level:3},{value:"guideline",id:"guideline-23",level:4},{value:"rationale",id:"rationale-22",level:4},{value:"Task Scheduling Algorithm",id:"task-scheduling-algorithm",level:3},{value:"guideline",id:"guideline-24",level:4},{value:"rationale",id:"rationale-23",level:4},{value:"notes",id:"notes-6",level:4},{value:"exceptions",id:"exceptions-4",level:4},{value:"Abort",id:"abort",level:3},{value:"guideline",id:"guideline-25",level:4},{value:"rationale",id:"rationale-24",level:4},{value:"Unprotected Shared Variables and Pragmas Atomic and Volatile",id:"unprotected-shared-variables-and-pragmas-atomic-and-volatile",level:3},{value:"guideline",id:"guideline-26",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-25",level:4},{value:"Exceptions",id:"exceptions-5",level:2},{value:"Predefined and User-Defined Exceptions",id:"predefined-and-user-defined-exceptions",level:3},{value:"guideline",id:"guideline-27",level:4},{value:"rationale",id:"rationale-26",level:4},{value:"Implementation-Specific Exceptions",id:"implementation-specific-exceptions",level:3},{value:"guideline",id:"guideline-28",level:4},{value:"rationale",id:"rationale-27",level:4},{value:"Representation Clauses And Implementation-Dependent Features",id:"representation-clauses-and-implementation-dependent-features",level:2},{value:"Representation Clauses",id:"representation-clauses",level:3},{value:"guideline",id:"guideline-29",level:4},{value:"rationale",id:"rationale-28",level:4},{value:"notes",id:"notes-7",level:4},{value:"Package System",id:"package-system",level:3},{value:"guideline",id:"guideline-30",level:4},{value:"rationale",id:"rationale-29",level:4},{value:"notes",id:"notes-8",level:4},{value:"exceptions",id:"exceptions-6",level:4},{value:"Machine Code Inserts",id:"machine-code-inserts",level:3},{value:"guideline",id:"guideline-31",level:4},{value:"rationale",id:"rationale-30",level:4},{value:"exceptions",id:"exceptions-7",level:4},{value:"Interfacing to Foreign Languages",id:"interfacing-to-foreign-languages",level:3},{value:"guideline",id:"guideline-32",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-31",level:4},{value:"exceptions",id:"exceptions-8",level:4},{value:"Implementation-Specific Pragmas and Attributes",id:"implementation-specific-pragmas-and-attributes",level:3},{value:"guideline",id:"guideline-33",level:4},{value:"rationale",id:"rationale-32",level:4},{value:"Unchecked Deallocation",id:"unchecked-deallocation",level:3},{value:"guideline",id:"guideline-34",level:4},{value:"rationale",id:"rationale-33",level:4},{value:"notes",id:"notes-9",level:4},{value:"exceptions",id:"exceptions-9",level:4},{value:"Unchecked Access",id:"unchecked-access",level:3},{value:"guideline",id:"guideline-35",level:4},{value:"rationale",id:"rationale-34",level:4},{value:"Unchecked Conversion",id:"unchecked-conversion",level:3},{value:"guideline",id:"guideline-36",level:4},{value:"rationale",id:"rationale-35",level:4},{value:"exceptions",id:"exceptions-10",level:4},{value:"Run-Time Dependencies",id:"run-time-dependencies",level:3},{value:"guideline",id:"guideline-37",level:4},{value:"rationale",id:"rationale-36",level:4},{value:"exceptions",id:"exceptions-11",level:4},{value:"Input/Output",id:"inputoutput",level:2},{value:"Name and Form Parameters",id:"name-and-form-parameters",level:3},{value:"guideline",id:"guideline-38",level:4},{value:"rationale",id:"rationale-37",level:4},{value:"notes",id:"notes-10",level:4},{value:"File Closing",id:"file-closing",level:3},{value:"guideline",id:"guideline-39",level:4},{value:"rationale",id:"rationale-38",level:4},{value:"Input/Output on Access Types",id:"inputoutput-on-access-types",level:3},{value:"guideline",id:"guideline-40",level:4},{value:"rationale",id:"rationale-39",level:4},{value:"Package Ada.Streams.Stream_IO",id:"package-adastreamsstream_io",level:3},{value:"guideline",id:"guideline-41",level:4},{value:"rationale",id:"rationale-40",level:4},{value:"Current Error Files",id:"current-error-files",level:3},{value:"guideline",id:"guideline-42",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-41",level:4},{value:"notes",id:"notes-11",level:4},{value:"Summary",id:"summary",level:2},{value:"fundamentals",id:"fundamentals-1",level:3},{value:"numeric types and expressions",id:"numeric-types-and-expressions-1",level:3},{value:"storage control",id:"storage-control-1",level:3},{value:"tasking",id:"tasking-1",level:3},{value:"exceptions",id:"exceptions-12",level:4},{value:"representation clauses and implementation-dependent features",id:"representation-clauses-and-implementation-dependent-features-1",level:3},{value:"input/output",id:"inputoutput-1",level:3}],y={toc:g};function v(e){var n,t=e,{components:i}=t,u=((e,n)=>{var t={};for(var a in e)l.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(null!=e&&s)for(var a of s(e))n.indexOf(a)<0&&d.call(e,a)&&(t[a]=e[a]);return t})(t,["components"]);return(0,a.kt)("wrapper",(n=p(p({},y),u),o(n,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Discussions concerning portability usually concentrate on the\ndifferences in computer systems, but the development and run-time\nenvironment may also change:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"portability (software)",(0,a.kt)("br",{parentName:"li"}),"The ease with which software can be transferred from one computer\nsystem or environment to another (IEEE Dictionary 1984).")),(0,a.kt)("p",null,"Most portability problems are not pure language issues. Portability\ninvolves hardware (byte order, device I/O) and software (utility\nlibraries, operating systems, run-time libraries). This chapter will not\naddress these challenging design issues."),(0,a.kt)("p",null,"This chapter does identify the more common portability problems that are\nspecific to Ada when moving from one platform or compiler to another. It\nalso suggests ways that nonportable code can be isolated. By using the\nimplementation hiding features of Ada, the cost of porting can be\nsignificantly reduced."),(0,a.kt)("p",null,"In fact, many language portability issues are solved by the strict\ndefinition of the Ada language itself. In most programming languages,\ndifferent dialects are prevalent as vendors extend or dilute a language\nfor various reasons: conformance to a programming environment or\nfeatures for a particular application domain. The Ada Compiler\nValidation Capability (ACVC) was developed by the U.S. Department of\nDefense at the Ada Validation Facility, ASD/SIDL, Wright-Patterson Air\nForce Base, to ensure that implementors strictly adhered to the Ada\nstandard."),(0,a.kt)("p",null,"As part of the strict definition of Ada, certain constructs are defined\nto be erroneous, and the effect of executing an erroneous construct is\nunpredictable. Therefore, erroneous constructs are obviously not\nportable. Erroneous constructs and bounded errors are discussed in\nGuideline 5.9.10 and are not repeated in this chapter."),(0,a.kt)("p",null,"Most programmers new to the language expect Ada to eliminate all\nportability problems; it definitely does not. Certain areas of Ada are\nnot yet covered by validation. The definition of Ada leaves certain\ndetails to the implementor. The compiler implementor's choices, with\nrespect to these details, affect portability."),(0,a.kt)("p",null,"The revisions to the Ada language approved in the 1995 standard generate\na new area of portability concerns. Some programs are intended to have a\nlong life and may start in Ada 83 (Ada Reference Manual 1983) but\ntransition to Ada 95 (Ada Reference Manual 1995). Although this style\nguide focuses on the current Ada standard and does not address\ntransition issues, there are portability issues relating to using\ncertain features of the language. These issues revolve around the\nlanguage features designated as obsolescent in Annex J of the Ada\nReference Manual (1995)."),(0,a.kt)("p",null,"The constructs of the language have been developed to satisfy a series\nof needs. These constructs can legitimately be used even though they may\nimpact portability. There are some general principles to enhancing\nportability that are exemplified by many of the guidelines in this\nchapter. They are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Recognize those Ada constructs that may adversely affect portability\non the relevant implementations or platforms."),(0,a.kt)("li",{parentName:"ul"},"Rely on those Ada constructs that depend on characteristics shared\nby all relevant implementations. Avoid the use of those constructs\nwhose implementation characteristics vary on the relevant platforms."),(0,a.kt)("li",{parentName:"ul"},"Localize and encapsulate nonportable features of a program if their\nuse is essential."),(0,a.kt)("li",{parentName:"ul"},"Highlight the use of constructs that may cause portability problems.")),(0,a.kt)("p",null,"These guidelines cannot be applied thoughtlessly. Many of them involve a\ndetailed understanding of the Ada model and its implementation. In many\ncases, you will have to make carefully considered tradeoffs between\nefficiency and portability. Reading this chapter should improve your\ninsight into the tradeoffs involved. The material in this chapter was\nlargely acquired from three sources: the Ada Run-Time Environments\nWorking Group (ARTEWG) Catalogue of Ada Runtime Implementation\nDependencies (ARTEWG 1986); the Nissen and Wallis book on Portability\nand Style in Ada (Nissen and Wallis 1984); and a paper written for the\nU.S. Air Force by SofTech on Ada Portability Guidelines (Pappas 1985).\nThe last of these sources (Pappas 1985) encompasses the other two and\nprovides an in-depth explanation of the issues, numerous examples, and\ntechniques for minimizing portability problems. Conti (1987) is a\nvaluable reference for understanding the latitude allowed for\nimplementors of Ada and the criteria often used to make decisions."),(0,a.kt)("p",null,"This chapter's purpose is to provide a summary of portability issues in\nthe guideline format of this book. The chapter does not include all\nissues identified in the references but only the most significant. For\nan in-depth presentation, see Pappas (1985). A few additional guidelines\nare presented here and others are elaborated upon where applicable. For\nfurther reading on Ada I/O portability issues, see Matthews (1987),\nGriest (1989), and CECOM (1989)."),(0,a.kt)("p",null,"Some of the guidelines in this chapter cross reference and place\nstricter constraints on other guidelines in this book. These constraints\napply when portability is being emphasized."),(0,a.kt)("p",null,'Guidelines in this chapter are frequently worded "consider . . ."\nbecause hard and fast rules cannot apply in all situations. The specific\nchoice you make in a given situation involves design tradeoffs. The\nrationale for these guidelines is intended to give you insight into some\nof these tradeoffs.'),(0,a.kt)("h2",p({},{id:"fundamentals"}),"Fundamentals"),(0,a.kt)("p",null,"This section introduces some generally applicable principles of writing\nportable Ada programs. It includes guidelines about the assumptions you\nshould make with respect to a number of Ada features and their\nimplementations and guidelines about the use of other Ada features to\nensure maximum portability."),(0,a.kt)("h3",p({},{id:"obsolescent-features"}),"Obsolescent Features"),(0,a.kt)("h4",p({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'In programs or components intended to have a long life, avoid using\nthe features of Ada declared as "obsolescent" by Annex J of the Ada\nReference Manual (1995), unless the use of the feature is needed for\nbackward compatibility with Ada 83 (Ada Reference Manual 1983).'),(0,a.kt)("li",{parentName:"ul"},"Document the use of any obsolescent features."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the following features:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The short renamings of the packages in the predefined\nenvironment (e.g., Text_IO as opposed to Ada.Text_IO)"),(0,a.kt)("li",{parentName:"ul"},"The character replacements of ","!"," for |, : for ","#",", and % for\nquotation marks"),(0,a.kt)("li",{parentName:"ul"},"Reduced accuracy subtypes of floating-point types"),(0,a.kt)("li",{parentName:"ul"},"The 'Constrained attribute as applied to private types"),(0,a.kt)("li",{parentName:"ul"},"The predefined package ASCII"),(0,a.kt)("li",{parentName:"ul"},"The exception Numeric_Error"),(0,a.kt)("li",{parentName:"ul"},"Various representation specifications, including at clauses, mod\nclauses, interrupt entries, and the Storage_Size attribute")))),(0,a.kt)("h4",p({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"Ten years of reflection on the use of Ada 83 led to the conclusion that\nsome features of the original language are not as useful as originally\nintended. These features have been replaced with others in the Ada 95\nrevision. It would have been desirable to remove the obsolescent\nfeatures completely, but that would have prevented the upward compatible\ntransition of programs from Ada 83 to Ada 95. Thus, the obsolescent\nfeatures remain in the language and are explicitly labeled as such in\nAnnex J of the Ada Reference Manual (1995). The features listed in Annex\nJ are candidates for removal from the language during its next revision.\nIf a program's lifetime may extend beyond the next language revision, it\nshould avoid the obsolescent language features unless backward\ncompatibility with Ada 83 forces their use."),(0,a.kt)("h4",p({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"When you instantiate Ada.Text_IO.Float_IO, the values of the\nDefault_Fore and Default_Aft fields are set from the values of the\n'Fore and 'Aft attributes of the actual floating-point type used in the\ninstantiation. If you declare a reduced accuracy floating-point type\nthat you then use to instantiate Ada.Text_IO.Float_IO, the output\nfield widths are determined from the reduced accuracy type, although the\nimplementation accuracy is unchanged (Rationale 1995, \xa73.3)."),(0,a.kt)("h3",p({},{id:"global-assumptions"}),"Global Assumptions"),(0,a.kt)("h4",p({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make informed assumptions about the support provided for the\nfollowing on potential target platforms:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Number of bits available for type Integer (range constraints)"),(0,a.kt)("li",{parentName:"ul"},"Number of decimal digits of precision available for\nfloating-point types"),(0,a.kt)("li",{parentName:"ul"},"Number of bits available for fixed-point types (delta and range\nconstraints)"),(0,a.kt)("li",{parentName:"ul"},"Number of characters per line of source text"),(0,a.kt)("li",{parentName:"ul"},"Number of bits for Root_Integer expressions"),(0,a.kt)("li",{parentName:"ul"},"Number of seconds for the range of Duration"),(0,a.kt)("li",{parentName:"ul"},"Number of milliseconds for Duration'Small"),(0,a.kt)("li",{parentName:"ul"},"Minimum and maximum scale for decimal types"))),(0,a.kt)("li",{parentName:"ul"},"Avoid assumptions about the values and the number of values included\nin the type Character.")),(0,a.kt)("h4",p({},{id:"instantiation"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"These are minimum values (or minimum precision in the case of\nDuration'Small) that a project or application might assume that an\nimplementation provides. There is no guarantee that a given\nimplementation provides more than the minimum, so these would be\ntreated by the project or application as maximum values also.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"16 bits available for type Integer (-2","*","*","15 .. 2","*","*","15 - 1)"),(0,a.kt)("li",{parentName:"ul"},"6 decimal digits of precision available for floating-point types"),(0,a.kt)("li",{parentName:"ul"},"24 bits available for fixed-point types"),(0,a.kt)("li",{parentName:"ul"},"200 characters per line of source text"),(0,a.kt)("li",{parentName:"ul"},"16 bits for expressions"),(0,a.kt)("li",{parentName:"ul"},"-","86_400 .. 86_400 seconds (1 day) for the range of Duration\n(as specified in Ada Reference Manual ","[","1995, \xa79.6","]",")"),(0,a.kt)("li",{parentName:"ul"},"20 milliseconds for Duration'Small (as specified in Ada\nReference Manual ","[","1995, \xa79.6","]",")")))),(0,a.kt)("h4",p({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Some assumptions must be made with respect to certain\nimplementation-specific values. The exact values assumed should cover\nthe majority of the target equipment of interest. Choosing the lowest\ncommon denominator for values improves portability. Implementations may\nsupply an alternate character set specific to a locale or environment.\nFor instance, the implementation on an IBM-compatible PC may support\nthat machine's native character set rather than Latin 1. As a result,\nsome character values may or may not be supported, for example, the\nsmiley face."),(0,a.kt)("h4",p({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"Of the microcomputers currently available for incorporation within\nembedded systems, 16-bit and 32-bit processors are prevalent. Using\ncurrent representation schemes, 6 decimal digits of floating point\naccuracy imply a representation mantissa at least 21 bits wide, leaving\n11 bits for exponent and sign within a 32-bit representation. This\ncorrelates with the data widths of floating point hardware currently\navailable for the embedded systems market. A 32-bit minimum on\nfixed-point numbers correlates with the accuracy and storage\nrequirements of floating point numbers. The 16-bit example for\nRoot_Integer expressions matches that for Integer storage. (The 32-bit\nintegers can be assumed if the application will only be considered for\n32-bit processors with a corresponding 32-bit operating system and\nsupporting compiler.)"),(0,a.kt)("p",null,"The values for the range and accuracy of values of the predefined type\nDuration are the limits expressed in the Ada Reference Manual (1995,\n\xa79.6). You should not expect an implementation to provide a wider range\nor a finer granularity."),(0,a.kt)("p",null,"A standard-mode Ada character set of Latin 1 can be assumed in most\ncases for the contents and internal behavior of type Character and\npackages Character.Latin_1, Character.Handling, and Strings.Maps.\nHowever, this does not mean that the target hardware platform is capable\nof displaying the entire character set. You should not use a nonstandard\nAda character set unless intentionally producing a nonportable user\ninterface with a specific purpose."),(0,a.kt)("h3",p({},{id:"comments"}),"Comments"),(0,a.kt)("h4",p({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use highlighting comments for each package, subprogram, and task\nwhere any nonportable features are present."),(0,a.kt)("li",{parentName:"ul"},"For each nonportable feature employed, describe the expectations for\nthat feature.")),(0,a.kt)("h4",p({},{id:"example"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Memory_Mapped_IO is\n   -- WARNING - This package is implementation specific.\n   -- It uses absolute memory addresses to interface with the I/O\n   -- system. It assumes a particular printer's line length.\n   -- Change memory mapping and printer details when porting.\n   Printer_Line_Length : constant := 132;\n   type Data is array (1 .. Printer_Line_Length) of Character;\n   procedure Write_Line (Line : in     Data);\nend Memory_Mapped_IO;\n------------------------------------------------------------------------\nwith System;\nwith System.Storage_Elements;\npackage body Memory_Mapped_IO is\n   -- WARNING: Implementation specific memory address\n\n   Buffer_Address : constant System.Address\n      := System.Storage_Elements.To_Address(16#200#);\n\n   ---------------------------------------------------------------------\n   procedure Write_Line (Line : in     Data) is\n      Buffer : Data;\n      for Buffer'Address use Buffer_Address;\n\n   begin  -- Write_Line\n       -- perform output operation through specific memory locations.\n       ...\n   end Write_Line;\n   ---------------------------------------------------------------------\nend Memory_Mapped_IO;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",p({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Explicitly commenting each breach of portability will raise its\nvisibility and aid in the porting process. A description of the\nnonportable feature's expectations covers the common case where vendor\ndocumentation of the original implementation is not available to the\nperson performing the porting process."),(0,a.kt)("h3",p({},{id:"main-subprogram"}),"Main Subprogram"),(0,a.kt)("h4",p({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using only a parameterless procedure as the main\nsubprogram."),(0,a.kt)("li",{parentName:"ul"},"Consider using Ada.Command_Line for accessing values from the\nenvironment, but recognize that this package's behavior and even its\nspecification are nonportable (see Guideline 7.1.6)."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate and document all uses of package Ada.Command_Line.")),(0,a.kt)("h4",p({},{id:"example-1"}),"example"),(0,a.kt)("p",null,'The following example encapsulates the arguments for a hypothetical\n"execution mode" argument passed from the environment. It encapsulates\nboth the expected position and the expected values of the argument, as\nwell as provides a default in cases where the environment was unable to\nprovide the information:'),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),'package Environment is\n\n   type Execution_Mode is (Unspecified, Interactive, Batch);\n\n   function Execution_Argument return Execution_Mode;\n\n   ...\n\nend Environment;\n\n----------------------------------------------------------------------\n\nwith Ada.Command_Line;       use Ada.Command_Line;\nwith Ada.Strings.Unbounded;  use Ada.Strings.Unbounded;\n\npackage body Environment is\n\n   function Execution_Argument return Execution_Mode is\n\n      Execution_Argument_Number : constant := 1;\n\n      Interactive_Mode_String : constant String := "-i";\n      Batch_Mode_String       : constant String := "-b";\n\n   begin\n      if Argument_Count < Execution_Argument_Number then\n         return Unspecified;\n      elsif To_Unbounded_String (Argument (Execution_Argument_Number)) =\n               Interactive_Mode_String then\n         return Interactive;\n      elsif To_Unbounded_String (Argument (Execution_Argument_Number)) =\n               Batch_Mode_String then\n         return Batch;\n      else\n         return Unspecified;\n      end if;\n   end Execution_Argument;\n\nend Environment;\n')),(0,a.kt)("h4",p({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"The predefined language environment declares the package\nAda.Command_Line, providing a standardized way for a program to obtain\nthe values of a command line. Because all Ada compilers must implement\nthe packages in the predefined language environment, you can create a\nprogram that is more portable, maintainable, and readable by using this\npackage. You should, however, be aware that even though the language\ndefines the objects and type profiles of this package, it does not force\na relationship between the function results and any other entity or\noperation, and thus, allows the possibility of a nonportable behavior\nand specification."),(0,a.kt)("p",null,"The value returned by the function Ada.Command_Line.Argument_Count is\nimplementation-dependent. Different operating systems follow different\nconventions regarding the parsing and meaning of command line\nparameters. To enhance your program's portability, assume the simplest\ncase: that the external execution environment does not support passing\narguments to a program."),(0,a.kt)("p",null,"Some operating systems are capable of acquiring and interpreting\nreturned integer values near 0 from a function, but many others cannot.\nFurther, many real-time, embedded systems will not be designed to\nterminate, so a function or a procedure having parameters with modes out\nor in out will be inappropriate to such applications."),(0,a.kt)("p",null,"This leaves procedures with in parameters. Although some operating\nsystems can pass parameters into a program as it starts, others are not.\nAlso, an implementation may not be able to perform type checking on such\nparameters even if the surrounding environment is capable of providing\nthem."),(0,a.kt)("h4",p({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,'Real-time, embedded applications may not have an "operator" initiating\nthe program to supply the parameters, in which case it would be more\nappropriate for the program to have been compiled with a package\ncontaining the appropriate constant values or for the program to read\nthe necessary values from switch settings or a downloaded auxiliary\nfile. In any case, the variation in surrounding initiating environments\nis far too great to depend upon the kind of last-minute (program)\nparameterization implied by (subprogram) parameters to the main\nsubprogram. POSIX 5 provides a standard operating system command line\ninterface that might be a more appropriate alternative to the Ada\ncommand line facility depending on the implementation family of an\napplication.'),(0,a.kt)("h3",p({},{id:"encapsulating-implementation-dependencies"}),"Encapsulating Implementation Dependencies"),(0,a.kt)("h4",p({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Create packages specifically designed to isolate hardware and\nimplementation dependencies and designed so that their specification\nwill not change when porting."),(0,a.kt)("li",{parentName:"ul"},"Clearly indicate the objectives if machine or solution efficiency is\nthe reason for hardware or implementation-dependent code."),(0,a.kt)("li",{parentName:"ul"},"For the packages that hide implementation dependencies, maintain\ndifferent package bodies for different target environments."),(0,a.kt)("li",{parentName:"ul"},"Isolate interrupt receiving tasks into implementation-dependent\npackages."),(0,a.kt)("li",{parentName:"ul"},"Refer to Annex M of the Ada Reference Manual (1995) for a list of\nimplementation-dependent features.")),(0,a.kt)("h4",p({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"See Guideline 7.1.3."),(0,a.kt)("h4",p({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"Encapsulating hardware and implementation dependencies in a package\nallows the remainder of the code to ignore them and, thus, to be fully\nportable. It also localizes the dependencies, making it clear exactly\nwhich parts of the code may need to change when porting the program."),(0,a.kt)("p",null,"Some implementation-dependent features may be used to achieve particular\nperformance or efficiency objectives. Commenting these objectives\nensures that the programmer can find an appropriate way to achieve them\nwhen porting to a different implementation or explicitly recognize that\nthey cannot be achieved."),(0,a.kt)("p",null,'Interrupt entries are implementation-dependent features that may not be\nsupported (e.g., VAX Ada uses pragmas to assign system traps to "normal"\nrendezvous). However, interrupt entries cannot be avoided in most\nembedded, real-time systems, and it is reasonable to assume that they\nare supported by an Ada implementation. The value for an interrupt is\nimplementation-defined. Isolate it.'),(0,a.kt)("h4",p({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"You can use Ada to write machine-dependent programs that take advantage\nof an implementation in a manner consistent with the Ada model but that\nmake particular choices where Ada allows implementation freedom. These\nmachine dependencies should be treated in the same way as any other\nimplementation-dependent features of the code."),(0,a.kt)("h3",p({},{id:"implementation-added-features"}),"Implementation-Added Features"),(0,a.kt)("h4",p({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid the use of vendor-supplied packages."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of features added to the predefined packages that are\nnot specified in the Ada language definition or Specialized Needs\nAnnexes.")),(0,a.kt)("h4",p({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"Vendor-added features are not likely to be provided by other\nimplementations. Even if a majority of vendors eventually provide\nsimilar additional features, they are unlikely to have identical\nformulations. Indeed, different vendors may use the same formulation for\n(semantically) entirely different features. See Guideline 7.5.2 for\nfurther information on vendor-supplied exceptions."),(0,a.kt)("p",null,"Ada has introduced a number of new pragmas and attributes that were not\npresent in Ada 83 (Ada Reference Manual 1983). These new pragmas and\nattributes may clash with implementation-defined pragmas and attributes."),(0,a.kt)("h4",p({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"There are many kinds of applications that require the use of these\nfeatures. Examples include multilingual systems that standardize on a\nvendor's file system, applications that are closely integrated with\nvendor products (i.e., user interfaces), and embedded systems for\nperformance reasons. Isolate the use of these features into packages."),(0,a.kt)("p",null,"If a vendor-supplied package is provided in compilable source code form,\nuse of the package does not make a program nonportable provided that the\npackage does not contain any nonportable code and can be lawfully\nincluded in your program."),(0,a.kt)("h3",p({},{id:"specialized-needs-annexes"}),"Specialized Needs Annexes"),(0,a.kt)("h4",p({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use features defined in the Specialized Needs Annexes rather than\nvendor-defined features."),(0,a.kt)("li",{parentName:"ul"},"Document clearly the use of any features from the Specialized Needs\nAnnexes (systems programming, real-time systems, distributed\nsystems, information systems, numerics, and safety and security).")),(0,a.kt)("h4",p({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"The Specialized Needs Annexes define standards for specific application\nareas without extending the syntax of the language. You can port a\nprogram with specific domain needs (e.g., distributed systems,\ninformation systems) across vendor implementations more easily if they\nsupport the features standardized in an annex rather than rely on\nspecific vendor extensions. The purpose of the annexes is to provide a\nconsistent and uniform way to address issues faced in several\napplication areas where Ada is expected to be used. Because different\ncompilers will support different sets of annexes if any, you may have\nportability problems if you rely on the features defined in any given\nannex."),(0,a.kt)("p",null,"The Specialized Needs Annexes provide special capabilities that go\nbeyond the core language definition. Because compilers are not required\nto support the special-purpose annexes, you should localize your use of\nthese features where possible. By documenting their usage, you are\nleaving a record of potential porting difficulties for future\nprogrammers."),(0,a.kt)("h3",p({},{id:"dependence-on-parameter-passing-mechanism"}),"Dependence on Parameter Passing Mechanism"),(0,a.kt)("h4",p({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not write code whose correct execution depends on the particular\nparameter passing mechanism used by an implementation (Ada Reference\nManual 1995, \xa76.2; Cohen 1986)."),(0,a.kt)("li",{parentName:"ul"},"If a subprogram has more than one formal parameter of a given\nsubtype, at least one of which is ","[","in","]"," out, make sure that the\nsubprogram can properly handle the case when both formal parameters\ndenote the same actual object.")),(0,a.kt)("h4",p({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"The output of this program depends on the particular parameter passing\nmechanism that was used:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Ada.Integer_Text_IO;\nprocedure Outer is\n   type Coordinates is\n      record\n         X : Integer := 0;\n         Y : Integer := 0;\n      end record;\n   Outer_Point : Coordinates;\n   ---------------------------------------------------------------------\n   procedure Inner (Inner_Point : in out Coordinates) is\n   begin\n      Inner_Point.X := 5;\n      -- The following line causes the output of the program to\n      -- depend on the parameter passing mechanism.\n      Ada.Integer_Text_IO.Put(Outer_Point.X);\n   end Inner;\n   ---------------------------------------------------------------------\nbegin  -- Outer\n   Ada.Integer_Text_IO.Put(Outer_Point.X);\n   Inner(Outer_Point);\n   Ada.Integer_Text_IO.Put(Outer_Point.X);\nend Outer;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"If the parameter passing mechanism is by copy, the results on the\nstandard output file are:"),(0,a.kt)("p",null,"0 0 5"),(0,a.kt)("p",null,"If the parameter passing mechanism is by reference, the results are:"),(0,a.kt)("p",null,"0 5 5"),(0,a.kt)("p",null,"The following code fragment shows where there is a potential for bounded\nerror when a procedure is called with actual parameters denoting the\nsame object:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"procedure Test_Bounded_Error (Parm_1 : in out    Integer;\n                              Parm_2 : in out Integer) is\n   procedure Inner (Parm : in out Integer) is\n   begin\n      Parm := Parm * 10;\n   end Inner;\nbegin\n   Parm_2 := 5;\n   Inner (Parm_1);\nend Test_Bounded_Error;\n")),(0,a.kt)("p",null,"In executing the procedure Test_Bounded_Error, both Parm_1 and\nParm_2 denote the object Actual_Parm. After executing the first\nstatement, the object Actual_Parm has the value 5. When the procedure\nInner is called, its formal parameter Parm denotes Actual_Parm. It\ncannot be determined whether it denotes the old value of Parm_1, in\nthis case 1, or the new value, in this case 5."),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"Actual_Parm : Integer := 1;\n...\nTest_Bounded_Error (Actual_Parm, Actual_Parm);  -- potential bounded error\n")),(0,a.kt)("h4",p({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"Certain composite types (untagged records and arrays) can be passed\neither by copy or by reference. If there are two or more formal\nparameters of the same type, one or more of which is writable, then you\nshould document whether you assume that these formal parameters do not\ndenote the same actual object. Similarly, if a subprogram that has a\nformal parameter of a given subtype also makes an up-level reference to\nan object of this same type, you should document whether you assume that\nthe formal parameter denotes a different object from the object named in\nthe up-level reference. In these situations where an object can be\naccessed through distinct formal parameter paths, the exception\nProgram_Error may be raised, the new value may be read, or the old\nvalue of the object may be used (Ada Reference Manual 1995, \xa76.2)."),(0,a.kt)("p",null,"See also Guideline 8.2.7."),(0,a.kt)("h4",p({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("p",null,"Frequently, when interfacing Ada to foreign code, dependence on\nparameter-passing mechanisms used by a particular implementation is\nunavoidable. In this case, isolate the calls to the foreign code in an\ninterface package that exports operations that do not depend on the\nparameter-passing mechanism."),(0,a.kt)("h3",p({},{id:"arbitrary-order-dependencies"}),"Arbitrary Order Dependencies"),(0,a.kt)("h4",p({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid depending on the order in which certain constructs in Ada are\nevaluated.")),(0,a.kt)("h4",p({},{id:"example-4"}),"example"),(0,a.kt)("p",null,"The output of this program depends upon the order of evaluation of\nsubprogram parameters, but the Ada Reference Manual (1995, \xa76.4)\nspecifies that these evaluations are done in an arbitrary order:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"package Utilities is\n   function Unique_ID return Integer;\nend Utilities;\n\npackage body Utilities is\n\n   ID : Integer := 0;\n\n   function Unique_ID return Integer is\n   begin\n      ID := ID + 1;\n      return ID;\n   end Unique_ID;\n\nend Utilities;\n\n--------------------------------------------------------------------------------\nwith Ada.Text_IO;\nwith Utilities; use Utilities;\nprocedure P is\nbegin\n   Ada.Text_IO.Put_Line (Integer'Image(Unique_ID) & Integer'Image(Unique_ID));\nend P;\n")),(0,a.kt)("p",null,'If the parameters to the "&" function are evaluated in textual order,\nthe output is:'),(0,a.kt)("p",null,"1 2"),(0,a.kt)("p",null,"If the parameters are evaluated in the reverse order, the output is:"),(0,a.kt)("p",null,"2 1"),(0,a.kt)("h4",p({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"The Ada language defines certain evaluations to occur in arbitrary order\n(e.g., subprogram parameters). While a dependency on the order of\nevaluation may not adversely affect the program on a certain\nimplementation, the code might not execute correctly when it is ported.\nFor example, if two actual parameters of a subprogram call have side\neffects, the effect of the program could depend on the order of\nevaluation (Ada Reference Manual 1995, \xa71.1.4). Avoid arbitrary order\ndependencies, but also recognize that even an unintentional error of\nthis kind could prohibit portability."),(0,a.kt)("h2",p({},{id:"numeric-types-and-expressions"}),"Numeric Types and Expressions"),(0,a.kt)("p",null,"A great deal of care was taken with the design of the Ada features\nrelated to numeric computations to ensure that the language could be\nused in embedded systems and mathematical applications where precision\nwas important. As far as possible, these features were made portable.\nHowever, there is an inevitable tradeoff between maximally exploiting\nthe available precision of numeric computation on a particular machine\nand maximizing the portability of Ada numeric constructs. This means\nthat these Ada features, particularly numeric types and expressions,\nmust be used with great care if full portability of the resulting\nprogram is to be guaranteed."),(0,a.kt)("h3",p({},{id:"predefined-numeric-types"}),"Predefined Numeric Types"),(0,a.kt)("h4",p({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using the predefined numeric types in package Standard. Use\nrange and digits declarations and let the implementation pick the\nappropriate representation."),(0,a.kt)("li",{parentName:"ul"},"For programs that require greater accuracy than that provided by the\nglobal assumptions, define a package that declares a private type\nand operations as needed; see Pappas (1985) for a full explanation\nand examples."),(0,a.kt)("li",{parentName:"ul"},"Consider using predefined numeric types (Integer, Natural, Positive)\nfor:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Indexes into arrays where the index type is not significant,\nsuch as type String"),(0,a.kt)("li",{parentName:"ul"},'"Pure" numbers, that is, numbers with no associated physical\nunit (e.g., exponents)'),(0,a.kt)("li",{parentName:"ul"},"Values whose purpose is to control a repeat or iteration count")))),(0,a.kt)("h4",p({},{id:"example-5"}),"example"),(0,a.kt)("p",null,"The second and third examples below are not representable as subranges\nof Integer on a machine with a 16-bit word. The first example below\nallows a compiler to choose a multiword representation, if necessary."),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"type    Second_Of_Day is             range 0 .. 86_400;\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"type    Second_Of_Day is new Integer range 1 .. 86_400;\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"subtype Second_Of_Day is     Integer range 1 .. 86_400;\n")),(0,a.kt)("h4",p({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"An implementor is free to define the range of the predefined numeric\ntypes. Porting code from an implementation with greater accuracy to one\nof lesser accuracy is a time consuming and error-prone process. Many of\nthe errors are not reported until run-time."),(0,a.kt)("p",null,"This applies to more than just numerical computation. An\neasy-to-overlook instance of this problem occurs if you neglect to use\nexplicitly declared types for integer discrete ranges (array sizes, loop\nranges, etc.) (see Guidelines 5.5.1 and 5.5.2). If you do not provide an\nexplicit type when specifying index constraints and other discrete\nranges, a predefined integer type is assumed."),(0,a.kt)("p",null,"The predefined numeric types are useful when you use them wisely. You\nshould not use them to avoid declaring numeric types\u2014then you lose the\nbenefits of strong typing. When your application deals with different\nkinds of quantities and units, you should definitely separate them\nthrough the use of distinct numeric types. However, if you are simply\ncounting the number of iterations in an iterative approximation\nalgorithm, declaring a special integer type is probably overkill. The\npredefined exponentiation operators ","*","*"," require an integer as the type\nof its right operand."),(0,a.kt)("p",null,"You should use the predefined types Natural and Positive for\nmanipulating certain kinds of values in the predefined language\nenvironment. The types String and Wide_String use an index of type\nPositive. If your code indexes into a string using an incompatible\ninteger type, you will be forced to do type conversion, reducing its\nreadability. If you are performing operations like slices and\nconcatenation, the subtype of your numeric array index is probably\ninsignificant and you are better off using a predefined subtype. On the\nother hand, if your array represents a table (e.g., a hash table), then\nyour index subtype is significant, and you should declare a distinct\nindex type."),(0,a.kt)("h4",p({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"There is an alternative that this guideline permits. As Guideline 7.1.5\nsuggests, implementation dependencies can be encapsulated in packages\nintended for that purpose. This could include the definition of a 32-bit\ninteger type. It would then be possible to derive additional types from\nthat 32-bit type."),(0,a.kt)("h3",p({},{id:"accuracy-model"}),"Accuracy Model"),(0,a.kt)("h4",p({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use an implementation that supports the Numerics Annex (Ada\nReference Manual 1995, Annex G) when performance and accuracy are\noverriding concerns.")),(0,a.kt)("h4",p({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,'The Numerics Annex defines the accuracy and performance requirements for\nfloating- and fixed-point arithmetic. The Annex provides a "strict" mode\nin which the compiler must support these requirements. To guarantee that\nyour program\'s numerical performance is portable, you should compile and\nlink in the strict mode. If your program relies upon the numeric\nproperties of the strict mode, then it will only be portable to other\nenvironments that support the strict numerics mode.'),(0,a.kt)("p",null,"The accuracy of floating-point numbers is based on what machine numbers\ncan be represented exactly in storage. A computational result in a\nregister can fall between two machine numbers when the register contains\nmore bits than storage. You can step through the machine numbers using\nthe attributes 'Pred and 'Succ. Other attributes return values of the\nmantissa, exponent, radix, and other characteristics of floating- and\nfixed-point numbers."),(0,a.kt)("h3",p({},{id:"accuracy-analysis"}),"Accuracy Analysis"),(0,a.kt)("h4",p({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Carefully analyze what accuracy and precision you really need.")),(0,a.kt)("h4",p({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,'Floating-point calculations are done with the equivalent of the\nimplementation\'s predefined floating-point types. The effect of extra\n"guard" digits in internal computations can sometimes lower the number\nof digits that must be specified in an Ada declaration. This may not be\nconsistent over implementations where the program is intended to be run.\nIt may also lead to the false conclusion that the declared types are\nsufficient for the accuracy required.'),(0,a.kt)("p",null,"You should choose the numeric type declarations to satisfy the lowest\nprecision (smallest number of digits) that will provide the required\naccuracy. Careful analysis will be necessary to show that the\ndeclarations are adequate. When you move to a machine with less\nprecision, you probably can use the same type declaration."),(0,a.kt)("h3",p({},{id:"accuracy-constraints"}),"Accuracy Constraints"),(0,a.kt)("h4",p({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not press the accuracy limits of the machine(s).")),(0,a.kt)("h4",p({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"Just because two different machines use the same number of digits in the\nmantissa of a floating-point number does not imply they will have the\nsame arithmetic properties. Some Ada implementations may give slightly\nbetter accuracy than required by Ada because they make efficient use of\nthe machine. Do not write programs that depend on this."),(0,a.kt)("h3",p({},{id:"comments-1"}),"Comments"),(0,a.kt)("h4",p({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Comment the analysis and derivation of the numerical aspects of a\nprogram.")),(0,a.kt)("h4",p({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"Decisions and background about why certain precisions are required in a\nprogram are important to program revision or porting. The underlying\nnumerical analysis leading to the program should be commented."),(0,a.kt)("h3",p({},{id:"subexpression-evaluation"}),"Subexpression Evaluation"),(0,a.kt)("h4",p({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Anticipate the range of values of subexpressions to avoid exceeding\nthe underlying range of their base type. Use derived types,\nsubtypes, factoring, and range constraints on numeric types (see\nGuidelines 3.4.1, 5.3.1, and 5.5.3).")),(0,a.kt)("h4",p({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"This example is adapted from the Rationale (1995, \xa73.3):"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),'with Ada.Text_IO;\nwith Ada.Integer_Text_IO;\nprocedure Demo_Overflow is\n-- assume the predefined type Integer has a 16-bit range\n   X : Integer := 24_000;\n   Y : Integer;\nbegin  -- Demo_Overflow\n   y := (3 * X) / 4;  -- raises Constraint_Error if the machine registers used are 16-bit\n  -- mathematically correct intermediate result if 32-bit registers\n   Ada.Text_IO.Put ("(");\n   Ada.Integer_Text_IO.Put (X);\n   Ada.Text_IO.Put (" * 3 ) / 4 = ");\n   Ada.Integer_Text_IO.Put (Y);\nexception\n   when Constraint_Error =>\n      Ada.Text_IO.Put_Line ("3 * X too big for register!");\nend Demo_Overflow;\n')),(0,a.kt)("h4",p({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"The Ada language does not require that an implementation perform range\nchecks on subexpressions within an expression. Ada does require that\noverflow checks be performed. Thus, depending on the order of evaluation\nand the size of the registers, a subexpression will either overflow or\nproduce the mathematically correct result. In the event of an overflow,\nyou will get the exception Constraint_Error. Even if the implementation\non your program's current target does not result in an overflow on a\nsubexpression evaluation, your program might be ported to an\nimplementation that does."),(0,a.kt)("h3",p({},{id:"relational-tests"}),"Relational Tests"),(0,a.kt)("h4",p({},{id:"guideline-15"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using \\<= and ",">","= to do relational tests on real valued\narguments, avoiding the \\<, ",">",", =, and /= operations."),(0,a.kt)("li",{parentName:"ul"},"Use values of type attributes in comparisons and checking for small\nvalues.")),(0,a.kt)("h4",p({},{id:"example-7"}),"example"),(0,a.kt)("p",null,'The following examples test for (1) absolute "equality" in storage, (2)\nabsolute "equality" in computation, (3) relative "equality" in storage,\nand (4) relative "equality" in computation:'),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"abs (X - Y) <= Float_Type'Model_Small                -- (1)\nabs (X - Y) <= Float_Type'Base'Model_Small           -- (2)\nabs (X - Y) <= abs X * Float_Type'Model_Epsilon      -- (3)\nabs (X - Y) <= abs X * Float_Type'Base'Model_Epsilon -- (4)\n")),(0,a.kt)("p",null,'And, specifically, for "equality" to 0:'),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"abs X <= Float_Type'Model_Small                      -- (1)\nabs X <= Float_Type'Base'Model_Small                 -- (2)\nabs X <= abs X * Float_Type'Model_Epsilon            -- (3)\nabs X <= abs X * Float_Type'Base'Model_Epsilon       -- (4)\n")),(0,a.kt)("h4",p({},{id:"rationale-15"}),"rationale"),(0,a.kt)("p",null,"Strict relational comparisons ( \\<, ",">",", =, /= ) are a general problem\nwith computations involving real numbers. Because of the way comparisons\nare defined in terms of model intervals, it is possible for the values\nof the comparisons to depend on the implementation. Within a model\ninterval, the result of comparing two values is nondeterministic if the\nvalues are not model numbers. In general, you should test for proximity\nrather than equality as shown in the examples. See also Rationale (1995,\n\xa7\xa7G.4.1 and G.4.2.)."),(0,a.kt)("p",null,"Type attributes are the primary means of symbolically accessing the\nimplementation of the Ada numeric model. When the characteristics of the\nmodel numbers are accessed by type attributes, the source code is\nportable. The appropriate model numbers of any implementation will then\nbe used by the generated code."),(0,a.kt)("p",null,"Although 0 is technically not a special case, it is often overlooked\nbecause it looks like the simplest and, therefore, safest case. But in\nreality, each time comparisons involve small values, you should evaluate\nthe situation to determine which technique is appropriate."),(0,a.kt)("h4",p({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"Regardless of language, real-valued computations have inaccuracy. That\nthe corresponding mathematical operations have algebraic properties\nusually introduces some confusion. This guideline explains how Ada deals\nwith the problem that most languages face."),(0,a.kt)("h3",p({},{id:"decimal-types-and-the-information-systems-annex"}),"Decimal Types and the Information Systems Annex"),(0,a.kt)("h4",p({},{id:"guideline-16"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In information systems, declare different numeric decimal types to\ncorrespond to different scales (Brosgol, Eachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Create objects of different decimal types to reflect different units\nof measure (Brosgol, Eachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Declare subtypes of the appropriately scaled decimal type to provide\nappropriate range constraints for application-specific types."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate each measure category in a package (Brosgol, Eachus, and\nEmery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Declare as few decimal types as possible for unitless data (Brosgol,\nEachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"For decimal calculations, determine whether the result should be\ntruncated toward 0 or rounded."),(0,a.kt)("li",{parentName:"ul"},"Avoid decimal types and arithmetic on compilers that do not support\nthe Information Systems Annex (Ada Reference Manual 1995, Annex F)\nin full.")),(0,a.kt)("h4",p({},{id:"example-8"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"-- The salary cap today is $500,000; however this can be expanded to $99,999,999.99.\ntype Executive_Salary is delta 0.01 digits 10 range 0 .. 500_000.00;\n\n------------------------------------------------------------------------------\npackage Currency is\n\n   type Dollars is delta 0.01 digits 12;\n\n   type Marks   is delta 0.01 digits 12;\n\n   type Yen     is delta 0.01 digits 12;\n\n   function To_Dollars (M : Marks) return Dollars;\n   function To_Dollars (Y : Yen)   return Dollars;\n\n   function To_Marks (D : Dollars) return Marks;\n   function To_Marks (Y : Yen)     return Marks;\n\n   function To_Yen (D : Dollars) return Yen;\n   function To_Yen (M : Marks)   return Yen;\n\nend Currency;\n")),(0,a.kt)("h4",p({},{id:"rationale-16"}),"rationale"),(0,a.kt)("p",null,"The Ada language does not provide any predefined decimal types.\nTherefore, you need to declare decimal types for the different scales\nyou will need to use. Differences in scale and precision must be\nconsidered in deciding whether or not a common type will suffice\n(Brosgol, Eachus, and Emery 1994)."),(0,a.kt)("p",null,"You need different types for objects measured in different units. This\nallows the compiler to detect mismatched values in expressions. If you\ndeclare all decimal objects to be of a single type, you forego the\nbenefits of strong typing. For example, in an application that involves\nseveral currencies, each currency should be declared as a separate type.\nYou should provide appropriate conversions between different currencies."),(0,a.kt)("p",null,"You should map data with no particular unit of measure to a small set of\ntypes or a single type to avoid the explosion of conversions between\nnumeric types."),(0,a.kt)("p",null,"Separate the range requirement on a decimal type from its precision,\ni.e., the number of significant digits required. From the point of view\nof planning for change and ease of maintenance, you can use the digit's\nvalue to accommodate future growth in the values to be stored in objects\nof the type. For example, you may want to anticipate growth for database\nvalues and report formats. You can constrain the values of the type\nthrough a range constraint that matches current needs. It is easier to\nmodify the range and avoid redefining databases and reports."),(0,a.kt)("p",null,"Ada automatically truncates toward 0. If your requirements are to round\nthe decimal result, you must explicitly do so using the 'Round\nattribute."),(0,a.kt)("p",null,"The core language defines the basic syntax of and operations on decimal\ntypes. It does not specify, however, the minimum number of significant\ndigits that must be supported. Nor does the core language require the\ncompiler to support values of Small other than powers of 2, thus\nenabling the compiler effectively to reject a decimal declaration (Ada\nReference Manual 1995, \xa73.5.9). The Information Systems Annex provides\nadditional support for decimal types. It requires a minimum of 18\nsignificant digits. It also specifies a Text_IO.Editing package that\nprovides support analogous to the COBOL picture approach."),(0,a.kt)("h3",p({},{id:"storage-control"}),"Storage Control"),(0,a.kt)("p",null,"The management of dynamic storage can vary between Ada environments. In\nfact, some environments do not provide any deallocation. The following\nAda storage control mechanisms are implementation-dependent and should\nbe used with care in writing portable programs."),(0,a.kt)("h3",p({},{id:"representation-clause"}),"Representation Clause"),(0,a.kt)("h4",p({},{id:"guideline-17"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not use a representation clause to specify number of storage\nunits.")),(0,a.kt)("h4",p({},{id:"rationale-17"}),"rationale"),(0,a.kt)("p",null,"The meaning of the 'Storage_Size attribute is ambiguous; specifying a\nparticular value will not improve portability. It may or may not include\nspace allocated for parameters, data, etc. Save the use of this feature\nfor designs that must depend on a particular vendor's implementation."),(0,a.kt)("h4",p({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"During a porting activity, it can be assumed that any occurrence of\nstorage specification indicates an implementation dependency that must\nbe redesigned."),(0,a.kt)("h3",p({},{id:"access-to-subprogram-values"}),"Access-to-Subprogram Values"),(0,a.kt)("h4",p({},{id:"guideline-18"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not compare access-to-subprogram values.")),(0,a.kt)("h4",p({},{id:"rationale-18"}),"rationale"),(0,a.kt)("p",null,'The Ada Reference Manual (1995, \xa73.10.2) explains that an\n"implementation may consider two access-to-subprogram values to be\nunequal, even though they designate the same subprogram. This might be\nbecause one points directly to the subprogram, while the other points to\na special prologue that performs an Elaboration_Check and then jumps to\nthe subprogram." The Ada Reference Manual (1995, \xa74.5.2) states that it\nis "unspecified whether two access values that designate the same\nsubprogram but are the result of distinct evaluations of Access\nattribute references are equal or unequal."'),(0,a.kt)("p",null,"See also Guideline 5.3.4."),(0,a.kt)("h4",p({},{id:"exceptions-3"}),"exceptions"),(0,a.kt)("p",null,"If you must compare an access-to-subprogram value, you should define a\nconstant using the access-to-subprogram value and make all future\ncomparisons against the constant. However, if you attempt to compare\naccess-to-subprogram values with different levels of indirection, the\nvalues might still be unequal, even if designating the same subprogram."),(0,a.kt)("h3",p({},{id:"storage-pool-mechanisms"}),"Storage Pool Mechanisms"),(0,a.kt)("h4",p({},{id:"guideline-19"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using explicitly defined storage pool mechanisms.")),(0,a.kt)("h4",p({},{id:"example-9"}),"example"),(0,a.kt)("p",null,"See the Ada Reference Manual 1995, \xa713.11.2)."),(0,a.kt)("p",null,"You use allocators as before. Instead of using unchecked deallocation,\nyou maintain your own free lists of objects that are no longer in use\nand available for reuse."),(0,a.kt)("p",null,"You use allocators and possibly unchecked deallocation; however, you\nimplement a storage pool and associate it with the access type(s) via a\nStorage_Pool clause. You can use this technique to implement a\nmark/release storage management paradigm, which might be significantly\nfaster than an allocate/deallocate paradigm. Some vendors may provide a\nmark/release package as part of their Ada environment."),(0,a.kt)("p",null,"You do not use allocators, but instead use unchecked conversion from the\naddress and do all your own default initialization, etc. It is unlikely\nyou would use this last option because you lose automatic default\ninitialization."),(0,a.kt)("h2",p({},{id:"tasking"}),"Tasking"),(0,a.kt)("p",null,"The definition of tasking in the Ada language leaves many\ncharacteristics of the tasking model up to the implementor. This allows\na vendor to make appropriate tradeoffs for the intended application\ndomain, but it also diminishes the portability of designs and code\nemploying the tasking features. In some respects, this diminished\nportability is an inherent characteristic of concurrency approaches (see\nNissen and Wallis 1984, 37). A discussion of Ada tasking dependencies\nwhen employed in a distributed target environment is beyond the scope of\nthis book. For example, multiprocessor task scheduling, interprocessor\nrendezvous, and the distributed sense of time through package Calendar\nare all subject to differences between implementations. For more\ninformation, Nissen and Wallis (1984) and ARTEWG (1986) touch on these\nissues, and Volz et al. (1985) is one of many research articles\navailable."),(0,a.kt)("p",null,"If the Real-Time Systems Annex is supported, then many concurrency\naspects are fully defined and, therefore, a program can rely on these\nfeatures while still being portable to other implementations that\nconform to the Real-Time Systems Annex. The following sections provide\nguidelines based on the absence of this annex."),(0,a.kt)("h3",p({},{id:"task-activation-order"}),"Task Activation Order"),(0,a.kt)("h4",p({},{id:"guideline-20"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the order in which task objects are activated when\ndeclared in the same declarative list.")),(0,a.kt)("h4",p({},{id:"rationale-19"}),"rationale"),(0,a.kt)("p",null,"The order in which task objects are activated is left undefined in the\nAda Reference Manual (1995, \xa79.2). See also Guideline 6.1.5."),(0,a.kt)("h3",p({},{id:"delay-statements"}),"Delay Statements"),(0,a.kt)("h4",p({},{id:"guideline-21"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on a particular delay being achievable (Nissen and\nWallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Never use knowledge of the execution pattern of tasks to achieve\ntiming requirements.")),(0,a.kt)("h4",p({},{id:"rationale-20"}),"rationale"),(0,a.kt)("p",null,"The rationale for this appears in Guideline 6.1.7. In addition, the\ntreatment of delay statements varies from implementation to\nimplementation, thereby hindering portability."),(0,a.kt)("p",null,"Using knowledge of the execution pattern of tasks to achieve timing\nrequirements is nonportable. Ada does not specify the underlying\nscheduling algorithm, and there is no guarantee that system clock ticks\nwill be consistently precise between different systems. Thus, when you\nchange system clocks, your delay behavior also changes."),(0,a.kt)("h3",p({},{id:"package-calendar-type-duration-and-systemtick"}),"Package Calendar, Type Duration, and System.Tick"),(0,a.kt)("h4",p({},{id:"guideline-22"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not assume a correlation between System.Tick and type Duration\n(see Guidelines 6.1.7 and 7.4.2).")),(0,a.kt)("h4",p({},{id:"rationale-21"}),"rationale"),(0,a.kt)("p",null,"Such a correlation is not required, although it may exist in some\nimplementations."),(0,a.kt)("h3",p({},{id:"select-statement-evaluation-order"}),"Select Statement Evaluation Order"),(0,a.kt)("h4",p({},{id:"guideline-23"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the order in which guard conditions are evaluated\nor on the algorithm for choosing among several open select\nalternatives.")),(0,a.kt)("h4",p({},{id:"rationale-22"}),"rationale"),(0,a.kt)("p",null,"The language does not define the order of these conditions, so assume\nthat they are arbitrary."),(0,a.kt)("h3",p({},{id:"task-scheduling-algorithm"}),"Task Scheduling Algorithm"),(0,a.kt)("h4",p({},{id:"guideline-24"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not assume that tasks execute uninterrupted until they reach a\nsynchronization point."),(0,a.kt)("li",{parentName:"ul"},"Use pragma Priority to distinguish general levels of importance only\n(see Guideline 6.1.6).")),(0,a.kt)("h4",p({},{id:"rationale-23"}),"rationale"),(0,a.kt)("p",null,"The Ada tasking model requires that tasks be synchronized only through\nthe explicit means provided in the language (i.e., rendezvous, task\ndependence, pragma Atomic). The scheduling algorithm is not defined by\nthe language and may vary from time sliced to preemptive priority. Some\nimplementations provide several choices that a user may select for the\napplication."),(0,a.kt)("h4",p({},{id:"notes-6"}),"notes"),(0,a.kt)("p",null,"The number of priorities may vary between implementations. In addition,\nthe manner in which tasks of the same priority are handled may vary\nbetween implementations even if the implementations use the same general\nscheduling algorithm."),(0,a.kt)("h4",p({},{id:"exceptions-4"}),"exceptions"),(0,a.kt)("p",null,"In real-time systems, it is often necessary to tightly control the\ntasking algorithm to obtain the required performance. For example,\navionics systems are frequently driven by cyclic events with limited\nasynchronous interruptions. A nonpreemptive tasking model is\ntraditionally used to obtain the greatest performance in these\napplications. Cyclic executives can be programmed in Ada, as can a\nprogression of scheduling schemes from cyclic through\nmultiple-frame-rate to full asynchrony (MacLaren 1980), although an\nexternal clock is usually required."),(0,a.kt)("h3",p({},{id:"abort"}),"Abort"),(0,a.kt)("h4",p({},{id:"guideline-25"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using the abort statement.")),(0,a.kt)("h4",p({},{id:"rationale-24"}),"rationale"),(0,a.kt)("p",null,"The rationale for this appears in Guideline 6.3.3. In addition,\ntreatment of the abort statement varies from implementation to\nimplementation, thereby hindering portability."),(0,a.kt)("h3",p({},{id:"unprotected-shared-variables-and-pragmas-atomic-and-volatile"}),"Unprotected Shared Variables and Pragmas Atomic and Volatile"),(0,a.kt)("h4",p({},{id:"guideline-26"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected types to provide data synchronization."),(0,a.kt)("li",{parentName:"ul"},"Have tasks communicate through the rendezvous mechanism."),(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables as a task synchronization\ndevice."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to encapsulate shared data."),(0,a.kt)("li",{parentName:"ul"},"Use pragma Atomic or Volatile only when you are forced to by\nrun-time system deficiencies.")),(0,a.kt)("h4",p({},{id:"example-10"}),"example"),(0,a.kt)("p",null,"See Guidelines 6.1.1 and 6.1.2."),(0,a.kt)("h4",p({},{id:"rationale-25"}),"rationale"),(0,a.kt)("p",null,"The rationale for this appears in Guidelines 6.1.1 and 6.2.4. In\naddition, the treatment of unprotected shared variables varies from\nimplementation to implementation, thereby hindering portability."),(0,a.kt)("h2",p({},{id:"exceptions-5"}),"Exceptions"),(0,a.kt)("p",null,"You should exercise care when using predefined exceptions because\naspects of their treatment may vary between implementations.\nImplementation-specific exceptions must, of course, be avoided. See\nGuidelines 4.3 an 5.8 for further information on exceptions. See\nGuideline 7.1.6 for further information on vendor-supplied features."),(0,a.kt)("h3",p({},{id:"predefined-and-user-defined-exceptions"}),"Predefined and User-Defined Exceptions"),(0,a.kt)("h4",p({},{id:"guideline-27"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the exact locations at which predefined exceptions\nare raised."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on the behavior of Ada.Exceptions beyond the minimum\ndefined in the language.")),(0,a.kt)("h4",p({},{id:"rationale-26"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995, \xa711) states that, among implementations,\na predefined exception for the same cause may be raised from different\nlocations. You will not be able to discriminate between the exceptions.\nFurther, each of the predefined exceptions is associated with a variety\nof conditions. Any exception handler written for a predefined exception\nmust be prepared to deal with any of these conditions."),(0,a.kt)("p",null,"Guideline 5.6.9 discusses the use of blocks to define local exception\nhandlers that can catch exceptions close to their point of origin."),(0,a.kt)("h3",p({},{id:"implementation-specific-exceptions"}),"Implementation-Specific Exceptions"),(0,a.kt)("h4",p({},{id:"guideline-28"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not raise implementation-specific exceptions."),(0,a.kt)("li",{parentName:"ul"},"Convert implementation-specific exceptions within interface packages\nto visible user-defined exceptions.")),(0,a.kt)("h4",p({},{id:"rationale-27"}),"rationale"),(0,a.kt)("p",null,"No exception defined specifically by an implementation can be guaranteed\nto be portable to other implementations whether or not they are from the\nsame vendor. Not only may the names be different, but the range of\nconditions triggering the exceptions may be different also."),(0,a.kt)("p",null,"If you create interface packages for the implementation-specific\nportions of your program, those packages can catch or recognize\nimplementation-specific exceptions and convert them into user-defined\nexceptions that have been declared in the specification. Do not allow\nyourself to be forced to find and change the name of every handler you\nhave written for these exceptions when the program is ported."),(0,a.kt)("h2",p({},{id:"representation-clauses-and-implementation-dependent-features"}),"Representation Clauses And Implementation-Dependent Features"),(0,a.kt)("p",null,"Ada provides many implementation-dependent features that permit greater\ncontrol over and interaction with the underlying hardware architecture\nthan is normally provided by a high-order language. These mechanisms are\nintended to assist in systems programming and real-time programming to\nobtain greater efficiency (e.g., specific size and layout of variables\nthrough representation clauses) and direct hardware interaction (e.g.,\ninterrupt entries) without having to resort to assembly level\nprogramming. Given the objectives for these features, it is not\nsurprising that you must usually pay a significant price in portability\nto use them. In general, where portability is the main objective, do not\nuse these features. When you must use these features, encapsulate them\nin packages that are well-commented as interfacing to the particular\ntarget environment. This section identifies the various features and\ntheir recommended use with respect to portability."),(0,a.kt)("h3",p({},{id:"representation-clauses"}),"Representation Clauses"),(0,a.kt)("h4",p({},{id:"guideline-29"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use algorithms that do not depend on the representation of the data\nand, therefore, do not need representation clauses."),(0,a.kt)("li",{parentName:"ul"},"Consider using representation clauses when accessing or defining\ninterface data or when a specific representation is needed to\nimplement a design."),(0,a.kt)("li",{parentName:"ul"},"Do not assume that sharing source files between programs guarantees\nthe same representation of data types in those files.")),(0,a.kt)("h4",p({},{id:"rationale-28"}),"rationale"),(0,a.kt)("p",null,"In many cases, it is easy to use representation clauses to implement an\nalgorithm, even when it is not necessary. There is also a tendency to\ndocument the original programmer's assumptions about the representation\nfor future reference. But there is no guarantee that another\nimplementation will support the representation chosen. Unnecessary\nrepresentation clauses also confuse porting or maintenance efforts,\nwhich must assume that the programmer depends on the documented\nrepresentation."),(0,a.kt)("p",null,"Interfaces to external systems and devices are the most common\nsituations where a representation clause is needed. Uses of pragma\nImport and address clauses should be evaluated during design and porting\nto determine whether a representation clause is needed."),(0,a.kt)("p",null,"Without representation clauses, the language does not require two\ncompilations of an unchanged file to result in the same data\nrepresentation. Things that can change the representation between\ncompilations include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A change in a file earlier in the compilation order"),(0,a.kt)("li",{parentName:"ul"},"A change in the optimization strategy or level"),(0,a.kt)("li",{parentName:"ul"},"A change in versions of the compiler"),(0,a.kt)("li",{parentName:"ul"},"A change in actual compilers"),(0,a.kt)("li",{parentName:"ul"},"A change in the availability of system resources")),(0,a.kt)("p",null,"Therefore, two independently linked programs or partitions should only\nshare data that has their representations explicitly controlled."),(0,a.kt)("h4",p({},{id:"notes-7"}),"notes"),(0,a.kt)("p",null,"During a porting effort, all representation clauses can be evaluated as\neither design artifacts or specifications for accessing interface data\nthat might change with a new implementation."),(0,a.kt)("h3",p({},{id:"package-system"}),"Package System"),(0,a.kt)("h4",p({},{id:"guideline-30"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using package System constants except in attempting to\ngeneralize other machine-dependent constructs.")),(0,a.kt)("h4",p({},{id:"rationale-29"}),"rationale"),(0,a.kt)("p",null,"Because the values in this package are implementation-provided,\nunexpected effects can result from their use."),(0,a.kt)("h4",p({},{id:"notes-8"}),"notes"),(0,a.kt)("p",null,"If you must guarantee that physical record layouts will remain the same\nbetween implementations, you can express record fields by their first\nand last bit positions as shown in the Ada Reference Manual (1995,\n\xa713.5.1). Static expressions and named numbers should be used to let\nthe compiler compute the endpoints of each range in terms of earlier\nfields. In this case, greater portability can be achieved by using\nSystem.Storage_Unit to let the compiler compute the value of the named\nnumber. However, this method might not work for all values of\nSystem.Storage_Unit."),(0,a.kt)("h4",p({},{id:"exceptions-6"}),"exceptions"),(0,a.kt)("p",null,"Do use package System constants to parameterize other\nimplementation-dependent features (see Pappas (1985, \xa713.7.1)."),(0,a.kt)("h3",p({},{id:"machine-code-inserts"}),"Machine Code Inserts"),(0,a.kt)("h4",p({},{id:"guideline-31"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid machine code inserts.")),(0,a.kt)("h4",p({},{id:"rationale-30"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995, Annex C) suggests that the package that\nimplements machine code inserts is optional. Additionally, it is not\nstandardized so that machine code inserts are most likely not portable.\nIn fact, it is possible that two different vendors' syntax will differ\nfor an identical target, and differences in lower-level details, such as\nregister conventions, will hinder portability."),(0,a.kt)("h4",p({},{id:"exceptions-7"}),"exceptions"),(0,a.kt)("p",null,"If machine code inserts must be used to meet another project\nrequirement, recognize and document the portability decreasing effects."),(0,a.kt)("p",null,"In the declarative region of the body of the routine where machine code\ninserts are being used, insert comments explaining what functions\ninserts provide and (especially) why the inserts are necessary. Comment\nthe necessity of using machine code inserts by delineating what went\nwrong with attempts to use other higher level constructs."),(0,a.kt)("h3",p({},{id:"interfacing-to-foreign-languages"}),"Interfacing to Foreign Languages"),(0,a.kt)("h4",p({},{id:"guideline-32"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use the package Interfaces and its language-defined child packages\nrather than implementation-specific mechanisms."),(0,a.kt)("li",{parentName:"ul"},'Consider using pragma Import rather than access-to-subprogram types\nfor interfacing to subprograms in other languages. (Preferably using\nthe "External_Name =',">",'" argument.)'),(0,a.kt)("li",{parentName:"ul"},"Isolate all subprograms employing pragmas Import, Export, and\nConvention to implementation-specific (interface) package bodies.")),(0,a.kt)("h4",p({},{id:"example-11"}),"example"),(0,a.kt)("p",null,"This example shows how to interface with the following cube root\nfunction written in C:"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-c"}),"double cbrt (double x);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),'package Math_Utilities is\n\n   Argument_Error : exception;\n\n   function Cube_Root (X : Float) return Float;\n\n   ...\n\nend Math_Utilities;\n\n------------------------------------------------------------------------------\nwith Interfaces.C;\npackage body Math_Utilities is\n\n   function Cube_Root (X : Float) return Float is\n\n      function C_Cbrt (X : Interfaces.C.Double) return Interfaces.C.Double;\n      pragma Import (Convention    => C,\n                     Entity        => C_Cbrt,\n                     External_Name => "cbrt");\n\n   begin\n      if X < 0.0 then\n         raise Argument_Error;\n      else\n         return Float (C_Cbrt (Interfaces.C.Double (X)));\n      end if;\n   end Cube_Root;\n\n   ...\n\nend Math_Utilities;\n')),(0,a.kt)("h4",p({},{id:"rationale-31"}),"rationale"),(0,a.kt)("p",null,"For static interfacing to subprograms in other languages, the pragma\nImport provides a better solution than access to subprograms because no\nindirection is required. The pragma Interface (Ada Reference Manual 1983) has been replaced by pragmas Import, Export, and Convention. Annex\nB of the Rationale (1995) discusses how to use these pragmas in\nconjunction with the access-to-subprogram types in interfacing to other\nlanguages."),(0,a.kt)("p",null,'Note especially the distinction between the "External_Name =',">",'" and\n"Link_Name =',">",'" parameters to pragma Import which are frequently\nconfused. External_Name specifies the procedure name as it appears in\nthe source code of the other language (such as C or Fortran). Link_Name\nspecifies the name used by the linker. Typically, only one of these\nparameters is specified, and generally External_Name is the preferred\nchoice for portability.'),(0,a.kt)("p",null,"Access to subprogram types is useful for implementing callbacks in a\nseparate subsystem, such as the X Window system."),(0,a.kt)("p",null,"The problems with interfacing to foreign languages are complex. These\nproblems include pragma syntax differences, conventions for\nlinking/binding Ada to other languages, and mapping Ada variables to\nforeign language variables. By hiding these dependencies within\ninterface packages, the amount of code modification can be reduced."),(0,a.kt)("h4",p({},{id:"exceptions-8"}),"exceptions"),(0,a.kt)("p",null,"It is often necessary to interact with other languages, if only an\nassembly language, to reach certain hardware features. In these cases,\nclearly comment the requirements and limitations of the interface and\npragma Import, Export, and Conventions usage."),(0,a.kt)("h3",p({},{id:"implementation-specific-pragmas-and-attributes"}),"Implementation-Specific Pragmas and Attributes"),(0,a.kt)("h4",p({},{id:"guideline-33"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid pragmas and attributes added by the compiler implementor.")),(0,a.kt)("h4",p({},{id:"rationale-32"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995) permits an implementor to add pragmas\nand attributes to exploit a particular hardware architecture or software\nenvironment. These are obviously even more implementation-specific and\ntherefore less portable than an implementor's interpretations of the\npredefined pragmas and attributes. However, the Ada Reference Manual\n(1995) defines a set of annexes that have a uniform and consistent\napproach to certain specialized needs, namely, real-time systems,\ndistributed systems, information systems, numerics, interfacing to\nforeign languages, and safety and security. You should always prefer the\nfacilities defined in the annexes to any vendor-defined pragmas and\nattributes."),(0,a.kt)("h3",p({},{id:"unchecked-deallocation"}),"Unchecked Deallocation"),(0,a.kt)("h4",p({},{id:"guideline-34"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Deallocation (see Guideline\n5.9.2).")),(0,a.kt)("h4",p({},{id:"rationale-33"}),"rationale"),(0,a.kt)("p",null,"The unchecked storage deallocation mechanism is one method for\noverriding the default time at which allocated storage is reclaimed. The\nearliest default time is when an object is no longer accessible, for\nexample, when control leaves the scope where an access type was declared\n(the exact point after this time is implementation-dependent). Any\nunchecked deallocation of storage performed prior to this may result in\nan erroneous Ada program if an attempt is made to access the object."),(0,a.kt)("p",null,"This guideline is stronger than Guideline 5.9.2 because of the extreme\ndependence on the implementation of Ada.Unchecked_Deallocation. Using\nit could cause considerable difficulty with portability."),(0,a.kt)("h4",p({},{id:"notes-9"}),"notes"),(0,a.kt)("p",null,"Ada.Unchecked_Deallocation is a supported feature in all Ada\nimplementations. The portability issue arises in that unchecked storage\ndeallocations might cause varying results in different implementations."),(0,a.kt)("h4",p({},{id:"exceptions-9"}),"exceptions"),(0,a.kt)("p",null,"Using unchecked deallocation of storage can be beneficial in local\ncontrol of highly iterative or recursive algorithms where available\nstorage may be exceeded."),(0,a.kt)("h3",p({},{id:"unchecked-access"}),"Unchecked Access"),(0,a.kt)("h4",p({},{id:"guideline-35"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on the attribute Unchecked_Access (see Guideline\n5.9.2).")),(0,a.kt)("h4",p({},{id:"rationale-34"}),"rationale"),(0,a.kt)("p",null,"Access values are subject to accessibility restrictions. Using the\nattribute Unchecked_Access prevents these rules from being checked, and\nthe programmer runs the risk of having dangling references."),(0,a.kt)("h3",p({},{id:"unchecked-conversion"}),"Unchecked Conversion"),(0,a.kt)("h4",p({},{id:"guideline-36"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Conversion (see Guideline 5.9.1).")),(0,a.kt)("h4",p({},{id:"rationale-35"}),"rationale"),(0,a.kt)("p",null,"The unchecked type conversion mechanism is, in effect, a means of\nbypassing the strong typing facilities in Ada. An implementation is free\nto limit the types that may be matched and the results that occur when\nobject sizes differ."),(0,a.kt)("h4",p({},{id:"exceptions-10"}),"exceptions"),(0,a.kt)("p",null,"Unchecked type conversion is useful in implementation-dependent parts of\nAda programs where lack of portability is isolated and where low-level\nprogramming and foreign language interfacing are the objectives."),(0,a.kt)("p",null,"If an enumeration representation clause is used, unchecked type\nconversion is the only language-provided way to retrieve the internal\ninteger code of an enumeration value."),(0,a.kt)("h3",p({},{id:"run-time-dependencies"}),"Run-Time Dependencies"),(0,a.kt)("h4",p({},{id:"guideline-37"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid the direct invocation of or implicit dependence upon an\nunderlying host operating system or Ada run-time support system,\nexcept where the interface is explicitly defined in the language\n(e.g., Annex C or D of the Ada Reference Manual ","[","1995","]",")."),(0,a.kt)("li",{parentName:"ul"},"Use standard bindings and the package Ada.Command_Line when you\nneed to invoke the underlying run-time support system."),(0,a.kt)("li",{parentName:"ul"},"Use features defined in the Annexes rather than vendor-defined\nfeatures.")),(0,a.kt)("h4",p({},{id:"rationale-36"}),"rationale"),(0,a.kt)("p",null,"Features of an implementation not specified in the Ada Reference Manual\n(1995) will usually differ between implementations. Specific\nimplementation-dependent features are not likely to be provided in other\nimplementations. In addition to the mandatory predefined language\nenvironment, the annexes define various packages, attributes, and\npragmas to standardize implementation-dependent features for several\nspecialized domains. You enhance portability when you use the features\ndeclared in the packages in the Annexes because you can port your\nprogram to other vendor environments that implement the same Annexes you\nhave used. Even if a majority of vendors eventually provide similar\nfeatures, they are unlikely to have identical formulations. Indeed,\ndifferent vendors may use the same formulation for (semantically)\nentirely different features."),(0,a.kt)("p",null,"When coding, try to avoid depending on the underlying operating system.\nConsider the consequences of including system calls in a program on a\nhost development system. If these calls are not flagged for removal and\nreplacement, the program could go through development and testing only\nto be unusable when moved to a target environment that lacks the\nfacilities provided by those system calls on the host."),(0,a.kt)("p",null,"Guideline 7.1.5 discusses the use of the package Ada.Command_Line. If\nan Ada environment implements a standard binding to operating system\nservices, such as POSIX/Ada, and you write POSIX-compliant calls, your\nprogram should be portable across more systems."),(0,a.kt)("h4",p({},{id:"exceptions-11"}),"exceptions"),(0,a.kt)("p",null,"In real-time, embedded systems, making calls to low-level support system\nfacilities may often be unavoidable. Isolating the uses of these\nfacilities may be too difficult. Comment them as you would machine code\ninserts (see Guideline 7.6.3); they are, in a sense, instructions for\nthe virtual machine provided by the support system. When isolating the\nuses of these features, provide an interface for the rest of your\nprogram to use, which can be ported through replacement of the\ninterface's implementation."),(0,a.kt)("h2",p({},{id:"inputoutput"}),"Input/Output"),(0,a.kt)("p",null,"I/O facilities in Ada are not a part of the syntactic definition of the\nlanguage. The constructs in the language have been used to define a set\nof packages for this purpose. These packages are not expected to meet\nall the I/O needs of all applications, in particular, embedded systems.\nThey serve as a core subset that may be used on straightforward data and\nthat can be used as examples of building I/O facilities upon the\nlow-level constructs provided by the language. Providing an I/O\ndefinition that could meet the requirements of all applications and\nintegrate with the many existing operating systems would result in\nunacceptable implementation dependencies. The types of portability\nproblems encountered with I/O tend to be different for applications\nrunning with a host operating system versus embedded targets where the\nAda run-time is self-sufficient. Interacting with a host operating\nsystem offers the added complexity of coexisting with the host file\nsystem structures (e.g., hierarchical directories), access methods\n(e.g., indexed sequential access method ","[","ISAM","]","), and naming\nconventions (e.g., logical names and aliases based on the current\ndirectory). The section on Input/Output in ARTEWG (1986) provides some\nexamples of this kind of dependency. Embedded applications have\ndifferent dependencies that often tie them to the low-level details of\ntheir hardware devices."),(0,a.kt)("p",null,"The major defense against these inherent implementation dependencies in\nI/O is to try to isolate their functionality in any given application.\nThe majority of the following guidelines are focused in this direction."),(0,a.kt)("h3",p({},{id:"name-and-form-parameters"}),"Name and Form Parameters"),(0,a.kt)("h4",p({},{id:"guideline-38"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use constants and variables as symbolic actuals for the Name and\nForm parameters on the predefined I/O packages. Declare and\ninitialize them in an implementation dependency package.")),(0,a.kt)("h4",p({},{id:"rationale-37"}),"rationale"),(0,a.kt)("p",null,"The format and allowable values of these parameters on the predefined\nI/O packages can vary greatly between implementations. Isolation of\nthese values facilitates portability. Not specifying a Form string or\nusing a null value does not guarantee portability because the\nimplementation is free to specify defaults."),(0,a.kt)("h4",p({},{id:"notes-10"}),"notes"),(0,a.kt)("p",null,"It may be desirable to further abstract the I/O facilities by defining\nadditional Create and Open procedures that hide the visibility of the\nForm parameter entirely (see Pappas 1985, 54-55)."),(0,a.kt)("h3",p({},{id:"file-closing"}),"File Closing"),(0,a.kt)("h4",p({},{id:"guideline-39"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Close all files explicitly.")),(0,a.kt)("h4",p({},{id:"rationale-38"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995, \xa7A.7) does not define what happens to\nexternal files after completion of the main subprogram (in particular,\nif corresponding files have not been closed)."),(0,a.kt)("p",null,"The disposition of a closed temporary file may vary, perhaps affecting\nperformance and space availability (ARTEWG 1986)."),(0,a.kt)("h3",p({},{id:"inputoutput-on-access-types"}),"Input/Output on Access Types"),(0,a.kt)("h4",p({},{id:"guideline-40"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid performing I/O on access types.")),(0,a.kt)("h4",p({},{id:"rationale-39"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995, \xa7A.7) does not specify the effects of\nI/O on access types. When such a value is written, it is placed out of\nreach of the implementation. Thus, it is out of reach of the\nreliability-enhancing controls of strong type checking."),(0,a.kt)("p",null,"Consider the meaning of this operation. One possible implementation of\nthe values of access types is virtual addresses. If you write such a\nvalue, how can you expect another program to read that value and make\nany sensible use of it? The value cannot be construed to refer to any\nmeaningful location within the reader's address space, nor can a reader\ninfer any information about the writer's address space from the value\nread. The latter is the same problem that the writer would have trying\nto interpret or use the value if it is read back in. To wit, a garbage\ncollection and/or heap compaction scheme may have moved the item\nformerly accessed by that value, leaving that value \"pointing\" at space\nthat is now being put to indeterminable uses by the underlying\nimplementation."),(0,a.kt)("h3",p({},{id:"package-adastreamsstream_io"}),"Package Ada.Streams.Stream_IO"),(0,a.kt)("h4",p({},{id:"guideline-41"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using Sequential_IO or Direct_IO instead of Stream_IO\nunless you need the low-level, heterogeneous I/O features provided\nby Stream_IO.")),(0,a.kt)("h4",p({},{id:"rationale-40"}),"rationale"),(0,a.kt)("p",null,"Sequential_IO and Direct_IO are still well suited for processing\nhomogeneous files. Additionally, in cases where the intent is to process\nhomogeneous files, the use of Sequential_IO or Direct_IO has the\nadvantage of enforcing this intent at compile time."),(0,a.kt)("p",null,"Stream_IO should be reserved for processing heterogeneous files. In\nthis case, a file is not a sequence of objects of all the same type but\nrather a sequence of objects of varying types. To read a heterogeneous\nsequence of objects in the correct order requires some\napplication-specific knowledge."),(0,a.kt)("h3",p({},{id:"current-error-files"}),"Current Error Files"),(0,a.kt)("h4",p({},{id:"guideline-42"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using Current_Error and Set_Error for run-time error\nmessages.")),(0,a.kt)("h4",p({},{id:"example-12"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",p({parentName:"pre"},{className:"language-ada"}),'with Ada.Text_IO;\n\n...\n\nbegin\n   Ada.Text_IO.Open (File => Configuration_File,\n                     Mode => Ada.Text_IO.In_File,\n                     Name => Configuration_File_Name);\nexception\n   when Ada.Text_IO.Name_Error =>\n      Ada.Text_IO.Put_Line (File => Ada.Text_IO.Standard_Error,\n                            Item => "Can\'t open configuration file.");\n      ...\nend;\n')),(0,a.kt)("h4",p({},{id:"rationale-41"}),"rationale"),(0,a.kt)("p",null,"The package Text_IO includes the concept of a current error file. You\nshould report errors to the user through the associated subprograms\nCurrent_Error and Set_Error instead of the standard output facilities.\nIn interactive applications, using the Text_IO error facilities\nincreases the portability of your user interface."),(0,a.kt)("h4",p({},{id:"notes-11"}),"notes"),(0,a.kt)("p",null,'In a program with multiple tasks for I/O, you need to be careful of two\nor more tasks trying to set Current_Input, Current_Output, or\nCurrent_Error. The potential problem lies in unprotected updates to the\n"shared" state associated with a package, in this case, the package\nText_IO. Guidelines 6.1.1 and 6.2.4 discuss the related issues of\nunprotected shared variables.'),(0,a.kt)("h2",p({},{id:"summary"}),"Summary"),(0,a.kt)("h3",p({},{id:"fundamentals-1"}),"fundamentals"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'In programs or components intended to have a long life, avoid using\nthe features of Ada declared as "obsolescent" by Annex J of the Ada\nReference Manual (1995), unless the use of the feature is needed for\nbackward compatibility with Ada 83 (Ada Reference Manual 1983).'),(0,a.kt)("li",{parentName:"ul"},"Document the use of any obsolescent features."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the following features:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The short renamings of the packages in the predefined\nenvironment (e.g., Text_IO as opposed to Ada.Text_IO)"),(0,a.kt)("li",{parentName:"ul"},"The character replacements of ","!"," for |, : for ","#",", and % for\nquotation marks"),(0,a.kt)("li",{parentName:"ul"},"Reduced accuracy subtypes of floating-point types"),(0,a.kt)("li",{parentName:"ul"},"The 'Constrained attribute as applied to private types"),(0,a.kt)("li",{parentName:"ul"},"The predefined package ASCII"),(0,a.kt)("li",{parentName:"ul"},"The exception Numeric_Error"),(0,a.kt)("li",{parentName:"ul"},"Various representation specifications, including at clauses, mod\nclauses, interrupt entries, and the Storage_Size attribute"))),(0,a.kt)("li",{parentName:"ul"},"Make informed assumptions about the support provided for the\nfollowing on potential target platforms:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Number of bits available for type Integer (range constraints)"),(0,a.kt)("li",{parentName:"ul"},"Number of decimal digits of precision available for\nfloating-point types"),(0,a.kt)("li",{parentName:"ul"},"Number of bits available for fixed-point types (delta and range\nconstraints)"),(0,a.kt)("li",{parentName:"ul"},"Number of characters per line of source text"),(0,a.kt)("li",{parentName:"ul"},"Number of bits for Root_Integer expressions"),(0,a.kt)("li",{parentName:"ul"},"Number of seconds for the range of Duration"),(0,a.kt)("li",{parentName:"ul"},"Number of milliseconds for Duration'Small"),(0,a.kt)("li",{parentName:"ul"},"Minimum and maximum scale for decimal types"))),(0,a.kt)("li",{parentName:"ul"},"Avoid assumptions about the values and the number of values included\nin the type Character."),(0,a.kt)("li",{parentName:"ul"},"Use highlighting comments for each package, subprogram, and task\nwhere any nonportable features are present."),(0,a.kt)("li",{parentName:"ul"},"For each nonportable feature employed, describe the expectations for\nthat feature."),(0,a.kt)("li",{parentName:"ul"},"Consider using only a parameterless procedure as the main\nsubprogram."),(0,a.kt)("li",{parentName:"ul"},"Consider using Ada.Command_Line for accessing values from the\nenvironment, but recognize that this package's behavior and even its\nspecification are nonportable."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate and document all uses of package Ada.Command_Line."),(0,a.kt)("li",{parentName:"ul"},"Create packages specifically designed to isolate hardware and\nimplementation dependencies and designed so that their specification\nwill not change when porting."),(0,a.kt)("li",{parentName:"ul"},"Clearly indicate the objectives if machine or solution efficiency is\nthe reason for hardware or implementation-dependent code."),(0,a.kt)("li",{parentName:"ul"},"For the packages that hide implementation dependencies, maintain\ndifferent package bodies for different target environments."),(0,a.kt)("li",{parentName:"ul"},"Isolate interrupt receiving tasks into implementation-dependent\npackages."),(0,a.kt)("li",{parentName:"ul"},"Refer to Annex M of the Ada Reference Manual (1995) for a list of\nimplementation-dependent features."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of vendor-supplied packages."),(0,a.kt)("li",{parentName:"ul"},"Avoid the use of features added to the predefined packages that are\nnot specified in the Ada language definition or Specialized Needs\nAnnexes."),(0,a.kt)("li",{parentName:"ul"},"Use features defined in the Specialized Needs Annexes rather than\nvendor-defined features."),(0,a.kt)("li",{parentName:"ul"},"Document clearly the use of any features from the Specialized Needs\nAnnexes (systems programming, real-time systems, distributed\nsystems, information systems, numerics, and safety and security)."),(0,a.kt)("li",{parentName:"ul"},"Do not write code whose correct execution depends on the particular\nparameter passing mechanism used by an implementation (Ada Reference\nManual 1995, \xa76.2; Cohen 1986)."),(0,a.kt)("li",{parentName:"ul"},"If a subprogram has more than one formal parameter of a given\nsubtype, at least one of which is ","[","in","]"," out, make sure that the\nsubprogram can properly handle the case when both formal parameters\ndenote the same actual object."),(0,a.kt)("li",{parentName:"ul"},"Avoid depending on the order in which certain constructs in Ada are\nevaluated .")),(0,a.kt)("h3",p({},{id:"numeric-types-and-expressions-1"}),"numeric types and expressions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using the predefined numeric types in package Standard . Use\nrange and digits declarations and let the implementation pick the\nappropriate representation."),(0,a.kt)("li",{parentName:"ul"},"For programs that require greater accuracy than that provided by the\nglobal assumptions, define a package that declares a private type\nand operations as needed; see Pappas (1985) for a full explanation\nand examples."),(0,a.kt)("li",{parentName:"ul"},"Consider using predefined numeric types (Integer, Natural, Positive)\nfor:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Indexes into arrays where the index type is not significant,\nsuch as type String"),(0,a.kt)("li",{parentName:"ul"},'"Pure" numbers, that is, numbers with no associated physical\nunit (e.g., exponents)'),(0,a.kt)("li",{parentName:"ul"},"Values whose purpose is to control a repeat or iteration count"))),(0,a.kt)("li",{parentName:"ul"},"Use an implementation that supports the Numerics Annex (Ada\nReference Manual 1995, Annex G) when performance and accuracy are\noverriding concerns ."),(0,a.kt)("li",{parentName:"ul"},"Carefully analyze what accuracy and precision you really need."),(0,a.kt)("li",{parentName:"ul"},"Do not press the accuracy limits of the machine(s)."),(0,a.kt)("li",{parentName:"ul"},"Comment the analysis and derivation of the numerical aspects of a\nprogram."),(0,a.kt)("li",{parentName:"ul"},"Anticipate the range of values of subexpressions to avoid exceeding\nthe underlying range of their base type. Use derived types,\nsubtypes, factoring, and range constraints on numeric types."),(0,a.kt)("li",{parentName:"ul"},"Consider using \\<= and ",">","= to do relational tests on real valued\narguments, avoiding the \\<, ",">",", =, and /= operations."),(0,a.kt)("li",{parentName:"ul"},"Use values of type attributes in comparisons and checking for small\nvalues."),(0,a.kt)("li",{parentName:"ul"},"In information systems, declare different numeric decimal types to\ncorrespond to different scales (Brosgol, Eachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Create objects of different decimal types to reflect different units\nof measure (Brosgol, Eachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Declare subtypes of the appropriately scaled decimal type to provide\nappropriate range constraints for application-specific types."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate each measure category in a package (Brosgol, Eachus, and\nEmery 1994)."),(0,a.kt)("li",{parentName:"ul"},"Declare as few decimal types as possible for unitless data (Brosgol,\nEachus, and Emery 1994)."),(0,a.kt)("li",{parentName:"ul"},"For decimal calculations, determine whether the result should be\ntruncated toward 0 or rounded."),(0,a.kt)("li",{parentName:"ul"},"Avoid decimal types and arithmetic on compilers that do not support\nthe Information Systems Annex (Ada Reference Manual 1995, Annex F)\nin full.")),(0,a.kt)("h3",p({},{id:"storage-control-1"}),"storage control"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not use a representation clause to specify number of storage\nunits."),(0,a.kt)("li",{parentName:"ul"},"Do not compare access-to-subprogram values."),(0,a.kt)("li",{parentName:"ul"},"Consider using explicitly defined storage pool mechanisms.")),(0,a.kt)("h3",p({},{id:"tasking-1"}),"tasking"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the order in which task objects are activated when\ndeclared in the same declarative list."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on a particular delay being achievable (Nissen and\nWallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Never use knowledge of the execution pattern of tasks to achieve\ntiming requirements."),(0,a.kt)("li",{parentName:"ul"},"Do not assume a correlation between System.Tick and type Duration."),(0,a.kt)("li",{parentName:"ul"},"Do not depend on the order in which guard conditions are evaluated\nor on the algorithm for choosing among several open select\nalternatives."),(0,a.kt)("li",{parentName:"ul"},"Do not assume that tasks execute uninterrupted until they reach a\nsynchronization point."),(0,a.kt)("li",{parentName:"ul"},"Use pragma Priority to distinguish general levels of importance\nonly."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the abort statement."),(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected types to provide data synchronization."),(0,a.kt)("li",{parentName:"ul"},"Have tasks communicate through the rendezvous mechanism."),(0,a.kt)("li",{parentName:"ul"},"Do not use unprotected shared variables as a task synchronization\ndevice."),(0,a.kt)("li",{parentName:"ul"},"Consider using protected objects to encapsulate shared data."),(0,a.kt)("li",{parentName:"ul"},"Use pragma Atomic or Volatile only when you are forced to by\nrun-time system deficiencies.")),(0,a.kt)("h4",p({},{id:"exceptions-12"}),"exceptions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not depend on the exact locations at which predefined exceptions\nare raised."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on the behavior of Ada.Exceptions beyond the minimum\ndefined in the language."),(0,a.kt)("li",{parentName:"ul"},"Do not raise implementation-specific exceptions."),(0,a.kt)("li",{parentName:"ul"},"Convert implementation-specific exceptions within interface packages\nto visible user-defined exceptions.")),(0,a.kt)("h3",p({},{id:"representation-clauses-and-implementation-dependent-features-1"}),"representation clauses and implementation-dependent features"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use algorithms that do not depend on the representation of the data\nand, therefore, do not need representation clauses."),(0,a.kt)("li",{parentName:"ul"},"Consider using representation clauses when accessing or defining\ninterface data or when a specific representation is needed to\nimplement a design ."),(0,a.kt)("li",{parentName:"ul"},"Do not assume that sharing source files between programs guarantees\nthe same representation of data types in those files."),(0,a.kt)("li",{parentName:"ul"},"Avoid using package System constants except in attempting to\ngeneralize other machine-dependent constructs."),(0,a.kt)("li",{parentName:"ul"},"Avoid machine code inserts."),(0,a.kt)("li",{parentName:"ul"},"Use the package Interfaces and its language-defined child packages\nrather than implementation-specific mechanisms."),(0,a.kt)("li",{parentName:"ul"},"Consider using pragma Import rather than access-to-subprogram types\nfor interfacing to subprograms in other languages."),(0,a.kt)("li",{parentName:"ul"},"Isolate all subprograms employing pragmas Import, Export, and\nConvention to implementation-specific (interface) package bodies."),(0,a.kt)("li",{parentName:"ul"},"Avoid pragmas and attributes added by the compiler implementor."),(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Deallocation."),(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on the attribute Unchecked_Access."),(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Conversion."),(0,a.kt)("li",{parentName:"ul"},"Avoid the direct invocation of or implicit dependence upon an\nunderlying host operating system or Ada run-time support system,\nexcept where the interface is explicitly defined in the language\n(e.g., Annex C or D of the Ada Reference Manual ","[","1995","]",")."),(0,a.kt)("li",{parentName:"ul"},"Use standard bindings and the package Ada.Command_Line when you\nneed to invoke the underlying")),(0,a.kt)("p",null,"run-time support system."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use features defined in the Annexes rather than vendor-defined\nfeatures.")),(0,a.kt)("h3",p({},{id:"inputoutput-1"}),"input/output"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use constants and variables as symbolic actuals for the Name and\nForm parameters on the predefined I/O packages. Declare and\ninitialize them in an implementation dependency package."),(0,a.kt)("li",{parentName:"ul"},"Close all files explicitly."),(0,a.kt)("li",{parentName:"ul"},"Avoid performing I/O on access types."),(0,a.kt)("li",{parentName:"ul"},"Consider using Sequential_IO or Direct_IO instead of Stream_IO\nunless you need the low-level, heterogeneous I/O features provided\nby Stream_IO."),(0,a.kt)("li",{parentName:"ul"},"Consider using Current_Error and Set_Error for run-time error\nmessages.")),(0,a.kt)("admonition",p({},{type:"note"}),(0,a.kt)("p",{parentName:"admonition"},'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",p({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",p({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work.")))}v.isMDXComponent=!0}}]);