"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1250],{1716:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>f});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),c=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},l=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=c(a),f=i,m=d["".concat(p,".").concat(f)]||d[f]||h[f]||r;return a?n.createElement(m,o(o({ref:t},l),{},{components:a})):n.createElement(m,o({ref:t},l))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2522:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:24},o="3.8  Record Types",s={unversionedId:"arm/AA-3.8",id:"arm/AA-3.8",title:"3.8  Record Types",description:"A record object is a composite object consisting of named components. The value of a record object is a composite value consisting of the values of the components.",source:"@site/docs/arm/AA-3.8.md",sourceDirName:"arm",slug:"/arm/AA-3.8",permalink:"/docs/arm/AA-3.8",draft:!1,tags:[],version:"current",sidebarPosition:24,frontMatter:{sidebar_position:24},sidebar:"tutorialSidebar",previous:{title:"3.7  Discriminants",permalink:"/docs/arm/AA-3.7"},next:{title:"3.9  Tagged Types and Type Extensions",permalink:"/docs/arm/AA-3.9"}},p={},c=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"3.8.1  Variant Parts and Discrete Choices",id:"381--variant-parts-and-discrete-choices",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],l={toc:c};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"38--record-types"},"3.8  Record Types"),(0,i.kt)("p",null,"A record object is a composite object consisting of named components. The value of a record object is a composite value consisting of the values of the components. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"record_type_definition",(0,i.kt)("a",{id:"S0066"})," ::= ","[[abstract] tagged][limited]"," ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition")),(0,i.kt)("p",null,"{AI12-0213-1} record",(0,i.kt)("em",{parentName:"p"},"definition",(0,i.kt)("a",{id:"S0067"})," ::=\nrecord\n",(0,i.kt)("a",{parentName:"em",href:"./AA-3.8#S0068"},"component_list"),"\nend record [record"),(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),"]\n| null record"),(0,i.kt)("p",null,"component_list",(0,i.kt)("a",{id:"S0068"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0069"},"component_item")," {",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0069"},"component_item"),"}\n| {",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0069"},"component_item"),"} ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),"\n|  null;"),(0,i.kt)("p",null,"{8652/0009} {AI95-00137-01} component_item",(0,i.kt)("a",{id:"S0069"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0343"},"aspect_clause")),(0,i.kt)("p",null,"{AI05-0183-1} component_declaration",(0,i.kt)("a",{id:"S0070"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0033"},"defining_identifier_list")," : ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," [:= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"]\n[",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"];"),(0,i.kt)("p",null,"{AI12-0213-1} If a record_",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," appears at the end of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition"),", it shall repeat the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," of the enclosing ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),". "),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expected type for the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),", if any, in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," is the type of the component. "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"This paragraph was deleted.{AI95-00287-01} "),(0,i.kt)("p",null,"{AI95-00366-01} Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," declares a component of the record type. Besides components declared by ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration"),"s, the components of a record type include any components declared by ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0062"},"discriminant_specification"),"s of the record type declaration. ","[The identifiers of all components of a record type shall be distinct.]"," "),(0,i.kt)("p",null,"Proof: {AI05-0299-1} The identifiers of all components of a record type have to be distinct because they are all declared immediately within the same declarative region. See Clause 8. "),(0,i.kt)("p",null,"Within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration"),", a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes a component, protected subprogram, or entry of the type is allowed only in the following cases:"),(0,i.kt)("p",null,"{AI05-0004-1} {AI05-0295-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes any component, protected subprogram, or entry is allowed within an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),", an operational item, or a representation item that occurs within the declaration of the composite type."),(0,i.kt)("p",null,"{AI05-0264-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes a noninherited discriminant is allowed within the declaration of the type, but not within the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0059"},"discriminant_part"),". If the discriminant is used to define the constraint of a component, the bounds of an entry family, or the constraint of the parent subtype in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition"),", then its name shall appear alone as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," (not as part of a larger expression or expanded name). A discriminant shall not be used to define the constraint of a scalar component. "),(0,i.kt)("p",null,"Reason: The penultimate restriction simplifies implementation, and allows the outer discriminant and the inner discriminant or bound to possibly share storage. "),(0,i.kt)("p",null,"Ramification: Other rules prevent such a discriminant from being an inherited one. "),(0,i.kt)("p",null,"Reason: The last restriction is inherited from Ada 83. The restriction is not really necessary from a language design point of view, but we did not remove it, in order to avoid unnecessary changes to existing compilers. "),(0,i.kt)("p",null,"Discussion: Note that a discriminant can be used to define the constraint for a component that is of an access-to-composite type. "),(0,i.kt)("p",null,"Reason: {AI95-00373-01} The above rules, and a similar one in 6.1 for formal parameters, are intended to allow initializations of components or parameters to occur in a (nearly) arbitrary order - whatever order is most efficient (subject to the restrictions of 3.3.1), since one ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression")," cannot depend on the value of another one. They also prevent circularities. "),(0,i.kt)("p",null,"Ramification: {AI05-0295-1} Inherited discriminants are not allowed to be denoted, except within ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s and representation items. However, the discriminant_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," of the parent ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," is allowed to denote a discriminant of the parent. "),(0,i.kt)("p",null,"If the name of the current instance of a type (see 8.6) is used to define the constraint of a component, then it shall appear as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," that is the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose result is of an access type, and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," shall appear alone. "),(0,i.kt)("p",null,"Reason: This rule allows T'Access or T'Unchecked_Access, but disallows, for example, a range constraint (1..T'Size). Allowing things like (1..T'Size) would mean that a per-object constraint could affect the size of the object, which would be bad. "),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"{AI95-00318-02} {AI05-0004-1} If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0066"},"record_type_definition")," includes the reserved word limited, the type is called an explicitly limited record type."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," defines the (nominal) subtype of the component. If the reserved word aliased appears in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),", then the component is aliased (see 3.10). "),(0,i.kt)("p",null,"If the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," of a record type is defined by the reserved word null and there are no discriminants, then the record type has no components and all records of the type are null records. A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition")," of null record is equivalent to record null; end record. "),(0,i.kt)("p",null,"Ramification: {AI12-0426-1} This shorthand is available both for declaring a record type and a record extension - see 3.9.1. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0066"},"record_type_definition")," creates the record type and its first subtype, and consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition"),". The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition")," consists of the elaboration of its ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list"),", if any."),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0069"},"component_item"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),", if any, in the order in which they appear. The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),". "),(0,i.kt)("p",null,"Discussion: If the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0033"},"defining_identifier_list")," has more than one ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),", we presume here that the transformation explained in 3.3.1 has already taken place. Alternatively, we could say that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," is elaborated once for each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," in the list. "),(0,i.kt)("p",null,"{8652/0002} {AI95-00171-01} {AI95-00230-01} Within the definition of a composite type, if a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," (see 9.5.2) includes a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes a discriminant of the type, or that is an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," denotes the current instance of the type, the expression containing the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," is called a per-object expression, and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," being defined is called a per-object constraint. For the elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," or the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.5#S0257"},"entry_declaration")," for an entry family (see 9.5.2), if the component subtype is defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition")," or if the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," is not a per-object constraint, then the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," is elaborated. On the other hand, if the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," is a per-object constraint, then the elaboration consists of the evaluation of any included expression that is not part of a per-object expression. Each such expression is evaluated once unless it is part of a named association in a discriminant constraint, in which case it is evaluated once for each associated discriminant."),(0,i.kt)("p",null,"{8652/0002} {AI95-00171-01} When a per-object constraint is elaborated ","[(as part of creating an object)]",", each per-object expression of the constraint is evaluated. For other expressions, the values determined during the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.5#S0257"},"entry_declaration")," are used. Any checks associated with the enclosing ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," are performed","[, including the subtype compatibility check (see 3.2.2),]"," and the associated subtype is created. "),(0,i.kt)("p",null,"Discussion: The evaluation of other expressions that appear in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"s is performed when the type definition is elaborated. The evaluation of expressions that appear as ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s is postponed until an object is created. Expressions in representation items that appear within a composite type definition are evaluated according to the rules of the particular representation item. "),(0,i.kt)("p",null,"NOTE 1   A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," with several identifiers is equivalent to a sequence of single ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration"),"s, as explained in 3.3.1."),(0,i.kt)("p",null,"NOTE 2   The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression")," of a record component is only evaluated upon the creation of a default-initialized object of the record type (presuming the object has the component, if it is in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," - see 3.3.1)."),(0,i.kt)("p",null,"NOTE 3   The subtype defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," (see 3.6) has to be a definite subtype."),(0,i.kt)("p",null,"NOTE 4   If a record type does not have a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),", then the same components are present in all values of the type."),(0,i.kt)("p",null,"NOTE 5   A record type is limited if it has the reserved word limited in its definition, or if any of its components are limited (see 7.5)."),(0,i.kt)("p",null,"NOTE 6   The predefined operations of a record type include membership tests, qualification, and explicit conversion. If the record type is nonlimited, they also include assignment and the predefined equality operators."),(0,i.kt)("p",null,"NOTE 7   {AI95-00287-01} A component of a record can be named with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0098"},"selected_component"),". A value of a record can be specified with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0107"},"record_aggregate"),"."),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of record type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0430-1} type Date is\n   record\n      Day   : Integer range 1 .. 31;\n      Month : Month_Name;                  -- see 3.5.1\n      Year  : Integer range 0 .. 4000;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0213-1} type Complex is\n   record\n      Re : Real := 0.0;\n      Im : Real := 0.0;\n   end record Complex;\n\n")),(0,i.kt)("p",null,"Examples of record variables: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Tomorrow, Yesterday : Date;\nA, B, C : Complex;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-- both components of A, B, and C are implicitly initialized to zero \n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," is modified to use ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," (instead of component_subtype_definition). The effect of this change is to allow the reserved word aliased before the component_subtype_definition."),(0,i.kt)("p",null,"A short-hand is provided for defining a null record type (and a null record extension), as these will be more common for abstract root types (and derived types without additional components)."),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0066"},"record_type_definition")," is modified to allow the reserved words tagged and limited. Tagging is new. Limitedness is now orthogonal to privateness. In Ada 83 the syntax implied that limited private was sort of more private than private. However, limitedness really has nothing to do with privateness; limitedness simply indicates the lack of assignment capabilities, and makes perfect sense for nonprivate types such as record types. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"{8652/0009} {AI95-00137-01} The syntax rules now allow ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0343"},"aspect_clause"),"s to appear in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0067"},"record_definition"),". This is not a language extension, because Legality Rules prevent all language-defined representation clauses from appearing there. However, an implementation-defined ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," could appear there. The reason for this change is to allow the rules for ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0343"},"aspect_clause"),"s and representation pragmas to be as similar as possible. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00287-01} Record components can have an anonymous access type."),(0,i.kt)("p",null,"{AI95-00287-01} Limited components can be initialized, so long as the expression is one that allows building the object in place (such as an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0106"},"aggregate")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call"),"). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0002} {AI95-00171-01} Corrigendum: Improved the description of the elaboration of per-object constraints."),(0,i.kt)("p",null,"{8652/0009} {AI95-00137-01} Corrigendum: Changed representation clauses to aspect clauses to reflect that they are used for more than just representation."),(0,i.kt)("p",null,"{AI95-00318-02} Defined explicitly limited record type to use in other rules. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0183-1} An optional ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," can be used in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration"),". This is described in 13.1.1. "),(0,i.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0213-1} The record_",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," following end record is new. "),(0,i.kt)("h2",{id:"381--variant-parts-and-discrete-choices"},"3.8.1  Variant Parts and Discrete Choices"),(0,i.kt)("p",null,"A record type with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," specifies alternative lists of components. Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," defines the components for the value or values of the discriminant covered by its ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list"),". "),(0,i.kt)("p",null,"Discussion: ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"Discrete_choice_list"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"s are said to cover values as defined below; which ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," covers a value determines which of various alternatives is chosen. These are used in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),"s, ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0113"},"array_aggregate"),"s, and ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),"s. "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,'The definition of "cover" in this subclause and the rules about discrete choices are designed so that they are also appropriate for array aggregates and case statements.'),(0,i.kt)("p",null,"The rules of this subclause intentionally parallel those for case statements. "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"variant",(0,i.kt)("em",{parentName:"p"},"part",(0,i.kt)("a",{id:"S0071"})," ::=\ncase discriminant"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," is\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"\n{",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"}\nend case;"),(0,i.kt)("p",null,"variant",(0,i.kt)("a",{id:"S0072"})," ::=\nwhen ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," =",">","\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")),(0,i.kt)("p",null,"{AI12-0212-1} discrete_choice_list",(0,i.kt)("a",{id:"S0073"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," {'|' ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"}"),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0158-1} discrete",(0,i.kt)("em",{parentName:"p"},"choice",(0,i.kt)("a",{id:"S0074"})," ::= ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0133"},"choice_expression")," | discrete"),(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," | others"),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"The discriminant_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," shall resolve to denote a discriminant (called the discriminant of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),") specified in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," that contains the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),". The expected type for each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," is the type of the discriminant of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),". "),(0,i.kt)("p",null,"Ramification: A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," has to have a (new) ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part"),"; the discriminant of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," cannot be an inherited discriminant. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"The discriminant of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," shall be of a discrete type. "),(0,i.kt)("p",null,"Ramification: It shall not be of an access type, named or anonymous."),(0,i.kt)("p",null,"{AI05-0153-3} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0133"},"choice_expression"),"s, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"s, and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),"s given as ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"s in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," shall be static. The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," others shall appear alone in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list"),", and such a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list"),", if it appears, shall be the last one in the enclosing construct."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," is defined to cover a value in the following cases: "),(0,i.kt)("p",null,"{AI05-0262-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," that is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0133"},"choice_expression")," covers a value if the value equals the value of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0133"},"choice_expression")," converted to the expected type."),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0262-1} {AI12-0071-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," that is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," covers all values (possibly none) that belong to the subtype and that satisfy the static predicates of the subtype (see 3.2.4)."),(0,i.kt)("p",null,"Ramification: {AI05-0262-1} A dynamic predicate is never allowed in this case (for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"s, ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),"s, and ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0151"},"case_expression"),"s, a subtype with a dynamic predicate isn't static and thus isn't allowed in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),", and for a choice in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0113"},"array_aggregate"),", a dynamic predicate is explicitly disallowed - see 3.2.4). "),(0,i.kt)("p",null,"{AI05-0153-3} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," that is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," covers all values (possibly none) that belong to the range."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," others covers all values of its expected type that are not covered by previous ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list"),"s of the same construct. "),(0,i.kt)("p",null,"Ramification: For ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),"s, this includes values outside the range of the static subtype (if any) to be covered by the choices. It even includes values outside the base range of the case expression's type, since values of numeric types (and undefined values of any scalar type?) can be outside their base range. "),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," covers a value if one of its ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"s covers the value."),(0,i.kt)("p",null,"The possible values of the discriminant of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," shall be covered as follows: "),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0188-1} {AI05-0262-1} {AI12-0071-1} If the discriminant is of a static constrained scalar subtype then, except within an instance of a generic unit, each non-others ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," shall cover only values in that subtype that satisfy its predicates, and each value of that subtype that satisfies its predicates shall be covered by some ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," ","[(either explicitly or by others)]",";"),(0,i.kt)("p",null,"Reason: {AI05-0188-1} The exemption for a discriminated type declared in an instance allows the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type T is new Integer;\npackage G is\n   type Rec (Discrim : T) is record\n      case Discrim is\n         when -10 .. -1 =&gt\n            Foo : Float;\n         when others =&gt\n            null;\n      end case;\n   end record;\nend G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package I is new G (Natural); -- Legal\n\n")),(0,i.kt)("p",null,"{AI05-0264-1} If the type of the discriminant is a descendant of a generic formal scalar type, then the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," shall have an others ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"; "),(0,i.kt)("p",null,"Reason: The base range is not known statically in this case. "),(0,i.kt)("p",null,"Otherwise, each value of the base range of the type of the discriminant shall be covered ","[(either explicitly or by others)]",". "),(0,i.kt)("p",null,"Two distinct ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"s of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," shall not cover the same value."),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"If the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," is specified by null, the variant has no components."),(0,i.kt)("p",null,"The discriminant of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," is said to govern the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," and its ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"s. In addition, the discriminant of a derived type governs a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," and its ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"s if it corresponds (see 3.7) to the discriminant of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),"."),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"A record value contains the values of the components of a particular ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," only if the value of the discriminant governing the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," is covered by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),". This rule applies in turn to any further ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," that is, itself, included in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," of the given ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),"."),(0,i.kt)("p",null,"{AI05-0290-1} When an object of a discriminated type T is initialized by default, Constraint_Error is raised if no ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," of any ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," of T covers the value of the discriminant that governs the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),". When a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," appears in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," of another ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," V, this test is only applied if the value of the discriminant governing V is covered by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," of V. "),(0,i.kt)("p",null,'Implementation Note: This is not a "check"; it cannot be suppressed. However, in most cases it is not necessary to generate any code to raise this exception. A test is needed (and can fail) in the case where the discriminant subtype has a Static_Predicate specified, it also has predicate checking disabled, and the discriminant governs a ',(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," which lacks a when others choice."),(0,i.kt)("p",null,"The test also could fail for a static discriminant subtype with range checking suppressed and the discriminant governs a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," which lacks a when others choice. But execution is erroneous if a range check that would have failed is suppressed (see 11.5), so an implementation does not have to generate code to check this case. (An unchecked failed predicate does not cause erroneous execution, so the test is required in that case.)"),(0,i.kt)("p",null,"Like the checks associated with a per-object constraint, this test is not made during the elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". "),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0068"},"component_list")," of each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," in the order in which they appear. "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Example of record type with a variant part: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Device is (Printer, Disk, Drum);\ntype State  is (Open, Closed);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Peripheral(Unit : Device := Disk) is\n   record\n      Status : State;\n      case Unit is\n         when Printer =&gt\n            Line_Count : Integer range 1 .. Page_Size;\n         when others =&gt\n            Cylinder   : Cylinder_Index;\n            Track      : Track_Number;\n      end case;\n   end record;\n\n")),(0,i.kt)("p",null,"Examples of record subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Drum_Unit is Peripheral(Drum);\nsubtype Disk_Unit is Peripheral(Disk);\n\n")),(0,i.kt)("p",null,"Examples of constrained record variables: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Writer   : Peripheral(Unit  =&gt Printer);\nArchive  : Disk_Unit;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"In Ada 83, the discriminant of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," is not allowed to be of a generic formal type. This restriction is removed in Ada 95; an others ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," is required in this case. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntactic category choice is removed. The syntax rules for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0113"},"array_aggregate"),", and ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement")," now use ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," instead. The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0107"},"record_aggregate")," now defines its own syntax for named associations."),(0,i.kt)("p",null,'{AI05-0299-1} We have added the term Discrete Choice to the title since this is where they are talked about. This is analogous to the name of the subclause "Index Constraints and Discrete Ranges" in the subclause on Array Types.'),(0,i.kt)("p",null,"The rule requiring that the discriminant denote a discriminant of the type being defined seems to have been left implicit in RM83. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,i.kt)("p",null,"{AI05-0158-1} Membership tests are no longer allowed as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),", in order that those tests can be expanded to allow multiple tests in a single expression without ambiguity. Since a membership test has a boolean type, they are very unlikely to be used as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),". "),(0,i.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0153-3} Subtypes with static predicates can be used in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice"),"s, and the coverage rules are modified to respect the predicates."),(0,i.kt)("p",null,"{AI05-0188-1} Variants in generic specifications are no longer rejected if the subtype of the actual type does not include all of the case choices. This probably isn't useful, but it is consistent with the treatment of ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0151"},"case_expression"),"s. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0290-1} Added a test that some ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0072"},"variant")," covers the value of a discriminant that governs a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),". This is similar to the test that some case limb covers the value of the Selecting_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),". This test cannot change the behavior of any nonerroneous Ada 2005 program, so it is not an inconsistency. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,'{AI12-0071-1} Corrigendum: Updated wording of the coverage rules to use the new term "satisfies the predicates" (see 3.2.4).'))}h.isMDXComponent=!0}}]);