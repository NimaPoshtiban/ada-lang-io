"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6941],{33418:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>m,default:()=>u,frontMatter:()=>g,metadata:()=>y,toc:()=>c});var i=t(58168),a=(t(96540),t(15680)),r=t(20793),o=t(91435),l=t(21432),s=t(79162),d=t(34421);const g={sidebar_position:169},m="D.15 Timing Events",y={unversionedId:"arm/AA-D/AA-D.15",id:"arm/AA-D/AA-D.15",title:"D.15 Timing Events",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-D/AA-D.15.mdx",sourceDirName:"arm/AA-D",slug:"/arm/AA-D/AA-D.15",permalink:"/docs/arm/AA-D/AA-D.15",draft:!1,tags:[],version:"current",sidebarPosition:169,frontMatter:{sidebar_position:169},sidebar:"referenceManualSidebar",previous:{title:"D.14 Execution Time",permalink:"/docs/arm/AA-D/AA-D.14"},next:{title:"D.16 Multiprocessor Implementation",permalink:"/docs/arm/AA-D/AA-D.16"}},p={},c=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Metrics",id:"metrics",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}],h={toc:c},T="wrapper";function u(e){let{components:n,...t}=e;return(0,a.yg)(T,(0,i.A)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"d15-timing-events"},"D.15 Timing Events"),(0,a.yg)("admonition",{type:"warning"},(0,a.yg)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,a.yg)(s.A,{mdxType:"MarginText"},"1/5"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0299-1","AI12-0445-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"This subclause describes a language-defined package to allow user-defined protected procedures to be executed at a specified time without the use of a task or a delay statement. ",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"static-semantics"},"Static Semantics"),(0,a.yg)(s.A,{mdxType:"MarginText"},"2/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The following language-defined library package exists: ",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"3/5"),(0,a.yg)(d.A,{items:["AI12-0241-1","AI12-0302-1"],mdxType:"MarginInfo"}),(0,a.yg)(l.A,{language:"ada",mdxType:"CodeBlock"},"package Ada.Real","_","Time.Timing","_","Events","\n","  with Nonblocking, Global =",">"," in out synchronized is","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"4/5"),(0,a.yg)(d.A,{items:["AI12-0241-1"],mdxType:"MarginInfo"}),"type Timing","_","Event is tagged limited private;","\n","  type Timing","_","Event","_","Handler","\n","       is access protected procedure (Event : in out Timing","_","Event)","\n","       with Nonblocking =",">"," False;","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"5/2"),"procedure Set","_","Handler (Event   : in out Timing","_","Event;","\n","                         At","_","Time : in Time;","\n","                         Handler : in Timing","_","Event","_","Handler);","\n","  procedure Set","_","Handler (Event   : in out Timing","_","Event;","\n","                         In","_","Time : in Time","_","Span;","\n","                         Handler : in Timing","_","Event","_","Handler);","\n","  function Current","_","Handler (Event : Timing","_","Event)","\n","       return Timing","_","Event","_","Handler;","\n","  procedure Cancel","_","Handler (Event     : in out Timing","_","Event;","\n","                            Cancelled : out Boolean);","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"6/2"),"function Time","_","Of","_","Event (Event : Timing","_","Event) return Time;","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"7/2"),"private","\n","  ... -- not specified by the language","\n","end Ada.Real","_","Time.Timing","_","Events;","\n"),(0,a.yg)(s.A,{mdxType:"MarginText"},"8/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The type Timing","_","Event represents a time in the future when an event is to occur. The type Timing","_","Event needs finalization (see ",(0,a.yg)("a",{href:"../AA-7/AA-7.6"},"7.6"),").",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"9/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"An object of type Timing","_","Event is said to be ",(0,a.yg)("em",null,"set")," if it is associated with a nonnull value of type Timing","_","Event","_","Handler and ",(0,a.yg)("em",null,"cleared")," otherwise. All Timing","_","Event objects are initially cleared. ",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"10/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The type Timing","_","Event","_","Handler identifies a protected procedure to be executed by the implementation when the timing event occurs. Such a protected procedure is called a ",(0,a.yg)("em",null,"handler"),". ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"10.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"Type Timing","_","Event is tagged. This makes it possible to share a handler between several events. In simple cases, 'Access can be used to compare the parameter with a specific timing event object (this works because a tagged type is a by-reference type). In more complex cases, a type extension of type Timing","_","Event can be declared; a double type conversion can be used to access the extension data. For example:",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"10.b/2"),(0,a.yg)(l.A,{language:"ada",mdxType:"CodeBlock"},"type Toaster","_","Timing","_","Event is new Timing","_","Event with record","\n","   Slot : Natural;","\n","end record;","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"10.c/2"),"...","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"10.d/2"),"protected body Toaster is","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"10.e/2"),"procedure Timer (Event : in out Timing","_","Event) is","\n","   begin","\n","      Pop","_","Up","_","Toast (Toaster","_","Timing","_","Event(Timing","_","Event'Class(Event)).Slot);","\n","   end Timer;","\n",(0,a.yg)(s.A,{mdxType:"MarginText"},"10.f/2"),"...","\n","end Toaster;","\n")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"10.g/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The extra conversion to the class-wide type is necessary to make the conversions legal. While this usage is clearly ugly, we think that the need for this sort of usage will be rare, so we can live with it. It's certainly better than having no way to associate data with an event. ",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,a.yg)(s.A,{mdxType:"MarginText"},"11/3"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The procedures Set","_","Handler associate the handler Handler with the event Event: if Handler is ",(0,a.yg)("strong",null,"null"),", the event is cleared; otherwise, it is set. The first procedure Set","_","Handler sets the execution time for the event to be At","_","Time. The second procedure Set","_","Handler sets the execution time for the event to be Real","_","Time.Clock + In","_","Time.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"12/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"A call of a procedure Set","_","Handler for an event that is already set replaces the handler and the time of execution; if Handler is not ",(0,a.yg)("strong",null,"null"),", the event remains set.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"13/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"As soon as possible after the time set for the event, the handler is executed, passing the event as parameter. The handler is only executed if the timing event is in the set state at the time of execution. The initial action of the execution of the handler is to clear the event.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"13.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.yg)("strong",null),"The second sentence of this paragraph is because of a potential race condition. The time might expire and yet before the handler is executed, some task could call Cancel","_","Handler (or equivalently call Set","_","Handler with a ",(0,a.yg)("strong",null,"null")," parameter) and thus clear the handler. ",(0,a.yg)("br",null))),(0,a.yg)(s.A,{mdxType:"MarginText"},"14/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If the Ceiling","_","Locking policy (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.3"},"D.3"),") is in effect when a procedure Set","_","Handler is called, a check is made that the ceiling priority of Handler.",(0,a.yg)("strong",null,"all")," is Interrupt","_","Priority'Last. If the check fails, Program","_","Error is raised.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"15/3"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0094-1","AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If a procedure Set","_","Handler is called with zero or negative In","_","Time or with At","_","Time indicating a time in the past, then the handler is executed as soon as possible after the completion of the call of Set","_","Handler.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"15.a/3"),(0,a.yg)(d.A,{items:["AI05-0094-1"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.yg)("strong",null),"The handler will still be executed. Under no circumstances is a scheduled call of a handler lost. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"15.b/3"),(0,a.yg)(d.A,{items:["AI05-0094-1"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"We say \u201cas soon as possible\u201d so that we do not deadlock if we are executing the handler when Set","_","Handler is called. In that case, the current invocation of the handler must complete before the new handler can start executing. ",(0,a.yg)("br",null))),(0,a.yg)(s.A,{mdxType:"MarginText"},"16/3"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The function Current","_","Handler returns the handler associated with the event Event if that event is set; otherwise, it returns ",(0,a.yg)("strong",null,"null"),".",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"17/3"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The procedure Cancel","_","Handler clears the event if it is set. Cancelled is assigned True if the event was set prior to it being cleared; otherwise, it is assigned False.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"18/3"),(0,a.yg)(d.A,{items:["AI95-00297-01","AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The function Time","_","Of","_","Event returns the time of the event if the event is set; otherwise, it returns Real","_","Time.Time","_","First.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"19/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"As part of the finalization of an object of type Timing","_","Event, the Timing","_","Event is cleared.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"19.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.yg)("strong",null),"This is the only finalization defined by the language that has a visible effect; but an implementation may have other finalization that it needs to perform. Implementations need to ensure that the event is cleared before anything else is finalized that would prevent a set event from being triggered. ",(0,a.yg)("br",null))),(0,a.yg)(s.A,{mdxType:"MarginText"},"20/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If several timing events are set for the same time, they are executed in FIFO order of being set.",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"21/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"An exception propagated from a handler invoked by a timing event has no effect.",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,a.yg)(s.A,{mdxType:"MarginText"},"22/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"For a given Timing","_","Event object, the implementation shall perform the operations declared in this package atomically with respect to any of these operations on the same Timing","_","Event object. The replacement of a handler by a call of Set","_","Handler shall be performed atomically with respect to the execution of the handler.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"22.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.yg)("strong",null),"This prevents various race conditions. In particular it ensures that if an event occurs when Set","_","Handler is changing the handler then either the new or old handler is executed in response to the appropriate event. It is never possible for a new handler to be executed in response to an old event. ",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"metrics"},"Metrics"),(0,a.yg)(s.A,{mdxType:"MarginText"},"23/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The implementation shall document the following metric: ",(0,a.yg)("br",null)),(0,a.yg)(s.A,{mdxType:"MarginText"},"24/3"),(0,a.yg)(d.A,{items:["AI05-0210-1"],mdxType:"MarginInfo"}),(0,a.yg)("ul",null,(0,a.yg)("li",null,"An upper bound on the lateness of the execution of a handler. That is, the maximum time between the time specified for the event and when a handler is actually invoked assuming no other handler or task is executing during this interval.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"24.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Documentation Requirement: "),"The metrics for timing events.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,a.yg)(s.A,{mdxType:"MarginText"},"25/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The protected handler procedure should be executed directly by the real-time clock interrupt mechanism.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"25.a/2"),(0,a.yg)(r.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,a.yg)("strong",null),"For a timing event, the handler should be executed directly by the real-time clock interrupt mechanism.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"26/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   Since a call of Set","_","Handler is not a potentially blocking operation, it can be called from within a handler.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"27/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   A Timing","_","Event","_","Handler can be associated with several Timing","_","Event objects.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"27.a/2"),(0,a.yg)(d.A,{items:["AI95-00297-01"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The package Real","_","Time.Timing","_","Events is new. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"27.b/3"),(0,a.yg)(d.A,{items:["AI05-0094-1"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.yg)("strong",null)," Reworded to eliminate a deadlock condition if the event time is in the past and a handler is currently executing. This is technically an inconsistency, but only if a program is depending on deadlocking; since it is impossible to imagine how that could be useful, we have not documented this as an inconsistency.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(s.A,{mdxType:"MarginText"},"27.c/3"),(0,a.yg)(d.A,{items:["AI05-0210-1"],mdxType:"MarginInfo"}),(0,a.yg)(r.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.yg)("strong",null)," Clarified the metric for lateness of a timing event to exclude interference from other handlers and tasks. This change might change the documentation of an implementation, but not the implementation itself, so there is no inconsistency. ",(0,a.yg)("br",null))))}u.isMDXComponent=!0}}]);