"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4768],{11027:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>A,frontMatter:()=>y,metadata:()=>g,toc:()=>u});var r=n(58168),a=(n(96540),n(15680)),i=n(20793),o=n(91435),l=n(21432),d=n(79162),s=n(34421);const y={sidebar_position:149},p="C.3 Interrupt Support",g={unversionedId:"arm/AA-C/AA-C.3",id:"arm/AA-C/AA-C.3",title:"C.3 Interrupt Support",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-C/AA-C.3.mdx",sourceDirName:"arm/AA-C",slug:"/arm/AA-C/AA-C.3",permalink:"/docs/arm/AA-C/AA-C.3",draft:!1,tags:[],version:"current",sidebarPosition:149,frontMatter:{sidebar_position:149},sidebar:"referenceManualSidebar",previous:{title:"C.2 Required Representation Support",permalink:"/docs/arm/AA-C/AA-C.2"},next:{title:"C.4 Preelaboration Requirements",permalink:"/docs/arm/AA-C/AA-C.4"}},m={},u=[{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"C.3.1  Protected Procedure Handlers",id:"c31--protected-procedure-handlers",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Metrics",id:"metrics",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"C.3.2  The Package Interrupts",id:"c32--the-package-interrupts",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Documentation Requirements",id:"documentation-requirements-1",level:4},{value:"Implementation Advice",id:"implementation-advice-2",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4}],c={toc:u},h="wrapper";function A(e){let{components:t,...n}=e;return(0,a.yg)(h,(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"c3-interrupt-support"},"C.3 Interrupt Support"),(0,a.yg)("admonition",{type:"warning"},(0,a.yg)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,a.yg)(d.A,{mdxType:"MarginText"},"1/3"),(0,a.yg)(s.A,{items:["AI05-0299-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"[This subclause specifies the language-defined model for hardware interrupts in addition to mechanisms for handling interrupts.] ",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"2"),(0,a.yg)("p",null,"[An ",(0,a.yg)("em",null,"interrupt")," represents a class of events that are detected by the hardware or the system software.] Interrupts are said to occur. An ",(0,a.yg)("em",null,"occurrence")," of an interrupt is separable into generation and delivery. ",(0,a.yg)("em",null,"Generation")," of an interrupt is the event in the underlying hardware or system that makes the interrupt available to the program. ",(0,a.yg)("em",null,"Delivery")," is the action that invokes part of the program as response to the interrupt occurrence. Between generation and delivery, the interrupt occurrence [(or interrupt)] is ",(0,a.yg)("em",null,"pending"),". Some or all interrupts may be ",(0,a.yg)("em",null,"blocked"),". When an interrupt is blocked, all occurrences of that interrupt are prevented from being delivered. Certain interrupts are ",(0,a.yg)("em",null,"reserved"),". The set of reserved interrupts is implementation defined. A reserved interrupt is either an interrupt for which user-defined handlers are not supported, or one which already has an attached handler by some other implementation-defined means. Program units can be connected to nonreserved interrupts. While connected, the program unit is said to be ",(0,a.yg)("em",null,"attached")," to that interrupt. The execution of that program unit, the ",(0,a.yg)("em",null,"interrupt handler"),", is invoked upon delivery of the interrupt occurrence. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"2.a/2"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("em",null,"This paragraph was deleted."),(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"2.b"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"To be honest: "),"As an obsolescent feature, interrupts may be attached to task entries by an address clause. See ",(0,a.yg)("a",{href:"../AA-J/AA-J.7#Subclause_J.7.1"},"J.7.1"),". ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"3"),(0,a.yg)("p",null,"While a handler is attached to an interrupt, it is called once for each delivered occurrence of that interrupt. While the handler executes, the corresponding interrupt is blocked.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"4"),(0,a.yg)("p",null,"While an interrupt is blocked, all occurrences of that interrupt are prevented from being delivered. Whether such occurrences remain pending or are lost is implementation defined.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"5"),(0,a.yg)("p",null,"Each interrupt has a ",(0,a.yg)("em",null,"default treatment")," which determines the system's response to an occurrence of that interrupt when no user-defined handler is attached. The set of possible default treatments is implementation defined, as is the method (if one exists) for configuring the default treatments for interrupts.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"6"),(0,a.yg)("p",null,"An interrupt is delivered to the handler (or default treatment) that is in effect for that interrupt at the time of delivery.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"7"),(0,a.yg)("p",null,"An exception propagated from a handler that is invoked by an interrupt has no effect.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"8"),(0,a.yg)("p",null,"[If the Ceiling","_","Locking policy (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.3"},"D.3"),") is in effect, the interrupt handler executes with the active priority that is the ceiling priority of the corresponding protected object.]",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,a.yg)(d.A,{mdxType:"MarginText"},"9/5"),(0,a.yg)(s.A,{items:["AI12-0445-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The implementation shall provide a mechanism to determine the minimum stack space that is necessary for each interrupt handler and to reserve that space for the execution of the handler. [This space should accommodate nested invocations of the handler where the system permits this.]",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"10"),(0,a.yg)("p",null,"If the hardware or the underlying system holds pending interrupt occurrences, the implementation shall provide for later delivery of these occurrences to the program.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"11"),(0,a.yg)("p",null,"If the Ceiling","_","Locking policy is not in effect, the implementation shall provide means for the application to specify whether interrupts are to be blocked during protected actions.",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"documentation-requirements"},"Documentation Requirements"),(0,a.yg)(d.A,{mdxType:"MarginText"},"12"),(0,a.yg)("p",null,"The implementation shall document the following items: ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"12.a"),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"This information may be different for different forms of interrupt handlers. ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"13"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"1."),(0,a.yg)("dl",null,(0,a.yg)("dd",null,"For each interrupt, which interrupts are blocked from delivery when a handler attached to that interrupt executes (either as a result of an interrupt delivery or of an ordinary call on a procedure of the corresponding protected object).",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"14"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"2."),(0,a.yg)("dd",null,"Any interrupts that cannot be blocked, and the effect of attaching handlers to such interrupts, if this is permitted.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"15"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"3."),(0,a.yg)("dd",null,"Which run-time stack an interrupt handler uses when it executes as a result of an interrupt delivery; if this is configurable, what is the mechanism to do so; how to specify how much space to reserve on that stack.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"16/5"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"4."),(0,a.yg)(s.A,{items:["AI12-0453-1"],mdxType:"MarginInfo"}),(0,a.yg)("dd",null,"Any implementation- or hardware-specific activity that happens before a user-defined interrupt handler gets control (for example, reading device registers, acknowledging devices).",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"17"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"5."),(0,a.yg)("dd",null,"Any timing or other limitations imposed on the execution of interrupt handlers.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"18"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"6."),(0,a.yg)("dd",null,"The state (blocked/unblocked) of the nonreserved interrupts when the program starts; if some interrupts are unblocked, what is the mechanism a program can use to protect itself before it can attach the corresponding handlers.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"19"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"7."),(0,a.yg)("dd",null,"Whether the interrupted task is allowed to resume execution before the interrupt handler returns.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"20/5"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"8."),(0,a.yg)(s.A,{items:["AI12-0453-1"],mdxType:"MarginInfo"}),(0,a.yg)("dd",null,"The treatment of interrupt occurrences that are generated while the interrupt is blocked; that is, whether one or more occurrences are held for later delivery, or all are lost.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"21"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"9."),(0,a.yg)("dd",null,"Whether predefined or implementation-defined exceptions are raised as a result of the occurrence of any interrupt, and the mapping between the machine interrupts (or traps) and the predefined exceptions.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"22"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"10."),(0,a.yg)("dd",null,"On a multi-processor, the rules governing the delivery of an interrupt to a particular processor. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"22.a/2"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Documentation Requirement: "),"The treatment of interrupts.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,a.yg)(d.A,{mdxType:"MarginText"},"23/2"),(0,a.yg)(s.A,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If the underlying system or hardware does not allow interrupts to be blocked, then no blocking is required [as part of the execution of subprograms of a protected object for which one of its subprograms is an interrupt handler].",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"24"),(0,a.yg)("p",null,"In a multi-processor with more than one interrupt subsystem, it is implementation defined whether (and how) interrupt sources from separate subsystems share the same Interrupt","_","Id type (see ",(0,a.yg)("a",{href:"../AA-C/AA-C.3#Subclause_C.3.2"},"C.3.2"),"). In particular, the meaning of a blocked or pending interrupt may then be applicable to one processor only. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"24.a"),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"This issue is tightly related to the issue of scheduling on a multi-processor. In a sense, if a particular interrupt source is not available to all processors, the system is not truly homogeneous.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"24.b/5"),(0,a.yg)(s.A,{items:["AI12-0453-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"One way to approach this problem is to assign sub-ranges within Interrupt","_","Id to each interrupt subsystem, such that \u201csimilar\u201d interrupt sources (for example a timer) in different subsystems get a distinct id. ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"25"),(0,a.yg)("p",null,"Implementations are allowed to impose timing or other limitations on the execution of interrupt handlers. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.a"),(0,a.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.yg)("strong",null),"These limitations are often necessary to ensure proper behavior of the implementation. ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"26/3"),(0,a.yg)(s.A,{items:["AI95-00434-01","AI05-0299-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"Other forms of handlers are allowed to be supported, in which case the rules of this subclause should be adhered to.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"27"),(0,a.yg)("p",null,"The active priority of the execution of an interrupt handler is allowed to vary from one occurrence of the same interrupt to another.",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,a.yg)(d.A,{mdxType:"MarginText"},"28/2"),(0,a.yg)(s.A,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If the Ceiling","_","Locking policy is not in effect, the implementation should provide means for the application to specify which interrupts are to be blocked during protected actions, if the underlying system allows for finer-grained control of interrupt blocking. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"28.a/2"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,a.yg)("strong",null),"If the Ceiling","_","Locking policy is not in effect and the target system allows for finer-grained control of interrupt blocking, a means for the application to specify which interrupts are to be blocked during protected actions should be provided.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"29/5"),(0,a.yg)(s.A,{items:["AI12-0447-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   The default treatment for an interrupt can be to keep the interrupt pending or to deliver it to an implementation-defined handler. Examples of actions that an implementation-defined handler can perform include aborting the partition, ignoring (that is, discarding occurrences of) the interrupt, or queuing one or more occurrences of the interrupt for possible later delivery when a user-defined handler is attached to that interrupt.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"30"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   It is a bounded error to call Task","_","Identification.Current","_","Task (see ",(0,a.yg)("a",{href:"../AA-C/AA-C.7#Subclause_C.7.1"},"C.7.1"),") from an interrupt handler.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"31"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   The rule that an exception propagated from an interrupt handler has no effect is modeled after the rule about exceptions propagated out of task bodies.",(0,a.yg)("br",null))),(0,a.yg)("a",{id:"Subclause_C.3.1"}),(0,a.yg)("h2",{id:"c31--protected-procedure-handlers"},"C.3.1  Protected Procedure Handlers"),(0,a.yg)("p",null,(0,a.yg)("em",null,"Paragraphs 1 through 6 were moved to ",(0,a.yg)("a",{href:"../AA-J/"},"Annex J"),", \u201c",(0,a.yg)("a",{href:"../AA-J/"},"Obsolescent Features"),"\u201d.")," ",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"static-semantics"},"Static Semantics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"6.1/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"For a parameterless protected procedure, the following language-defined representation aspects may be specified: ",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"6.2/3_C.3.1"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"Interrupt","_","Handler"),(0,a.yg)("dl",null,(0,a.yg)("dd",null," The type of aspect Interrupt","_","Handler is Boolean. If directly specified, the aspect","_","definition shall be a static expression. [This aspect is never inherited;] if not directly specified, the aspect is False.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"6.a/3_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Aspect Description for "),(0,a.yg)("strong",null,"Interrupt","_","Handler: "),"Protected procedure may be attached to interrupts.",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"6.3/3_C.3.1"),(0,a.yg)("dt",null,(0,a.yg)("br",null),"Attach","_","Handler"),(0,a.yg)("dl",null,(0,a.yg)("dd",null," The aspect Attach","_","Handler is an ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", which shall be of type Interrupts.Interrupt","_","Id. [This aspect is never inherited.]",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"6.b/3_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Aspect Description for "),(0,a.yg)("strong",null,"Attach","_","Handler: "),"Protected procedure is attached to an interrupt.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"legality-rules"},"Legality Rules"),(0,a.yg)(d.A,{mdxType:"MarginText"},"7/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00434-01","AI05-0033-1","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If either the Attach","_","Handler or Interrupt","_","Handler aspect are specified for a protected procedure, the corresponding ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-9/AA-9.4#S0249"},"protected","_","type","_","declaration"))," or ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-9/AA-9.4#S0250"},"single","_","protected","_","declaration"))," shall be a library-level declaration and shall not be declared within a generic body. In addition to the places where Legality Rules normally apply (see ",(0,a.yg)("a",{href:"../AA-12/AA-12.3"},"12.3"),"), this rule also applies in the private part of an instance of a generic unit.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"7.a_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"In the case of a ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-9/AA-9.4#S0249"},"protected_type_declaration")),", an ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," of an object of that type need not be at library level.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"7.b/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0033-1","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"We cannot allow these aspects in protected declarations in a generic body, because legality rules are not checked for instance bodies, and these should not be allowed if the instance is not at the library level. The protected types can be declared in the private part if this is desired. Note that while the 'Access to use the handler would provide the check in the case of Interrupt","_","Handler, there is no other check for Attach","_","Handler. Since these aspects are so similar, we want the rules to be the same. ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"8/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00253-01","AI95-00303-01","AI05-0033-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,(0,a.yg)("em",null,"This paragraph was deleted."),(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"9/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If the Interrupt","_","Handler aspect of a protected procedure is True, then the procedure may be attached dynamically, as a handler, to interrupts (see ",(0,a.yg)("a",{href:"../AA-C/AA-C.3#Subclause_C.3.2"},"C.3.2"),"). [Such procedures are allowed to be attached to multiple interrupts.]",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"10/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," specified for the Attach","_","Handler aspect of a protected procedure ",(0,a.yg)("em",null,"P")," is evaluated as part of the creation of the protected object that contains ",(0,a.yg)("em",null,"P"),". The value of the ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," identifies an interrupt. As part of the initialization of that object, ",(0,a.yg)("em",null,"P")," (the ",(0,a.yg)("em",null,"handler")," procedure) is attached to the identified interrupt. A check is made that the corresponding interrupt is not reserved. Program","_","Error is raised if the check fails, and the existing treatment for the interrupt is not affected.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"11/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00434-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If the Ceiling","_","Locking policy (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.3"},"D.3"),") is in effect, then upon the initialization of a protected object that contains a protected procedure for which either the Attach","_","Handler aspect is specified or the  Interrupt","_","Handler aspect is True, a check is made that the initial ceiling priority of the object is in the range of System.Interrupt","_","Priority. If the check fails, Program","_","Error is raised.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"12/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00121-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"{",(0,a.yg)("em",null,"8652/0068"),"}"," When a protected object is finalized, for any of its procedures that are attached to interrupts, the handler is detached. If the handler was attached by a procedure in the Interrupts package or if no user handler was previously attached to the interrupt, the default treatment is restored. If the Attach","_","Handler aspect was specified and the most recently attached handler for the same interrupt is the same as the one that was attached at the time the protected object was initialized, the previous handler is restored. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"12.a/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00121-01","AI95-00303-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"{",(0,a.yg)("em",null,"8652/0068"),"}"," If all protected objects for interrupt handlers are declared at the library level, the finalization discussed above occurs only as part of the finalization of all library-level packages in a partition. However, objects of a protected type containing procedures with an Attach","_","Handler aspect specified need not be at the library level. Thus, an implementation needs to be able to restore handlers during the execution of the program. (An object with an Interrupt","_","Handler aspect also need not be at the library level, but such a handler cannot be attached to an interrupt using the Interrupts package.) ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"13_C.3.1"),(0,a.yg)("p",null,"When a handler is attached to an interrupt, the interrupt is blocked [(subject to the Implementation Permission in ",(0,a.yg)("a",{href:"../AA-C/AA-C.3"},"C.3"),")] during the execution of every protected action on the protected object containing the handler.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"13.1/5_C.3.1"),(0,a.yg)(s.A,{items:["AI12-0252-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If restriction No","_","Dynamic","_","Attachment is in effect, then a check is made that the interrupt identified by an Attach","_","Handler aspect does not appear in any previously elaborated Attach","_","Handler aspect; Program","_","Error is raised if this check fails.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"13.a/5_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.yg)("strong",null),"When No","_","Dynamic","_","Attachment is in effect, it is not possible to call any previous handler. Therefore, the only possibility is to replace the original handler, rendering it ineffective. Having an unused handler in a program is likely a bug, so we require an exception to be raised. ",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,a.yg)(d.A,{mdxType:"MarginText"},"14_C.3.1"),(0,a.yg)("p",null,"If the Ceiling","_","Locking policy (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.3"},"D.3"),") is in effect and an interrupt is delivered to a handler, and the interrupt hardware priority is higher than the ceiling priority of the corresponding protected object, the execution of the program is erroneous.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"14.1/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00121-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"{",(0,a.yg)("em",null,"8652/0068"),"}"," If the handlers for a given interrupt attached via aspect Attach","_","Handler are not attached and detached in a stack-like (LIFO) order, program execution is erroneous. In particular, when a protected object is finalized, the execution is erroneous if any of the procedures of the protected object are attached to interrupts via aspect Attach","_","Handler and the most recently attached handler for the same interrupt is not the same as the one that was attached at the time the protected object was initialized. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"14.a/3_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00121-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"{",(0,a.yg)("em",null,"8652/0068"),"}"," This simplifies implementation of the Attach","_","Handler aspect by not requiring a check that the current handler is the same as the one attached by the initialization of a protected object. ",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"metrics"},"Metrics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"15_C.3.1"),(0,a.yg)("p",null,"The following metric shall be documented by the implementation: ",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"16/2_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,a.yg)("ul",null,(0,a.yg)("li",null,"The worst-case overhead for an interrupt handler that is a parameterless protected procedure, in clock cycles. This is the execution time not directly attributable to the handler procedure or the interrupted execution. It is estimated as C \u2013 (A+B), where A is how long it takes to complete a given sequence of instructions without any interrupt, B is how long it takes to complete a normal call to a given protected procedure, and C is how long it takes to complete the same sequence of instructions when it is interrupted by one execution of the same procedure called via an interrupt. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"16.a_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.yg)("strong",null),"The instruction sequence and interrupt handler used to measure interrupt handling overhead should be chosen so as to maximize the execution time cost due to cache misses. For example, if the processor has cache memory and the activity of an interrupt handler could invalidate the contents of cache memory, the handler should be written such that it invalidates all of the cache memory. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"16.b/2_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Documentation Requirement: "),"The metrics for interrupt handlers.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,a.yg)(d.A,{mdxType:"MarginText"},"17/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"When the aspects Attach","_","Handler or Interrupt","_","Handler are specified for a protected procedure, the implementation is allowed to impose implementation-defined restrictions on the corresponding ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-9/AA-9.4#S0249"},"protected","_","type","_","declaration"))," and ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-9/AA-9.4#S0254"},"protected","_","body")),". ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"17.a_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.yg)("strong",null),"The restrictions may be on the constructs that are allowed within them, and on ordinary calls (i.e. not via interrupts) on protected operations in these protected objects. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"17.b/3_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-defined",mdxType:"Admonition"},(0,a.yg)("strong",null),"Any restrictions on a protected procedure or its containing type when an aspect Attach","_","handler or Interrupt","_","Handler is specified.",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"18_C.3.1"),(0,a.yg)("p",null,"An implementation may use a different mechanism for invoking a protected procedure in response to a hardware interrupt than is used for a call to that protected procedure from a task. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"18.a_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.yg)("strong",null),"This is despite the fact that the priority of an interrupt handler (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.1"},"D.1"),") is modeled after a hardware task calling the handler. ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"19/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"Notwithstanding what this subclause says elsewhere, the Attach","_","Handler and Interrupt","_","Handler aspects are allowed to be used for other, implementation defined, forms of interrupt handlers. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"19.a/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.yg)("strong",null),"For example, if an implementation wishes to allow interrupt handlers to have parameters, it is allowed to do so via these aspects; it need not invent implementation-defined aspects for the purpose. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"19.b/3_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-defined",mdxType:"Admonition"},(0,a.yg)("strong",null),"Any other forms of interrupt handler supported by the Attach","_","Handler and Interrupt","_","Handler aspects.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,a.yg)(d.A,{mdxType:"MarginText"},"20_C.3.1"),(0,a.yg)("p",null,"Whenever possible, the implementation should allow interrupt handlers to be called directly by the hardware. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"20.a/2_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,a.yg)("strong",null),"Interrupt handlers should be called directly by the hardware.",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"21_C.3.1"),(0,a.yg)("p",null,"Whenever practical, the implementation should detect violations of any implementation-defined restrictions before run time. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"21.a/2_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,a.yg)("strong",null),"Violations of any implementation-defined restrictions on interrupt handlers should be detected before run time.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"22/5_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1","AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   The Attach","_","Handler aspect can provide static attachment of handlers to interrupts if the implementation supports preelaboration of protected objects. (See ",(0,a.yg)("a",{href:"../AA-C/AA-C.4"},"C.4"),".)",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"23/5_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00434-01","AI12-0442-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   For a protected object that has a (protected) procedure attached to an interrupt, the correct ceiling priority is at least as high as the highest processor priority at which that interrupt will ever be delivered.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"24_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   Protected procedures can also be attached dynamically to interrupts via operations declared in the predefined package Interrupts.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25_C.3.1"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 4   An example of a possible implementation-defined restriction is disallowing the use of the standard storage pools within the body of a protected procedure that is an interrupt handler.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"incompatibilities-with-ada-95"},"Incompatibilities With Ada 95")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.a/2_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00253-01"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.yg)("strong",null,"Amendment ")," Corrected the wording so that the rules for the use of Attach","_","Handler and Interrupt","_","Handler are identical. This means that uses of pragma Interrupt","_","Handler outside of the target protected type or single protected object are now illegal. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.b/2_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00121-01"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,a.yg)("em",null,"8652/0068"),"}"," ",(0,a.yg)("strong",null,"Corrigendum:")," Clarified the meaning of \u201cthe previous handler\u201d when finalizing protected objects containing interrupt handlers.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.c/2_C.3.1"),(0,a.yg)(s.A,{items:["AI95-00303-01"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Dropped the requirement that an object of a type containing an Interrupt","_","Handler pragma must be declared at the library level. This was a generic contract model violation. This change is not an extension, as an attempt to attach such a handler with a routine in package Interrupts will fail an accessibility check anyway. Moreover, implementations can retain the rule as an implementation-defined restriction on the use of the type, as permitted by the Implementation Permissions above. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.d/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Aspects Interrupt","_","Handler and Attach","_","Handler are new; ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s Interrupt","_","Handler and Attach","_","Handler are now obsolescent. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.e/3_C.3.1"),(0,a.yg)(s.A,{items:["AI05-0033-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.yg)("strong",null)," Added missing generic contract wording for the aspects Attach","_","Handler and Interrupt","_","Handler. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"inconsistencies-with-ada-2012"},"Inconsistencies With Ada 2012")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.f/5_C.3.1"),(0,a.yg)(s.A,{items:["AI12-0252-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.yg)("strong",null)," Program","_","Error might be raised if two handlers are attached when restriction No","_","Dynamic","_","Attachment is in effect (including as part of the Ravenscar profile). Original Ada 2012 would have just ignored the first handler. This is almost certainly a bug rather than an intended result. ",(0,a.yg)("br",null))),(0,a.yg)("a",{id:"Subclause_C.3.2"}),(0,a.yg)("h2",{id:"c32--the-package-interrupts"},"C.3.2  The Package Interrupts"),(0,a.yg)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"1_C.3.2"),(0,a.yg)("p",null,"The following language-defined packages exist: ",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"2/5_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0167-1","AI12-0241-1","AI12-0302-1"],mdxType:"MarginInfo"}),(0,a.yg)(l.A,{language:"ada",mdxType:"CodeBlock"},"with System;","\n","with System.Multiprocessors;","\n","package Ada.Interrupts","\n","   with Nonblocking, Global =",">"," in out synchronized is","\n","   type Interrupt","_","Id is implementation-defined;","\n","   type Parameterless","_","Handler is","\n","      access protected procedure","\n","      with Nonblocking =",">"," False;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"3/1_C.3.2"),"This paragraph was deleted.","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"4_C.3.2"),"function Is","_","Reserved (Interrupt : Interrupt","_","Id)","\n","      return Boolean;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"5_C.3.2"),"function Is","_","Attached (Interrupt : Interrupt","_","Id)","\n","      return Boolean;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"6_C.3.2"),"function Current","_","Handler (Interrupt : Interrupt","_","Id)","\n","      return Parameterless","_","Handler;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"7_C.3.2"),"procedure Attach","_","Handler","\n","      (New","_","Handler : in Parameterless","_","Handler;","\n","       Interrupt   : in Interrupt","_","Id);","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"8_C.3.2"),"procedure Exchange","_","Handler","\n","      (Old","_","Handler : out Parameterless","_","Handler;","\n","       New","_","Handler : in Parameterless","_","Handler;","\n","       Interrupt   : in Interrupt","_","Id);","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"9_C.3.2"),"procedure Detach","_","Handler","\n","      (Interrupt : in Interrupt","_","Id);","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"10_C.3.2"),"function Reference (Interrupt : Interrupt","_","Id)","\n","      return System.Address;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"10.1/3_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0167-1"],mdxType:"MarginInfo"}),"function Get","_","CPU (Interrupt : Interrupt","_","Id)","\n","      return System.Multiprocessors.CPU","_","Range;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"11_C.3.2"),"private","\n","   ... -- not specified by the language","\n","end Ada.Interrupts;","\n",(0,a.yg)(d.A,{mdxType:"MarginText"},"12/5_C.3.2"),(0,a.yg)(s.A,{items:["AI12-0302-1"],mdxType:"MarginInfo"}),"package Ada.Interrupts.Names ","\n","   with Nonblocking, Global =",">"," null is","\n","   implementation-defined : constant Interrupt","_","Id :=","\n","     implementation-defined;","\n","      . . .","\n","   implementation-defined : constant Interrupt","_","Id :=","\n","     implementation-defined;","\n","end Ada.Interrupts.Names;","\n"),(0,a.yg)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,a.yg)(d.A,{mdxType:"MarginText"},"13_C.3.2"),(0,a.yg)("p",null,"The Interrupt","_","Id type is an implementation-defined discrete type used to identify interrupts.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"14_C.3.2"),(0,a.yg)("p",null,"The Is","_","Reserved function returns True if and only if the specified interrupt is reserved.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"15_C.3.2"),(0,a.yg)("p",null,"The Is","_","Attached function returns True if and only if a user-specified interrupt handler is attached to the interrupt.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"16/1_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00166-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"{",(0,a.yg)("em",null,"8652/0069"),"}"," The Current","_","Handler function returns a value that represents the attached handler of the interrupt. If no user-defined handler is attached to the interrupt, Current","_","Handler returns ",(0,a.yg)("strong",null,"null"),".",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"17/3_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The Attach","_","Handler procedure attaches the specified handler to the interrupt, overriding any existing treatment (including a user handler) in effect for that interrupt. If New","_","Handler is ",(0,a.yg)("strong",null,"null"),", the default treatment is restored. If New","_","Handler designates a protected procedure for which the aspect Interrupt","_","Handler is False, Program","_","Error is raised. In this case, the operation does not modify the existing interrupt treatment.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"18/1_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00166-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"{",(0,a.yg)("em",null,"8652/0069"),"}"," The Exchange","_","Handler procedure operates in the same manner as Attach","_","Handler with the addition that the value returned in Old","_","Handler designates the previous treatment for the specified interrupt. If the previous treatment is not a user-defined handler, ",(0,a.yg)("strong",null,"null")," is returned. ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"18.a_C.3.2"),(0,a.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.yg)("strong",null),"Calling Attach","_","Handler or Exchange","_","Handler with this value for New","_","Handler restores the previous handler.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"18.a.1/1_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00166-01"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,a.yg)("em",null,"8652/0069"),"}"," If the application uses only parameterless procedures as handlers (other types of handlers may be provided by the implementation, but are not required by the standard), then if Old","_","Handler is not ",(0,a.yg)("strong",null,"null"),", it may be called to execute the previous handler. This provides a way to cascade application interrupt handlers. However, the default handler cannot be cascaded this way (Old","_","Handler must be ",(0,a.yg)("strong",null,"null")," for the default handler). ",(0,a.yg)("br",null))),(0,a.yg)(d.A,{mdxType:"MarginText"},"19_C.3.2"),(0,a.yg)("p",null,"The Detach","_","Handler procedure restores the default treatment for the specified interrupt.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"20_C.3.2"),(0,a.yg)("p",null,"For all operations defined in this package that take a parameter of type Interrupt","_","Id, with the exception of Is","_","Reserved and Reference, a check is made that the specified interrupt is not reserved. Program","_","Error is raised if this check fails.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"21/3_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"If, by using the Attach","_","Handler, Detach","_","Handler, or Exchange","_","Handler procedures, an attempt is made to detach a handler that was attached statically (using the aspect Attach","_","Handler), the handler is not detached and Program","_","Error is raised.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"22/2_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00434-01"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The Reference function returns a value of type System.Address that can be used to attach a task entry via an address clause (see ",(0,a.yg)("a",{href:"../AA-J/AA-J.7#Subclause_J.7.1"},"J.7.1"),") to the interrupt specified by Interrupt. This function raises Program","_","Error if attaching task entries to interrupts (or to this particular interrupt) is not supported.",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"22.1/3_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0153-3"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The function Get","_","CPU returns the processor on which the handler for Interrupt is executed. If the handler can execute on more than one processor the value System.Multiprocessors.Not","_","A","_","Specific","_","CPU is returned.",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,a.yg)(d.A,{mdxType:"MarginText"},"23_C.3.2"),(0,a.yg)("p",null,"At no time during attachment or exchange of handlers shall the current handler of the corresponding interrupt be undefined.",(0,a.yg)("br",null)),(0,a.yg)("h4",{id:"documentation-requirements-1"},"Documentation Requirements"),(0,a.yg)(d.A,{mdxType:"MarginText"},"24/5_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00434-01","AI05-0229-1","AI12-0320-1","AI12-0444-1"],mdxType:"MarginInfo"}),(0,a.yg)("p",null,"The implementation shall document, when the Ceiling","_","Locking policy (see ",(0,a.yg)("a",{href:"../AA-D/AA-D.3"},"D.3"),") is in effect, the default ceiling priority assigned to a protected object that contains a protected procedure that specifies either the Attach","_","Handler or Interrupt","_","Handler aspects, but does not specify the Interrupt","_","Priority aspect. [This default can be different for different interrupts.] ",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"24.a.1/3_C.3.2"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.yg)("strong",null,"Documentation Requirement: "),"If the Ceiling","_","Locking policy is in effect, the default ceiling priority for a protected object that specifies an interrupt handler aspect.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"implementation-advice-2"},"Implementation Advice"),(0,a.yg)(d.A,{mdxType:"MarginText"},"25_C.3.2"),(0,a.yg)("p",null,"If implementation-defined forms of interrupt handler procedures are supported, such as protected procedures with parameters, then for each such form of a handler, a type analogous to Parameterless","_","Handler should be specified in a child package of Interrupts, with the same operations as in the predefined package Interrupts.",(0,a.yg)("br",null)),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"25.a/2_C.3.2"),(0,a.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,a.yg)("strong",null),"If implementation-defined forms of interrupt handler procedures are supported, then for each such form of a handler, a type analogous to Parameterless","_","Handler should be specified in a child package of Interrupts, with the same operations as in the predefined package Interrupts.",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"26_C.3.2"),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE   The package Interrupts.Names contains implementation-defined names (and constant values) for the interrupts that are supported by the implementation.",(0,a.yg)("br",null))),(0,a.yg)("h4",{id:"examples"},"Examples"),(0,a.yg)(d.A,{mdxType:"MarginText"},"27_C.3.2"),(0,a.yg)("p",null,(0,a.yg)("em",null,"Example of interrupt handlers:")," ",(0,a.yg)("br",null)),(0,a.yg)(d.A,{mdxType:"MarginText"},"28/5_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0229-1","AI12-0178-1"],mdxType:"MarginInfo"}),(0,a.yg)(l.A,{language:"ada",mdxType:"CodeBlock"},"Device","_","Priority : constant","\n","  array (Ada.Interrupts.Interrupt","_","Id range 1..5) of","\n","    System.Interrupt","_","Priority := ( ... );","\n","protected type Device","_","Interface","\n","  (Int","_","Id : Ada.Interrupts.Interrupt","_","Id) ","\n","     with Interrupt","_","Priority =",">"," Device","_","Priority(Int","_","Id) is","\n","  procedure Handler","\n","     with Attach","_","Handler =",">"," Int","_","Id;","\n","  ...","\n","end Device","_","Interface;","\n","  ...","\n","Device","_","1","_","Driver : Device","_","Interface(1);","\n","  ...","\n","Device","_","5","_","Driver : Device","_","Interface(5);","\n","  ...","\n"),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"28.a/2_C.3.2"),(0,a.yg)(s.A,{items:["AI95-00166-01"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,a.yg)("em",null,"8652/0069"),"}"," ",(0,a.yg)("strong",null,"Corrigendum:")," Clarified that the value returned by Current","_","Handler and Exchange","_","Handler for the default treatment is null. ",(0,a.yg)("br",null))),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005")),(0,a.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,a.yg)(d.A,{mdxType:"MarginText"},"28.b/3_C.3.2"),(0,a.yg)(s.A,{items:["AI05-0167-1"],mdxType:"MarginInfo"}),(0,a.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Function Get","_","CPU is added to Interrupts. If Interrupts is referenced in a ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause")),", and an entity ",(0,a.yg)("em",null,"E")," with a ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," of Get","_","CPU is defined in a package that is also referenced in a ",(0,a.yg)("code",null,(0,a.yg)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause")),", the entity ",(0,a.yg)("em",null,"E")," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,a.yg)("br",null))))}A.isMDXComponent=!0}}]);