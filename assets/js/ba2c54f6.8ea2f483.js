"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[312],{1716:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=c(a),u=i,m=h["".concat(l,".").concat(u)]||h[u]||p[u]||s;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9666:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const s={sidebar_position:4},o="3 Declarations and Types",r={unversionedId:"arm/AA-3",id:"arm/AA-3",title:"3 Declarations and Types",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-3.md",sourceDirName:"arm",slug:"/arm/AA-3",permalink:"/docs/arm/AA-3",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"2 Lexical Elements",permalink:"/docs/arm/AA-2"},next:{title:"4 Names and Expressions",permalink:"/docs/arm/AA-4"}},l={},c=[{value:"3.1  Declarations",id:"31--declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"3.2  Types and Subtypes",id:"32--types-and-subtypes",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"3.2.1  Type Declarations",id:"321--type-declarations",level:3},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"3.2.2  Subtype Declarations",id:"322--subtype-declarations",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"3.2.3  Classification of Operations",id:"323--classification-of-operations",level:3},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"3.3  Objects and Named Numbers",id:"33--objects-and-named-numbers",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"3.3.1  Object Declarations",id:"331--object-declarations",level:3},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4},{value:"3.3.2  Number Declarations",id:"332--number-declarations",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-7",level:4},{value:"3.4  Derived Types and Classes",id:"34--derived-types-and-classes",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-8",level:4},{value:"3.4.1  Derivation Classes",id:"341--derivation-classes",level:3},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"3.5  Scalar Types",id:"35--scalar-types",level:2},{value:"Syntax",id:"syntax-6",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-9",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-6",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-5",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-9",level:4},{value:"3.5.1  Enumeration Types",id:"351--enumeration-types",level:3},{value:"Syntax",id:"syntax-7",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-10",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-7",level:4},{value:"Examples",id:"examples-6",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-10",level:4},{value:"3.5.2  Character Types",id:"352--character-types",level:3},{value:"Static Semantics",id:"static-semantics-11",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples-7",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-6",level:4},{value:"3.5.3  Boolean Types",id:"353--boolean-types",level:3},{value:"Static Semantics",id:"static-semantics-12",level:4},{value:"3.5.4  Integer Types",id:"354--integer-types",level:3},{value:"Syntax",id:"syntax-8",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-13",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-8",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Examples",id:"examples-8",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-7",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-11",level:4},{value:"3.5.5  Operations of Discrete Types",id:"355--operations-of-discrete-types",level:3},{value:"Static Semantics",id:"static-semantics-14",level:4},{value:"Implementation Advice",id:"implementation-advice-2",level:4},{value:"Examples",id:"examples-9",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-8",level:4},{value:"3.5.6  Real Types",id:"356--real-types",level:3},{value:"Syntax",id:"syntax-9",level:4},{value:"Static Semantics",id:"static-semantics-15",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-9",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-12",level:4},{value:"3.5.7  Floating Point Types",id:"357--floating-point-types",level:3},{value:"Syntax",id:"syntax-10",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-5",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Static Semantics",id:"static-semantics-16",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-10",level:4},{value:"Implementation Requirements",id:"implementation-requirements-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-4",level:4},{value:"Implementation Advice",id:"implementation-advice-3",level:4},{value:"Examples",id:"examples-10",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-13",level:4},{value:"3.5.8  Operations of Floating Point Types",id:"358--operations-of-floating-point-types",level:3},{value:"Static Semantics",id:"static-semantics-17",level:4},{value:"3.5.9  Fixed Point Types",id:"359--fixed-point-types",level:3},{value:"Syntax",id:"syntax-11",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-6",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Static Semantics",id:"static-semantics-18",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-11",level:4},{value:"Implementation Requirements",id:"implementation-requirements-3",level:4},{value:"Implementation Permissions",id:"implementation-permissions-5",level:4},{value:"Examples",id:"examples-11",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-9",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-14",level:4},{value:"3.5.10  Operations of Fixed Point Types",id:"3510--operations-of-fixed-point-types",level:3},{value:"Static Semantics",id:"static-semantics-19",level:4},{value:"3.6  Array Types",id:"36--array-types",level:2},{value:"Syntax",id:"syntax-12",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-7",level:4},{value:"Legality Rules",id:"legality-rules-8",level:4},{value:"Static Semantics",id:"static-semantics-20",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-12",level:4},{value:"Examples",id:"examples-12",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-10",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-15",level:4},{value:"3.6.1  Index Constraints and Discrete Ranges",id:"361--index-constraints-and-discrete-ranges",level:3},{value:"Syntax",id:"syntax-13",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-8",level:4},{value:"Legality Rules",id:"legality-rules-9",level:4},{value:"Static Semantics",id:"static-semantics-21",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-13",level:4},{value:"Examples",id:"examples-13",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-11",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-16",level:4},{value:"3.6.2  Operations of Array Types",id:"362--operations-of-array-types",level:3},{value:"Legality Rules",id:"legality-rules-10",level:4},{value:"Static Semantics",id:"static-semantics-22",level:4},{value:"Implementation Advice",id:"implementation-advice-4",level:4},{value:"Examples",id:"examples-14",level:4},{value:"3.6.3  String Types",id:"363--string-types",level:3},{value:"Static Semantics",id:"static-semantics-23",level:4},{value:"Examples",id:"examples-15",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-4",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-5",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-12",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-17",level:4},{value:"3.7  Discriminants",id:"37--discriminants",level:2},{value:"Syntax",id:"syntax-14",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-9",level:4},{value:"Legality Rules",id:"legality-rules-11",level:4},{value:"Static Semantics",id:"static-semantics-24",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-14",level:4},{value:"Examples",id:"examples-16",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-13",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-18",level:4},{value:"3.7.1  Discriminant Constraints",id:"371--discriminant-constraints",level:3},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax-15",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-10",level:4},{value:"Legality Rules",id:"legality-rules-12",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-15",level:4},{value:"Examples",id:"examples-17",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-5",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-19",level:4},{value:"3.7.2  Operations of Discriminated Types",id:"372--operations-of-discriminated-types",level:3},{value:"Static Semantics",id:"static-semantics-25",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-14",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-20",level:4},{value:"3.8  Record Types",id:"38--record-types",level:2},{value:"Syntax",id:"syntax-16",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-11",level:4},{value:"Legality Rules",id:"legality-rules-13",level:4},{value:"Static Semantics",id:"static-semantics-26",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-16",level:4},{value:"Examples",id:"examples-18",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-15",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-21",level:4},{value:"3.8.1  Variant Parts and Discrete Choices",id:"381--variant-parts-and-discrete-choices",level:3},{value:"Language Design Principles",id:"language-design-principles-1",level:4},{value:"Syntax",id:"syntax-17",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-12",level:4},{value:"Legality Rules",id:"legality-rules-14",level:4},{value:"Static Semantics",id:"static-semantics-27",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-17",level:4},{value:"Examples",id:"examples-19",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-16",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-22",level:4},{value:"3.9  Tagged Types and Type Extensions",id:"39--tagged-types-and-type-extensions",level:2},{value:"Language Design Principles",id:"language-design-principles-2",level:4},{value:"Static Semantics",id:"static-semantics-28",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-18",level:4},{value:"Implementation Permissions",id:"implementation-permissions-6",level:4},{value:"Examples",id:"examples-20",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-17",level:4},{value:"3.9.1  Type Extensions",id:"391--type-extensions",level:3},{value:"Language Design Principles",id:"language-design-principles-3",level:4},{value:"Syntax",id:"syntax-18",level:4},{value:"Legality Rules",id:"legality-rules-15",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-19",level:4},{value:"Examples",id:"examples-21",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-18",level:4},{value:"3.9.2  Dispatching Operations of Tagged Types",id:"392--dispatching-operations-of-tagged-types",level:3},{value:"Language Design Principles",id:"language-design-principles-4",level:4},{value:"Static Semantics",id:"static-semantics-29",level:4},{value:"Legality Rules",id:"legality-rules-16",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-20",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-19",level:4},{value:"3.9.3  Abstract Types and Subprograms",id:"393--abstract-types-and-subprograms",level:3},{value:"Language Design Principles",id:"language-design-principles-5",level:4},{value:"Legality Rules",id:"legality-rules-17",level:4},{value:"Examples",id:"examples-22",level:4},{value:"Syntax",id:"syntax-19",level:4},{value:"Static Semantics",id:"static-semantics-30",level:4},{value:"3.10  Access Types",id:"310--access-types",level:2},{value:"Language Design Principles",id:"language-design-principles-6",level:4},{value:"Syntax",id:"syntax-20",level:4},{value:"Static Semantics",id:"static-semantics-31",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-21",level:4},{value:"Examples",id:"examples-23",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-20",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-23",level:4},{value:"3.10.1  Incomplete Type Declarations",id:"3101--incomplete-type-declarations",level:3},{value:"Syntax",id:"syntax-21",level:4},{value:"Legality Rules",id:"legality-rules-18",level:4},{value:"Static Semantics",id:"static-semantics-32",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-22",level:4},{value:"Examples",id:"examples-24",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-21",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-24",level:4},{value:"3.10.2  Operations of Access Types",id:"3102--operations-of-access-types",level:3},{value:"Language Design Principles",id:"language-design-principles-7",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-13",level:4},{value:"Static Semantics",id:"static-semantics-33",level:4},{value:"Examples",id:"examples-25",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-22",level:4},{value:"3.11  Declarative Parts",id:"311--declarative-parts",level:2},{value:"Syntax",id:"syntax-22",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-23",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-23",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-25",level:4},{value:"3.11.1  Completions of Declarations",id:"3111--completions-of-declarations",level:3},{value:"Name Resolution Rules",id:"name-resolution-rules-14",level:4},{value:"Legality Rules",id:"legality-rules-19",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-26",level:4}],d={toc:c};function p(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"3-declarations-and-types"},"3 Declarations and Types"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"This section describes the types in the language and the rules for declaring constants, variables, and named numbers. "),(0,i.kt)("h2",{id:"31--declarations"},"3.1  Declarations"),(0,i.kt)("p",null,"The language defines several kinds of named entities that are declared by declarations. The entity's name is defined by the declaration, usually by a defining_identifier, but sometimes by a defining_character_literal or defining_operator_symbol."),(0,i.kt)("p",null,"There are several forms of declaration. A basic_declaration is a form of declaration defined as follows. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"basic_declaration ::=\ntype_declaration\t| subtype_declaration\n| object_declaration\t| number_declaration\n| subprogram_declaration\t| abstract_subprogram_declaration\n| package_declaration\t| renaming_declaration\n| exception_declaration\t| generic_declaration\n| generic_instantiation"),(0,i.kt)("p",null,"defining_identifier ::= identifier"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"A declaration is a language construct that associates a name with (a view of) an entity. A declaration may appear explicitly in the program text (an explicit declaration), or may be supposed to occur at a given place in the text as a consequence of the semantics of another construct (an implicit declaration). "),(0,i.kt)("p",null,"Discussion: An implicit declaration generally declares a predefined or inherited operation associated with the definition of a type. This term is used primarily when allowing explicit declarations to override implicit declarations, as part of a type declaration. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[declaration]",", Def=","[a language construct that associates a name with (a view of) an entity]",", Note1=","[A declaration can appear explicitly in the program text (an explicit declaration), or can be supposed to occur at a given place in the text as a consequence of the semantics of another construct (an implicit declaration).]"),(0,i.kt)("p",null,"Each of the following is defined to be a declaration: any basic_declaration; an enumeration_literal_specification; a discriminant_specification; a component_declaration; a loop_parameter_specification; a parameter_specification; a subprogram_body; an entry_declaration; an entry_index_specification; a choice_parameter_specification; a generic_formal_parameter_declaration. "),(0,i.kt)("p",null,'Discussion: This list (when basic_declaration is expanded out) contains all syntactic categories that end in "_declaration" or "_specification", except for program unit _specifications. Moreover, it contains subprogram_body. A subprogram_body is a declaration, whether or not it completes a previous declaration. This is a bit strange, subprogram_body is not part of the syntax of basic_declaration or library_unit_declaration. A renaming-as-body is considered a declaration. An accept_statement is not considered a declaration. Completions are sometimes declarations, and sometimes not. '),(0,i.kt)("p",null,"All declarations contain a definition for a view of an entity. A view consists of an identification of the entity (the entity of the view), plus view-specific characteristics that affect the use of the entity through that view (such as mode of access to an object, formal parameter names and defaults for a subprogram, or visibility to components of a type). In most cases, a declaration also contains the definition for the entity itself (a renaming_declaration is an example of a declaration that does not define a new entity, but instead defines a view of an existing entity (see 8.5))."),(0,i.kt)("p",null,"Glossary entry: (See Definition.)"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[T]",",Term=","[view of an entity]",", Def=","[a representation of an entity that reveals some or all of the properties of the entity]",", Note1=","[A single entity can have multiple views.]"),(0,i.kt)("p",null,"Discussion: Most declarations define a view (of some entity) whose view-specific characteristics are unchanging for the life of the view. However, subtypes are somewhat unusual in that they inherit characteristics from whatever view of their type is currently visible. Hence, a subtype is not a view of a type; it is more of an indirect reference. By contrast, a private type provides a single, unchanging (partial) view of its full type. "),(0,i.kt)("p",null,"This paragraph was deleted.All declarations contain a definition for a view of an entity. A view consists of an identification of the entity (the entity of the view), plus view-specific characteristics that affect the use of the entity through that view (such as mode of access to an object, formal parameter names and defaults for a subprogram, or visibility to components of a type). In most cases, a declaration also contains the definition for the entity itself (a renaming_declaration is an example of a declaration that does not define a new entity, but instead defines a view of an existing entity (see 8.5))."),(0,i.kt)("p",null,"For each declaration, the language rules define a certain region of text called the scope of the declaration (see 8.2). Most declarations associate an identifier with a declared entity. Within its scope, and only there, there are places where it is possible to use the identifier to refer to the declaration, the view it defines, and the associated entity; these places are defined by the visibility rules (see 8.3). At such places the identifier is said to be a name of the entity (the direct_name or selector_name); the name is said to denote the declaration, the view, and the associated entity (see 8.6). The declaration is said to declare the name, the view, and in most cases, the entity itself."),(0,i.kt)("p",null,"As an alternative to an identifier, an enumeration literal can be declared with a character_literal as its name (see 3.5.1), and a function can be declared with an operator_symbol as its name (see 6.1)."),(0,i.kt)("p",null,"The syntax rules use the terms defining_identifier, defining_character_literal, and defining_operator_symbol for the defining occurrence of a name; these are collectively called defining names. The terms direct_name and selector_name are used for usage occurrences of identifiers, character_literals, and operator_symbols. These are collectively called usage names. "),(0,i.kt)("p",null,"To be honest: The terms identifier, character_literal, and operator_symbol are used directly in contexts where the normal visibility rules do not apply (such as the identifier that appears after the end of a task_body). Analogous conventions apply to the use of designator, which is the collective term for identifier and operator_symbol. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The process by which a construct achieves its run-time effect is called execution. This process is also called elaboration for declarations and evaluation for expressions. One of the terms execution, elaboration, or evaluation is defined by this Reference Manual for each construct that has a run-time effect. "),(0,i.kt)("p",null,"Glossary entry: The process by which a construct achieves its run-time effect is called execution. Execution of a declaration is also called elaboration. Execution of an expression is also called evaluation."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[R]",",Term=","[execution]",", Def=","[the process by which a construct achieves its run-time effect]",", Note1=","[Execution of a declaration is also called elaboration. Execution of an expression is also called evaluation.]"," "),(0,i.kt)("p",null,"To be honest: The term elaboration is also used for the execution of certain constructs that are not declarations, and the term evaluation is used for the execution of certain constructs that are not expressions. For example, subtype_indications are elaborated, and ranges are evaluated."),(0,i.kt)("p",null,"For bodies, execution and elaboration are both explicitly defined. When we refer specifically to the execution of a body, we mean the explicit definition of execution for that kind of body, not its elaboration. "),(0,i.kt)("p",null,'Discussion: Technically, "the execution of a declaration" and "the elaboration of a declaration" are synonymous. We use the term "elaboration" of a construct when we know the construct is elaborable. When we are talking about more arbitrary constructs, we use the term "execution". For example, we use the term "erroneous execution", to refer to any erroneous execution, including erroneous elaboration or evaluation.'),(0,i.kt)("p",null,"When we explicitly define evaluation or elaboration for a construct, we are implicitly defining execution of that construct."),(0,i.kt)("p",null,'We also use the term "execution" for things like statements, which are executable, but neither elaborable nor evaluable. We considered using the term "execution" only for nonelaborable, nonevaluable constructs, and defining the term "action" to mean what we have defined "execution" to mean. We rejected this idea because we thought three terms that mean the same thing was enough - four would be overkill. Thus, the term "action" is used only informally in the standard (except where it is defined as part of a larger term, such as "protected action"). '),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[R]",",Term=","[elaboration]",", Def=","[the process by which a declaration achieves its run-time effect]",", Note1=","[Elaboration is one of the forms of execution.]"," Version=","[5]",",Kind=(Added),Group=","[R]",",Term=","[evaluation]",", Def=","[the process by which an expression achieves its run-time effect]",", Note1=","[Evaluation is one of the forms of execution.]"," "),(0,i.kt)("p",null,"To be honest: A construct is elaborable if elaboration is defined for it. A construct is evaluable if evaluation is defined for it. A construct is executable if execution is defined for it. "),(0,i.kt)("p",null,'Discussion: Don\'t confuse "elaborable" with "preelaborable" (defined in 10.2.1).'),(0,i.kt)("p",null,'Evaluation of an evaluable construct produces a result that is either a value, a denotation, or a range. The following are evaluable: expression; name prefix; range; entry_list_iterator; and possibly discrete_range. The last one is curious - RM83 uses the term "evaluation of a discrete_range", but never defines it. One might presume that the evaluation of a discrete_range consists of the evaluation of the range or the subtype_indication, depending on what it is. But subtype_indications are not evaluated; they are elaborated.'),(0,i.kt)("p",null,"Intuitively, an executable construct is one that has a defined run-time effect (which may be null). Since execution includes elaboration and evaluation as special cases, all elaborable and all evaluable constructs are also executable. Hence, most constructs in Ada are executable. An important exception is that the constructs inside a generic unit are not executable directly, but rather are used as a template for (generally) executable constructs in instances of the generic. "),(0,i.kt)("p",null,"NOTE   At compile time, the declaration of an entity declares the entity. At run time, the elaboration of the declaration creates the entity. "),(0,i.kt)("p",null,"Ramification: Syntactic categories for declarations are named either entity_declaration (if they include a trailing semicolon) or entity_specification (if not)."),(0,i.kt)("p",null,"The various kinds of named entities that can be declared are as follows: an object (including components and parameters), a named number, a type (the name always refers to its first subtype), a subtype, a subprogram (including enumeration literals and operators), a single entry, an entry family, a package, a protected or task unit (which corresponds to either a type or a single object), an exception, a generic unit, a label, and the name of a statement."),(0,i.kt)("p",null,"Identifiers are also associated with names of pragmas, arguments to pragmas, and with attributes, but these are not user-definable. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for defining_identifier is new. It is used for the defining occurrence of an identifier. Usage occurrences use the direct_name or selector_name syntactic categories. Each occurrence of an identifier (or simple_name), character_literal, or operator_symbol in the Ada 83 syntax rules is handled as follows in Ada 95: "),(0,i.kt)("p",null,"It becomes a defining_identifier, defining_character_literal, or defining_operator_symbol (or some syntactic category composed of these), to indicate a defining occurrence;"),(0,i.kt)("p",null,"It becomes a direct_name, in usage occurrences where the usage is required (in Section 8) to be directly visible;"),(0,i.kt)("p",null,"It becomes a selector_name, in usage occurrences where the usage is required (in Section 8) to be visible but not necessarily directly visible;"),(0,i.kt)("p",null,"It remains an identifier, character_literal, or operator_symbol, in cases where the visibility rules do not apply (such as the designator that appears after the end of a subprogram_body). "),(0,i.kt)("p",null,'For declarations that come in "two parts" (program unit declaration plus body, private or incomplete type plus full type, deferred constant plus full constant), we consider both to be defining occurrences. Thus, for example, the syntax for package_body uses defining_identifier after the reserved word body, as opposed to direct_name.'),(0,i.kt)("p",null,"The defining occurrence of a statement name is in its implicit declaration, not where it appears in the program text. Considering the statement name itself to be the defining occurrence would complicate the visibility rules."),(0,i.kt)("p",null,'The phrase "visible by selection" is not used in Ada 95. It is subsumed by simply "visible" and the Name Resolution Rules for selector_names.'),(0,i.kt)("p",null,"(Note that in Ada 95, a declaration is visible at all places where one could have used a selector_name, not just at places where a selector_name was actually used. Thus, the places where a declaration is directly visible are a subset of the places where it is visible. See Section 8 for details.)"),(0,i.kt)("p",null,'We use the term "declaration" to cover _specifications that declare (views of) objects, such as parameter_specifications. In Ada 83, these are referred to as a "form of declaration", but it is not entirely clear that they are considered simply "declarations".'),(0,i.kt)("p",null,'RM83 contains an incomplete definition of "elaborated" in this clause: it defines "elaborated" for declarations, declarative_parts, declarative_items and compilation_units, but "elaboration" is defined elsewhere for various other constructs. To make matters worse, Ada 95 has a different set of elaborable constructs. Instead of correcting the list, it is more maintainable to refer to the term "elaborable," which is defined in a distributed manner.'),(0,i.kt)("p",null,'RM83 uses the term "has no other effect" to describe an elaboration that doesn\'t do anything except change the state from not-yet-elaborated to elaborated. This was a confusing wording, because the answer to "other than what?" was to be found many pages away. In Ada 95, we change this wording to "has no effect" (for things that truly do nothing at run time), and "has no effect other than to establish that so-and-so can happen without failing the Elaboration_Check" (for things where it matters).'),(0,i.kt)("p",null,'We make it clearer that the term "execution" covers elaboration and evaluation as special cases. This was implied in RM83. For example, "erroneous execution" can include any execution, and RM83-9.4(3) has, "The task designated by any other task object depends on the master whose execution creates the task object;" the elaboration of the master\'s declarative_part is doing the task creation. '),(0,i.kt)("h2",{id:"32--types-and-subtypes"},"3.2  Types and Subtypes"),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"A type is characterized by a set of values, and a set of primitive operations which implement the fundamental aspects of its semantics. An object of a given type is a run-time entity that contains (has) a value of the type. "),(0,i.kt)("p",null,"Glossary entry: Each object has a type. A type has an associated set of values, and a set of primitive operations which implement the fundamental aspects of its semantics. Types are grouped into classes. The types of a given class share a set of primitive operations.  Classes are closed under derivation; that is, if a type is in a class, then all of its derivatives are in that class."),(0,i.kt)("p",null,"Glossary entry: A subtype is a type together with a constraint, which constrains the values of the subtype to satisfy a certain condition. The values of a subtype are a subset of the values of its type."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[type]",", Def=","[a defining characteristic of each object and expression of the language, with an associated set of values, and a set of primitive operations that implement the fundamental aspects of its semantics]",", Note1=","[Types are grouped into categories. Most language-defined categories of types are also classes of types.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[subtype]",", Def=","[a type together with optional constraints, null exclusions, and predicates, which constrain the values of the type to the subset that satisfies the implied conditions]"),(0,i.kt)("p",null,"Types are grouped into classes of types, reflecting the similarity of their values and primitive operations. There exist several language-defined classes of types (see NOTES below). Elementary types are those whose values are logically indivisible; composite types are those whose values are composed of component values. "),(0,i.kt)("p",null,"Glossary entry: A class is a set of types that is closed under derivation, which means that if a given type is in the class, then all types derived from that type are also in the class. The set of types of a class share common properties, such as their primitive operations."),(0,i.kt)("p",null,"Glossary entry: An elementary type does not have components."),(0,i.kt)("p",null,"Glossary entry: A composite type has components."),(0,i.kt)("p",null,"Glossary entry: A scalar type is either a discrete type or a real type."),(0,i.kt)("p",null,'Glossary entry: An access type has values that designate aliased objects. Access types correspond to "pointer types" or "reference types" in some other languages.'),(0,i.kt)("p",null,"Glossary entry: A discrete type is either an integer type or an enumeration type. Discrete types may be used, for example, in case_statements and as array indices."),(0,i.kt)("p",null,"Glossary entry: A real type has values that are approximations of the real numbers. Floating point and fixed point types are real types."),(0,i.kt)("p",null,'Glossary entry: Integer types comprise the signed integer types and the modular types. A signed integer type has a base range that includes both positive and negative numbers, and has operations that may raise an exception when the result is outside the base range. A modular type has a base range whose lower bound is zero, and has operations with "wraparound" semantics. Modular types subsume what are called "unsigned types" in some other languages.'),(0,i.kt)("p",null,"Glossary entry: An enumeration type is defined by an enumeration of its values, which may be named by identifiers or character literals."),(0,i.kt)("p",null,"Glossary entry: A character type is an enumeration type whose values include characters."),(0,i.kt)("p",null,"Glossary entry: A record type is a composite type consisting of zero or more named components, possibly of different types."),(0,i.kt)("p",null,"Glossary entry: A record extension is a type that extends another type by adding additional components."),(0,i.kt)("p",null,"Glossary entry: An array type is a composite type whose components are all of the same type. Components are selected by indexing."),(0,i.kt)("p",null,"Glossary entry: A task type is a composite type whose values are tasks, which are active entities that may execute concurrently with other tasks. The top-level task of a partition is called the environment task."),(0,i.kt)("p",null,"Glossary entry: A protected type is a composite type whose components are protected from concurrent access by multiple tasks."),(0,i.kt)("p",null,"Glossary entry: A private type is a partial view of a type whose full view is hidden from its clients."),(0,i.kt)("p",null,"Glossary entry: A private extension is like a record extension, except that the components of the extension part are hidden from its clients."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[class of types]",", Def=","[a set of types that is closed under derivation, which means that if a given type is in the class, then all types derived from that type are also in the class]",", Note1=","[The set of types of a class share common properties, such as their primitive operations.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[category of types]",", Def=","[a set of types with one or more common properties, such as primitive operations]",", Note1=","[A category of types that is closed under derivation is also known as a class.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[elementary type]",", Def=","[a type that does not have components]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[composite type]",", Def=","[a type with components, such as an array or record]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[scalar type]",", Def=","[either a discrete type or a real type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[access type]",", Def=","[a type that has values that designate aliased objects]",", Note1=",'[Access types correspond to "pointer types" or "reference types" in some other languages.]'," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[discrete type]",", Def=","[a type that is either an integer type or an enumeration type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[real type]",", Def=","[a type that has values that are approximations of the real numbers]",", Note1=","[Floating point and fixed point types are real types.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[integer type]",", Def=","[a type that represents signed or modular integers]",", Note1=",'[A signed integer type has a base range that includes both positive and negative numbers, and has operations that can raise an exception when the result is outside the base range. A modular type has a base range whose lower bound is zero, and has operations with "wraparound" semantics. Modular types subsume what are called "unsigned types" in some other languages.]'," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[enumeration type]",", Def=","[a type defined by an enumeration of its values, which can be denoted by identifiers or character literals]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[character type]",", Def=","[an enumeration type whose values include characters]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[record type]",", Def=","[a composite type consisting of zero or more named components, possibly of different types]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[record extension]",", Def=","[a type that extends another type optionally with additional components]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[array type]",", Def=","[a composite type whose components are all of the same type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[task type]",", Def=","[a composite type used to represent active entities which execute concurrently and that can communicate via queued task entries]",", Note1=","[The top-level task of a partition is called the environment task.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[protected type]",", Def=","[a composite type whose components are accessible only through one of its protected operations, which synchronize concurrent access by multiple tasks]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[private type]",", Def=","[a view of a type that reveals only some of its properties]",", Note1=","[The remaining properties are provided by the full view given elsewhere. Private types can be used for defining abstractions that hide unnecessary details from their clients.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[private extension]",", Def=","[a type that extends another type, with the additional properties hidden from its clients]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[incomplete type]",", Def=","[a view of a type that reveals only a few of its properties]",", Note1=","[The remaining properties are provided by the full view given elsewhere.]",", Note2=","[Incomplete types can be used for defining recursive data structures.]"),(0,i.kt)("p",null,"The elementary types are the scalar types (discrete and real) and the access types (whose values provide access to objects or subprograms). Discrete types are either integer types or are defined by enumeration of their values (enumeration types). Real types are either floating point types or fixed point types."),(0,i.kt)("p",null,"The composite types are the record types, record extensions, array types, task types, and protected types. A private type or private extension represents a partial view (see 7.3) of a type, providing support for data abstraction. A partial view is a composite type. "),(0,i.kt)("p",null,'To be honest: The set of all record types do not form a class (because tagged record types can have private extensions), though the set of untagged record types do. In any case, what record types had in common in Ada 83 (component selection) is now a property of the composite class, since all composite types (other than array types) can have discriminants. Similarly, the set of all private types do not form a class (because tagged private types can have record extensions), though the set of untagged private types do. Nevertheless, the set of untagged private types is not particularly "interesting" - more interesting is the set of all nonlimited types, since that is what a generic formal (nonlimited) private type matches. '),(0,i.kt)("p",null,"Certain composite types (and partial views thereof) have special components called discriminants whose values affect the presence, constraints, or initialization of other components. Discriminants can be thought of as parameters of the type."),(0,i.kt)("p",null,"The term subcomponent is used in this Reference Manual in place of the term component to indicate either a component, or a component of another subcomponent. Where other subcomponents are excluded, the term component is used instead. Similarly, a part of an object or value is used to mean the whole object or value, or any set of its subcomponents. "),(0,i.kt)("p",null,'Discussion: The definition of "part" here is designed to simplify rules elsewhere. By design, the intuitive meaning of "part" will convey the correct result to the casual reader, while this formalistic definition will answer the concern of the compiler-writer.'),(0,i.kt)("p",null,'We use the term "part" when talking about the parent part, ancestor part, or extension part of a type extension. In contexts such as these, the part might represent an empty set of subcomponents (e.g. in a null record extension, or a nonnull extension of a null record). We also use "part" when specifying rules such as those that apply to an object with a "controlled part" meaning that it applies if the object as a whole is controlled, or any subcomponent is. '),(0,i.kt)("p",null,"The set of possible values for an object of a given type can be subjected to a condition that is called a constraint (the case of a null constraint that specifies no restriction is also included)","[; the rules for which values satisfy a given kind of constraint are given in 3.5 for range_constraints, 3.6.1 for index_constraints, and 3.7.1 for discriminant_constraints]","."),(0,i.kt)("p",null,"A subtype of a given type is a combination of the type, a constraint on values of the type, and certain attributes specific to the subtype. The given type is called the type of the subtype. Similarly, the associated constraint is called the constraint of the subtype. The set of values of a subtype consists of the values of its type that satisfy its constraint. Such values belong to the subtype. "),(0,i.kt)("p",null,"Discussion: We make a strong distinction between a type and its subtypes. In particular, a type is not a subtype of itself. There is no constraint associated with a type (not even a null one), and type-related attributes are distinct from subtype-specific attributes. "),(0,i.kt)("p",null,'Discussion: We no longer use the term "base type." All types were "base types" anyway in Ada 83, so the term was redundant, and occasionally confusing. In the RM95 we say simply "the type of the subtype" instead of "the base type of the subtype." '),(0,i.kt)("p",null,"Ramification: The value subset for a subtype might be empty, and need not be a proper subset. "),(0,i.kt)("p",null,'To be honest: Any name of a class of types (such as "discrete" or "real"), or other category of types (such as "limited" or "incomplete") is also used to qualify its subtypes, as well as its objects, values, declarations, and definitions, such as an "integer type declaration" or an "integer value". In addition, if a term such as "parent subtype" or "index subtype" is defined, then the corresponding term for the type of the subtype is "parent type" or "index type". '),(0,i.kt)("p",null,"Discussion: We use these corresponding terms without explicitly defining them, when the meaning is obvious. "),(0,i.kt)("p",null,"A subtype is called an unconstrained subtype if its type has unknown discriminants, or if its type allows range, index, or discriminant constraints, but the subtype does not impose such a constraint; otherwise, the subtype is called a constrained subtype (since it has no unconstrained characteristics). "),(0,i.kt)("p",null,'Discussion: In an earlier version of Ada 9X, "constrained" meant "has a nonnull constraint." However, we changed to this definition since we kept having to special case composite non-array/nondiscriminated types. It also corresponds better to the (now obsolescent) attribute \'Constrained.'),(0,i.kt)("p",null,'For scalar types, "constrained" means "has a nonnull constraint". For composite types, in implementation terms, "constrained" means that the size of all objects of the subtype is the same, assuming a typical implementation model.'),(0,i.kt)("p",null,"Class-wide subtypes are always unconstrained. "),(0,i.kt)("p",null,'NOTE   Any set of types that is closed under derivation (see 3.4) can be called a "class" of types. However, only certain classes are used in the description of the rules of the language - generally those that have their own particular set of primitive operations (see 3.2.3), or that correspond to a set of types that are matched by a given kind of generic formal type (see 12.5). The following are examples of "interesting" language-defined classes: elementary, scalar, discrete, enumeration, character, boolean, integer, signed integer, modular, real, floating point, fixed point, ordinary fixed point, decimal fixed point, numeric, access, access-to-object, access-to-subprogram, composite, array, string, (untagged) record, tagged, task, protected, nonlimited. Special syntax is provided to define types in each of these classes. '),(0,i.kt)("p",null,"Discussion: A value is a run-time entity with a given type which can be assigned to an object of an appropriate subtype of the type. An operation is a program entity that operates on zero or more operands to produce an effect, or yield a result, or both. "),(0,i.kt)("p",null,"Ramification: Note that a type's class depends on the place of the reference - a private type is composite outside and possibly elementary inside. It's really the view that is elementary or composite. Note that although private types are composite, there are some properties that depend on the corresponding full view - for example, parameter passing modes, and the constraint checks that apply in various places."),(0,i.kt)("p",null,"Not every property of types represents a class. For example, the set of all abstract types does not form a class, because this set is not closed under derivation."),(0,i.kt)("p",null,'The set of limited types forms a class in the sense that it is closed under derivation, but the more interesting class, from the point of generic formal type matching, is the set of all types, limited and nonlimited, since that is what matches a generic formal "limited" private type. Note also that a limited type can "become nonlimited" under certain circumstances, which makes "limited" somewhat problematic as a class of types.'),(0,i.kt)("p",null,"These language-defined classes are organized like this: "),(0,i.kt)("p",null,"all types\nelementary\nscalar\ndiscrete\nenumeration\ncharacter\nboolean\nother enumeration\ninteger\nsigned integer\nmodular integer\nreal\nfloating point\nfixed point\nordinary fixed point\ndecimal fixed point\naccess\naccess-to-object\naccess-to-subprogram\ncomposite\narray\nstring\nother array\nuntagged record\ntagged\ntask\nprotected"),(0,i.kt)("p",null,'The classes "numeric" and "nonlimited" represent other classification dimensions and do not fit into the above strictly hierarchical picture. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"This clause and its subclauses now precede the clause and subclauses on objects and named numbers, to cut down on the number of forward references."),(0,i.kt)("p",null,'We have dropped the term "base type" in favor of simply "type" (all types in Ada 83 were "base types" so it wasn\'t clear when it was appropriate/necessary to say "base type"). Given a subtype S of a type T, we call T the "type of the subtype S." '),(0,i.kt)("h3",{id:"321--type-declarations"},"3.2.1  Type Declarations"),(0,i.kt)("p",null,"A type_declaration declares a type and its first subtype. "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"type_declaration ::=  full_type_declaration\n| incomplete_type_declaration\n| private_type_declaration\n| private_extension_declaration"),(0,i.kt)("p",null,"full_type_declaration ::=\ntype defining_identifier ","[known_discriminant_part]"," is type_definition;\n| task_type_declaration\n| protected_type_declaration"),(0,i.kt)("p",null,"type_definition ::=\nenumeration_type_definition\t| integer_type_definition\n| real_type_definition\t| array_type_definition\n| record_type_definition\t| access_type_definition\n| derived_type_definition"),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"A given type shall not have a subcomponent whose type is the given type itself. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,'The defining_identifier of a type_declaration denotes the first subtype of the type. The known_discriminant_part, if any, defines the discriminants of the type (see 3.7, "Discriminants"). The remainder of the type_declaration defines the remaining characteristics of (the view of) the type.'),(0,i.kt)("p",null,'A type defined by a type_declaration is a named type; such a type has one or more nameable subtypes. Certain other forms of declaration also include type definitions as part of the declaration for an object (including a parameter or a discriminant). The type defined by such a declaration is anonymous - it has no nameable subtypes. For explanatory purposes, this document sometimes refers to an anonymous type by a pseudo-name, written in italics, and uses such pseudo-names at places where the syntax normally requires an identifier. For a named type whose first subtype is T, this document sometimes refers to the type of T as simply "the type T". '),(0,i.kt)("p",null,"Ramification: The only user-defined types that can be anonymous in the above sense are array, access, task, and protected types. An anonymous array, task, or protected type can be defined as part of an object_declaration. An anonymous access type can be defined as part of a parameter or discriminant specification. "),(0,i.kt)("p",null,"A named type that is declared by a full_type_declaration, or an anonymous type that is defined as part of declaring an object of the type, is called a full type. The type_definition, task_definition, protected_definition, or access_definition that defines a full type is called a full type definition. ","[Types declared by other forms of type_declaration are not separate types; they are partial or incomplete views of some full type.]"," "),(0,i.kt)("p",null,"To be honest: Class-wide, universal, and root numeric types are full types. "),(0,i.kt)("p",null,'The definition of a type implicitly declares certain predefined operators that operate on the type, according to what classes the type belongs, as specified in 4.5, "Operators and Expression Evaluation". '),(0,i.kt)("p",null,"Discussion: We no longer talk about the implicit declaration of basic operations. These are treated like an if_statement - they don't need to be declared, but are still applicable to only certain classes of types."),(0,i.kt)("p",null,"The predefined types ","[(for example the types Boolean, Wide_Character, Integer, root_integer, and universal_integer)]"," are the types that are defined in ","[a predefined library package called]"," Standard[; this package also includes the ","[(implicit)]"," declarations of their predefined operators]. ","[The package Standard is described in A.1.]"," "),(0,i.kt)("p",null,'Ramification: We use the term "predefined" to refer to entities declared in the visible part of Standard, to implicitly declared operators of a type whose semantics are defined by the language, to Standard itself, and to the "predefined environment". We do not use this term to refer to library packages other than Standard. For example Text_IO is a language-defined package, not a predefined package, and Text_IO.Put_Line is not a predefined operation. '),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a full_type_declaration consists of the elaboration of the full type definition. Each elaboration of a full type definition creates a distinct type and its first subtype. "),(0,i.kt)("p",null,"Reason: The creation is associated with the type definition, rather than the type declaration, because there are types that are created by full type definitions that are not immediately contained within a type declaration (e.g. an array object declaration, a singleton task declaration, etc.). "),(0,i.kt)("p",null,"Ramification: Any implicit declarations that occur immediately following the full type definition are elaborated where they (implicitly) occur. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of type definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"(White, Red, Yellow, Green, Blue, Brown, Black)\nrange 1 .. 72\narray(1 .. 10) of Integer\n\n")),(0,i.kt)("p",null,"Examples of type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);\ntype Column is range 1 .. 72;\ntype Table  is array(1 .. 10) of Integer;\n\n")),(0,i.kt)("p",null,'NOTE 1   Each of the above examples declares a named type. The identifier given denotes the first subtype of the type. Other named subtypes of the type can be declared with subtype_declarations (see 3.2.2). Although names do not directly denote types, a phrase like "the type Column" is sometimes used in this document to refer to the type of Column, where Column denotes the first subtype of the type. For an example of the definition of an anonymous type, see the declaration of the array Color_Table in 3.3.1; its type is anonymous - it has no nameable subtypes. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntactic category full_type_declaration now includes task and protected type declarations."),(0,i.kt)("p",null,'We have generalized the concept of first-named subtype (now called simply "first subtype") to cover all kinds of types, for uniformity of description elsewhere. RM83 defined first-named subtype in Section 13. We define first subtype here, because it is now a more fundamental concept. We renamed the term, because in Ada 95 some first subtypes have no name.'),(0,i.kt)("p",null,"We no longer elaborate discriminant_parts, because there is nothing to do, and it was complex to say that you only wanted to elaborate it once for a private or incomplete type. This is also consistent with the fact that subprogram specifications are not elaborated (neither in Ada 83 nor in Ada 95). Note, however, that an access_definition appearing in a discriminant_part is elaborated when an object with such a discriminant is created. "),(0,i.kt)("h3",{id:"322--subtype-declarations"},"3.2.2  Subtype Declarations"),(0,i.kt)("p",null,"A subtype_declaration declares a subtype of some previously declared type, as defined by a subtype_indication. "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"subtype_declaration ::=\nsubtype defining_identifier is subtype_indication;"),(0,i.kt)("p",null,"subtype_indication ::=  subtype_mark ","[constraint]"),(0,i.kt)("p",null,"subtype_mark ::= subtype_name"),(0,i.kt)("p",null,"Ramification: Note that name includes attribute_reference; thus, S'Base can be used as a subtype_mark. "),(0,i.kt)("p",null,'Reason: We considered changing subtype_mark to subtype_name. However, existing users are used to the word "mark," so we\'re keeping it. '),(0,i.kt)("p",null,"constraint ::= scalar_constraint | composite_constraint"),(0,i.kt)("p",null,"scalar_constraint ::=\nrange_constraint | digits_constraint | delta_constraint"),(0,i.kt)("p",null,"composite_constraint ::=\nindex_constraint | discriminant_constraint"),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"A subtype_mark shall resolve to denote a subtype. The type determined by a subtype_mark is the type of the subtype denoted by the subtype_mark. "),(0,i.kt)("p",null,"Ramification: Types are never directly named; all subtype_marks denote subtypes - possibly an unconstrained (base) subtype, but never the type. When we use the term anonymous type we really mean a type with no namable subtypes. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a subtype_declaration consists of the elaboration of the subtype_indication. The elaboration of a subtype_indication creates a new subtype. If the subtype_indication does not include a constraint, the new subtype has the same (possibly null) constraint as that denoted by the subtype_mark. The elaboration of a subtype_indication that includes a constraint proceeds as follows: "),(0,i.kt)("p",null,"The constraint is first elaborated."),(0,i.kt)("p",null,"A check is then made that the constraint is compatible with the subtype denoted by the subtype_mark. "),(0,i.kt)("p",null,"Ramification: The checks associated with constraint compatibility are all Range_Checks. Discriminant_Checks and Index_Checks are associated only with checks that a value satisfies a constraint. "),(0,i.kt)("p",null,"The condition imposed by a constraint is the condition obtained after elaboration of the constraint. The rules defining compatibility are given for each form of constraint in the appropriate subclause. These rules are such that if a constraint is compatible with a subtype, then the condition imposed by the constraint cannot contradict any condition already imposed by the subtype on its values. The exception Constraint_Error is raised if any check of compatibility fails. "),(0,i.kt)("p",null,"To be honest: The condition imposed by a constraint is named after it - a range_constraint imposes a range constraint, etc. "),(0,i.kt)("p",null,"Ramification: A range_constraint causes freezing of its type. Other constraints do not. "),(0,i.kt)("p",null,"NOTE 1   A scalar_constraint may be applied to a subtype of an appropriate scalar type (see 3.5, 3.5.9, and J.3), even if the subtype is already constrained. On the other hand, a composite_constraint may be applied to a composite subtype (or an access-to-composite subtype) only if the composite subtype is unconstrained (see 3.6.1 and 3.7.1). "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Examples of subtype declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Rainbow   is Color range Red .. Blue;        --  see 3.2.1\nsubtype Red_Blue  is Rainbow;\nsubtype Int       is Integer;\nsubtype Small_Int is Integer range -10 .. 10;\nsubtype Up_To_K   is Column range 1 .. K;            --  see 3.2.1\nsubtype Square    is Matrix(1 .. 10, 1 .. 10);       --  see 3.6\nsubtype Male      is Person(Sex =&gt M);               --  see 3.10.1\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"In Ada 95, all range_constraints cause freezing of their type. Hence, a type-related representation item for a scalar type has to precede any range_constraints whose type is the scalar type. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Subtype_marks allow only subtype names now, since types are never directly named. There is no need for RM83-3.3.2(3), which says a subtype_mark can denote both the type and the subtype; in Ada 95, you denote an unconstrained (base) subtype if you want, but never the type."),(0,i.kt)("p",null,"The syntactic category type_mark is now called subtype_mark, since it always denotes a subtype. "),(0,i.kt)("h3",{id:"323--classification-of-operations"},"3.2.3  Classification of Operations"),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"An operation operates on a type T if it yields a value of type T, if it has an operand whose expected type (see 8.6) is T, or if it has an access parameter (see 6.1) designating T. A predefined operator, or other language-defined operation such as assignment or a membership test, that operates on a type, is called a predefined operation of the type. The primitive operations of a type are the predefined operations of the type, plus any user-defined primitive subprograms. "),(0,i.kt)("p",null,"Glossary entry: The primitive operations of a type are the operations (such as subprograms) declared together with the type declaration. They are inherited by other types in the same class of types. For a tagged type, the primitive subprograms are dispatching subprograms, providing run-time polymorphism. A dispatching subprogram may be called with statically tagged operands, in which case the subprogram body invoked is determined at compile time. Alternatively, a dispatching subprogram may be called using a dispatching call, in which case the subprogram body invoked is determined at run time."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[T]",",Term=","[primitive operations of a type]",", Def=","[the operations (such as subprograms) declared together with the type declarations]",", Note1=","[Primitive operations are inherited by other types in the same derivation class of types.]"),(0,i.kt)("p",null,'To be honest: Protected subprograms are not considered to be "primitive subprograms", even though they are subprograms, and they are inherited by derived types. '),(0,i.kt)("p",null,'Discussion: We use the term "primitive subprogram" in most of the rest of the manual. The term "primitive operation" is used mostly in conceptual discussions. '),(0,i.kt)("p",null,"The primitive subprograms of a specific type are defined as follows: "),(0,i.kt)("p",null,"The predefined operators of the type (see 4.5);"),(0,i.kt)("p",null,"For a derived type, the inherited (see 3.4) user-defined subprograms;"),(0,i.kt)("p",null,"For an enumeration type, the enumeration literals (which are considered parameterless functions - see 3.5.1);"),(0,i.kt)("p",null,"For a specific type declared immediately within a package_specification, any subprograms (in addition to the enumeration literals) that are explicitly declared immediately within the same package_specification and that operate on the type;"),(0,i.kt)("p",null,"Any subprograms not covered above ","[that are explicitly declared immediately within the same declarative region as the type]"," and that override (see 8.3) other implicitly declared primitive subprograms of the type. "),(0,i.kt)("p",null,'Discussion: In Ada 83, only subprograms declared in the visible part were "primitive" (i.e. derivable). In Ada 95, mostly because of child library units, we include all operations declared in the private part as well, and all operations that override implicit declarations. '),(0,i.kt)("p",null,"Ramification: It is possible for a subprogram to be primitive for more than one type, though it is illegal for a subprogram to be primitive for more than one tagged type. See 3.9. "),(0,i.kt)("p",null,'Discussion: The order of the implicit declarations when there are both predefined operators and inherited subprograms is described in 3.4, "Derived Types and Classes". '),(0,i.kt)("p",null,"A primitive subprogram whose designator is an operator_symbol is called a primitive operator."),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"The attribute S'Base is no longer defined for nonscalar subtypes. Since this was only permitted as the prefix of another attribute, and there are no interesting nonscalar attributes defined for an unconstrained composite or access subtype, this should not affect any existing programs. "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The primitive subprograms (derivable subprograms) include subprograms declared in the private part of a package specification as well, and those that override implicitly declared subprograms, even if declared in a body. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have dropped the confusing term operation of a type in favor of the more useful primitive operation of a type and the phrase operates on a type."),(0,i.kt)("p",null,'The description of S\'Base has been moved to 3.5, "Scalar Types" because it is now defined only for scalar types. '),(0,i.kt)("h2",{id:"33--objects-and-named-numbers"},"3.3  Objects and Named Numbers"),(0,i.kt)("p",null,"[Objects are created at run time and contain a value of a given type. An object can be created and initialized as part of elaborating a declaration, evaluating an allocator, aggregate, or function_call, or passing a parameter by copy. Prior to reclaiming the storage for an object, it is finalized if necessary (see 7.6.1).]"," "),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"All of the following are objects: "),(0,i.kt)("p",null,"Glossary entry: An object is either a constant or a variable. An object contains a value. An object is created by an object_declaration or by an allocator. A formal parameter is (a view of) an object. A subcomponent of an object is an object."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[object]",", Def=","[an entity that contains a value, and is either a constant or a variable]",", Note1=","[An object is created by an object_declaration or by an allocator. A formal parameter is (a view of) an object. A subcomponent of an object is an object.]"),(0,i.kt)("p",null,"the entity declared by an object_declaration;"),(0,i.kt)("p",null,"a formal parameter of a subprogram, entry, or generic subprogram;"),(0,i.kt)("p",null,"a generic formal object;"),(0,i.kt)("p",null,"a loop parameter;"),(0,i.kt)("p",null,"a choice parameter of an exception_handler;"),(0,i.kt)("p",null,"an entry index of an entry_body;"),(0,i.kt)("p",null,"the result of dereferencing an access-to-object value (see 4.1);"),(0,i.kt)("p",null,"the result of evaluating a function_call (or the equivalent operator invocation - see 6.6);"),(0,i.kt)("p",null,"the result of evaluating an aggregate;"),(0,i.kt)("p",null,"a component, slice, or view conversion of another object. "),(0,i.kt)("p",null,"An object is either a constant object or a variable object. The value of a constant object cannot be changed between its initialization and its finalization, whereas the value of a variable object can be changed. Similarly, a view of an object is either a constant or a variable. All views of a constant object are constant. A constant view of a variable object cannot be used to modify the value of the variable. The terms constant and variable by themselves refer to constant and variable views of objects."),(0,i.kt)("p",null,"The value of an object is read when the value of any part of the object is evaluated, or when the value of an enclosing object is evaluated. The value of a variable is updated when an assignment is performed to any part of the variable, or when an assignment is performed to an enclosing object. "),(0,i.kt)("p",null,'Ramification: Reading and updating are intended to include read/write references of any kind, even if they are not associated with the evaluation of a particular construct. Consider, for example, the expression "X.all(F)", where X is an access-to-array object, and F is a function. The implementation is allowed to first evaluate "X.all" and then F. Finally, a read is performed to get the value of the F\'th component of the array. Note that the array is not necessarily read as part of the evaluation of "X.all". This is important, because if F were to free X using Unchecked_Deallocation, we want the execution of the final read to be erroneous. '),(0,i.kt)("p",null,"Whether a view of an object is constant or variable is determined by the definition of the view. The following (and no others) represent constants: "),(0,i.kt)("p",null,"an object declared by an object_declaration with the reserved word constant;"),(0,i.kt)("p",null,"a formal parameter or generic formal object of mode in;"),(0,i.kt)("p",null,"a discriminant;"),(0,i.kt)("p",null,"a loop parameter, choice parameter, or entry index;"),(0,i.kt)("p",null,"the dereference of an access-to-constant value;"),(0,i.kt)("p",null,"the result of evaluating a function_call or an aggregate;"),(0,i.kt)("p",null,"a selected_component, indexed_component, slice, or view conversion of a constant."),(0,i.kt)("p",null,"To be honest: A noninvertible view conversion to a general access type is also defined to be a constant - see 4.6. "),(0,i.kt)("p",null,"At the place where a view of an object is defined, a nominal subtype is associated with the view. The object's actual subtype (that is, its subtype) can be more restrictive than the nominal subtype of the view; it always is if the nominal subtype is an indefinite subtype. A subtype is an indefinite subtype if it is an unconstrained array subtype, or if it has unknown discriminants or unconstrained discriminants without defaults (see 3.7); otherwise the subtype is a definite subtype ","[(all elementary subtypes are definite subtypes)]",". ","[A class-wide subtype is defined to have unknown discriminants, and is therefore an indefinite subtype. An indefinite subtype does not by itself provide enough information to create an object; an additional constraint or explicit initialization expression is necessary (see 3.3.1). A component cannot have an indefinite nominal subtype.]"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",", Term=","[nominal subtype of a view of an object]",", Def=","[the subtype specified when the view is defined]"),(0,i.kt)("p",null,"A named number provides a name for a numeric value known at compile time. It is declared by a number_declaration. "),(0,i.kt)("p",null,"NOTE 1   A constant cannot be the target of an assignment operation, nor be passed as an in out or out parameter, between its initialization and finalization, if any."),(0,i.kt)("p",null,"NOTE 2   The nominal and actual subtypes of an elementary object are always the same. For a discriminated or array object, if the nominal subtype is constrained then so is the actual subtype. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"There are additional kinds of objects (choice parameters and entry indices of entry bodies)."),(0,i.kt)("p",null,"The result of a function and of evaluating an aggregate are considered (constant) objects. This is necessary to explain the action of finalization on such things. Because a function_call is also syntactically a name (see 4.1), the result of a function_call can be renamed, thereby allowing repeated use of the result without calling the function again. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"This clause and its subclauses now follow the clause and subclauses on types and subtypes, to cut down on the number of forward references."),(0,i.kt)("p",null,'The term nominal subtype is new. It is used to distinguish what is known at compile time about an object\'s constraint, versus what its "true" run-time constraint is.'),(0,i.kt)("p",null,"The terms definite and indefinite (which apply to subtypes) are new. They are used to aid in the description of generic formal type matching, and to specify when an explicit initial value is required in an object_declaration."),(0,i.kt)("p",null,"We have moved the syntax for object_declaration and number_declaration down into their respective subclauses, to keep the syntax close to the description of the associated semantics."),(0,i.kt)("p",null,"We talk about variables and constants here, since the discussion is not specific to object_declarations, and it seems better to have the list of the kinds of constants juxtaposed with the kinds of objects."),(0,i.kt)("p",null,"We no longer talk about indirect updating due to parameter passing. Parameter passing is handled in 6.2 and 6.4.1 in a way that there is no need to mention it here in the definition of read and update. Reading and updating now includes the case of evaluating or assigning to an enclosing object. "),(0,i.kt)("h3",{id:"331--object-declarations"},"3.3.1  Object Declarations"),(0,i.kt)("p",null,"An object_declaration declares a stand-alone object with a given nominal subtype and, optionally, an explicit initial value given by an initialization expression. For an array, task, or protected object, the object_declaration may include the definition of the (anonymous) type of the object. "),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"object_declaration ::=\ndefining_identifier_list : ","[aliased][constant]"," subtype_indication ","[:= expression]",";\n| defining_identifier_list : ","[aliased][constant]"," array_type_definition ","[:= expression]",";\n| single_task_declaration\n| single_protected_declaration"),(0,i.kt)("p",null,"defining_identifier_list ::=\ndefining_identifier {, defining_identifier}"),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"For an object_declaration with an expression following the compound delimiter :=, the type expected for the expression is that of the object. This expression is called the initialization expression. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"An object_declaration without the reserved word constant declares a variable object. If it has a subtype_indication or an array_type_definition that defines an indefinite subtype, then there shall be an initialization expression. An initialization expression shall not be given if the object is of a limited type. "),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"An object_declaration with the reserved word constant declares a constant object. If it has an initialization expression, then it is called a full constant declaration. Otherwise it is called a deferred constant declaration. The rules for deferred constant declarations are given in clause 7.4. The rules for full constant declarations are given in this subclause."),(0,i.kt)("p",null,"Any declaration that includes a defining_identifier_list with more than one defining_identifier is equivalent to a series of declarations each containing one defining_identifier from the list, with the rest of the text of the declaration copied for each declaration in the series, in the same order as the list. The remainder of this Reference Manual relies on this equivalence; explanations are given for declarations with a single defining_identifier."),(0,i.kt)("p",null,"The subtype_indication or full type definition of an object_declaration defines the nominal subtype of the object. The object_declaration declares an object of the type of the nominal subtype. "),(0,i.kt)("p",null,'Discussion: The phrase "full type definition" here includes the case of an anonymous array, task, or protected type. '),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"If a composite object declared by an object_declaration has an unconstrained nominal subtype, then if this subtype is indefinite or the object is constant or aliased (see 3.10) the actual subtype of this object is constrained. The constraint is determined by the bounds or discriminants (if any) of its initial value; the object is said to be constrained by its initial value. ","[In the case of an aliased object, this initial value may be either explicit or implicit; in the other cases, an explicit initial value is required.]"," When not constrained by its initial value, the actual and nominal subtypes of the object are the same. If its actual subtype is constrained, the object is called a constrained object."),(0,i.kt)("p",null,"For an object_declaration without an initialization expression, any initial values for the object or its subcomponents are determined by the implicit initial values defined for its nominal subtype, as follows: "),(0,i.kt)("p",null,"The implicit initial value for an access subtype is the null value of the access type."),(0,i.kt)("p",null,"The implicit initial (and only) value for each discriminant of a constrained discriminated subtype is defined by the subtype."),(0,i.kt)("p",null,"For a (definite) composite subtype, the implicit initial value of each component with a default_expression is obtained by evaluation of this expression and conversion to the component's nominal subtype (which might raise Constraint_Error - see 4.6, \"Type Conversions\"), unless the component is a discriminant of a constrained subtype (the previous case), or is in an excluded variant (see 3.8.1). For each component that does not have a default_expression, any implicit initial values are those determined by the component's nominal subtype."),(0,i.kt)("p",null,"For a protected or task subtype, there is an implicit component (an entry queue) corresponding to each entry, with its implicit initial value being an empty queue. "),(0,i.kt)("p",null,"Implementation Note: The implementation may add implicit components for its own use, which might have implicit initial values. For a task subtype, such components might represent the state of the associated thread of control. For a type with dynamic-sized components, such implicit components might be used to hold the offset to some explicit component. "),(0,i.kt)("p",null,"The elaboration of an object_declaration proceeds in the following sequence of steps: "),(0,i.kt)("p",null,"a)The subtype_indication, array_type_definition, single_task_declaration, or single_protected_declaration is first elaborated. This creates the nominal subtype (and the anonymous type in the latter three cases)."),(0,i.kt)("p",null,"b)If the object_declaration includes an initialization expression, the (explicit) initial value is obtained by evaluating the expression and converting it to the nominal subtype (which might raise Constraint_Error - see 4.6). "),(0,i.kt)("p",null,"c)The object is created, and, if there is not an initialization expression, any per-object expressions (see 3.8) are evaluated and any implicit initial values for the object or for its subcomponents are obtained as determined by the nominal subtype. "),(0,i.kt)("p",null,"Discussion: For a per-object constraint that contains some per-object expressions and some non-per-object expressions, the values used for the constraint consist of the values of the non-per-object expressions evaluated at the point of the type_declaration, and the values of the per-object expressions evaluated at the point of the creation of the object."),(0,i.kt)("p",null,"The elaboration of per-object constraints was presumably performed as part of the dependent compatibility check in Ada 83. If the object is of a limited type with an access discriminant, the access_definition is elaborated at this time (see 3.7). "),(0,i.kt)("p",null,'Reason: The reason we say that evaluating an explicit initialization expression happens before creating the object is that in some cases it is impossible to know the size of the object being created until its initial value is known, as in "X: String := Func_Call(...);". The implementation can create the object early in the common case where the size can be known early, since this optimization is semantically neutral. '),(0,i.kt)("p",null,"d)Any initial values (whether explicit or implicit) are assigned to the object or to the corresponding subcomponents. As described in 5.2 and 7.6, Initialize and Adjust procedures can be called. "),(0,i.kt)("p",null,"Ramification: Since the initial values have already been converted to the appropriate nominal subtype, the only Constraint_Errors that might occur as part of these assignments are for values outside their base range that are used to initialize unconstrained numeric subcomponents. See 3.5. "),(0,i.kt)("p",null,"For the third step above, the object creation and any elaborations and evaluations are performed in an arbitrary order, except that if the default_expression for a discriminant is evaluated to obtain its initial value, then this evaluation is performed before that of the default_expression for any component that depends on the discriminant, and also before that of any default_expression that includes the name of the discriminant. The evaluations of the third step and the assignments of the fourth step are performed in an arbitrary order, except that each evaluation is performed before the resulting value is assigned. "),(0,i.kt)("p",null,"Reason: For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type R(D : Integer := F) is\n    record\n        S : String(1..D) := (others =&gt G);\n    end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"X : R;\n\n")),(0,i.kt)("p",null,"For the elaboration of the declaration of X, it is important that F be evaluated before the aggregate. "),(0,i.kt)("p",null,"[There is no implicit initial value defined for a scalar subtype.]"," In the absence of an explicit initialization, a newly created scalar object might have a value that does not belong to its subtype (see 13.9.1 and H.1). "),(0,i.kt)("p",null,'To be honest: It could even be represented by a bit pattern that doesn\'t actually represent any value of the type at all, such as an invalid internal code for an enumeration type, or a NaN for a floating point type. It is a generally a bounded error to reference scalar objects with such "invalid representations", as explained in 13.9.1, "Data Validity". '),(0,i.kt)("p",null,'Ramification: There is no requirement that two objects of the same scalar subtype have the same implicit initial "value" (or representation). It might even be the case that two elaborations of the same object_declaration produce two different initial values. However, any particular uninitialized object is default-initialized to a single value (or invalid representation). Thus, multiple reads of such an uninitialized object will produce the same value each time (if the implementation chooses not to detect the error). '),(0,i.kt)("p",null,"NOTE 1   Implicit initial values are not defined for an indefinite subtype, because if an object's nominal subtype is indefinite, an explicit initial value is required."),(0,i.kt)("p",null,'NOTE 2   As indicated above, a stand-alone object is an object declared by an object_declaration. Similar definitions apply to "stand-alone constant" and "stand-alone variable". A subcomponent of an object is not a stand-alone object, nor is an object that is created by an allocator. An object declared by a loop_parameter_specification, parameter_specification, entry_index_specification, choice_parameter_specification, or a formal_object_declaration is not called a stand-alone object.'),(0,i.kt)("p",null,"NOTE 3   The type of a stand-alone object cannot be abstract (see 3.9.3). "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Example of a multiple object declaration: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  the multiple object declaration \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"John, Paul : Person_Name := new Person(Sex =&gt M);  --  see 3.10.1\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  is equivalent to the two single object declarations in the order given\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"John : Person_Name := new Person(Sex =&gt M);\nPaul : Person_Name := new Person(Sex =&gt M);\n\n")),(0,i.kt)("p",null,"Examples of variable declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Count, Sum  : Integer;\nSize        : Integer range 0 .. 10_000 := 0;\nSorted      : Boolean := False;\nColor_Table : array(1 .. Max) of Color;\nOption      : Bit_Vector(1 .. 10) := (others =&gt True);\nHello       : constant String := "Hi, world.";\n\n')),(0,i.kt)("p",null,"Examples of constant declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Limit     : constant Integer := 10_000;\nLow_Limit : constant Integer := Limit/10;\nTolerance : constant Real := Dispersion(1.15);\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for object_declaration is modified to allow the aliased reserved word."),(0,i.kt)("p",null,"A variable declared by an object_declaration can be constrained by its initial value; that is, a variable of a nominally unconstrained array subtype, or discriminated type without defaults, can be declared so long as it has an explicit initial value. In Ada 83, this was permitted for constants, and for variables created by allocators, but not for variables declared by object_declarations. This is particularly important for tagged class-wide types, since there is no way to constrain them explicitly, and so an initial value is the only way to provide a constraint. It is also important for generic formal private types with unknown discriminants."),(0,i.kt)("p",null,'We now allow an unconstrained_array_definition in an object_declaration. This allows an object of an anonymous array type to have its bounds determined by its initial value. This is for uniformity: If one can write "X: constant array(Integer range 1..10) of Integer := ...;" then it makes sense to also allow "X: constant array(Integer range ',"<",">",") of Integer := ...;\". (Note that if anonymous array types are ever sensible, a common situation is for a table implemented as an array. Tables are often constant, and for constants, there's usually no point in forcing the user to count the number of elements in the value.) "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have moved the syntax for object_declarations into this subclause."),(0,i.kt)("p",null,"Deferred constants no longer have a separate syntax rule, but rather are incorporated in object_declaration as constants declared without an initialization expression. "),(0,i.kt)("h3",{id:"332--number-declarations"},"3.3.2  Number Declarations"),(0,i.kt)("p",null,"A number_declaration declares a named number. "),(0,i.kt)("p",null,"Discussion: If a value or other property of a construct is required to be static that means it is required to be determined prior to execution. A static expression is an expression whose value is computed at compile time and is usable in contexts where the actual value might affect the legality of the construct. This is fully defined in clause 4.9. "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"number_declaration ::=\ndefining_identifier_list : constant := static_expression;"),(0,i.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,i.kt)("p",null,"The static_expression given for a number_declaration is expected to be of any numeric type."),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"The static_expression given for a number declaration shall be a static expression, as defined by clause 4.9. "),(0,i.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,i.kt)("p",null,"The named number denotes a value of type universal_integer if the type of the static_expression is an integer type. The named number denotes a value of type universal_real if the type of the static_expression is a real type."),(0,i.kt)("p",null,"The value denoted by the named number is the value of the static_expression, converted to the corresponding universal type. "),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a number_declaration has no effect. "),(0,i.kt)("p",null,"Proof: Since the static_expression was evaluated at compile time. "),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Examples of number declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Two_Pi        : constant := 2.0*Ada.Numerics.Pi;   -- a real number (see A.5)\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Max           : constant := 500;                   -- an integer number\nMax_Line_Size : constant := Max/6                  -- the integer 83\nPower_16      : constant := 2**16;                 -- the integer 65_536\nOne, Un, Eins : constant := 1;                     -- three different names for 1\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,i.kt)("p",null,"We now allow a static expression of any numeric type to initialize a named number. For integer types, it was possible in Ada 83 to use 'Pos to define a named number, but there was no way to use a static expression of some nonuniversal real type to define a named number. This change is upward compatible because of the preference rule for the operators of the root numeric types. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-7"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have moved the syntax rule into this subclause."),(0,i.kt)("p",null,"AI83-00263 describes the elaboration of a number declaration in words similar to that of an object_declaration. However, since there is no expression to be evaluated and no object to be created, it seems simpler to say that the elaboration has no effect. "),(0,i.kt)("h2",{id:"34--derived-types-and-classes"},"3.4  Derived Types and Classes"),(0,i.kt)("p",null,"A derived_type_definition defines a new type (and its first subtype) whose characteristics are derived from those of a parent type. "),(0,i.kt)("p",null,"Glossary entry: A derived type is a type defined in terms of another type, which is the parent type of the derived type. Each class containing the parent type also contains the derived type. The derived type inherits properties such as components and primitive operations from the parent. A type together with the types derived from it (directly or indirectly) form a derivation class."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[derived type]",", Def=","[a type defined in terms of a parent type and zero or more progenitor types given in a derived type definition]",", Note1=","[A derived type inherits properties such as components and primitive operations from its parent and progenitors.]",", Note2=","[A type together with the types derived from it (directly or indirectly) form a derivation class.]"),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("p",null,"derived_type_definition ::= ","[abstract]"," new parent_subtype_indication ","[record_extension_part]"),(0,i.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,i.kt)("p",null,"The parent_subtype_indication defines the parent subtype; its type is the parent type. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[parent of a derived type]",", Def=","[the first ancestor type given in the definition of the derived type]",", Note1=","[The parent can be almost any kind of type, including an interface type.]"),(0,i.kt)("p",null,"A type shall be completely defined (see 3.11.1) prior to being specified as the parent type in a derived_type_definition - ","[the full_type_declarations for the parent type and any of its subcomponents have to precede the derived_type_definition.]"," "),(0,i.kt)("p",null,"Discussion: This restriction does not apply to the ancestor type of a private extension - see 7.3; such a type need not be completely defined prior to the private_extension_declaration. However, the restriction does apply to record extensions, so the ancestor type will have to be completely defined prior to the full_type_declaration corresponding to the private_extension_declaration. "),(0,i.kt)("p",null,"Reason: We originally hoped we could relax this restriction. However, we found it too complex to specify the rules for a type derived from an incompletely defined limited type that subsequently became nonlimited. "),(0,i.kt)("p",null,"If there is a record_extension_part, the derived type is called a record extension of the parent type. A record_extension_part shall be provided if and only if the parent type is a tagged type. "),(0,i.kt)("p",null,"Implementation Note: We allow a record extension to inherit discriminants; an early version of Ada 9X did not. If the parent subtype is unconstrained, it can be implemented as though its discriminants were repeated in a new known_discriminant_part and then used to constrain the old ones one-for-one. However, in an extension aggregate, the discriminants in this case do not appear in the component association list. "),(0,i.kt)("p",null,"Ramification: This rule needs to be rechecked in the visible part of an instance of a generic unit "),(0,i.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,i.kt)("p",null,"The first subtype of the derived type is unconstrained if a known_discriminant_part is provided in the declaration of the derived type, or if the parent subtype is unconstrained. Otherwise, the constraint of the first subtype corresponds to that of the parent subtype in the following sense: it is the same as that of the parent subtype except that for a range constraint (implicit or explicit), the value of each bound of its range is replaced by the corresponding value of the derived type. "),(0,i.kt)("p",null,'Discussion: A digits_constraint in a subtype_indication for a decimal fixed point subtype always imposes a range constraint, implicitly if there is no explicit one given. See 3.5.9, "Fixed Point Types". '),(0,i.kt)("p",null,"The characteristics of the derived type are defined as follows: "),(0,i.kt)("p",null,"Each class of types that includes the parent type also includes the derived type. "),(0,i.kt)("p",null,'Discussion: This is inherent in our notion of a "class" of types. It is not mentioned in the initial definition of "class" since at that point type derivation has not been defined. In any case, this rule ensures that every class of types is closed under derivation. '),(0,i.kt)("p",null,"If the parent type is an elementary type or an array type, then the set of possible values of the derived type is a copy of the set of possible values of the parent type. For a scalar type, the base range of the derived type is the same as that of the parent type. "),(0,i.kt)("p",null,"Discussion: The base range of a type defined by an integer_type_definition or a real_type_definition is determined by the _definition, and is not necessarily the same as that of the corresponding root numeric type from which the newly defined type is implicitly derived. Treating numerics types as implicitly derived from one of the two root numeric types is simply to link them into a type hierarchy; such an implicit derivation does not follow all the rules given here for an explicit derived_type_definition. "),(0,i.kt)("p",null,"If the parent type is a composite type other than an array type, then the components, protected subprograms, and entries that are declared for the derived type are as follows: "),(0,i.kt)("p",null,"The discriminants specified by a new known_discriminant_part, if there is one; otherwise, each discriminant of the parent type (implicitly declared in the same order with the same specifications) - in the latter case, the discriminants are said to be inherited, or if unknown in the parent, are also unknown in the derived type;"),(0,i.kt)("p",null,"Each nondiscriminant component, entry, and protected subprogram of the parent type, implicitly declared in the same order with the same declarations; these components, entries, and protected subprograms are said to be inherited; "),(0,i.kt)("p",null,'Ramification: The profiles of entries and protected subprograms do not change upon type derivation, although the type of the "implicit" parameter identified by the prefix of the name in a call does.'),(0,i.kt)("p",null,"To be honest: Any name in the parent type_declaration that denotes the current instance of the type is replaced with a name denoting the current instance of the derived type, converted to the parent type."),(0,i.kt)("p",null,"Each component declared in a record_extension_part, if any. "),(0,i.kt)("p",null,"Declarations of components, protected subprograms, and entries, whether implicit or explicit, occur immediately within the declarative region of the type, in the order indicated above, following the parent subtype_indication. "),(0,i.kt)("p",null,"Discussion: The order of declarations within the region matters for record_aggregates and extension_aggregates. "),(0,i.kt)("p",null,'Ramification: In most cases, these things are implicitly declared immediately following the parent subtype_indication. However, 7.3.1, "Private Operations" defines some cases in which they are implicitly declared later, and some cases in which the are not declared at all. '),(0,i.kt)("p",null,'Discussion: The place of the implicit declarations of inherited components matters for visibility - they are not visible in the known_discriminant_part nor in the parent subtype_indication, but are usually visible within the record_extension_part, if any (although there are restrictions on their use). Note that a discriminant specified in a new known_discriminant_part is not considered "inherited" even if it has the same name and subtype as a discriminant of the parent type. '),(0,i.kt)("p",null,"The derived type is limited if and only if the parent type is limited. "),(0,i.kt)("p",null,"To be honest: The derived type can become nonlimited if the derivation takes place in the visible part of a child package, and the parent type is nonlimited as viewed from the private part of the child package - see 7.5. "),(0,i.kt)("p",null,"[For each predefined operator of the parent type, there is a corresponding predefined operator of the derived type.]"," "),(0,i.kt)("p",null,"Proof: This is a ramification of the fact that each class that includes the parent type also includes the derived type, and the fact that the set of predefined operators that is defined for a type, as described in 4.5, is determined by the classes to which it belongs. "),(0,i.kt)("p",null,'Reason: Predefined operators are handled separately because they follow a slightly different rule than user-defined primitive subprograms. In particular the systematic replacement described below does not apply fully to the relational operators for Boolean and the exponentiation operator for Integer. The relational operators for a type derived from Boolean still return Standard.Boolean. The exponentiation operator for a type derived from Integer still expects Standard.Integer for the right operand. In addition, predefined operators "reemerge" when a type is the actual type corresponding to a generic formal type, so they need to be well defined even if hidden by user-defined primitive subprograms. '),(0,i.kt)("p",null,"For each user-defined primitive subprogram (other than a user-defined equality operator - see below) of the parent type that already exists at the place of the derived_type_definition, there exists a corresponding inherited primitive subprogram of the derived type with the same defining name. Primitive user-defined equality operators of the parent type are also inherited by the derived type, except when the derived type is a nonlimited record extension, and the inherited operator would have a profile that is type conformant with the profile of the corresponding predefined equality operator; in this case, the user-defined equality operator is not inherited, but is rather incorporated into the implementation of the predefined equality operator of the record extension (see 4.5.2). "),(0,i.kt)("p",null,'Ramification: We say "...already exists..." rather than "is visible" or "has been declared" because there are certain operations that are declared later, but still exist at the place of the derived_type_definition, and there are operations that are never declared, but still exist. These cases are explained in 7.3.1.'),(0,i.kt)("p",null,"Note that nonprivate extensions can appear only after the last primitive subprogram of the parent - the freezing rules ensure this. "),(0,i.kt)("p",null,"Reason: A special case is made for the equality operators on nonlimited record extensions because their predefined equality operators are already defined in terms of the primitive equality operator of their parent type (and of the tagged components of the extension part). Inheriting the parent's equality operator as is would be undesirable, because it would ignore any components of the extension part. On the other hand, if the parent type is limited, then any user-defined equality operator is inherited as is, since there is no predefined equality operator to take its place. "),(0,i.kt)("p",null,"Ramification: Because user-defined equality operators are not inherited by record extensions, the formal parameter names of = and /= revert to Left and Right, even if different formal parameter names were used in the user-defined equality operators of the parent type. "),(0,i.kt)("p",null,"The profile of an inherited subprogram (including an inherited enumeration literal) is obtained from the profile of the corresponding (user-defined) primitive subprogram of the parent type, after systematic replacement of each subtype of its profile (see 6.1) that is of the parent type with a corresponding subtype of the derived type. For a given subtype of the parent type, the corresponding subtype of the derived type is defined as follows: "),(0,i.kt)("p",null,"If the declaration of the derived type has neither a known_discriminant_part nor a record_extension_part, then the corresponding subtype has a constraint that corresponds (as defined above for the first subtype of the derived type) to that of the given subtype."),(0,i.kt)("p",null,"If the derived type is a record extension, then the corresponding subtype is the first subtype of the derived type."),(0,i.kt)("p",null,"If the derived type has a new known_discriminant_part but is not a record extension, then the corresponding subtype is constrained to those values that when converted to the parent type belong to the given subtype (see 4.6). "),(0,i.kt)("p",null,"Reason: An inherited subprogram of an untagged type has an Intrinsic calling convention, which precludes the use of the Access attribute. We preclude 'Access because correctly performing all required constraint checks on an indirect call to such an inherited subprogram was felt to impose an undesirable implementation burden."),(0,i.kt)("p",null,"The same formal parameters have default_expressions in the profile of the inherited subprogram. ","[Any type mismatch due to the systematic replacement of the parent type by the derived type is handled as part of the normal type conversion associated with parameter passing - see 6.4.1.]"," "),(0,i.kt)("p",null,"Reason: We don't introduce the type conversion explicitly here since conversions to record extensions or on access parameters are not generally legal. Furthermore, any type conversion would just be \"undone\" since the parent's subprogram is ultimately being called anyway. "),(0,i.kt)("p",null,"If a primitive subprogram of the parent type is visible at the place of the derived_type_definition, then the corresponding inherited subprogram is implicitly declared immediately after the derived_type_definition. Otherwise, the inherited subprogram is implicitly declared later or not at all, as explained in 7.3.1."),(0,i.kt)("p",null,"A derived type can also be defined by a private_extension_declaration (see 7.3) or a formal_derived_type_definition (see 12.5.1). Such a derived type is a partial view of the corresponding full or actual type."),(0,i.kt)("p",null,"All numeric types are derived types, in that they are implicitly derived from a corresponding root numeric type (see 3.5.4 and 3.5.6)."),(0,i.kt)("h4",{id:"dynamic-semantics-5"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a derived_type_definition creates the derived type and its first subtype, and consists of the elaboration of the subtype_indication and the record_extension_part, if any. If the subtype_indication depends on a discriminant, then only those expressions that do not depend on a discriminant are evaluated. "),(0,i.kt)("p",null,"For the execution of a call on an inherited subprogram, a call on the corresponding primitive subprogram of the parent type is performed; the normal conversion of each actual parameter to the subtype of the corresponding formal parameter (see 6.4.1) performs any necessary type conversion as well. If the result type of the inherited subprogram is the derived type, the result of calling the parent's subprogram is converted to the derived type. "),(0,i.kt)("p",null,"Discussion: If an inherited function returns the derived type, and the type is a record extension, then the inherited function is abstract, and (unless overridden) cannot be called except via a dispatching call. See 3.9.3. "),(0,i.kt)("p",null,"NOTE 1   Classes are closed under derivation - any class that contains a type also contains its derivatives. Operations available for a given class of types are available for the derived types in that class."),(0,i.kt)("p",null,"NOTE 2   Evaluating an inherited enumeration literal is equivalent to evaluating the corresponding enumeration literal of the parent type, and then converting the result to the derived type. This follows from their equivalence to parameterless functions. "),(0,i.kt)("p",null,"NOTE 3   A generic subprogram is not a subprogram, and hence cannot be a primitive subprogram and cannot be inherited by a derived type. On the other hand, an instance of a generic subprogram can be a primitive subprogram, and hence can be inherited."),(0,i.kt)("p",null,"NOTE 4   If the parent type is an access type, then the parent and the derived type share the same storage pool; there is a null access value for the derived type and it is the implicit initial value for the type. See 3.10."),(0,i.kt)("p",null,"NOTE 5   If the parent type is a boolean type, the predefined relational operators of the derived type deliver a result of the predefined type Boolean (see 4.5.2). If the parent type is an integer type, the right operand of the predefined exponentiation operator is of the predefined type Integer (see 4.5.6)."),(0,i.kt)("p",null,"NOTE 6   Any discriminants of the parent type are either all inherited, or completely replaced with a new set of discriminants."),(0,i.kt)("p",null,"NOTE 7   For an inherited subprogram, the subtype of a formal parameter of the derived type need not have any value in common with the first subtype of the derived type. "),(0,i.kt)("p",null,"Proof: This happens when the parent subtype is constrained to a range that does not overlap with the range of a subtype of the parent type that appears in the profile of some primitive subprogram of the parent type. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T1 is range 1..100;\nsubtype S1 is T1 range 1..10;\nprocedure P(X : in S1);  -- P is a primitive subprogram\ntype T2 is new T1 range 11..20;\n-- implicitly declared:\n-- procedure P(X : in T2'Base range 1..10);\n--      X cannot be in T2'First .. T2'Last\n\n")),(0,i.kt)("p",null,"NOTE 8   If the reserved word abstract is given in the declaration of a type, the type is abstract (see 3.9.3)."),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Examples of derived type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Local_Coordinate is new Coordinate;   --  two different types\ntype Midweek is new Day range Tue .. Thu;  --  see 3.5.1\ntype Counter is new Positive;              --  same range as Positive \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'type Special_Key is new Key_Manager.Key;   --  see 7.3.1\n  -- the inherited subprograms have the following specifications: \n  --         procedure Get_Key(K : out Special_Key);\n  --         function "&lt"(X,Y : Special_Key) return Boolean;\n\n')),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"When deriving from a (nonprivate, nonderived) type in the same visible part in which it is defined, if a predefined operator had been overridden prior to the derivation, the derived type will inherit the user-defined operator rather than the predefined operator. The work-around (if the new behavior is not the desired behavior) is to move the definition of the derived type prior to the overriding of any predefined operators."),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-2"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"When deriving from a (nonprivate, nonderived) type in the same visible part in which it is defined, a primitive subprogram of the parent type declared before the derived type will be inherited by the derived type. This can cause upward incompatibilities in cases like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   package P is\n      type T is (A, B, C, D);\n      function F( X : T := A ) return Integer;\n      type NT is new T;\n      -- inherits F as\n      -- function F( X : NT := A ) return Integer;\n      -- in Ada 95 only\n      ...\n   end P;\n   ...\n   use P;  -- Only one declaration of F from P is use-visible in\n           -- Ada 83;  two declarations of F are use-visible in\n           -- Ada 95.\nbegin\n   ...\n   if F &gt 1 then ... -- legal in Ada 83, ambiguous in Ada 95\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax for a derived_type_definition is amended to include an optional record_extension_part (see 3.9.1)."),(0,i.kt)("p",null,"A derived type may override the discriminants of the parent by giving a new discriminant_part."),(0,i.kt)("p",null,"The parent type in a derived_type_definition may be a derived type defined in the same visible part."),(0,i.kt)("p",null,"When deriving from a type in the same visible part in which it is defined, the primitive subprograms declared prior to the derivation are inherited as primitive subprograms of the derived type. See 3.2.3. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-8"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We now talk about the classes to which a type belongs, rather than a single class."),(0,i.kt)("p",null,'As explained in Section 13, the concept of "storage pool" replaces the Ada 83 concept of "collection." These concepts are similar, but not the same. '),(0,i.kt)("h3",{id:"341--derivation-classes"},"3.4.1  Derivation Classes"),(0,i.kt)("p",null,"In addition to the various language-defined classes of types, types can be grouped into derivation classes. "),(0,i.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,i.kt)("p",null,"A derived type is derived from its parent type directly; it is derived indirectly from any type from which its parent type is derived. The derivation class of types for a type T (also called the class rooted at T) is the set consisting of T (the root type of the class) and all types derived from T (directly or indirectly) plus any associated universal or class-wide types (defined below). "),(0,i.kt)("p",null,'Discussion: Note that the definition of "derived from" is a recursive definition. We don\'t define a root type for all interesting language-defined classes, though presumably we could. '),(0,i.kt)("p",null,'To be honest: By the class-wide type "associated" with a type T, we mean the type T\'Class. Similarly, the universal type associated with root_integer, root_real, and root_fixed are universal_integer, universal_real, and universal_fixed, respectively. '),(0,i.kt)("p",null,"Every type is either a specific type, a class-wide type, or a universal type. A specific type is one defined by a type_declaration, a formal_type_declaration, or a full type definition embedded in a declaration for an object. Class-wide and universal types are implicitly defined, to act as representatives for an entire class of types, as follows: "),(0,i.kt)("p",null,"To be honest: The root types root_integer, root_real, and root_fixed are also specific types. They are declared in the specification of package Standard. "),(0,i.kt)("p",null,"Class-wide types Class-wide types are defined for ","[(and belong to)]"," each derivation class rooted at a tagged type (see 3.9). Given a subtype S of a tagged type T, S'Class is the subtype_mark for a corresponding subtype of the tagged class-wide type T'Class. Such types are called \"class-wide\" because when a formal parameter is defined to be of a class-wide type T'Class, an actual parameter of any type in the derivation class rooted at T is acceptable (see 8.6)."),(0,i.kt)("p",null,"The set of values for a class-wide type T'Class is the discriminated union of the set of values of each specific type in the derivation class rooted at T (the tag acts as the implicit discriminant - see 3.9). Class-wide types have no primitive subprograms of their own. However, as explained in 3.9.2, operands of a class-wide type T'Class can be used as part of a dispatching call on a primitive subprogram of the type T. The only components ","[(including discriminants)]"," of T'Class that are visible are those of T. If S is a first subtype, then S'Class is a first subtype. "),(0,i.kt)("p",null,"Reason: We want S'Class to be a first subtype when S is, so that an attribute_definition_clause like \"for S'Class'Output use ...;\" will be legal. "),(0,i.kt)("p",null,"Universal types Universal types are defined for ","[(and belong to)]",' the integer, real, and fixed point classes, and are referred to in this standard as respectively, universal_integer, universal_real, and universal_fixed. These are analogous to class-wide types for these language-defined numeric classes. As with class-wide types, if a formal parameter is of a universal type, then an actual parameter of any type in the corresponding class is acceptable. In addition, a value of a universal type (including an integer or real numeric_literal) is "universal" in that it is acceptable where some particular type in the class is expected (see 8.6).'),(0,i.kt)("p",null,'The set of values of a universal type is the undiscriminated union of the set of values possible for any definable type in the associated class. Like class-wide types, universal types have no primitive subprograms of their own. However, their "universality" allows them to be used as operands with the primitive subprograms of any type in the corresponding class. '),(0,i.kt)("p",null,"Discussion: A class-wide type is only class-wide in one direction, from specific to class-wide, whereas a universal type is class-wide (universal) in both directions, from specific to universal and back."),(0,i.kt)("p",null,"We considered defining class-wide or perhaps universal types for all derivation classes, not just tagged classes and these three numeric classes. However, this was felt to overly weaken the strong-typing model in some situations. Tagged types preserve strong type distinctions thanks to the run-time tag. Class-wide or universal types for untagged types would weaken the compile-time type distinctions without providing a compensating run-time-checkable distinction."),(0,i.kt)("p",null,"We considered defining standard names for the universal numeric types so they could be used in formal parameter specifications. However, this was felt to impose an undue implementation burden for some implementations. "),(0,i.kt)("p",null,"To be honest: Formally, the set of values of a universal type is actually a copy of the undiscriminated union of the values of the types in its class. This is because we want each value to have exactly one type, with explicit or implicit conversion needed to go between types. An alternative, consistent model would be to associate a class, rather than a particular type, with a value, even though any given expression would have a particular type. In that case, implicit type conversions would not generally need to change the value, although an associated subtype conversion might need to. "),(0,i.kt)("p",null,"The integer and real numeric classes each have a specific root type in addition to their universal type, named respectively root_integer and root_real."),(0,i.kt)("p",null,"A class-wide or universal type is said to cover all of the types in its class. A specific type covers only itself."),(0,i.kt)("p",null,"A specific type T2 is defined to be a descendant of a type T1 if T2 is the same as T1, or if T2 is derived (directly or indirectly) from T1. A class-wide type T2'Class is defined to be a descendant of type T1 if T2 is a descendant of T1. Similarly, the universal types are defined to be descendants of the root types of their classes. If a type T2 is a descendant of a type T1, then T1 is called an ancestor of T2. The ultimate ancestor of a type is the ancestor of the type that is not a descendant of any other type. "),(0,i.kt)("p",null,"Ramification: A specific type is a descendant of itself. Class-wide types are considered descendants of the corresponding specific type, and do not have any descendants of their own."),(0,i.kt)("p",null,"A specific type is an ancestor of itself. The root of a derivation class is an ancestor of all types in the class, including any class-wide types in the class. "),(0,i.kt)("p",null,"Discussion: The terms root, parent, ancestor, and ultimate ancestor are all related. For example: "),(0,i.kt)("p",null,'Each type has at most one parent, and one or more ancestor types; each type has exactly one ultimate ancestor. In Ada 83, the term "parent type" was sometimes used more generally to include any ancestor type (e.g. RM83-9.4(14)). In Ada 95, we restrict parent to mean the immediate ancestor.'),(0,i.kt)("p",null,"A class of types has at most one root type; a derivation class has exactly one root type."),(0,i.kt)("p",null,"The root of a class is an ancestor of all of the types in the class (including itself)."),(0,i.kt)("p",null,"The type root_integer is the root of the integer class, and is the ultimate ancestor of all integer types. A similar statement applies to root_real. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[ancestor of a type]",", Def=","[the type itself or, in the case of a type derived from other types, its parent type or one of its progenitor types or one of their ancestors]",", Note1=","[Ancestor and descendant are inverse relationships.]"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[descendant of a type]",", Def=","[the type itself or a type derived (directly or indirectly) from it]",", Note1=","[Descendant and ancestor are inverse relationships.]"),(0,i.kt)("p",null,"An inherited component ","[(including an inherited discriminant)]"," of a derived type is inherited from a given ancestor of the type if the corresponding component was inherited by each derived type in the chain of derivations going back to the given ancestor."),(0,i.kt)("p",null,"NOTE   Because operands of a universal type are acceptable to the predefined operators of any type in their class, ambiguity can result. For universal_integer and universal_real, this potential ambiguity is resolved by giving a preference (see 8.6) to the predefined operators of the corresponding root types (root_integer and root_real, respectively). Hence, in an apparently ambiguous expression like "),(0,i.kt)("p",null,"1 + 4 ","<"," 7"),(0,i.kt)("p",null,"where each of the literals is of type universal_integer, the predefined operators of root_integer will be preferred over those of other specific integer types, thereby resolving the ambiguity. "),(0,i.kt)("p",null,'Ramification: Except for this preference, a root numeric type is essentially like any other specific type in the associated numeric class. In particular, the result of a predefined operator of a root numeric type is not "universal" (implicitly convertible) even if both operands were. '),(0,i.kt)("h2",{id:"35--scalar-types"},"3.5  Scalar Types"),(0,i.kt)("p",null,"Scalar types comprise enumeration types, integer types, and real types. Enumeration types and integer types are called discrete types; each value of a discrete type has a position number which is an integer value. Integer types and real types are called numeric types. ","[All scalar types are ordered, that is, all relational operators are predefined for their values.]"),(0,i.kt)("h4",{id:"syntax-6"},"Syntax"),(0,i.kt)("p",null,"range_constraint ::=  range range"),(0,i.kt)("p",null,"range ::=  range_attribute_reference\n| simple_expression .. simple_expression"),(0,i.kt)("p",null,"Discussion: These need to be simple_expressions rather than more general expressions because ranges appear in membership tests and other contexts where expression .. expression would be ambiguous. "),(0,i.kt)("p",null,'A range has a lower bound and an upper bound and specifies a subset of the values of some scalar type (the type of the range). A range with lower bound L and upper bound R is described by "L .. R". If R is less than L, then the range is a null range, and specifies an empty set of values. Otherwise, the range specifies the values of the type from the lower bound to the upper bound, inclusive. A value belongs to a range if it is of the type of the range, and is in the subset of values specified by the range. A value satisfies a range constraint if it belongs to the associated range. One range is included in another if all values that belong to the first range also belong to the second. '),(0,i.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a subtype_indication containing a range_constraint, either directly or as part of some other scalar_constraint, the type of the range shall resolve to that of the type determined by the subtype_mark of the subtype_indication. For a range of a given type, the simple_expressions of the range (likewise, the simple_expressions of the equivalent range for a range_attribute_reference) are expected to be of the type of the range. "),(0,i.kt)("p",null,"Discussion: In Ada 95, constraints only appear within subtype_indications; things that look like constraints that appear in type declarations are called something else like real_range_specifications."),(0,i.kt)("p",null,'We say "the expected type is ..." or "the type is expected to be ..." depending on which reads better. They are fundamentally equivalent, and both feed into the type resolution rules of clause 8.6.'),(0,i.kt)("p",null,'In some cases, it doesn\'t work to use expected types. For example, in the above rule, we say that the "type of the range shall resolve to ..." rather than "the expected type for the range is ..." We then use "expected type" for the bounds. If we used "expected" at both points, there would be an ambiguity, since one could apply the rules of 8.6 either on determining the type of the range, or on determining the types of the individual bounds. It is clearly important to allow one bound to be of a universal type, and the other of a specific type, so we need to use "expected type" for the bounds. Hence, we used "shall resolve to" for the type of the range as a whole. There are other situations where "expected type" is not quite right, and we use "shall resolve to" instead. '),(0,i.kt)("h4",{id:"static-semantics-9"},"Static Semantics"),(0,i.kt)("p",null,"The base range of a scalar type is the range of finite values of the type that can be represented in every unconstrained object of the type; it is also the range supported at a minimum for intermediate values during the evaluation of expressions involving predefined operators of the type. "),(0,i.kt)("p",null,"Implementation Note: Note that in some machine architectures intermediates in an expression (particularly if static), and register-resident variables might accommodate a wider range. The base range does not include the values of this wider range that are not assignable without overflow to memory-resident objects."),(0,i.kt)("p",null,"Ramification: The base range of an enumeration type is the range of values of the enumeration type. "),(0,i.kt)("p",null,"Reason: If the representation supports infinities, the base range is nevertheless restricted to include only the representable finite values, so that 'Base'First and 'Base'Last are always guaranteed to be finite."),(0,i.kt)("p",null,'To be honest: By a "value that can be assigned without overflow" we don\'t mean to restrict ourselves to values that can be represented exactly. Values between machine representable values can be assigned, but on subsequent reading, a slightly different value might be retrieved, as (partially) determined by the number of digits of precision of the type. '),(0,i.kt)("p",null,"[A constrained scalar subtype is one to which a range constraint applies.]"," The range of a constrained scalar subtype is the range associated with the range constraint of the subtype. The range of an unconstrained scalar subtype is the base range of its type. "),(0,i.kt)("h4",{id:"dynamic-semantics-6"},"Dynamic Semantics"),(0,i.kt)("p",null,"A range is compatible with a scalar subtype if and only if it is either a null range or each bound of the range belongs to the range of the subtype. A range_constraint is compatible with a scalar subtype if and only if its range is compatible with the subtype. "),(0,i.kt)("p",null,"Ramification: Only range_constraints (explicit or implicit) impose conditions on the values of a scalar subtype. The other scalar_constraints, digits_constraints and delta_constraints impose conditions on the subtype denoted by the subtype_mark in a subtype_indication, but don't impose a condition on the values of the subtype being defined. Therefore, a scalar subtype is not called constrained if all that applies to it is a digits_constraint. Decimal subtypes are subtle, because a digits_constraint without a range_constraint nevertheless includes an implicit range_constraint. "),(0,i.kt)("p",null,"The elaboration of a range_constraint consists of the evaluation of the range. The evaluation of a range determines a lower bound and an upper bound. If simple_expressions are given to specify bounds, the evaluation of the range evaluates these simple_expressions in an arbitrary order, and converts them to the type of the range. If a range_attribute_reference is given, the evaluation of the range consists of the evaluation of the range_attribute_reference."),(0,i.kt)("p",null,"Attributes"),(0,i.kt)("p",null,"For every scalar subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'FirstS'First denotes the lower bound of the range of S. The value of this attribute is of the type of S. "),(0,i.kt)("p",null,"Ramification: Evaluating S'First never raises Constraint_Error."),(0,i.kt)("p",null,"S'LastS'Last denotes the upper bound of the range of S. The value of this attribute is of the type of S. "),(0,i.kt)("p",null,"Ramification: Evaluating S'Last never raises Constraint_Error."),(0,i.kt)("p",null,"S'RangeS'Range is equivalent to the range S'First .. S'Last."),(0,i.kt)("p",null,"S'BaseS'Base denotes an unconstrained subtype of the type of S. This unconstrained subtype is called the base subtype of the type. "),(0,i.kt)("p",null,"S'MinS'Min denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Min(Left, Right : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the lesser of the values of the two parameters. "),(0,i.kt)("p",null,"Discussion: The formal parameter names are italicized because they cannot be used in calls - see 6.4. Such a specification cannot be written by the user because an attribute_reference is not permitted as the designator of a user-defined function, nor can its formal parameters be anonymous. "),(0,i.kt)("p",null,"S'MaxS'Max denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Max(Left, Right : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the greater of the values of the two parameters."),(0,i.kt)("p",null,"S'SuccS'Succ denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Succ(Arg : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"For an enumeration type, the function returns the value whose position number is one more than that of the value of Arg; Constraint_Error is raised if there is no such value of the type. For an integer type, the function returns the result of adding one to the value of Arg. For a fixed point type, the function returns the result of adding small to the value of Arg. For a floating point type, the function returns the machine number (as defined in 3.5.7) immediately above the value of Arg; Constraint_Error is raised if there is no such machine number. "),(0,i.kt)("p",null,"Ramification: S'Succ for a modular integer subtype wraps around if the value of Arg is S'Base'Last. S'Succ for a signed integer subtype might raise Constraint_Error if the value of Arg is S'Base'Last, or it might return the out-of-base-range value S'Base'Last+1, as is permitted for all predefined numeric operations. "),(0,i.kt)("p",null,"S'PredS'Pred denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Pred(Arg : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"For an enumeration type, the function returns the value whose position number is one less than that of the value of Arg; Constraint_Error is raised if there is no such value of the type. For an integer type, the function returns the result of subtracting one from the value of Arg. For a fixed point type, the function returns the result of subtracting small from the value of Arg. For a floating point type, the function returns the machine number (as defined in 3.5.7) immediately below the value of Arg; Constraint_Error is raised if there is no such machine number. "),(0,i.kt)("p",null,"Ramification: S'Pred for a modular integer subtype wraps around if the value of Arg is S'Base'First. S'Pred for a signed integer subtype might raise Constraint_Error if the value of Arg is S'Base'First, or it might return the out-of-base-range value S'Base'First1, as is permitted for all predefined numeric operations. "),(0,i.kt)("p",null,"S'Wide_ImageS'Wide_Image denotes a function with the following specification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Wide_Image(Arg : S'Base)\n  return Wide_String\n\n")),(0,i.kt)("p",null,"The function returns an image of the value of Arg, that is, a sequence of characters representing the value in display form. The lower bound of the result is one."),(0,i.kt)("p",null,"Implementation defined: "),(0,i.kt)("p",null,"The image of an integer value is the corresponding decimal literal, without underlines, leading zeros, exponent, or trailing spaces, but with a single leading character that is either a minus sign or a space. "),(0,i.kt)("p",null,'Implementation Note: If the machine supports negative zeros for signed integer types, it is not specified whether "0" or " 0" should be returned for negative zero. We don\'t have enough experience with such machines to know what is appropriate, and what other languages do. In any case, the implementation should be consistent. '),(0,i.kt)("p",null,'The image of an enumeration value is either the corresponding identifier in upper case or the corresponding character literal (including the two apostrophes); neither leading nor trailing spaces are included. For a nongraphic character (a value of a character type that has no enumeration literal associated with it), the result is a corresponding language-defined or implementation-defined name in upper case (for example, the image of the nongraphic character identified as nul is "NUL" - the quotes are not part of the image). '),(0,i.kt)("p",null,'Implementation Note: For an enumeration type T that has "holes" (caused by an enumeration_representation_clause), T\'Wide_Image should raise Program_Error if the value is one of the holes (which is a bounded error anyway, since holes can be generated only via uninitialized variables and similar things). '),(0,i.kt)("p",null,"The image of a floating point value is a decimal real literal best approximating the value (rounded away from zero if halfway between) with a single leading character that is either a minus sign or a space, a single digit (that is nonzero unless the value is zero), a decimal point, S'Digits1 (see 3.5.8) digits after the decimal point (but one if S'Digits is one), an upper case E, the sign of the exponent (either + or ), and two or more digits (with leading zeros if necessary) representing the exponent. If S'Signed_Zeros is True, then the leading character is a minus sign for a negatively signed zero. "),(0,i.kt)("p",null,"To be honest: Leading zeros are present in the exponent only if necessary to make the exponent at least two digits. "),(0,i.kt)("p",null,"Reason: This image is intended to conform to that produced by Text_IO.Float_IO.Put in its default format. "),(0,i.kt)("p",null,"Implementation Note: The rounding direction is specified here to ensure portability of output results. "),(0,i.kt)("p",null,"The image of a fixed point value is a decimal real literal best approximating the value (rounded away from zero if halfway between) with a single leading character that is either a minus sign or a space, one or more digits before the decimal point (with no redundant leading zeros), a decimal point, and S'Aft (see 3.5.10) digits after the decimal point. "),(0,i.kt)("p",null,"Reason: This image is intended to conform to that produced by Text_IO.Fixed_IO.Put. "),(0,i.kt)("p",null,"Implementation Note: The rounding direction is specified here to ensure portability of output results. "),(0,i.kt)("p",null,'Implementation Note: For a machine that supports negative zeros, it is not specified whether "0.000" or " 0.000" is returned. See corresponding comment above about integer types with signed zeros. '),(0,i.kt)("p",null,"S'ImageS'Image denotes a function with the following specification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Image(Arg : S'Base)\n  return String\n\n")),(0,i.kt)("p",null,"The function returns an image of the value of Arg as a String. The lower bound of the result is one. The image has the same sequence of graphic characters as that defined for S'Wide_Image if all the graphic characters are defined in Character; otherwise the sequence of characters is implementation defined (but no shorter than that of S'Wide_Image for the same value of Arg)."),(0,i.kt)("p",null,"Implementation defined: The sequence of characters of the value returned by S'Image when some of the graphic characters of S'Wide_Image are not defined in Character."),(0,i.kt)("p",null,"S'Wide_WidthS'Wide_Width denotes the maximum length of a Wide_String returned by S'Wide_Image over all values of the subtype S. It denotes zero for a subtype that has a null range. Its type is universal_integer."),(0,i.kt)("p",null,"S'WidthS'Width denotes the maximum length of a String returned by S'Image over all values of the subtype S. It denotes zero for a subtype that has a null range. Its type is universal_integer."),(0,i.kt)("p",null,"S'Wide_ValueS'Wide_Value denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Wide_Value(Arg : Wide_String)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value given an image of the value as a Wide_String, ignoring any leading or trailing spaces."),(0,i.kt)("p",null,"For the evaluation of a call on S'Wide_Value for an enumeration subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Wide_Image for a nongraphic character of the type), the result is the corresponding enumeration value; otherwise Constraint_Error is raised. "),(0,i.kt)("p",null,"Discussion: It's not crystal clear that Range_Check is appropriate here, but it doesn't seem worthwhile to invent a whole new check name just for this weird case, so we decided to lump it in with Range_Check. "),(0,i.kt)("p",null,"For the evaluation of a call on S'Wide_Value (or S'Value) for an integer subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an integer literal, with an optional leading sign character (plus or minus for a signed type; only plus for a modular type), and the corresponding numeric value belongs to the base range of the type of S, then that value is the result; otherwise Constraint_Error is raised."),(0,i.kt)("p",null,"Discussion: We considered allowing 'Value to return a representable but out-of-range value without a Constraint_Error. However, we currently require (see 4.9) in an assignment_statement like \"X := ","<","numeric_literal",">","\" that the value of the numeric-literal be in X's base range (at compile time), so it seems unfriendly and confusing to have a different range allowed for 'Value. Furthermore, for modular types, without the requirement for being in the base range, 'Value would have to handle arbitrarily long literals (since overflow never occurs for modular types). "),(0,i.kt)("p",null,"For the evaluation of a call on S'Wide_Value (or S'Value) for a real subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of one of the following: "),(0,i.kt)("p",null,"numeric_literal"),(0,i.kt)("p",null,"numeral.","[exponent]"),(0,i.kt)("p",null,".numeral","[exponent]"),(0,i.kt)("p",null,"base#based_numeral.#","[exponent]"),(0,i.kt)("p",null,"base#.based_numeral#","[exponent]"," "),(0,i.kt)("p",null,"with an optional leading sign character (plus or minus), and if the corresponding numeric value belongs to the base range of the type of S, then that value is the result; otherwise Constraint_Error is raised. The sign of a zero value is preserved (positive if none has been specified) if S'Signed_Zeros is True."),(0,i.kt)("p",null,"S'ValueS'Value denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Value(Arg : String)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value given an image of the value as a String, ignoring any leading or trailing spaces."),(0,i.kt)("p",null,"For the evaluation of a call on S'Value for an enumeration subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Image for a value of the type), the result is the corresponding enumeration value; otherwise Constraint_Error is raised. For a numeric subtype S, the evaluation of a call on S'Value with Arg of type String is equivalent to a call on S'Wide_Value for a corresponding Arg of type Wide_String. "),(0,i.kt)("p",null,"Reason: S'Value is subtly different from S'Wide_Value for enumeration subtypessince S'Image might produce a different sequence of characters than S'Wide_Image if the enumeration literal uses characters outside of the predefined type Character. That is why we don't just define S'Value in terms of S'Wide_Value for enumeration subtypes. S'Value and S'Wide_Value for numeric subtypes yield the same result given the same sequence of characters. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may extend the Wide_Value, ","[Value, Wide_Image, and Image]"," attributes of a floating point type to support special values such as infinities and NaNs."),(0,i.kt)("p",null,"Proof: The permission is really only necessary for Wide_Value, because Value is defined in terms of Wide_Value, and because the behavior of Wide_Image and Image is already unspecified for things like infinities and NaNs. "),(0,i.kt)("p",null,"Reason: This is to allow implementations to define full support for IEEE arithmetic. See also the similar permission for Get in A.10.9. "),(0,i.kt)("p",null,"NOTE 1   The evaluation of S'First or S'Last never raises an exception. If a scalar subtype S has a nonnull range, S'First and S'Last belong to this range. These values can, for example, always be assigned to a variable of subtype S. "),(0,i.kt)("p",null,'Discussion: This paragraph addresses an issue that came up with Ada 83, where for fixed point types, the end points of the range specified in the type definition were not necessarily within the base range of the type. However, it was later clarified (and we reconfirm it in 3.5.9, "Fixed Point Types") that the First and Last attributes reflect the true bounds chosen for the type, not the bounds specified in the type definition (which might be outside the ultimately chosen base range). '),(0,i.kt)("p",null,"NOTE 2   For a subtype of a scalar type, the result delivered by the attributes Succ, Pred, and Value might not belong to the subtype; similarly, the actual parameters of the attributes Succ, Pred, and Image need not belong to the subtype."),(0,i.kt)("p",null,"NOTE 3   For any value V (including any nongraphic character) of an enumeration subtype S, S'Value(S'Image(V)) equals V, as does S'Wide_Value(S'Wide_Image(V)). Neither expression ever raises Constraint_Error. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"Examples of ranges: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-10 .. 10\nX .. X + 1\n0.0 .. 2.0*Pi\nRed .. Green     -- see 3.5.1\n1 .. 0           -- a null range\nTable'Range      -- a range attribute reference (see 3.6)\n\n")),(0,i.kt)("p",null,"Examples of range constraints: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"range -999.0 .. +999.0\nrange S'First+1 .. S'Last-1\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-3"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"S'Base is no longer defined for nonscalar types. One conceivable existing use of S'Base for nonscalar types is S'Base'Size where S is a generic formal private type. However, that is not generally useful because the actual subtype corresponding to S might be a constrained array or discriminated type, which would mean that S'Base'Size might very well overflow (for example, S'Base'Size where S is a constrained subtype of String will generally be 8 * (Integer'Last + 1)). For derived discriminated types that are packed, S'Base'Size might not even be well defined if the first subtype is constrained, thereby allowing some amount of normally required \"dope\" to have been squeezed out in the packing. Hence our conclusion is that S'Base'Size is not generally useful in a generic, and does not justify keeping the attribute Base for nonscalar types just so it can be used as a prefix."),(0,i.kt)("h4",{id:"extensions-to-ada-83-5"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The attribute S'Base for a scalar subtype is now permitted anywhere a subtype_mark is permitted. S'Base'First .. S'Base'Last is the base range of the type. Using an attribute_definition_clause, one cannot specify any subtype-specific attributes for the subtype denoted by S'Base (the base subtype)."),(0,i.kt)("p",null,"The attribute S'Range is now allowed for scalar subtypes."),(0,i.kt)("p",null,"The attributes S'Min and S'Max are now defined, and made available for all scalar types."),(0,i.kt)("p",null,"The attributes S'Succ, S'Pred, S'Image, S'Value, and S'Width are now defined for real types as well as discrete types."),(0,i.kt)("p",null,"Wide_String versions of S'Image and S'Value are defined. These are called S'Wide_Image and S'Wide_Value to avoid introducing ambiguities involving uses of these attributes with string literals. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-9"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We now use the syntactic category range_attribute_reference since it is now syntactically distinguished from other attribute references."),(0,i.kt)("p",null,"The definition of S'Base has been moved here from 3.3.3 since it now applies only to scalar types."),(0,i.kt)("p",null,"More explicit rules are provided for nongraphic characters. "),(0,i.kt)("h3",{id:"351--enumeration-types"},"3.5.1  Enumeration Types"),(0,i.kt)("p",null,"[ An enumeration_type_definition defines an enumeration type.]"," "),(0,i.kt)("h4",{id:"syntax-7"},"Syntax"),(0,i.kt)("p",null,"enumeration_type_definition ::=\n(enumeration_literal_specification {, enumeration_literal_specification})"),(0,i.kt)("p",null,"enumeration_literal_specification ::=  defining_identifier | defining_character_literal"),(0,i.kt)("p",null,"defining_character_literal ::= character_literal"),(0,i.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,i.kt)("p",null,"The defining_identifiers ","[and defining_character_literals]"," listed in an enumeration_type_definition shall be distinct. "),(0,i.kt)("p",null,"Proof: This is a ramification of the normal disallowance of homographs explicitly declared immediately in the same declarative region. "),(0,i.kt)("h4",{id:"static-semantics-10"},"Static Semantics"),(0,i.kt)("p",null,"Each enumeration_literal_specification is the explicit declaration of the corresponding enumeration literal: it declares a parameterless function, whose defining name is the defining_identifier or defining_character_literal, and whose result type is the enumeration type. "),(0,i.kt)("p",null,"Reason: This rule defines the profile of the enumeration literal, which is used in the various types of conformance. "),(0,i.kt)("p",null,"Ramification: The parameterless function associated with an enumeration literal is fully defined by the enumeration_type_definition; a body is not permitted for it, and it never fails the Elaboration_Check when called. "),(0,i.kt)("p",null,"Each enumeration literal corresponds to a distinct value of the enumeration type, and to a distinct position number. The position number of the value of the first listed enumeration literal is zero; the position number of the value of each subsequent enumeration literal is one more than that of its predecessor in the list."),(0,i.kt)("p",null,"[The predefined order relations between values of the enumeration type follow the order of corresponding position numbers.]"),(0,i.kt)("p",null,"[ If the same defining_identifier or defining_character_literal is specified in more than one enumeration_type_definition, the corresponding enumeration literals are said to be overloaded. At any place where an overloaded enumeration literal occurs in the text of a program, the type of the enumeration literal has to be determinable from the context (see 8.6).]"," "),(0,i.kt)("h4",{id:"dynamic-semantics-7"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an enumeration_type_definition creates the enumeration type and its first subtype, which is constrained to the base range of the type. "),(0,i.kt)("p",null,"Ramification: The first subtype of a discrete type is always constrained, except in the case of a derived type whose parent subtype is Whatever'Base. "),(0,i.kt)("p",null,"When called, the parameterless function associated with an enumeration literal returns the corresponding value of the enumeration type. "),(0,i.kt)("p",null,"NOTE 1   If an enumeration literal occurs in a context that does not otherwise suffice to determine the type of the literal, then qualification by the name of the enumeration type is one way to resolve the ambiguity (see 4.7). "),(0,i.kt)("h4",{id:"examples-6"},"Examples"),(0,i.kt)("p",null,"Examples of enumeration types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Day        is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\ntype Suit       is (Clubs, Diamonds, Hearts, Spades);\ntype Gender     is (M, F);\ntype Level      is (Low, Medium, Urgent);\ntype Color      is (White, Red, Yellow, Green, Blue, Brown, Black);\ntype Light      is (Red, Amber, Green); -- Red and Green are overloaded\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Hexa       is ('A', 'B', 'C', 'D', 'E', 'F');\ntype Mixed      is ('A', 'B', '*', B, None, '?', '%');\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Weekday is Day   range Mon .. Fri;\nsubtype Major   is Suit  range Hearts .. Spades;\nsubtype Rainbow is Color range Red .. Blue;  --  the Color Red, not the Light\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-10"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for defining_character_literal is new. It is used for the defining occurrence of a character_literal, analogously to defining_identifier. Usage occurrences use the name or selector_name syntactic categories."),(0,i.kt)("p",null,"We emphasize the fact that an enumeration literal denotes a function, which is called to produce a value. "),(0,i.kt)("h3",{id:"352--character-types"},"3.5.2  Character Types"),(0,i.kt)("h4",{id:"static-semantics-11"},"Static Semantics"),(0,i.kt)("p",null,"An enumeration type is said to be a character type if at least one of its enumeration literals is a character_literal."),(0,i.kt)("p",null,"The predefined type Character is a character type whose values correspond to the 256 code positions of Row 00 (also known as Latin-1) of the ISO 10646 Basic Multilingual Plane (BMP). Each of the graphic characters of Row 00 of the BMP has a corresponding character",(0,i.kt)("em",{parentName:"p"},"literal in Character. Each of the nongraphic positions of Row 00 (0000-001F and 007F-009F) has a corresponding language-defined name, which is not usable as an enumeration literal, but which is usable with the attributes (Wide"),')Image and (Wide_)Value; these names are given in the definition of type Character in A.1, "The Package Standard", but are set in italics. '),(0,i.kt)("p",null,"The predefined type Wide",(0,i.kt)("em",{parentName:"p"},"Character is a character type whose values correspond to the 65536 code positions of the ISO 10646 Basic Multilingual Plane (BMP). Each of the graphic characters of the BMP has a corresponding character_literal in Wide_Character. The first 256 values of Wide_Character have the same character_literal or language-defined name as defined for Character. The last 2 values of Wide_Character correspond to the nongraphic positions FFFE and FFFF of the BMP, and are assigned the language-defined names FFFE and FFFF. As with the other language-defined names for nongraphic characters, the names FFFE and FFFF are usable only with the attributes (Wide"),")Image and (Wide_)Value; they are not usable as enumeration literals. All other values of Wide_Character are considered graphic characters, and have a corresponding character_literal."),(0,i.kt)("p",null,'Reason: The language-defined names are not usable as enumeration literals to avoid "polluting" the name space. Since Wide_Character are defined in Standard, if the names FFFE and FFFF were usable as enumeration literals, they would hide other nonoverloadable declarations with the same names in use-d packages.'),(0,i.kt)("p",null,"ISO 10646 has not defined the meaning of all of the code positions from 0100 through FFFD, but they are all considered graphic characters by Ada to simplify the implementation, and to allow for revisions to ISO 10646. In ISO 10646, FFFE and FFFF are special, and will never be associated with graphic characters in any revision. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"In a nonstandard mode, an implementation may provide other interpretations for the predefined types Character and Wide_Character","[, to conform to local conventions]",". "),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,'If an implementation supports a mode with alternative interpretations for Character and Wide_Character, the set of graphic characters of Character should nevertheless remain a proper subset of the set of graphic characters of Wide_Character. Any character set "localizations" should be reflected in the results of the subprograms defined in the language-defined package Characters.Handling (see A.3) available in such a mode. In a mode with an alternative interpretation of Character, the implementation should also support a corresponding change in what is a legal identifier_letter. '),(0,i.kt)("p",null,"NOTE 1   The language-defined library package Characters.Latin_1 (see A.3.3) includes the declaration of constants denoting control characters, lower case characters, and special characters of the predefined type Character. "),(0,i.kt)("p",null,"To be honest: The package ASCII does the same, but only for the first 128 characters of Character. Hence, it is an obsolescent package, and we no longer mention it here. "),(0,i.kt)("p",null,"NOTE 2   A conventional character set such as EBCDIC can be declared as a character type; the internal codes of the characters can be specified by an enumeration_representation_clause as explained in clause 13.4. "),(0,i.kt)("h4",{id:"examples-7"},"Examples"),(0,i.kt)("p",null,"Example of a character type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-1"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"The declaration of Wide_Character in package Standard hides use-visible declarations with the same defining identifier. In the unlikely event that an Ada 83 program had depended on such a use-visible declaration, and the program remains legal after the substitution of Standard.Wide_Character, the meaning of the program will be different. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-4"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"The presence of Wide_Character in package Standard means that an expression such as "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"'a' = 'b'\n\n")),(0,i.kt)("p",null,"is ambiguous in Ada 95, whereas in Ada 83 both literals could be resolved to be of type Character."),(0,i.kt)("p",null,"The change in visibility rules (see 4.2) for character literals means that additional qualification might be necessary to resolve expressions involving overloaded subprograms and character literals. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-6"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The type Character has been extended to have 256 positions, and the type Wide_Character has been added. Note that this change was already approved by the ARG for Ada 83 conforming compilers."),(0,i.kt)("p",null,"The rules for referencing character literals are changed (see 4.2), so that the declaration of the character type need not be directly visible to use its literals, similar to null and string literals. Context is used to resolve their type. "),(0,i.kt)("h3",{id:"353--boolean-types"},"3.5.3  Boolean Types"),(0,i.kt)("h4",{id:"static-semantics-12"},"Static Semantics"),(0,i.kt)("p",null,"There is a predefined enumeration type named Boolean, ","[declared in the visible part of package Standard]",". It has the two enumeration literals False and True ordered with the relation False ","<"," True. Any descendant of the predefined type Boolean is called a boolean type. "),(0,i.kt)("p",null,'Implementation Note: An implementation is not required to support enumeration representation clauses on boolean types that impose an unacceptable implementation burden. See 13.4, "Enumeration Representation Clauses". However, it is generally straightforward to support representations where False is zero and True is 2**n  1 for some n. '),(0,i.kt)("h3",{id:"354--integer-types"},"3.5.4  Integer Types"),(0,i.kt)("p",null,"An integer_type_definition defines an integer type; it defines either a signed integer type, or a modular integer type. The base range of a signed integer type includes at least the values of the specified range. A modular type is an integer type with all arithmetic modulo a specified positive modulus; such a type corresponds to an unsigned type with wrap-around semantics. "),(0,i.kt)("h4",{id:"syntax-8"},"Syntax"),(0,i.kt)("p",null,"integer_type_definition ::= signed_integer_type_definition | modular_type_definition"),(0,i.kt)("p",null,"signed_integer_type_definition ::= range static_simple_expression .. static_simple_expression"),(0,i.kt)("p",null,"Discussion: We don't call this a range_constraint, because it is rather different - not only is it required to be static, but the associated overload resolution rules are different than for normal range constraints. A similar comment applies to real_range_specification. This used to be integer_range_specification but when we added support for modular types, it seemed overkill to have three levels of syntax rules, and just calling these signed_integer_range_specification and modular_range_specification loses the fact that they are defining different classes of types, which is important for the generic type matching rules. "),(0,i.kt)("p",null,"modular_type_definition ::= mod static_expression"),(0,i.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,i.kt)("p",null,"Each simple_expression in a signed_integer_type_definition is expected to be of any integer type; they need not be of the same type. The expression in a modular_type_definition is likewise expected to be of any integer type. "),(0,i.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,i.kt)("p",null,"The simple_expressions of a signed_integer_type_definition shall be static, and their values shall be in the range System.Min_Int .. System.Max_Int."),(0,i.kt)("p",null,"The expression of a modular_type_definition shall be static, and its value (the modulus) shall be positive, and shall be no greater than System.Max_Binary_Modulus if a power of 2, or no greater than System.Max_Nonbinary_Modulus if not. "),(0,i.kt)("p",null,"Reason: For a 2's-complement machine, supporting nonbinary moduli greater than System.Max_Int can be quite difficult, whereas essentially any binary moduli are straightforward to support, up to 2*System.Max_Int+2, so this justifies having two separate limits. "),(0,i.kt)("h4",{id:"static-semantics-13"},"Static Semantics"),(0,i.kt)("p",null,"The set of values for a signed integer type is the (infinite) set of mathematical integers","[, though only values of the base range of the type are fully supported for run-time operations]",". The set of values for a modular integer type are the values from 0 to one less than the modulus, inclusive."),(0,i.kt)("p",null,"A signed_integer_type_definition defines an integer type whose base range includes at least the values of the simple_expressions and is symmetric about zero, excepting possibly an extra negative value. A signed_integer_type_definition also defines a constrained first subtype of the type, with a range whose bounds are given by the values of the simple_expressions, converted to the type being defined. "),(0,i.kt)("p",null,"Implementation Note: The base range of a signed integer type might be much larger than is necessary to satisfy the aboved requirements. "),(0,i.kt)("p",null,"A modular_type_definition defines a modular type whose base range is from zero to one less than the given modulus. A modular_type_definition also defines a constrained first subtype of the type with a range that is the same as the base range of the type."),(0,i.kt)("p",null,"There is a predefined signed integer subtype named Integer","[, declared in the visible part of package Standard]",". It is constrained to the base range of its type. "),(0,i.kt)("p",null,"Reason: Integer is a constrained subtype, rather than an unconstrained subtype. This means that on assignment to an object of subtype Integer, a range check is required. On the other hand, an object of subtype Integer'Base is unconstrained, and no range check (only overflow check) is required on assignment. For example, if the object is held in an extended-length register, its value might be outside of Integer'First .. Integer'Last. All parameter and result subtypes of the predefined integer operators are of such unconstrained subtypes, allowing extended-length registers to be used as operands or for the result. In an earlier version of Ada 95, Integer was unconstrained. However, the fact that certain Constraint_Errors might be omitted or appear elsewhere was felt to be an undesirable upward inconsistency in this case. Note that for Float, the opposite conclusion was reached, partly because of the high cost of performing range checks when not actually necessary. Objects of subtype Float are unconstrained, and no range checks, only overflow checks, are performed for them. "),(0,i.kt)("p",null,"Integer has two predefined subtypes, ","[declared in the visible part of package Standard:]"," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Natural  is Integer range 0 .. Integer'Last;\nsubtype Positive is Integer range 1 .. Integer'Last;\n\n")),(0,i.kt)("p",null,"A type defined by an integer_type_definition is implicitly derived from root_integer, an anonymous predefined (specific) integer type, whose base range is System.Min_Int .. System.Max_Int. However, the base range of the new type is not inherited from root_integer, but is instead determined by the range or modulus specified by the integer_type_definition. ","[Integer literals are all of the type universal_integer, the universal type (see 3.4.1) for the class rooted at root_integer, allowing their use with the operations of any integer type.]"," "),(0,i.kt)("p",null,"Discussion: This implicit derivation is not considered exactly equivalent to explicit derivation via a derived_type_definition. In particular, integer types defined via a derived_type_definition inherit their base range from their parent type. A type defined by an integer_type_definition does not necessarily inherit its base range from root_integer. It is not specified whether the implicit derivation from root_integer is direct or indirect, not that it really matters. All we want is for all integer types to be descendants of root_integer."),(0,i.kt)("p",null,"Implementation Note: It is the intent that even nonstandard integer types (see below) will be descendants of root_integer, even though they might have a base range that exceeds that of root_integer. This causes no problem for static calculations, which are performed without range restrictions (see 4.9). However for run-time calculations, it is possible that Constraint_Error might be raised when using an operator of root_integer on the result of 'Val applied to a value of a nonstandard integer type. "),(0,i.kt)("p",null,"The position number of an integer value is equal to the value."),(0,i.kt)("p",null,"For every modular subtype S, the following attribute is defined: "),(0,i.kt)("p",null,"S'ModulusS'Modulus yields the modulus of the type of S, as a value of the type universal_integer. "),(0,i.kt)("h4",{id:"dynamic-semantics-8"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an integer_type_definition creates the integer type and its first subtype."),(0,i.kt)("p",null,"For a modular type, if the result of the execution of a predefined operator (see 4.5) is outside the base range of the type, the result is reduced modulo the modulus of the type to a value that is within the base range of the type."),(0,i.kt)("p",null,"For a signed integer type, the exception Constraint_Error is raised by the execution of an operation that cannot deliver the correct result because it is outside the base range of the type. ",'[ For any integer type, Constraint_Error is raised by the operators "/", "rem", and "mod" if the right operand is zero.]'),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation, the range of Integer shall include the range 2",(0,i.kt)("strong",{parentName:"p"},"15+1 .. +2"),"151."),(0,i.kt)("p",null,"If Long_Integer is predefined for an implementation, then its range shall include the range 2",(0,i.kt)("strong",{parentName:"p"},"31+1 .. +2"),"311."),(0,i.kt)("p",null,"System.Max_Binary_Modulus shall be at least 2**16. "),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"For the execution of a predefined operation of a signed integer type, the implementation need not raise Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced. "),(0,i.kt)("p",null,"Discussion: Constraint_Error is never raised for operations on modular types, except for divide-by-zero (and rem/mod-by-zero). "),(0,i.kt)("p",null,"An implementation may provide additional predefined signed integer types","[, declared in the visible part of Standard]",", whose first subtypes have names of the form Short_Integer, Long_Integer, Short_Short_Integer, Long_Long_Integer, etc. Different predefined integer types are allowed to have the same base range. However, the range of Integer should be no wider than that of Long_Integer. Similarly, the range of Short_Integer (if provided) should be no wider than Integer. Corresponding recommendations apply to any other predefined integer types. There need not be a named integer type corresponding to each distinct base range supported by an implementation. The range of each first subtype should be the base range of its type. "),(0,i.kt)("p",null,"Implementation defined: The predefined integer types declared in Standard."),(0,i.kt)("p",null,'An implementation may provide nonstandard integer types, descendants of root_integer that are declared outside of the specification of package Standard, which need not have all the standard characteristics of a type defined by an integer_type_definition. For example, a nonstandard integer type might have an asymmetric base range or it might not be allowed as an array or loop index (a very long integer). Any type descended from a nonstandard integer type is also nonstandard. An implementation may place arbitrary restrictions on the use of such types; it is implementation defined whether operators that are predefined for "any integer type" are defined for a particular nonstandard integer type. ',"[In any case, such types are not permitted as explicit_generic_actual_parameters for formal scalar types - see 12.5.2.]"," "),(0,i.kt)("p",null,"Implementation defined: Any nonstandard integer types and the operators defined for them."),(0,i.kt)("p",null,"For a one's complement machine, the high bound of the base range of a modular type whose modulus is one less than a power of 2 may be equal to the modulus, rather than one less than the modulus. It is implementation defined for which powers of 2, if any, this permission is exercised."),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"An implementation should support Long_Integer in addition to Integer if the target machine supports 32-bit (or longer) arithmetic. No other named integer subtypes are recommended for package Standard. Instead, appropriate named integer subtypes should be provided in the library package Interfaces (see B.2). "),(0,i.kt)("p",null,"Implementation Note: To promote portability, implementations should explicitly declare the integer (sub)types Integer and Long_Integer in Standard, and leave other predefined integer types anonymous. For implementations that already support Byte_Integer, etc., upward compatibility argues for keeping such declarations in Standard during the transition period, but perhaps generating a warning on use. A separate package Interfaces in the predefined environment is available for pre-declaring types such as Integer_8, Integer_16, etc. See B.2. In any case, if the user declares a subtype (first or not) whose range fits in, for example, a byte, the implementation can store variables of the subtype in a single byte, even if the base range of the type is wider. "),(0,i.kt)("p",null,"An implementation for a two's complement machine should support modular types with a binary modulus up to System.Max_Int*2+2. An implementation should support a nonbinary modulus up to Integer'Last. "),(0,i.kt)("p",null,'Reason: Modular types provide bit-wise "and", "or", "xor", and "not" operations. It is important for systems programming that these be available for all integer types of the target hardware. '),(0,i.kt)("p",null,"Ramification: Note that on a one's complement machine, the largest supported modular type would normally have a nonbinary modulus. On a two's complement machine, the largest supported modular type would normally have a binary modulus. "),(0,i.kt)("p",null,"Implementation Note: Supporting a nonbinary modulus greater than Integer'Last can impose an undesirable implementation burden on some machines. "),(0,i.kt)("p",null,'NOTE 1   Integer literals are of the anonymous predefined integer type universal_integer. Other integer types have no literals. However, the overload resolution rules (see 8.6, "The Context of Overload Resolution") allow expressions of the type universal_integer whenever an integer type is expected.'),(0,i.kt)("p",null,'NOTE 2   The same arithmetic operators are predefined for all signed integer types defined by a signed_integer_type_definition (see 4.5, "Operators and Expression Evaluation"). For modular types, these same operators are predefined, plus bit-wise logical operators (and, or, xor, and not). In addition, for the unsigned types declared in the language-defined package Interfaces (see B.2), functions are defined that provide bit-wise shifting and rotating.'),(0,i.kt)("p",null,'NOTE 3   Modular types match a generic_formal_parameter_declaration of the form "type T is mod ',"<",">",'"; signed integer types match "type T is range ',"<",">",'" (see 12.5.2). '),(0,i.kt)("h4",{id:"examples-8"},"Examples"),(0,i.kt)("p",null,"Examples of integer types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Page_Num  is range 1 .. 2_000;\ntype Line_Size is range 1 .. Max_Line_Size;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Small_Int   is Integer   range -10 .. 10;\nsubtype Column_Ptr  is Line_Size range 1 .. 10;\nsubtype Buffer_Size is Integer   range 0 .. Max;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Byte        is mod 256; -- an unsigned byte\ntype Hash_Index  is mod 97;  -- modulus is prime\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-7"},"Extensions to Ada 83"),(0,i.kt)("p",null,"An implementation is allowed to support any number of distinct base ranges for integer types, even if fewer integer types are explicitly declared in Standard."),(0,i.kt)("p",null,"Modular (unsigned, wrap-around) types are new. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-11"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Ada 83\'s integer types are now called "signed" integer types, to contrast them with "modular" integer types.'),(0,i.kt)("p",null,"Standard.Integer, Standard.Long_Integer, etc., denote constrained subtypes of predefined integer types, consistent with the Ada 95 model that only subtypes have names."),(0,i.kt)("p",null,"We now impose minimum requirements on the base range of Integer and Long_Integer."),(0,i.kt)("p",null,"We no longer explain integer type definition in terms of an equivalence to a normal type derivation, except to say that all integer types are by definition implicitly derived from root_integer. This is for various reasons."),(0,i.kt)("p",null,"First of all, the equivalence with a type derivation and a subtype declaration was not perfect, and was the source of various AIs (for example, is the conversion of the bounds static? Is a numeric type a derived type with respect to other rules of the language?)"),(0,i.kt)("p",null,"Secondly, we don't want to require that every integer size supported shall have a corresponding named type in Standard. Adding named types to Standard creates nonportabilities."),(0,i.kt)("p",null,'Thirdly, we don\'t want the set of types that match a formal derived type "type T is new Integer;" to depend on the particular underlying integer representation chosen to implement a given user-defined integer type. Hence, we would have needed anonymous integer types as parent types for the implicit derivation anyway. We have simply chosen to identify only one anonymous integer type - root_integer, and stated that every integer type is derived from it.'),(0,i.kt)("p",null,'Finally, the "fiction" that there were distinct preexisting predefined types for every supported representation breaks down for fixed point with arbitrary smalls, and was never exploited for enumeration types, array types, etc. Hence, there seems little benefit to pushing an explicit equivalence between integer type definition and normal type derivation. '),(0,i.kt)("h3",{id:"355--operations-of-discrete-types"},"3.5.5  Operations of Discrete Types"),(0,i.kt)("h4",{id:"static-semantics-14"},"Static Semantics"),(0,i.kt)("p",null,"For every discrete subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'PosS'Pos denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Pos(Arg : S'Base)\n  return universal_integer\n\n")),(0,i.kt)("p",null,"This function returns the position number of the value of Arg, as a value of type universal_integer."),(0,i.kt)("p",null,"S'ValS'Val denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Val(Arg : universal_integer)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value of the type of S whose position number equals the value of Arg. For the evaluation of a call on S'Val, if there is no value in the base range of its type with the given position number, Constraint_Error is raised. "),(0,i.kt)("p",null,"Ramification: By the overload resolution rules, a formal parameter of type universal_integer allows an actual parameter of any integer type."),(0,i.kt)("p",null,"Reason: We considered allowing S'Val for a signed integer subtype S to return an out-of-range value, but since checks were required for enumeration and modular types anyway, the allowance didn't seem worth the complexity of the rule."),(0,i.kt)("h4",{id:"implementation-advice-2"},"Implementation Advice"),(0,i.kt)("p",null,"For the evaluation of a call on S'Pos for an enumeration subtype, if the value of the operand does not correspond to the internal code for any enumeration literal of its type ","[(perhaps due to an uninitialized variable)]",", then the implementation should raise Program_Error. This is particularly important for enumeration types with noncontiguous internal codes specified by an enumeration_representation_clause. "),(0,i.kt)("p",null,"Reason: We say Program_Error here, rather than Constraint_Error, because the main reason for such values is uninitialized variables, and the normal way to indicate such a use (if detected) is to raise Program_Error. (Other reasons would involve the misuse of low-level features such as Unchecked_Conversion.) "),(0,i.kt)("p",null,"NOTE 1   Indexing and loop iteration use values of discrete types."),(0,i.kt)("p",null,"NOTE 2   The predefined operations of a discrete type include the assignment operation, qualification, the membership tests, and the relational operators; for a boolean type they include the short-circuit control forms and the logical operators; for an integer type they include type conversion to and from other numeric types, as well as the binary and unary adding operators  and +, the multiplying operators, the unary operator abs, and the exponentiation operator. The assignment operation is described in 5.2. The other predefined operations are described in Section 4."),(0,i.kt)("p",null,"NOTE 3   As for all types, objects of a discrete type have Size and Address attributes (see 13.3)."),(0,i.kt)("p",null,"NOTE 4   For a subtype of a discrete type, the result delivered by the attribute Val might not belong to the subtype; similarly, the actual parameter of the attribute Pos need not belong to the subtype. The following relations are satisfied (in the absence of an exception) by these attributes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   S'Val(S'Pos(X)) = X\n   S'Pos(S'Val(N)) = N\n\n")),(0,i.kt)("h4",{id:"examples-9"},"Examples"),(0,i.kt)("p",null,"Examples of attributes of discrete subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  For the types and subtypes declared in subclause 3.5.1 the following hold: \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Color'First   = White,   Color'Last   = Black\n--  Rainbow'First = Red,     Rainbow'Last = Blue\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown\n--  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4\n--  Color'Val(0)     = Rainbow'Val(0)     = White\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-8"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The attributes S'Succ, S'Pred, S'Width, S'Image, and S'Value have been generalized to apply to real types as well (see 3.5, \"Scalar Types\"). "),(0,i.kt)("h3",{id:"356--real-types"},"3.5.6  Real Types"),(0,i.kt)("p",null,"Real types provide approximations to the real numbers, with relative bounds on errors for floating point types, and with absolute bounds for fixed point types. "),(0,i.kt)("h4",{id:"syntax-9"},"Syntax"),(0,i.kt)("p",null,"real_type_definition ::=\nfloating_point_definition | fixed_point_definition"),(0,i.kt)("h4",{id:"static-semantics-15"},"Static Semantics"),(0,i.kt)("p",null,"A type defined by a real_type_definition is implicitly derived from root_real, an anonymous predefined (specific) real type. ","[Hence, all real types, whether floating point or fixed point, are in the derivation class rooted at root_real.]"," "),(0,i.kt)("p",null,"Ramification: It is not specified whether the derivation from root_real is direct or indirect, not that it really matters. All we want is for all real types to be descendants of root_real."),(0,i.kt)("p",null,"[ Real literals are all of the type universal_real, the universal type (see 3.4.1) for the class rooted at root_real, allowing their use with the operations of any real type. Certain multiplying operators have a result type of universal_fixed (see 4.5.5), the universal type for the class of fixed point types, allowing the result of the multiplication or division to be used where any specific fixed point type is expected.]"," "),(0,i.kt)("h4",{id:"dynamic-semantics-9"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a real_type_definition consists of the elaboration of the floating_point_definition or the fixed_point_definition. "),(0,i.kt)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,i.kt)("p",null,"An implementation shall perform the run-time evaluation of a use of a predefined operator of root_real with an accuracy at least as great as that of any floating point type definable by a floating_point_definition. "),(0,i.kt)("p",null,"Ramification: Static calculations using the operators of root_real are exact, as for all static calculations. See 4.9. "),(0,i.kt)("p",null,"Implementation Note: The Digits attribute of the type used to represent root_real at run time is at least as great as that of any other floating point type defined by a floating_point_definition, and its safe range includes that of any such floating point type with the same Digits attribute. On some machines, there might be real types with less accuracy but a wider range, and hence run-time calculations with root_real might not be able to accommodate all values that can be represented at run time in such floating point or fixed point types. "),(0,i.kt)("h4",{id:"implementation-permissions-3"},"Implementation Permissions"),(0,i.kt)("p",null,"[For the execution of a predefined operation of a real type, the implementation need not raise Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced, or the Machine_Overflows attribute of the type is false (see G.2).]"),(0,i.kt)("p",null,'An implementation may provide nonstandard real types, descendants of root_real that are declared outside of the specification of package Standard, which need not have all the standard characteristics of a type defined by a real_type_definition. For example, a nonstandard real type might have an asymmetric or unsigned base range, or its predefined operations might wrap around or "saturate" rather than overflow (modular or saturating arithmetic), or it might not conform to the accuracy model (see G.2). Any type descended from a nonstandard real type is also nonstandard. An implementation may place arbitrary restrictions on the use of such types; it is implementation defined whether operators that are predefined for "any real type" are defined for a particular nonstandard real type. ',"[In any case, such types are not permitted as explicit_generic_actual_parameters for formal scalar types - see 12.5.2.]"," "),(0,i.kt)("p",null,"Implementation defined: Any nonstandard real types and the operators defined for them."),(0,i.kt)("p",null,"NOTE 1   As stated, real literals are of the anonymous predefined real type universal_real. Other real types have no literals. However, the overload resolution rules (see 8.6) allow expressions of the type universal_real whenever a real type is expected."),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-12"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for real_type_definition is modified to use the new syntactic categories floating_point_definition and fixed_point_definition, instead of floating_point_constraint and fixed_point_constraint, because the semantics of a type definition are significantly different than the semantics of a constraint."),(0,i.kt)("p",null,"All discussion of model numbers, safe ranges, and machine numbers is moved to 3.5.7, 3.5.8, and G.2. Values of a fixed point type are now described as being multiples of the small of the fixed point type, and we have no need for model numbers, safe ranges, etc. for fixed point types."),(0,i.kt)("h3",{id:"357--floating-point-types"},"3.5.7  Floating Point Types"),(0,i.kt)("p",null,"For floating point types, the error bound is specified as a relative precision by giving the required minimum number of significant decimal digits. "),(0,i.kt)("h4",{id:"syntax-10"},"Syntax"),(0,i.kt)("p",null,"floating_point_definition ::=\ndigits static_expression ","[real_range_specification]"),(0,i.kt)("p",null,"real_range_specification ::=\nrange static_simple_expression .. static_simple_expression"),(0,i.kt)("h4",{id:"name-resolution-rules-5"},"Name Resolution Rules"),(0,i.kt)("p",null,"The requested decimal precision, which is the minimum number of significant decimal digits required for the floating point type, is specified by the value of the expression given after the reserved word digits. This expression is expected to be of any integer type."),(0,i.kt)("p",null,"Each simple_expression of a real_range_specification is expected to be of any real type","[; the types need not be the same]",". "),(0,i.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,i.kt)("p",null,"The requested decimal precision shall be specified by a static expression whose value is positive and no greater than System.Max_Base_Digits. Each simple_expression of a real_range_specification shall also be static. If the real_range_specification is omitted, the requested decimal precision shall be no greater than System.Max_Digits. "),(0,i.kt)("p",null,"Reason: We have added Max_Base_Digits to package System. It corresponds to the requested decimal precision of root_real. System.Max_Digits corresponds to the maximum value for Digits that may be specified in the absence of a real_range_specification, for upward compatibility. These might not be the same if root_real has a base range that does not include \ufffd 10.0*",(0,i.kt)("em",{parentName:"p"},"(4"),"Max_Base_Digits). "),(0,i.kt)("p",null,"A floating_point_definition is illegal if the implementation does not support a floating point type that satisfies the requested decimal precision and range. "),(0,i.kt)("p",null,"Implementation defined: What combinations of requested decimal precision and range are supported for floating point types."),(0,i.kt)("h4",{id:"static-semantics-16"},"Static Semantics"),(0,i.kt)("p",null,"The set of values for a floating point type is the (infinite) set of rational numbers. The machine numbers of a floating point type are the values of the type that can be represented exactly in every unconstrained variable of the type. The base range (see 3.5) of a floating point type is symmetric around zero, except that it can include some extra negative values in some implementations."),(0,i.kt)("p",null,"Implementation Note: For example, if a 2's complement representation is used for the mantissa rather than a sign-mantissa or 1's complement representation, then there is usually one extra negative machine number."),(0,i.kt)("p",null,"To be honest: If the Signed_Zeros attribute is True, then minus zero could in a sense be considered a value of the type. However, for most purposes, minus zero behaves the same as plus zero."),(0,i.kt)("p",null,"The base decimal precision of a floating point type is the number of decimal digits of precision representable in objects of the type. The safe range of a floating point type is that part of its base range for which the accuracy corresponding to the base decimal precision is preserved by all predefined operations. "),(0,i.kt)("p",null,"Implementation Note: In most cases, the safe range and base range are the same. However, for some hardware, values near the boundaries of the base range might result in excessive inaccuracies or spurious overflows when used with certain predefined operations. For such hardware, the safe range would omit such values."),(0,i.kt)("p",null,"A floating_point_definition defines a floating point type whose base decimal precision is no less than the requested decimal precision. If a real_range_specification is given, the safe range of the floating point type (and hence, also its base range) includes at least the values of the simple expressions given in the real_range_specification. If a real_range_specification is not given, the safe (and base) range of the type includes at least the values of the range 10.0",(0,i.kt)("strong",{parentName:"p"},"(4*D) .. +10.0"),"(4*D) where D is the requested decimal precision. ","[The safe range might include other values as well. The attributes Safe_First and Safe_Last give the actual bounds of the safe range.]"),(0,i.kt)("p",null,"A floating_point_definition also defines a first subtype of the type. If a real_range_specification is given, then the subtype is constrained to a range whose bounds are given by a conversion of the values of the simple_expressions of the real_range_specification to the type being defined. Otherwise, the subtype is unconstrained."),(0,i.kt)("p",null,"There is a predefined, unconstrained, floating point subtype named Float","[, declared in the visible part of package Standard]",". "),(0,i.kt)("h4",{id:"dynamic-semantics-10"},"Dynamic Semantics"),(0,i.kt)("p",null,"[The elaboration of a floating_point_definition creates the floating point type and its first subtype.]"," "),(0,i.kt)("h4",{id:"implementation-requirements-2"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation that supports floating point types with 6 or more digits of precision, the requested decimal precision for Float shall be at least 6."),(0,i.kt)("p",null,"If Long_Float is predefined for an implementation, then its requested decimal precision shall be at least 11. "),(0,i.kt)("h4",{id:"implementation-permissions-4"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation is allowed to provide additional predefined floating point types","[, declared in the visible part of Standard]",", whose (unconstrained) first subtypes have names of the form Short_Float, Long_Float, Short_Short_Float, Long_Long_Float, etc. Different predefined floating point types are allowed to have the same base decimal precision. However, the precision of Float should be no greater than that of Long_Float. Similarly, the precision of Short_Float (if provided) should be no greater than Float. Corresponding recommendations apply to any other predefined floating point types. There need not be a named floating point type corresponding to each distinct base decimal precision supported by an implementation. "),(0,i.kt)("p",null,"Implementation defined: The predefined floating point types declared in Standard."),(0,i.kt)("h4",{id:"implementation-advice-3"},"Implementation Advice"),(0,i.kt)("p",null,"An implementation should support Long_Float in addition to Float if the target machine supports 11 or more digits of precision. No other named floating point subtypes are recommended for package Standard. Instead, appropriate named floating point subtypes should be provided in the library package Interfaces (see B.2). "),(0,i.kt)("p",null,"Implementation Note: To promote portability, implementations should explicitly declare the floating point (sub)types Float and Long_Float in Standard, and leave other predefined float types anonymous. For implementations that already support Short_Float, etc., upward compatibility argues for keeping such declarations in Standard during the transition period, but perhaps generating a warning on use. A separate package Interfaces in the predefined environment is available for pre-declaring types such as Float_32, IEEE_Float_64, etc. See B.2. "),(0,i.kt)("p",null,"NOTE 1   If a floating point subtype is unconstrained, then assignments to variables of the subtype involve only Overflow_Checks, never Range_Checks. "),(0,i.kt)("h4",{id:"examples-10"},"Examples"),(0,i.kt)("p",null,"Examples of floating point types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Coefficient is digits 10 range -1.0 .. 1.0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Real is digits 8;\ntype Mass is digits 7 range 0.0 .. 1.0E35;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Probability is Real range 0.0 .. 1.0;   --   a subtype with a smaller range\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-2"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"No Range_Checks, only Overflow_Checks, are performed on variables (or parameters) of an unconstrained floating point subtype. This is upward compatible for programs that do not raise Constraint_Error. For those that do raise Constraint_Error, it is possible that the exception will be raised at a later point, or not at all, if extended range floating point registers are used to hold the value of the variable (or parameter). "),(0,i.kt)("p",null,"Reason: This change was felt to be justified by the possibility of improved performance on machines with extended-range floating point registers. An implementation need not take advantage of this relaxation in the range checking; it can hide completely the use of extended range registers if desired, presumably at some run-time expense. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-13"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rules for floating_point_constraint and floating_accuracy_definition are removed. The syntax rules for floating_point_definition and real_range_specification are new."),(0,i.kt)("p",null,'A syntax rule for digits_constraint is given in 3.5.9, "Fixed Point Types". In J.3 we indicate that a digits_constraint may be applied to a floating point subtype_mark as well (to be compatible with Ada 83\'s floating_point_constraint).'),(0,i.kt)("p",null,"Discussion of model numbers is postponed to 3.5.8 and G.2. The concept of safe numbers has been replaced by the concept of the safe range of values. The bounds of the safe range are given by T'Safe_First .. T'Safe_Last, rather than -T'Safe_Large .. T'Safe_Large, since on some machines the safe range is not perfectly symmetric. The concept of machine numbers is new, and is relevant to the definition of Succ and Pred for floating point numbers. "),(0,i.kt)("h3",{id:"358--operations-of-floating-point-types"},"3.5.8  Operations of Floating Point Types"),(0,i.kt)("h4",{id:"static-semantics-17"},"Static Semantics"),(0,i.kt)("p",null,"The following attribute is defined for every floating point subtype S:"),(0,i.kt)("p",null,"The requested decimal precision of the base subtype of a floating point type T is defined to be the largest value of d for which ceiling(d * log(10) / log(T'Machine_Radix)) + 1 ","<","= T'Model_Mantissa. "),(0,i.kt)("p",null,"NOTE 1   The predefined operations of a floating point type include the assignment operation, qualification, the membership tests, and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators  and +, certain multiplying operators, the unary operator abs, and the exponentiation operator."),(0,i.kt)("p",null,"NOTE 2   As for all types, objects of a floating point type have Size and Address attributes (see 13.3). Other attributes of floating point types are defined in A.5.3. "),(0,i.kt)("h3",{id:"359--fixed-point-types"},"3.5.9  Fixed Point Types"),(0,i.kt)("p",null,"A fixed point type is either an ordinary fixed point type, or a decimal fixed point type. The error bound of a fixed point type is specified as an absolute value, called the delta of the fixed point type. "),(0,i.kt)("h4",{id:"syntax-11"},"Syntax"),(0,i.kt)("p",null,"fixed_point_definition ::= ordinary_fixed_point_definition | decimal_fixed_point_definition"),(0,i.kt)("p",null,"ordinary_fixed_point_definition ::=\ndelta static_expression  real_range_specification"),(0,i.kt)("p",null,"decimal_fixed_point_definition ::=\ndelta static_expression digits static_expression ","[real_range_specification]"),(0,i.kt)("p",null,"digits_constraint ::=\ndigits static_expression ","[range_constraint]"),(0,i.kt)("h4",{id:"name-resolution-rules-6"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a type defined by a fixed_point_definition, the delta of the type is specified by the value of the expression given after the reserved word delta; this expression is expected to be of any real type. For a type defined by a decimal_fixed_point_definition (a decimal fixed point type), the number of significant decimal digits for its first subtype (the digits of the first subtype) is specified by the expression given after the reserved word digits; this expression is expected to be of any integer type."),(0,i.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,i.kt)("p",null,"In a fixed_point_definition or digits_constraint, the expressions given after the reserved words delta and digits shall be static; their values shall be positive."),(0,i.kt)("p",null,"The set of values of a fixed point type comprise the integral multiples of a number called the small of the type. For a type defined by an ordinary_fixed_point_definition (an ordinary fixed point type), the small may be specified by an attribute_definition_clause (see 13.3); if so specified, it shall be no greater than the delta of the type. If not specified, the small of an ordinary fixed point type is an implementation-defined power of two less than or equal to the delta. "),(0,i.kt)("p",null,"Implementation defined: The small of an ordinary fixed point type."),(0,i.kt)("p",null,"For a decimal fixed point type, the small equals the delta; the delta shall be a power of 10. If a real_range_specification is given, both bounds of the range shall be in the range (10",(0,i.kt)("strong",{parentName:"p"},"digits1)*delta .. +(10"),"digits1)*delta."),(0,i.kt)("p",null,"A fixed_point_definition is illegal if the implementation does not support a fixed point type with the given small and specified range or digits. "),(0,i.kt)("p",null,"Implementation defined: What combinations of small, range, and digits are supported for fixed point types."),(0,i.kt)("p",null,"For a subtype_indication with a digits_constraint, the subtype_mark shall denote a decimal fixed point subtype. "),(0,i.kt)("p",null,"To be honest: Or, as an obsolescent feature, a floating point subtype is permitted - see J.3. "),(0,i.kt)("h4",{id:"static-semantics-18"},"Static Semantics"),(0,i.kt)("p",null,"The base range (see 3.5) of a fixed point type is symmetric around zero, except possibly for an extra negative value in some implementations."),(0,i.kt)("p",null,"An ordinary_fixed_point_definition defines an ordinary fixed point type whose base range includes at least all multiples of small that are between the bounds specified in the real_range_specification. The base range of the type does not necessarily include the specified bounds themselves. An ordinary_fixed_point_definition also defines a constrained first subtype of the type, with each bound of its range given by the closer to zero of: "),(0,i.kt)("p",null,"the value of the conversion to the fixed point type of the corresponding expression of the real_range_specification; "),(0,i.kt)("p",null,"the corresponding bound of the base range. "),(0,i.kt)("p",null,"A decimal_fixed_point_definition defines a decimal fixed point type whose base range includes at least the range (10",(0,i.kt)("strong",{parentName:"p"},"digits1)*delta .. +(10"),"digits1)",(0,i.kt)("em",{parentName:"p"},"delta. A decimal_fixed_point_definition also defines a constrained first subtype of the type. If a real_range_specification is given, the bounds of the first subtype are given by a conversion of the values of the expressions of the real_range_specification. Otherwise, the range of the first subtype is (10**digits1)"),"delta .. +(10*",(0,i.kt)("em",{parentName:"p"},"digits1)"),"delta."),(0,i.kt)("h4",{id:"dynamic-semantics-11"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a fixed_point_definition creates the fixed point type and its first subtype."),(0,i.kt)("p",null,"For a digits_constraint on a decimal fixed point subtype with a given delta, if it does not have a range_constraint, then it specifies an implicit range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta, where D is the value of the expression. A digits_constraint is compatible with a decimal fixed point subtype if the value of the expression is no greater than the digits of the subtype, and if it specifies (explicitly or implicitly) a range that is compatible with the subtype. "),(0,i.kt)("p",null,"Discussion: Except for the requirement that the digits specified be no greater than the digits of the subtype being constrained, a digits_constraint is essentially equivalent to a range_constraint."),(0,i.kt)("p",null,"Consider the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type D is delta 0.01 digits 7 range -0.00 .. 9999.99;\n\n")),(0,i.kt)("p",null,'The compatibility rule implies that the digits_constraint "digits 6" specifies an implicit range of "99.9999 .. 99.9999". Thus, "digits 6" is not compatible with the constraint of D, but "digits 6 range 0.00 .. 9999.99" is compatible.'),(0,i.kt)("p",null,'A value of a scalar type belongs to a constrained subtype of the type if it belongs to the range of the subtype. Attributes like Digits and Delta have no affect on this fundamental rule. So the obsolescent forms of digits_constraints and delta_constraints that are called "accuracy constraints" in RM83 don\'t really represent constraints on the values of the subtype, but rather primarily affect compatibility of the "constraint" with the subtype being "constrained". In this sense, they might better be called "subtype assertions" rather than "constraints".'),(0,i.kt)("p",null,"Note that the digits_constraint on a decimal fixed point subtype is a combination of an assertion about the digits of the subtype being further constrained, and a constraint on the range of the subtype being defined, either explicit or implicit. "),(0,i.kt)("p",null,"The elaboration of a digits_constraint consists of the elaboration of the range_constraint, if any. If a range_constraint is given, a check is made that the bounds of the range are both in the range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta, where D is the value of the (static) expression given after the reserved word digits. If this check fails, Constraint_Error is raised. "),(0,i.kt)("h4",{id:"implementation-requirements-3"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall support at least 24 bits of precision (including the sign bit) for fixed point types. "),(0,i.kt)("p",null,"Reason: This is sufficient to represent Standard.Duration with a small no more than 50 milliseconds. "),(0,i.kt)("h4",{id:"implementation-permissions-5"},"Implementation Permissions"),(0,i.kt)("p",null,"Implementations are permitted to support only smalls that are a power of two. In particular, all decimal fixed point type declarations can be disallowed. Note however that conformance with the Information Systems Annex requires support for decimal smalls, and decimal fixed point type declarations with digits up to at least 18. "),(0,i.kt)("p",null,'Implementation Note: The accuracy requirements for multiplication, division, and conversion (see G.2.1, "Model of Floating Point Arithmetic") are such that support for arbitrary smalls should be practical without undue implementation effort. Therefore, implementations should support fixed point types with arbitrary values for small (within reason). One reasonable limitation would be to limit support to fixed point types that can be converted to the most precise floating point type without loss of precision (so that Fixed_IO is implementable in terms of Float_IO). '),(0,i.kt)("p",null,"NOTE   The base range of an ordinary fixed point type need not include the specified bounds themselves so that the range specification can be given in a natural way, such as: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Fraction is delta 2.0**(-15) range -1.0 .. 1.0;\n  \n\n")),(0,i.kt)("p",null,"With 2's complement hardware, such a type could have a signed 16-bit representation, using 1 bit for the sign and 15 bits for fraction, resulting in a base range of 1.0 .. 1.02.0**(15). "),(0,i.kt)("h4",{id:"examples-11"},"Examples"),(0,i.kt)("p",null,"Examples of fixed point types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Volt is delta 0.125 range 0.0 .. 255.0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"  -- A pure fraction which requires all the available\n  -- space in a word can be declared as the type Fraction:\ntype Fraction is delta System.Fine_Delta range -1.0 .. 1.0;\n  -- Fraction'Last = 1.0  System.Fine_Delta\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Money is delta 0.01 digits 15;  -- decimal fixed point\nsubtype Salary is Money digits 10;\n  -- Money'Last = 10.0**13  0.01, Salary'Last = 10.0**8  0.01\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-3"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"In Ada 95, S'Small always equals S'Base'Small, so if an implementation chooses a small for a fixed point type smaller than required by the delta, the value of S'Small in Ada 95 might not be the same as it was in Ada 83. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-9"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Decimal fixed point types are new, though their capabilities are essentially similar to that available in Ada 83 with a fixed point type whose small equals its delta equals a power of 10. However, in the Information Systems Annex, additional requirements are placed on the support of decimal fixed point types (e.g. a minimum of 18 digits of precision). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-14"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rules for fixed_point_constraint and fixed_accuracy_definition are removed. The syntax rule for fixed_point_definition is new. A syntax rule for delta_constraint is included in the Obsolescent features (to be compatible with Ada 83's fixed_point_constraint). "),(0,i.kt)("h3",{id:"3510--operations-of-fixed-point-types"},"3.5.10  Operations of Fixed Point Types"),(0,i.kt)("h4",{id:"static-semantics-19"},"Static Semantics"),(0,i.kt)("p",null,"The following attributes are defined for every fixed point subtype S: "),(0,i.kt)("p",null,"Small may be specified for nonderived fixed point types via an attribute_definition_clause (see 13.3); the expression of such a clause shall be static."),(0,i.kt)("p",null,"S'DeltaS'Delta denotes the delta of the fixed point subtype S. The value of this attribute is of the type universal_real. "),(0,i.kt)("p",null,"Reason: The delta is associated with the subtype as opposed to the type, because of the possibility of an (obsolescent) delta_constraint."),(0,i.kt)("p",null,"S'ForeS'Fore yields the minimum number of characters needed before the decimal point for the decimal representation of any value of the subtype S, assuming that the representation does not include an exponent, but includes a one-character prefix that is either a minus sign or a space. (This minimum number does not include superfluous zeros or underlines, and is at least 2.) The value of this attribute is of the type universal_integer."),(0,i.kt)("p",null,"S'AftS'Aft yields the number of decimal digits needed after the decimal point to accommodate the delta of the subtype S, unless the delta of the subtype S is greater than 0.1, in which case the attribute yields the value one. ","[(S'Aft is the smallest positive integer N for which (10*",(0,i.kt)("em",{parentName:"p"},"N)"),"S'Delta is greater than or equal to one.)]"," The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"The following additional attributes are defined for every decimal fixed point subtype S: "),(0,i.kt)("p",null,"S'DigitsS'Digits denotes the digits of the decimal fixed point subtype S, which corresponds to the number of decimal digits that are representable in objects of the subtype. The value of this attribute is of the type universal_integer. Its value is determined as follows: "),(0,i.kt)("p",null,"For a first subtype or a subtype defined by a subtype_indication with a digits_constraint, the digits is the value of the expression given after the reserved word digits;"),(0,i.kt)("p",null,"For a subtype defined by a subtype_indication without a digits_constraint, the digits of the subtype is the same as that of the subtype denoted by the subtype_mark in the subtype_indication. "),(0,i.kt)("p",null,"Implementation Note: Although a decimal subtype can be both range-constrained and digits-constrained, the digits constraint is intended to control the Size attribute of the subtype. For decimal types, Size can be important because input/output of decimal types is so common. "),(0,i.kt)("p",null,"The digits of a base subtype is the largest integer D such that the range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta is included in the base range of the type."),(0,i.kt)("p",null,"S'ScaleS'Scale denotes the scale of the subtype S, defined as the value N such that S'Delta = 10.0**(N). ","[The scale indicates the position of the point relative to the rightmost significant digits of values of subtype S.]"," The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"Ramification: S'Scale is negative if S'Delta is greater than one. By contrast, S'Aft is always positive. "),(0,i.kt)("p",null,"S'RoundS'Round denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Round(X : universal_real)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the value obtained by rounding X (away from 0, if X is midway between two values of the type of S). "),(0,i.kt)("p",null,"NOTE 1   All subtypes of a fixed point type will have the same value for the Delta attribute, in the absence of delta_constraints (see J.3)."),(0,i.kt)("p",null,"NOTE 2   S'Scale is not always the same as S'Aft for a decimal subtype; for example, if S'Delta = 1.0 then S'Aft is 1 while S'Scale is 0."),(0,i.kt)("p",null,"NOTE 3   The predefined operations of a fixed point type include the assignment operation, qualification, the membership tests, and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators  and +, multiplying operators, and the unary operator abs."),(0,i.kt)("p",null,"NOTE 4   As for all types, objects of a fixed point type have Size and Address attributes (see 13.3). Other attributes of fixed point types are defined in A.5.4. "),(0,i.kt)("h2",{id:"36--array-types"},"3.6  Array Types"),(0,i.kt)("p",null,"An array object is a composite object consisting of components which all have the same subtype. The name for a component of an array uses one or more index values belonging to specified discrete types. The value of an array object is a composite value consisting of the values of the components. "),(0,i.kt)("h4",{id:"syntax-12"},"Syntax"),(0,i.kt)("p",null,"array_type_definition ::=\nunconstrained_array_definition | constrained_array_definition"),(0,i.kt)("p",null,"unconstrained_array_definition ::=\narray(index_subtype_definition {, index_subtype_definition}) of component_definition"),(0,i.kt)("p",null,"index_subtype_definition ::= subtype_mark range ","<",">"),(0,i.kt)("p",null,"constrained_array_definition ::=\narray (discrete_subtype_definition {, discrete_subtype_definition}) of component_definition"),(0,i.kt)("p",null,"discrete_subtype_definition ::= discrete_subtype_indication | range"),(0,i.kt)("p",null,"component_definition ::= ","[aliased]"," subtype_indication"),(0,i.kt)("h4",{id:"name-resolution-rules-7"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a discrete_subtype_definition that is a range, the range shall resolve to be of some specific discrete type","[; which discrete type shall be determined without using any context other than the bounds of the range itself (plus the preference for root_integer - see 8.6).]"," "),(0,i.kt)("h4",{id:"legality-rules-8"},"Legality Rules"),(0,i.kt)("p",null,"Each index_subtype_definition or discrete_subtype_definition in an array_type_definition defines an index subtype; its type (the index type) shall be discrete. "),(0,i.kt)("p",null,"Discussion: An index is a discrete quantity used to select along a given dimension of an array. A component is selected by specifying corresponding values for each of the indices. "),(0,i.kt)("p",null,"The subtype defined by the subtype_indication of a component_definition (the component subtype) shall be a definite subtype. "),(0,i.kt)("p",null,"Ramification: This applies to all uses of component_definition, including in record_type_definitions and protected_definitions."),(0,i.kt)("p",null,"Within the definition of a nonlimited composite type (or a limited composite type that later in its immediate scope becomes nonlimited - see 7.3.1 and 7.5), if a component_definition contains the reserved word aliased and the type of the component is discriminated, then the nominal subtype of the component shall be constrained. "),(0,i.kt)("p",null,"Reason: If we allowed the subtype to be unconstrained, then the discriminants might change because of an assignment to the containing (nonlimited) object, thus causing a potential violation of an access subtype constraint of an access value designating the aliased component."),(0,i.kt)("p",null,"Note that the rule elsewhere defining all aliased discriminated objects to be constrained does not help - that rule prevents assignments to the component itself from doing any harm, but not assignments to the containing object."),(0,i.kt)("p",null,"We allow this for components within limited types since assignment to the enclosing object is not a problem. Furthermore, it is important to be able to use a default expression for a discriminant in arrays of limited components, since that is the only way to give the components different values for their discriminants. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"protected type Counter_Type(Initial_Value : Integer := 1) is\n   procedure Get_Next(Next_Value : out Integer);\n     -- Returns the next value on each call, bumping Count\n     -- before returning.\nprivate\n   Count : Integer := Initial_Value;\nend Counter_Type;\nprotected body Counter_Type is ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function Next_Id(Counter : access Counter_Type) return Integer is\n    Result : Integer;\nbegin\n    Counter.Get_Next(Result);\n    return Result;\nend Next_Id;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"C : aliased Counter_Type;\ntask type T(Who_Am_I : Integer := Next_Id(C'Access));\ntask body T is ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Task_Array : array(1..100) of aliased T;\n  -- Array of task elements, each with its own unique ID.\n  -- We specify "aliased" so we can use Task_Array(I)\'Access.\n  -- This is safe because Task_Array is of a limited type,\n  -- so there is no way an assignment to it could change\n  -- the discriminants of one of its components.\n\n')),(0,i.kt)("p",null,"Ramification: Note that this rule applies to array components and record components, but not to protected type components (since they are always limited). "),(0,i.kt)("h4",{id:"static-semantics-20"},"Static Semantics"),(0,i.kt)("p",null,"An array is characterized by the number of indices (the dimensionality of the array), the type and position of each index, the lower and upper bounds for each index, and the subtype of the components. The order of the indices is significant."),(0,i.kt)("p",null,"A one-dimensional array has a distinct component for each possible index value. A multidimensional array has a distinct component for each possible sequence of index values that can be formed by selecting one value for each index position (in the given order). The possible values for a given index are all the values between the lower and upper bounds, inclusive; this range of values is called the index range. The bounds of an array are the bounds of its index ranges. The length of a dimension of an array is the number of values of the index range of the dimension (zero for a null range). The length of a one-dimensional array is the length of its only dimension."),(0,i.kt)("p",null,"An array_type_definition defines an array type and its first subtype. For each object of this array type, the number of indices, the type and position of each index, and the subtype of the components are as in the type definition","[; the values of the lower and upper bounds for each index belong to the corresponding index subtype of its type, except for null arrays (see 3.6.1)]","."),(0,i.kt)("p",null,"An unconstrained_array_definition defines an array type with an unconstrained first subtype. Each index_subtype_definition defines the corresponding index subtype to be the subtype denoted by the subtype_mark. ","[ The compound delimiter ","<",">"," (called a box) of an index_subtype_definition stands for an undefined range (different objects of the type need not have the same bounds).]"),(0,i.kt)("p",null,"A constrained_array_definition defines an array type with a constrained first subtype. Each discrete_subtype_definition defines the corresponding index subtype, as well as the corresponding index range for the constrained first subtype. The constraint of the first subtype consists of the bounds of the index ranges. "),(0,i.kt)("p",null,"Discussion: Although there is no namable unconstrained array subtype in this case, the predefined slicing and concatenation operations can operate on and yield values that do not necessarily belong to the first array subtype. This is also true for Ada 83. "),(0,i.kt)("p",null,"The discrete subtype defined by a discrete_subtype_definition is either that defined by the subtype_indication, or a subtype determined by the range as follows: "),(0,i.kt)("p",null,"If the type of the range resolves to root_integer, then the discrete_subtype_definition defines a subtype of the predefined type Integer with bounds given by a conversion to Integer of the bounds of the range; "),(0,i.kt)("p",null,"Reason: This ensures that indexing over the discrete subtype can be performed with regular Integers, rather than only universal_integers. "),(0,i.kt)("p",null,'Discussion: We considered doing this by simply creating a "preference" for Integer when resolving the range. However, this can introduce Beaujolais effects when the simple_expressions involve calls on functions visible due to use clauses. '),(0,i.kt)("p",null,"Otherwise, the discrete_subtype_definition defines a subtype of the type of the range, with the bounds given by the range. "),(0,i.kt)("p",null,"The component_definition of an array_type_definition defines the nominal subtype of the components. If the reserved word aliased appears in the component_definition, then each component of the array is aliased (see 3.10). "),(0,i.kt)("p",null,"Ramification: In this case, the nominal subtype cannot be an unconstrained discriminated subtype. See 3.8. "),(0,i.kt)("h4",{id:"dynamic-semantics-12"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an array_type_definition creates the array type and its first subtype, and consists of the elaboration of any discrete_subtype_definitions and the component_definition."),(0,i.kt)("p",null,"The elaboration of a discrete_subtype_definition creates the discrete subtype, and consists of the elaboration of the subtype_indication or the evaluation of the range. The elaboration of a component_definition in an array_type_definition consists of the elaboration of the subtype_indication. The elaboration of any discrete_subtype_definitions and the elaboration of the component_definition are performed in an arbitrary order. "),(0,i.kt)("p",null,"NOTE 1   All components of an array have the same subtype. In particular, for an array of components that are one-dimensional arrays, this means that all components have the same bounds and hence the same length."),(0,i.kt)("p",null,"NOTE 2   Each elaboration of an array_type_definition creates a distinct array type. A consequence of this is that each object whose object_declaration contains an array_type_definition is of its own unique type. "),(0,i.kt)("h4",{id:"examples-12"},"Examples"),(0,i.kt)("p",null,"Examples of type declarations with unconstrained array definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Vector     is array(Integer  range &lt&gt) of Real;\ntype Matrix     is array(Integer  range &lt&gt, Integer range &lt&gt) of Real;\ntype Bit_Vector is array(Integer  range &lt&gt) of Boolean;\ntype Roman      is array(Positive range &lt&gt) of Roman_Digit; -- see 3.5.2\n\n")),(0,i.kt)("p",null,"Examples of type declarations with constrained array definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Table    is array(1 .. 10) of Integer;\ntype Schedule is array(Day) of Boolean;\ntype Line     is array(1 .. Max_Line_Size) of Character;\n\n")),(0,i.kt)("p",null,"Examples of object declarations with array type definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Grid : array(1 .. 80, 1 .. 100) of Boolean;\nMix  : array(Color range Red .. Green) of Boolean;\nPage : array(Positive range &lt&gt) of Line :=  --  an array of arrays\n  (1 | 50  =&gt Line'(1 | Line'Last =&gt '+', others =&gt '-'),  -- see 4.3.3\n   2 .. 49 =&gt Line'(1 | Line'Last =&gt '|', others =&gt ' '));\n    -- Page is constrained by its initial value to (1..50)\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-10"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for component_definition is modified to allow the reserved word aliased."),(0,i.kt)("p",null,"The syntax rules for unconstrained_array_definition and constrained_array_definition are modified to use component_definition (instead of component_subtype_indication). The effect of this change is to allow the reserved word aliased before the component subtype_indication."),(0,i.kt)("p",null,'A range in a discrete_subtype_definition may use arbitrary universal expressions for each bound (e.g. 1 .. 3+5), rather than strictly "implicitly convertible" operands. The subtype defined will still be a subtype of Integer. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-15"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We introduce a new syntactic category, discrete_subtype_definition, as distinct from discrete_range. These two constructs have the same syntax, but their semantics are quite different (one defines a subtype, with a preference for Integer subtypes, while the other just selects a subrange of an existing subtype). We use this new syntactic category in for loops and entry families."),(0,i.kt)("p",null,"The syntax for index_constraint and discrete_range have been moved to their own subclause, since they are no longer used here."),(0,i.kt)("p",null,"The syntax rule for component_definition (formerly component_subtype_definition) is moved here from RM83-3.7. "),(0,i.kt)("h3",{id:"361--index-constraints-and-discrete-ranges"},"3.6.1  Index Constraints and Discrete Ranges"),(0,i.kt)("p",null,"An index_constraint determines the range of possible values for every index of an array subtype, and thereby the corresponding array bounds. "),(0,i.kt)("h4",{id:"syntax-13"},"Syntax"),(0,i.kt)("p",null,"index_constraint ::=  (discrete_range {, discrete_range})"),(0,i.kt)("p",null,"discrete_range ::= discrete_subtype_indication | range"),(0,i.kt)("h4",{id:"name-resolution-rules-8"},"Name Resolution Rules"),(0,i.kt)("p",null,"The type of a discrete_range is the type of the subtype defined by the subtype_indication, or the type of the range. For an index_constraint, each discrete_range shall resolve to be of the type of the corresponding index. "),(0,i.kt)("p",null,"Discussion: In Ada 95, index_constraints only appear in a subtype_indication; they no longer appear in constrained_array_definitions. "),(0,i.kt)("h4",{id:"legality-rules-9"},"Legality Rules"),(0,i.kt)("p",null,"An index_constraint shall appear only in a subtype_indication whose subtype_mark denotes either an unconstrained array subtype, or an unconstrained access subtype whose designated subtype is an unconstrained array subtype; in either case, the index_constraint shall provide a discrete_range for each index of the array type. "),(0,i.kt)("h4",{id:"static-semantics-21"},"Static Semantics"),(0,i.kt)("p",null,"A discrete_range defines a range whose bounds are given by the range, or by the range of the subtype defined by the subtype_indication. "),(0,i.kt)("h4",{id:"dynamic-semantics-13"},"Dynamic Semantics"),(0,i.kt)("p",null,"An index_constraint is compatible with an unconstrained array subtype if and only if the index range defined by each discrete_range is compatible (see 3.5) with the corresponding index subtype. If any of the discrete_ranges defines a null range, any array thus constrained is a null array, having no components. An array value satisfies an index_constraint if at each index position the array value and the index_constraint have the same index bounds. "),(0,i.kt)("p",null,"Ramification: There is no need to define compatibility with a constrained array subtype, because one is not allowed to constrain it again."),(0,i.kt)("p",null,"The elaboration of an index_constraint consists of the evaluation of the discrete_range(s), in an arbitrary order. The evaluation of a discrete_range consists of the elaboration of the subtype_indication or the evaluation of the range. "),(0,i.kt)("p",null,"NOTE 1   The elaboration of a subtype_indication consisting of a subtype_mark followed by an index_constraint checks the compatibility of the index_constraint with the subtype_mark (see 3.2.2)."),(0,i.kt)("p",null,"NOTE 2   Even if an array value does not satisfy the index constraint of an array subtype, Constraint_Error is not raised on conversion to the array subtype, so long as the length of each dimension of the array value and the array subtype match. See 4.6. "),(0,i.kt)("h4",{id:"examples-13"},"Examples"),(0,i.kt)("p",null,"Examples of array declarations including an index constraint: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Board     : Matrix(1 .. 8,  1 .. 8);  --  see 3.6\nRectangle : Matrix(1 .. 20, 1 .. 30);\nInverse   : Matrix(1 .. N,  1 .. N);  --  N need not be static\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Filter    : Bit_Vector(0 .. 31);      --  see 3.6\n\n")),(0,i.kt)("p",null,"Example of array declaration with a constrained array subtype: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"My_Schedule : Schedule;  --  all arrays of type Schedule have the same bounds\n\n")),(0,i.kt)("p",null,"Example of record type with a component that is an array: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Var_Line(Length : Natural) is\n   record\n      Image : String(1 .. Length);\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Null_Line : Var_Line(0);  --  Null_Line.Image is a null array\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-11"},"Extensions to Ada 83"),(0,i.kt)("p",null,"We allow the declaration of a variable with a nominally unconstrained array subtype, so long as it has an initialization expression to determine its bounds. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-16"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have moved the syntax for index_constraint and discrete_range here since they are no longer used in constrained_array_definitions. We therefore also no longer have to describe the (special) semantics of index_constraints and discrete_ranges that appear in constrained_array_definitions."),(0,i.kt)("p",null,"The rules given in RM83-3.6.1(5,7-10), which define the bounds of an array object, are redundant with rules given elsewhere, and so are not repeated here. RM83-3.6.1(6), which requires that the (nominal) subtype of an array variable be constrained, no longer applies, so long as the variable is explicitly initialized. "),(0,i.kt)("h3",{id:"362--operations-of-array-types"},"3.6.2  Operations of Array Types"),(0,i.kt)("h4",{id:"legality-rules-10"},"Legality Rules"),(0,i.kt)("p",null,"[The argument N used in the attribute_designators for the N-th dimension of an array shall be a static expression of some integer type.]"," The value of N shall be positive (nonzero) and no greater than the dimensionality of the array. "),(0,i.kt)("h4",{id:"static-semantics-22"},"Static Semantics"),(0,i.kt)("p",null,"The following attributes are defined for a prefix A that is of an array type ","[(after any implicit dereference)]",", or denotes a constrained array subtype: "),(0,i.kt)("p",null,"Ramification: These attributes are not defined if A is a subtype-mark for an access-to-array subtype. They are defined (by implicit dereference) for access-to-array values."),(0,i.kt)("p",null,"A'FirstA'First denotes the lower bound of the first index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'First(N)A'First(N) denotes the lower bound of the N-th index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'LastA'Last denotes the upper bound of the first index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'Last(N)A'Last(N) denotes the upper bound of the N-th index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'RangeA'Range is equivalent to the range A'First .. A'Last, except that the prefix A is only evaluated once."),(0,i.kt)("p",null,"A'Range(N)A'Range(N) is equivalent to the range A'First(N) .. A'Last(N), except that the prefix A is only evaluated once."),(0,i.kt)("p",null,"A'LengthA'Length denotes the number of values of the first index range (zero for a null range); its type is universal_integer."),(0,i.kt)("p",null,"A'Length(N)A'Length(N) denotes the number of values of the N-th index range (zero for a null range); its type is universal_integer. "),(0,i.kt)("h4",{id:"implementation-advice-4"},"Implementation Advice"),(0,i.kt)("p",null,'An implementation should normally represent multidimensional arrays in row-major order, consistent with the notation used for multidimensional array aggregates (see 4.3.3). However, if a pragma Convention(Fortran, ...) applies to a multidimensional array type, then column-major order should be used instead (see B.5, "Interfacing with Fortran"). '),(0,i.kt)("p",null,"NOTE 1   The attribute_references A'First and A'First(1) denote the same value. A similar relation exists for the attribute_references A'Last, A'Range, and A'Length. The following relation is satisfied (except for a null array) by the above attributes if the index type is an integer type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   A'Length(N) = A'Last(N) - A'First(N) + 1\n\n")),(0,i.kt)("p",null,"NOTE 2   An array type is limited if its component type is limited (see 7.5)."),(0,i.kt)("p",null,"NOTE 3   The predefined operations of an array type include the membership tests, qualification, and explicit conversion. If the array type is not limited, they also include assignment and the predefined equality operators. For a one-dimensional array type, they include the predefined concatenation operators (if nonlimited) and, if the component type is discrete, the predefined relational operators; if the component type is boolean, the predefined logical operators are also included."),(0,i.kt)("p",null,"NOTE 4   A component of an array can be named with an indexed_component. A value of an array type can be specified with an array_aggregate, unless the array type is limited. For a one-dimensional array type, a slice of the array can be named; also, string literals are defined if the component type is a character type. "),(0,i.kt)("h4",{id:"examples-14"},"Examples"),(0,i.kt)("p",null,"Examples (using arrays declared in the examples of subclause 3.6.1): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Filter'First      =   0   Filter'Last       =  31   Filter'Length =  32\n--  Rectangle'Last(1) =  20   Rectangle'Last(2) =  30\n\n")),(0,i.kt)("h3",{id:"363--string-types"},"3.6.3  String Types"),(0,i.kt)("h4",{id:"static-semantics-23"},"Static Semantics"),(0,i.kt)("p",null,"A one-dimensional array type whose component type is a character type is called a string type."),(0,i.kt)("p",null,"[There are two predefined string types, String and Wide_String, each indexed by values of the predefined subtype Positive; these are declared in the visible part of package Standard:]"," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"[subtype Positive is Integer range 1 .. Integer'Last;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type String is array(Positive range &lt&gt) of Character;\ntype Wide_String is array(Positive range &lt&gt) of Wide_Character;\n\n]\n\n")),(0,i.kt)("p",null,"NOTE 1   String literals (see 2.6 and 4.2) are defined for all string types. The concatenation operator & is predefined for string types, as for all nonlimited one-dimensional array types. The ordering operators ","<",", ","<","=, ",">",", and ",">","= are predefined for string types, as for all one-dimensional discrete array types; these ordering operators correspond to lexicographic order (see 4.5.2)."),(0,i.kt)("h4",{id:"examples-15"},"Examples"),(0,i.kt)("p",null,"Examples of string objects: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Stars      : String(1 .. 120) := (1 .. 120 =&gt '*' );\nQuestion   : constant String  := \"How many characters?\";\n    -- Question'First = 1, Question'Last = 20\n    -- Question'Length = 20 (the number of characters)\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Ask_Twice  : String  := Question & Question;    -- constrained to (1..40)\nNinety_Six : constant Roman   := "XCVI";    -- see 3.5.2 and 3.6\n\n')),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-4"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"The declaration of Wide_String in Standard hides a use-visible declaration with the same defining_identifier. In rare cases, this might result in an inconsistency between Ada 83 and Ada 95. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-5"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"Because both String and Wide_String are always directly visible, an expression like "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'"a" &lt "bc"\n\n')),(0,i.kt)("p",null,"is now ambiguous, whereas in Ada 83 both string literals could be resolved to type String. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-12"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The type Wide_String is new (though it was approved by ARG for Ada 83 compilers as well). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-17"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We define the term string type as a natural analogy to the term character type. "),(0,i.kt)("h2",{id:"37--discriminants"},"3.7  Discriminants"),(0,i.kt)("p",null,"[ A composite type (other than an array type) can have discriminants, which parameterize the type. A known_discriminant_part specifies the discriminants of a composite type. A discriminant of an object is a component of the object, and is either of a discrete type or an access type. An unknown_discriminant_part in the declaration of a partial view of a type specifies that the discriminants of the type are unknown for the given view; all subtypes of such a partial view are indefinite subtypes.]"," "),(0,i.kt)("p",null,"Glossary entry: A discriminant is a parameter of a composite type. It can control, for example, the bounds of a component of the type if that type is an array type. A discriminant of a task type can be used to pass data to a task of the type upon creation."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[discriminant]",", Def=","[a parameter for a composite type, which can control, for example, the bounds of a component that is an array]",", Note1=","[A discriminant for a task type can be used to pass data to a task of the type upon its creation.]"," "),(0,i.kt)("p",null,"Discussion: A type, and all of its subtypes, have unknown discriminants when the number or names of the discriminants, if any, are unknown at the point of the type declaration. A discriminant_part of (","<",">",") is used to indicate unknown discriminants. "),(0,i.kt)("h4",{id:"syntax-14"},"Syntax"),(0,i.kt)("p",null,"discriminant_part ::= unknown_discriminant_part | known_discriminant_part"),(0,i.kt)("p",null,"unknown_discriminant_part ::= (","<",">",")"),(0,i.kt)("p",null,"known_discriminant_part ::=\n(discriminant_specification {; discriminant_specification})"),(0,i.kt)("p",null,"discriminant_specification ::=\ndefining_identifier_list : subtype_mark ","[:= default_expression]","\n| defining_identifier_list : access_definition ","[:= default_expression]"),(0,i.kt)("p",null,"default_expression ::= expression"),(0,i.kt)("h4",{id:"name-resolution-rules-9"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expected type for the default_expression of a discriminant_specification is that of the corresponding discriminant. "),(0,i.kt)("h4",{id:"legality-rules-11"},"Legality Rules"),(0,i.kt)("p",null,"A known_discriminant_part is only permitted in a declaration for a composite type that is not an array type ","[(this includes generic formal types)]","; a type declared with a known_discriminant_part is called a discriminated type, as is a type that inherits (known) discriminants. "),(0,i.kt)("p",null,"Implementation Note: Discriminants on array types were considered, but were omitted to ease (existing) implementations. "),(0,i.kt)("p",null,'Discussion: Note that the above definition for "discriminated type" does not include types declared with an unknown_discriminant_part. This seems consistent with Ada 83, where such types (in a generic formal part) would not be considered discriminated types. Furthermore, the full type for a type with unknown discriminants need not even be composite, much less have any discriminants.'),(0,i.kt)("p",null,"The subtype of a discriminant may be defined by a subtype_mark, in which case the subtype_mark shall denote a discrete or access subtype, or it may be defined by an access_definition ","[(in which case the subtype_mark of the access_definition may denote any kind of subtype)]",". A discriminant that is defined by an access_definition is called an access discriminant and is of an anonymous general access-to-variable type whose designated subtype is denoted by the subtype_mark of the access_definition. "),(0,i.kt)("p",null,"Reason: In an early version of Ada 9X, we allowed access discriminants on nonlimited types, but this created unpleasant complexities. It turned out to be simpler and more uniform to allow discriminants of a named access type on any discriminated type, and keep access discriminants just for limited types."),(0,i.kt)("p",null,'Note that discriminants of a named access type are not considered "access discriminants". Similarly, "access parameter" only refers to a formal parameter defined by an access_definition. '),(0,i.kt)("p",null,"A discriminant_specification for an access discriminant shall appear only in the declaration for a task or protected type, or for a type with the reserved word limited in its ","[(full)]"," definition or in that of one of its ancestors. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. "),(0,i.kt)("p",null,"Discussion: This rule implies that a type can have an access discriminant if the type is limited, but not if the only reason it's limited is because of a limited component. Compare with the definition of limited type in 7.5. "),(0,i.kt)("p",null,"Ramification: It is a consequence of this rule that only a return-by-reference type can have an access discriminant (see 6.5). This is important to avoid dangling references to local variables. "),(0,i.kt)("p",null,"Reason: We also considered the following rules: "),(0,i.kt)("p",null,"If a type has an access discriminant, this automatically makes it limited, just like having a limited component automatically makes a type limited. This was rejected because it decreases program readability, and because it seemed error prone (two bugs in a previous version of the RM9X were attributable to this rule)."),(0,i.kt)("p",null,'A type with an access discriminant shall be limited. This is equivalent to the rule we actually chose, except that it allows a type to have an access discriminant if it is limited just because of a limited component. For example, any record containing a task would be allowed to have an access discriminant, whereas the actual rule requires "limited record". This rule was also rejected due to readability concerns, and because would interact badly with the rules for limited types that "become nonlimited".'),(0,i.kt)("p",null,"Default_expressions shall be provided either for all or for none of the discriminants of a known_discriminant_part. No default_expressions are permitted in a known_discriminant_part in a declaration of a tagged type ","[or a generic formal type]",". "),(0,i.kt)("p",null,"Reason: The all-or-none rule is related to the rule that a discriminant constraint shall specify values for all discriminants. One could imagine a different rule that allowed a constraint to specify only some of the discriminants, with the others provided by default. Having defaults for discriminants has a special significance - it allows objects of the type to be unconstrained, with the discriminants alterable as part of assigning to the object."),(0,i.kt)("p",null,'Defaults for discriminants of tagged types are disallowed so that every object of a tagged type is constrained, either by an explicit constraint, or by its initial discriminant values. This substantially simplifies the semantic rules and the implementation of inherited dispatching operations. For generic formal types, the restriction simplifies the type matching rules. If one simply wants a "default" value for the discriminants, a constrained subtype can be declared for future use. '),(0,i.kt)("p",null,"For a type defined by a derived_type_definition, if a known_discriminant_part is provided in its declaration, then: "),(0,i.kt)("p",null,"The parent subtype shall be constrained;"),(0,i.kt)("p",null,"If the parent type is not a tagged type, then each discriminant of the derived type shall be used in the constraint defining the parent subtype;"),(0,i.kt)("p",null,"Implementation Note: This ensures that the new discriminant can share storage with an existing discriminant."),(0,i.kt)("p",null,"If a discriminant is used in the constraint defining the parent subtype, the subtype of the discriminant shall be statically compatible (see 4.9.1) with the subtype of the corresponding parent discriminant. "),(0,i.kt)("p",null,"Reason: This ensures that on conversion (or extension via an extension aggregate) to a distantly related type, if the discriminants satisfy the target type's requirements they satisfy all the intermediate types' requirements as well. "),(0,i.kt)("p",null,"Ramification: There is no requirement that the new discriminant have the same (or any) default_expression as the parent's discriminant. "),(0,i.kt)("p",null,"The type of the default_expression, if any, for an access discriminant shall be convertible to the anonymous access type of the discriminant (see 4.6). "),(0,i.kt)("p",null,"Ramification: This requires convertibility of the designated subtypes. "),(0,i.kt)("h4",{id:"static-semantics-24"},"Static Semantics"),(0,i.kt)("p",null,"A discriminant_specification declares a discriminant; the subtype_mark denotes its subtype unless it is an access discriminant, in which case the discriminant's subtype is the anonymous access-to-variable subtype defined by the access_definition."),(0,i.kt)("p",null,"[For a type defined by a derived_type_definition, each discriminant of the parent type is either inherited, constrained to equal some new discriminant of the derived type, or constrained to the value of an expression.]"," When inherited or constrained to equal some new discriminant, the parent discriminant and the discriminant of the derived type are said to correspond. Two discriminants also correspond if there is some common discriminant to which they both correspond. A discriminant corresponds to itself as well. If a discriminant of a parent type is constrained to a specific value by a derived_type_definition, then that discriminant is said to be specified by that derived_type_definition. "),(0,i.kt)("p",null,"Ramification: The correspondence relationship is transitive, symmetric, and reflexive. That is, if A corresponds to B, and B corresponds to C, then A, B, and C each corresponds to A, B, and C in all combinations."),(0,i.kt)("p",null,"A constraint that appears within the definition of a discriminated type depends on a discriminant of the type if it names the discriminant as a bound or discriminant value. A component_definition depends on a discriminant if its constraint depends on the discriminant, or on a discriminant that corresponds to it. "),(0,i.kt)("p",null,"Ramification: A constraint in a task_body is not considered to depend on a discriminant of the task type, even if it names it. It is only the constraints in the type definition itself that are considered dependents. Similarly for protected types. "),(0,i.kt)("p",null,"A component depends on a discriminant if: "),(0,i.kt)("p",null,"Its component_definition depends on the discriminant; or "),(0,i.kt)("p",null,"Ramification: A component does not depend on a discriminant just because its default_expression refers to the discriminant."),(0,i.kt)("p",null,"It is declared in a variant_part that is governed by the discriminant; or"),(0,i.kt)("p",null,"It is a component inherited as part of a derived_type_definition, and the constraint of the parent_subtype_indication depends on the discriminant; or "),(0,i.kt)("p",null,"Reason: When the parent subtype depends on a discriminant, the parent part of the derived type is treated like a discriminant-dependent component. "),(0,i.kt)("p",null,'Ramification: Because of this rule, we don\'t really need to worry about "corresponding" discriminants, since all the inherited components will be discriminant-dependent if there is a new known_discriminant_part whose discriminants are used to constrain the old discriminants. '),(0,i.kt)("p",null,"It is a subcomponent of a component that depends on the discriminant. "),(0,i.kt)("p",null,"Reason: The concept of discriminant-dependent (sub)components is primarily used in various rules that disallow renaming or 'Access, or specify that certain discriminant-changing assignments are erroneous. The goal is to allow implementations to move around or change the size of discriminant-dependent subcomponents upon a discriminant-changing assignment to an enclosing object. The above definition specifies that all subcomponents of a discriminant-dependent component or parent part are themselves discriminant-dependent, even though their presence or size does not in fact depend on a discriminant. This is because it is likely that they will move in a discriminant-changing assignment if they are a component of one of several discriminant-dependent parts of the same record. "),(0,i.kt)("p",null,"Each value of a discriminated type includes a value for each component of the type that does not depend on a discriminant","[; this includes the discriminants themselves]",". The values of discriminants determine which other component values are present in the value of the discriminated type. "),(0,i.kt)("p",null,'To be honest: Which values are present might depend on discriminants of some ancestor type that are constrained in an intervening derived_type_definition. That\'s why we say "values of discriminants" instead of "values of the discriminants" - a subtle point.'),(0,i.kt)("p",null,"A type declared with a known_discriminant_part is said to have known discriminants; its first subtype is unconstrained. A type declared with an unknown_discriminant_part is said to have unknown discriminants. A type declared without a discriminant_part has no discriminants, unless it is a derived type; if derived, such a type has the same sort of discriminants (known, unknown, or none) as its parent (or ancestor) type. A tagged class-wide type also has unknown discriminants. ","[Any subtype of a type with unknown discriminants is an unconstrained and indefinite subtype (see 3.2 and 3.3).]"," "),(0,i.kt)("p",null,'Discussion: An unknown_discriminant_part "(',"<",">",')" is only permitted in the declaration of a (generic or nongeneric) private type, private extension, or formal derived type. Hence, only such types, descendants thereof, and class-wide types can have unknown discriminants. An unknown_discriminant_part is used to indicate that the corresponding actual or full type might have discriminants without defaults, or be an unconstrained array subtype. Tagged class-wide types are also considered to have unknown discriminants because discriminants can be added by type extensions, so the total number of discriminants of any given value of a tagged class-wide type is not known at compile time.'),(0,i.kt)("p",null,'A subtype with unknown discriminants is indefinite, and hence an object of such a subtype needs explicit initialization. If the subtype is limited, no (stand-alone) objects can be declared since initialization is not permitted (though formal parameters are permitted, and objects of the actual/full type will generally be declarable). A limited private type with unknown discriminants is "extremely" limited; such a type  is useful for keeping complete control over object creation within the package declaring the type.'),(0,i.kt)("p",null,"A partial view of a type might have unknown discriminants, while the full view of the same type might have known, unknown, or no discriminants, "),(0,i.kt)("h4",{id:"dynamic-semantics-14"},"Dynamic Semantics"),(0,i.kt)("p",null,"An access_definition is elaborated when the value of a corresponding access discriminant is defined, either by evaluation of its default_expression or by elaboration of a discriminant_constraint. ","[The elaboration of an access_definition creates the anonymous access type. When the expression defining the access discriminant is evaluated, it is converted to this anonymous access type (see 4.6).]"," "),(0,i.kt)("p",null,"Ramification: This conversion raises Constraint_Error if the initial value is null, or, for an object created by an allocator of an access type T, if the initial value is an access parameter that designates a view whose accessibility level is deeper than that of T. "),(0,i.kt)("p",null,"NOTE 1   If a discriminated type has default_expressions for its discriminants, then unconstrained variables of the type are permitted, and the values of the discriminants can be changed by an assignment to such a variable. If defaults are not provided for the discriminants, then all variables of the type are constrained, either by explicit constraint or by their initial value; the values of the discriminants of such a variable cannot be changed after initialization. "),(0,i.kt)("p",null,"Discussion: This connection between discriminant defaults and unconstrained variables can be a source of confusion. For Ada 95, we considered various ways to break the connection between defaults and unconstrainedness, but ultimately gave up for lack of a sufficiently simple and intuitive alternative."),(0,i.kt)("p",null,"An unconstrained discriminated subtype with defaults is called a mutable subtype, and a variable of such a subtype is called a mutable variable, because the discriminants of such a variable can change. There are no mutable arrays (that is, the bounds of an array object can never change), because there is no way in the language to define default values for the bounds. Similarly, there are no mutable class-wide subtypes, because there is no way to define the default tag, and defaults for discriminants are not allowed in the tagged case. Mutable tags would also require a way for the maximum possible size of such a class-wide subtype to be known. (In some implementations, all mutable variables are allocated with the maximum possible size. This approach is appropriate for real-time applications where implicit use of the heap is inappropriate.)"),(0,i.kt)("p",null,"NOTE 2   The default_expression for a discriminant of a type is evaluated when an object of an unconstrained subtype of the type is created."),(0,i.kt)("p",null,"NOTE 3   Assignment to a discriminant of an object (after its initialization) is not allowed, since the name of a discriminant is a constant; neither assignment_statements nor assignments inherent in passing as an in out or out parameter are allowed. Note however that the value of a discriminant can be changed by assigning to the enclosing object, presuming it is an unconstrained variable. "),(0,i.kt)("p",null,"Discussion: An unknown_discriminant_part is permitted only in the declaration of a private type (including generic formal private), private extension, or generic formal derived type. These are the things that will have a corresponding completion or generic actual, which will either define the discriminants, or say there are none. The (","<",">",") indicates that the actual/full subtype might be an indefinite subtype. An unknown_discriminant_part is not permitted in a normal untagged derived type declaration, because there is no separate full type declaration for such a type. Note that (","<",">",") allows unconstrained array bounds; those are somewhat like undefaulted discriminants."),(0,i.kt)("p",null,"For a derived type, either the discriminants are inherited as is, or completely respecified in a new discriminant_part. In this latter case, each discriminant of the parent type shall be constrained, either to a specific value, or to equal one of the new discriminants. Constraining a parent type's discriminant to equal one of the new discriminants is like a renaming of the discriminant, except that the subtype of the new discriminant can be more restrictive than that of the parent's one. In any case, the new discriminant can share storage with the parent's discriminant. "),(0,i.kt)("p",null,"NOTE 4   A discriminant that is of a named access type is not called an access discriminant; that term is used only for discriminants defined by an access_definition. "),(0,i.kt)("h4",{id:"examples-16"},"Examples"),(0,i.kt)("p",null,"Examples of discriminated types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Buffer(Size : Buffer_Size := 100)  is        -- see 3.5.4\n   record\n      Pos   : Buffer_Size := 0;\n      Value : String(1 .. Size);\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Matrix_Rec(Rows, Columns : Integer) is\n   record\n      Mat : Matrix(1 .. Rows, 1 .. Columns);       -- see 3.6\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Square(Side : Integer) is new\n   Matrix_Rec(Rows =&gt Side, Columns =&gt Side);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Double_Square(Number : Integer) is\n   record\n      Left  : Square(Number);\n      Right : Square(Number);\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Item(Number : Positive) is\n   record\n      Content : Integer;\n      --  no component depends on the discriminant\n   end record;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-13"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax for a discriminant_specification is modified to allow an access discriminant, with a type specified by an access_definition (see 3.10)."),(0,i.kt)("p",null,"Discriminants are allowed on all composite types other than array types."),(0,i.kt)("p",null,"Discriminants may be of an access type. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-18"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Discriminant_parts are not elaborated, though an access_definition is elaborated when the discriminant is initialized."),(0,i.kt)("h3",{id:"371--discriminant-constraints"},"3.7.1  Discriminant Constraints"),(0,i.kt)("p",null,"A discriminant_constraint specifies the values of the discriminants for a given discriminated type. "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,'The rules in this clause are intentionally parallel to those given in 4.3.1, "Record Aggregates". '),(0,i.kt)("h4",{id:"syntax-15"},"Syntax"),(0,i.kt)("p",null,"discriminant_constraint ::=\n(discriminant_association {, discriminant_association})"),(0,i.kt)("p",null,"discriminant_association ::=\n","[discriminant_selector_name {| discriminant_selector_name} =",">]"," expression"),(0,i.kt)("p",null,"A discriminant_association is said to be named if it has one or more discriminant_selector_names; it is otherwise said to be positional. In a discriminant_constraint, any positional associations shall precede any named associations. "),(0,i.kt)("h4",{id:"name-resolution-rules-10"},"Name Resolution Rules"),(0,i.kt)("p",null,"Each selector_name of a named discriminant_association shall resolve to denote a discriminant of the subtype being constrained; the discriminants so named are the associated discriminants of the named association. For a positional association, the associated discriminant is the one whose discriminant_specification occurred in the corresponding position in the known_discriminant_part that defined the discriminants of the subtype being constrained."),(0,i.kt)("p",null,"The expected type for the expression in a discriminant_association is that of the associated discriminant(s). "),(0,i.kt)("h4",{id:"legality-rules-12"},"Legality Rules"),(0,i.kt)("p",null,"A discriminant_constraint is only allowed in a subtype_indication whose subtype_mark denotes either an unconstrained discriminated subtype, or an unconstrained access subtype whose designated subtype is an unconstrained discriminated subtype. there is a place within the immediate scope of the designated subtype where the designated subtype's view is constrained. "),(0,i.kt)("p",null,"A named discriminant_association with more than one selector_name is allowed only if the named discriminants are all of the same type. A discriminant_constraint shall provide exactly one value for each discriminant of the subtype being constrained."),(0,i.kt)("p",null,"The expression associated with an access discriminant shall be of a type convertible to the anonymous access type. "),(0,i.kt)("p",null,"Ramification: This implies both convertibility of designated types, and static accessibility. This implies that if an object of type T with an access discriminant is created by an allocator for an access type A, then it requires that the type of the expression associated with the access discriminant have an accessibility level that is not statically deeper than that of A. This is to avoid dangling references."),(0,i.kt)("h4",{id:"dynamic-semantics-15"},"Dynamic Semantics"),(0,i.kt)("p",null,"A discriminant_constraint is compatible with an unconstrained discriminated subtype if each discriminant value belongs to the subtype of the corresponding discriminant. "),(0,i.kt)("p",null,'Ramification: The "dependent compatibility check" has been eliminated in Ada 95. Any checking on subcomponents is performed when (and if) an object is created.'),(0,i.kt)("p",null,"Discussion: There is no need to define compatibility with a constrained discriminated subtype, because one is not allowed to constrain it again."),(0,i.kt)("p",null,"A composite value satisfies a discriminant constraint if and only if each discriminant of the composite value has the value imposed by the discriminant constraint."),(0,i.kt)("p",null,"For the elaboration of a discriminant_constraint, the expressions in the discriminant_associations are evaluated in an arbitrary order and converted to the type of the associated discriminant (which might raise Constraint_Error - see 4.6); the expression of a named association is evaluated (and converted) once for each associated discriminant. The result of each evaluation and conversion is the value imposed by the constraint for the associated discriminant. "),(0,i.kt)("p",null,"Reason: We convert to the type, not the subtype, so that the definition of compatibility of discriminant constraints is not vacuous."),(0,i.kt)("p",null,"NOTE   The rules of the language ensure that a discriminant of an object always has a value, either from explicit or implicit initialization. "),(0,i.kt)("p",null,"Discussion: Although it is illegal to constrain a class-wide tagged subtype, it is possible to have a partially constrained class-wide subtype: If the subtype S is defined by T(A =",">"," B), then S'Class is partially constrained in the sense that objects of subtype S'Class have to have discriminants corresponding to A equal to B, but there can be other discriminants defined in extensions that are not constrained to any particular value. "),(0,i.kt)("h4",{id:"examples-17"},"Examples"),(0,i.kt)("p",null,"Examples (using types declared above in clause 3.7): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Large   : Buffer(200);  --  constrained, always 200 characters\n                        --   (explicit discriminant value)\nMessage : Buffer;       --  unconstrained, initially 100 characters\n                        --   (default discriminant value)\nBasis   : Square(5);    --  constrained, always 5 by 5\nIllegal : Square;       --  illegal, a Square has to be constrained\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-5"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"Dependent compatibility checks are no longer performed on subtype declaration. Instead they are deferred until object creation (see 3.3.1). This is upward compatible for a program that does not raise Constraint_Error. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-19"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Everything in RM83-3.7.2(7-12), which specifies the initial values for discriminants, is now redundant with 3.3.1, 6.4.1, 8.5.1, and 12.4. Therefore, we don't repeat it here. Since the material is largely intuitive, but nevertheless complicated to state formally, it doesn't seem worth putting it in a \"NOTE\". "),(0,i.kt)("h3",{id:"372--operations-of-discriminated-types"},"3.7.2  Operations of Discriminated Types"),(0,i.kt)("p",null,"[If a discriminated type has default_expressions for its discriminants, then unconstrained variables of the type are permitted, and the discriminants of such a variable can be changed by assignment to the variable. For a formal parameter of such a type, an attribute is provided to determine whether the corresponding actual parameter is constrained or unconstrained.]"," "),(0,i.kt)("h4",{id:"static-semantics-25"},"Static Semantics"),(0,i.kt)("p",null,"For a prefix A that is of a discriminated type ","[(after any implicit dereference)]",", the following attribute is defined: "),(0,i.kt)("p",null,"A'ConstrainedYields the value True if A denotes a constant, a value, or a constrained variable, and False otherwise. "),(0,i.kt)("p",null,"Implementation Note: This attribute is primarily used on parameters, to determine whether the discriminants can be changed as part of an assignment. The Constrained attribute is statically True for in parameters. For in out and out parameters of a discriminated type, the value of this attribute needs to be passed as an implicit parameter, in general. However, if the type does not have defaults for its discriminants, the attribute is statically True, so no implicit parameter is needed. Parameters of a limited type with defaulted discriminants need this implicit parameter, unless there are no nonlimited views, because they might be passed to a subprogram whose body has visibility on a nonlimited view of the type, and hence might be able to assign to the object and change its discriminants. "),(0,i.kt)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,i.kt)("p",null,"The execution of a construct is erroneous if the construct has a constituent that is a name denoting a subcomponent that depends on discriminants, and the value of any of these discriminants is changed by this execution between evaluating the name and the last use (within this execution) of the subcomponent denoted by the name. "),(0,i.kt)("p",null,"Ramification: This rule applies to assignment_statements, calls (except when the discriminant-dependent subcomponent is an in parameter passed by copy), indexed_components, and slices. Ada 83 only covered the first two cases. AI83-00585 pointed out the situation with the last two cases. The cases of object_renaming_declarations and generic formal in out objects are handled differently, by disallowing the situation at compile time. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-14"},"Extensions to Ada 83"),(0,i.kt)("p",null,"For consistency with other attributes, we are allowing the prefix of Constrained to be a value as well as an object of a discriminated type, and also an implicit dereference. These extensions are not important capabilities, but there seems no reason to make this attribute different from other similar attributes. We are curious what most Ada 83 compilers do with F(1).X'Constrained."),(0,i.kt)("p",null,"We now handle in a general way the cases of erroneousness identified by AI83-00585, where the prefix of an indexed_component or slice is discriminant-dependent, and the evaluation of the index or discrete range changes the value of a discriminant. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-20"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have moved all discussion of erroneous use of names that denote discriminant-dependent subcomponents to this subclause. In Ada 83, it used to appear separately under assignment_statements and subprogram calls. "),(0,i.kt)("h2",{id:"38--record-types"},"3.8  Record Types"),(0,i.kt)("p",null,"A record object is a composite object consisting of named components. The value of a record object is a composite value consisting of the values of the components. "),(0,i.kt)("h4",{id:"syntax-16"},"Syntax"),(0,i.kt)("p",null,"record_type_definition ::= ","[[abstract] tagged][limited]"," record_definition"),(0,i.kt)("p",null,"record_definition ::=\nrecord\ncomponent_list\nend record\n| null record"),(0,i.kt)("p",null,"component_list ::=\ncomponent_item {component_item}\n| {component_item} variant_part\n|  null;"),(0,i.kt)("p",null,"component_item ::= component_declaration | representation_clause"),(0,i.kt)("p",null,"component_declaration ::=\ndefining_identifier_list : component_definition ","[:= default_expression]",";"),(0,i.kt)("h4",{id:"name-resolution-rules-11"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expected type for the default_expression, if any, in a component_declaration is the type of the component. "),(0,i.kt)("h4",{id:"legality-rules-13"},"Legality Rules"),(0,i.kt)("p",null,"A default_expression is not permitted if the component is of a limited type."),(0,i.kt)("p",null,"Each component_declaration declares a component of the record type. Besides components declared by component_declarations, the components of a record type include any components declared by discriminant_specifications of the record type declaration. ","[The identifiers of all components of a record type shall be distinct.]"," "),(0,i.kt)("p",null,"Proof: The identifiers of all components of a record type have to be distinct because they are all declared immediately within the same declarative region. See Section 8. "),(0,i.kt)("p",null,"Within a type_declaration, a name that denotes a component, protected subprogram, or entry of the type is allowed only in the following cases:"),(0,i.kt)("p",null,"A name that denotes any component, protected subprogram, or entry is allowed within a representation item that occurs within the declaration of the composite type."),(0,i.kt)("p",null,"A name that denotes a noninherited discriminant is allowed within the declaration of the type, but not within the discriminant_part. If the discriminant is used to define the constraint of a component, the bounds of an entry family, or the constraint of the parent subtype in a derived_type_definition then its name shall appear alone as a direct_name (not as part of a larger expression or expanded name). A discriminant shall not be used to define the constraint of a scalar component. "),(0,i.kt)("p",null,"Reason: The penultimate restriction simplifies implementation, and allows the outer discriminant and the inner discriminant or bound to possibly share storage. "),(0,i.kt)("p",null,"Ramification: Other rules prevent such a discriminant from being an inherited one. "),(0,i.kt)("p",null,"Reason: The last restriction is inherited from Ada 83. The restriction is not really necessary from a language design point of view, but we did not remove it, in order to avoid unnecessary changes to existing compilers. "),(0,i.kt)("p",null,"Discussion: Note that a discriminant can be used to define the constraint for a component that is of an access-to-composite type. "),(0,i.kt)("p",null,"Reason: The above rules, and a similar one in 6.1 for formal parameters, are intended to allow initializations of components or parameters to occur in an arbitrary order - whatever order is most efficient, since one default_expression cannot depend on the value of another one. It also prevent circularities. "),(0,i.kt)("p",null,"Ramification: Inherited discriminants are not allowed to be denoted, except within representation items. However, the discriminant_selector_name of the parent subtype_indication is allowed to denote a discriminant of the parent. "),(0,i.kt)("p",null,"If the name of the current instance of a type (see 8.6) is used to define the constraint of a component, then it shall appear as a direct_name that is the prefix of an attribute_reference whose result is of an access type, and the attribute_reference shall appear alone. "),(0,i.kt)("p",null,"Reason: This rule allows T'Access or T'Unchecked_Access, but disallows, for example, a range constraint (1..T'Size). Allowing things like (1..T'Size) would mean that a per-object constraint could affect the size of the object, which would be bad. "),(0,i.kt)("h4",{id:"static-semantics-26"},"Static Semantics"),(0,i.kt)("p",null,"The component_definition of a component_declaration defines the (nominal) subtype of the component. If the reserved word aliased appears in the component_definition, then the component is aliased (see 3.10). "),(0,i.kt)("p",null,"Ramification: In this case, the nominal subtype cannot be an unconstrained discriminated subtype. See 3.6. "),(0,i.kt)("p",null,"If the component_list of a record type is defined by the reserved word null and there are no discriminants, then the record type has no components and all records of the type are null records. A record_definition of null record is equivalent to record null; end record. "),(0,i.kt)("p",null,"Ramification: This short-hand is available both for declaring a record type and a record extension - see 3.9.1. "),(0,i.kt)("h4",{id:"dynamic-semantics-16"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a record_type_definition creates the record type and its first subtype, and consists of the elaboration of the record_definition. The elaboration of a record_definition consists of the elaboration of its component_list, if any."),(0,i.kt)("p",null,"The elaboration of a component_list consists of the elaboration of the component_items and variant_part, if any, in the order in which they appear. The elaboration of a component_declaration consists of the elaboration of the component_definition. "),(0,i.kt)("p",null,"Discussion: If the defining_identifier_list has more than one defining_identifier, we presume here that the transformation explained in 3.3.1 has already taken place. Alternatively, we could say that the component_definition is elaborated once for each defining_identifier in the list. "),(0,i.kt)("p",null,"Within the definition of a composite type, if a component_definition or discrete_subtype_definition (see 9.5.2) includes a name that denotes a discriminant of the type, or that is an attribute_reference whose prefix denotes the current instance of the type, the expression containing the name is called a per-object expression, and the constraint being defined is called a per-object constraint. For the elaboration of a component_definition of a component_declaration, if the constraint  of the subtype_indication  is not a per-object constraint, then the subtype_indication is elaborated. On the other hand, if the constraint  is a per-object constraint, then the elaboration consists of the evaluation of any included expression that is not part of a per-object expression. "),(0,i.kt)("p",null,"Discussion: The evaluation of other expressions that appear in component_definitions and discrete_subtype_definitions is performed when the type definition is elaborated. The evaluation of expressions that appear as default_expressions is postponed until an object is created. Expressions in representation items that appear within a composite type definition are evaluated according to the rules of the particular representation item. "),(0,i.kt)("p",null,"NOTE 1   A component_declaration with several identifiers is equivalent to a sequence of single component_declarations, as explained in 3.3.1."),(0,i.kt)("p",null,"NOTE 2   The default_expression of a record component is only evaluated upon the creation of a default-initialized object of the record type (presuming the object has the component, if it is in a variant_part - see 3.3.1)."),(0,i.kt)("p",null,"NOTE 3   The subtype defined by a component_definition (see 3.6) has to be a definite subtype."),(0,i.kt)("p",null,"NOTE 4   If a record type does not have a variant_part, then the same components are present in all values of the type."),(0,i.kt)("p",null,"NOTE 5   A record type is limited if it has the reserved word limited in its definition, or if any of its components are limited (see 7.5)."),(0,i.kt)("p",null,"NOTE 6   The predefined operations of a record type include membership tests, qualification, and explicit conversion. If the record type is nonlimited, they also include assignment and the predefined equality operators."),(0,i.kt)("p",null,"NOTE 7   A component of a record can be named with a selected_component. A value of a record can be specified with a record_aggregate, unless the record type is limited."),(0,i.kt)("h4",{id:"examples-18"},"Examples"),(0,i.kt)("p",null,"Examples of record type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Date is\n   record\n      Day   : Integer range 1 .. 31;\n      Month : Month_Name;\n      Year  : Integer range 0 .. 4000;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Complex is\n   record\n      Re : Real := 0.0;\n      Im : Real := 0.0;\n   end record;\n\n")),(0,i.kt)("p",null,"Examples of record variables: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Tomorrow, Yesterday : Date;\nA, B, C : Complex;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-- both components of A, B, and C are implicitly initialized to zero \n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-15"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for component_declaration is modified to use component_definition (instead of component_subtype_definition). The effect of this change is to allow the reserved word aliased before the component_subtype_definition."),(0,i.kt)("p",null,"A short-hand is provided for defining a null record type (and a null record extension), as these will be more common for abstract root types (and derived types without additional components)."),(0,i.kt)("p",null,"The syntax rule for record_type_definition is modified to allow the reserved words tagged and limited. Tagging is new. Limitedness is now orthogonal to privateness. In Ada 83 the syntax implied that limited private was sort of more private than private. However, limitedness really has nothing to do with privateness; limitedness simply indicates the lack of assignment capabilities, and makes perfect sense for nonprivate types such as record types. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-21"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rules now allow representation_clauses to appear in a record_definition. This is not a language extension, because Legality Rules prevent all language-defined representation clauses from appearing there. However, an implementation-defined attribute_definition_clause could appear there. The reason for this change is to allow the rules for representation_clauses and representation pragmas to be as similar as possible. "),(0,i.kt)("h3",{id:"381--variant-parts-and-discrete-choices"},"3.8.1  Variant Parts and Discrete Choices"),(0,i.kt)("p",null,"A record type with a variant_part specifies alternative lists of components. Each variant defines the components for the value or values of the discriminant covered by its discrete_choice_list. "),(0,i.kt)("p",null,"Discussion: Discrete_choice_lists and discrete_choices are said to cover values as defined below; which discrete_choice_list covers a value determines which of various alternatives is chosen. These are used in variant_parts, array_aggregates, and case_statements. "),(0,i.kt)("h4",{id:"language-design-principles-1"},"Language Design Principles"),(0,i.kt)("p",null,'The definition of "cover" in this subclause and the rules about discrete choices are designed so that they are also appropriate for array aggregates and case statements.'),(0,i.kt)("p",null,"The rules of this subclause intentionally parallel those for case statements. "),(0,i.kt)("h4",{id:"syntax-17"},"Syntax"),(0,i.kt)("p",null,"variant_part ::=\ncase discriminant_direct_name is\nvariant\n{variant}\nend case;"),(0,i.kt)("p",null,"variant ::=\nwhen discrete_choice_list =",">","\ncomponent_list"),(0,i.kt)("p",null,"discrete_choice_list ::= discrete_choice {| discrete_choice}"),(0,i.kt)("p",null,"discrete_choice ::= expression | discrete_range | others"),(0,i.kt)("h4",{id:"name-resolution-rules-12"},"Name Resolution Rules"),(0,i.kt)("p",null,"The discriminant_direct_name shall resolve to denote a discriminant (called the discriminant of the variant_part) specified in the known_discriminant_part of the full_type_declaration that contains the variant_part. The expected type for each discrete_choice in a variant is the type of the discriminant of the variant_part. "),(0,i.kt)("p",null,"Ramification: A full_type_declaration with a variant_part has to have a (new) known_discriminant_part; the discriminant of the variant_part cannot be an inherited discriminant. "),(0,i.kt)("h4",{id:"legality-rules-14"},"Legality Rules"),(0,i.kt)("p",null,"The discriminant of the variant_part shall be of a discrete type. "),(0,i.kt)("p",null,"Ramification: It shall not be of an access type, named or anonymous."),(0,i.kt)("p",null,"The expressions and discrete_ranges given as discrete_choices in a variant_part shall be static. The discrete_choice others shall appear alone in a discrete_choice_list, and such a discrete_choice_list, if it appears, shall be the last one in the enclosing construct."),(0,i.kt)("p",null,"A discrete_choice is defined to cover a value in the following cases: "),(0,i.kt)("p",null,"A discrete_choice that is an expression covers a value if the value equals the value of the expression converted to the expected type."),(0,i.kt)("p",null,"A discrete_choice that is a discrete_range covers all values (possibly none) that belong to the range."),(0,i.kt)("p",null,"The discrete_choice others covers all values of its expected type that are not covered by previous discrete_choice_lists of the same construct. "),(0,i.kt)("p",null,"Ramification: For case_statements, this includes values outside the range of the static subtype (if any) to be covered by the choices. It even includes values outside the base range of the case expression's type, since values of numeric types (and undefined values of any scalar type?) can be outside their base range. "),(0,i.kt)("p",null,"A discrete_choice_list covers a value if one of its discrete_choices covers the value."),(0,i.kt)("p",null,"The possible values of the discriminant of a variant_part shall be covered as follows: "),(0,i.kt)("p",null,"If the discriminant is of a static constrained scalar subtype, then each non-others discrete_choice shall cover only values in that subtype, and each value of that subtype shall be covered by some discrete_choice ","[(either explicitly or by others)]",";"),(0,i.kt)("p",null,"If the type of the discriminant is a descendant of a generic formal scalar type then the variant_part shall have an others discrete_choice; "),(0,i.kt)("p",null,"Reason: The base range is not known statically in this case. "),(0,i.kt)("p",null,"Otherwise, each value of the base range of the type of the discriminant shall be covered ","[(either explicitly or by others)]",". "),(0,i.kt)("p",null,"Two distinct discrete_choices of a variant_part shall not cover the same value."),(0,i.kt)("h4",{id:"static-semantics-27"},"Static Semantics"),(0,i.kt)("p",null,"If the component_list of a variant is specified by null, the variant has no components."),(0,i.kt)("p",null,"The discriminant of a variant_part is said to govern the variant_part and its variants. In addition, the discriminant of a derived type governs a variant_part and its variants if it corresponds (see 3.7) to the discriminant of the variant_part."),(0,i.kt)("h4",{id:"dynamic-semantics-17"},"Dynamic Semantics"),(0,i.kt)("p",null,"A record value contains the values of the components of a particular variant only if the value of the discriminant governing the variant is covered by the discrete_choice_list of the variant. This rule applies in turn to any further variant that is, itself, included in the component_list of the given variant."),(0,i.kt)("p",null,"The elaboration of a variant_part consists of the elaboration of the component_list of each variant in the order in which they appear. "),(0,i.kt)("h4",{id:"examples-19"},"Examples"),(0,i.kt)("p",null,"Example of record type with a variant part: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Device is (Printer, Disk, Drum);\ntype State  is (Open, Closed);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Peripheral(Unit : Device := Disk) is\n   record\n      Status : State;\n      case Unit is\n         when Printer =&gt\n            Line_Count : Integer range 1 .. Page_Size;\n         when others =&gt\n            Cylinder   : Cylinder_Index;\n            Track      : Track_Number;\n      end case;\n   end record;\n\n")),(0,i.kt)("p",null,"Examples of record subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Drum_Unit is Peripheral(Drum);\nsubtype Disk_Unit is Peripheral(Disk);\n\n")),(0,i.kt)("p",null,"Examples of constrained record variables: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Writer   : Peripheral(Unit  =&gt Printer);\nArchive  : Disk_Unit;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-16"},"Extensions to Ada 83"),(0,i.kt)("p",null,"In Ada 83, the discriminant of a variant_part is not allowed to be of a generic formal type. This restriction is removed in Ada 95; an others discrete_choice is required in this case. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-22"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntactic category choice is removed. The syntax rules for variant, array_aggregate, and case_statement now use discrete_choice_list or discrete_choice instead. The syntax rule for record_aggregate now defines its own syntax for named associations."),(0,i.kt)("p",null,'We have added the term Discrete Choice to the title since this is where they are talked about. This is analogous to the name of the subclause "Index Constraints and Discrete Ranges" in the clause on Array Types.'),(0,i.kt)("p",null,"The rule requiring that the discriminant denote a discriminant of the type being defined seems to have been left implicit in RM83. "),(0,i.kt)("h2",{id:"39--tagged-types-and-type-extensions"},"3.9  Tagged Types and Type Extensions"),(0,i.kt)("p",null,"[ Tagged types and type extensions support object-oriented programming, based on inheritance with extension and run-time polymorphism via dispatching operations. ]"),(0,i.kt)("h4",{id:"language-design-principles-2"},"Language Design Principles"),(0,i.kt)("p",null,"The intended implementation model is for a tag to be represented as a pointer to a statically allocated and link-time initialized type descriptor. The type descriptor contains the address of the code for each primitive operation of the type. It probably also contains other information, such as might make membership tests convenient and efficient."),(0,i.kt)("p",null,"The primitive operations of a tagged type are known at its first freezing point; the type descriptor is laid out at that point. It contains linker symbols for each primitive operation; the linker fills in the actual addresses."),(0,i.kt)("p",null,"Other implementation models are possible."),(0,i.kt)("p",null,'The rules ensure that "dangling dispatching" is impossible; that is, when a dispatching call is made, there is always a body to execute. This is different from some other object-oriented languages, such as Smalltalk, where it is possible to get a run-time error from a missing method.'),(0,i.kt)("p",null,'Dispatching calls should be efficient, and should have a bounded worst-case execution time. This is important in a language intended for real-time applications. In the intended implementation model, a dispatching call involves calling indirect through the appropriate slot in the dispatch table. No complicated "method lookup" is involved.'),(0,i.kt)("p",null,"The programmer should have the choice at each call site of a dispatching operation whether to do a dispatching call or a statically determined call (i.e. whether the body executed should be determined at run time or at compile time)."),(0,i.kt)("p",null,"The same body should be executed for a call where the tag is statically determined to be T'Tag as for a dispatching call where the tag is found at run time to be T'Tag. This allows one to test a given tagged type with statically determined calls, with some confidence that run-time dispatching will produce the same behavior."),(0,i.kt)("p",null,"All views of a type should share the same type descriptor and the same tag."),(0,i.kt)("p",null,"The visibility rules determine what is legal at compile time; they have nothing to do with what bodies can be executed at run time. Thus, it is possible to dispatch to a subprogram whose declaration is not visible at the call site. In fact, this is one of the primary facts that gives object-oriented programming its power. The subprogram that ends up being dispatched to by a given call might even be designed long after the call site has been coded and compiled."),(0,i.kt)("p",null,"Given that Ada has overloading, determining whether a given subprogram overrides another is based both on the names and the type profiles of the operations."),(0,i.kt)("p",null,"When a type extension is declared, if there is any place within its immediate scope where a certain subprogram of the parent is visible, then a matching subprogram should override. If there is no such place, then a matching subprogram should be totally unrelated, and occupy a different slot in the type descriptor. This is important to preserve the privacy of private parts; when an operation declared in a private part is inherited, the inherited version can be overridden only in that private part, in the package body, and in any children of the package."),(0,i.kt)("p",null,"If an implementation shares code for instances of generic bodies, it should be allowed to share type descriptors of tagged types declared in the generic body, so long as they are not extensions of types declared in the specification of the generic unit. "),(0,i.kt)("h4",{id:"static-semantics-28"},"Static Semantics"),(0,i.kt)("p",null,"A record type or private type that has the reserved word tagged in its declaration is called a tagged type. ","[When deriving from a tagged type, additional components may be defined. As for any derived type, additional primitive subprograms may be defined, and inherited primitive subprograms may be overridden.]"," The derived type is called an extension of the ancestor type, or simply a type extension. Every type extension is also a tagged type, and is either a record extension or a private extension of some other tagged type. A record extension is defined by a derived_type_definition with a record_extension_part. A private extension, which is a partial view of a record extension, can be declared in the visible part of a package (see 7.3) or in a generic formal part (see 12.5.1)."),(0,i.kt)("p",null,"Glossary entry: The objects of a tagged type have a run-time type tag, which indicates the specific type with which the object was originally created. An operand of a class-wide tagged type can be used in a dispatching call; the tag indicates which subprogram body to invoke. Nondispatching calls, in which the subprogram body to invoke is determined at compile time, are also allowed. Tagged types may be extended with additional components."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[tagged type]",", Def=","[a type whose objects each have a run-time type tag, which indicates the specific type for which the object was originally created]",", Note1=","[Tagged types can be extended with additional components.]"," "),(0,i.kt)("p",null,"Ramification: If a tagged type is declared other than in a package_specification, it is impossible to add new primitive subprograms for that type, although it can inherit primitive subprograms, and those can be overridden. If the user incorrectly thinks a certain subprogram is primitive when it is not, and tries to call it with a dispatching call, an error message will be given at the call site."),(0,i.kt)("p",null,"Note that the accessibility rules imply that a tagged type declared in a library package_specification cannot be extended in a nested subprogram or task body. "),(0,i.kt)("p",null,"An object of a tagged type has an associated (run-time) tag that identifies the specific tagged type used to create the object originally. ","[ The tag of an operand of a class-wide tagged type T'Class controls which subprogram body is to be executed when a primitive subprogram of type T is applied to the operand (see 3.9.2); using a tag to control which body to execute is called dispatching.]"," "),(0,i.kt)("p",null,"The tag of a specific tagged type identifies the full_type_declaration of the type. If a declaration for a tagged type occurs within a generic_package_declaration, then the corresponding type declarations in distinct instances of the generic package are associated with distinct tags. For a tagged type that is local to a generic package body, the language does not specify whether repeated instantiations of the generic body result in distinct tags. "),(0,i.kt)("p",null,"Reason: This eases generic code sharing. "),(0,i.kt)("p",null,"Implementation Note: The language does not specify whether repeated elaborations of the same full_type_declaration correspond to distinct tags. In most cases, we expect that all elaborations will correspond to the same tag, since the tag will frequently be the address (or index) of a statically allocated type descriptor. However, with shared generics, the type descriptor might have to be allocated on a per-instance basis, which in some implementation models implies per-elaboration of the instantiation. "),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Tags  is\n    type Tag is private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    function Expanded_Name(T : Tag) return String;\n    function External_Tag(T : Tag) return String;\n    function Internal_Tag(External : String) return Tag;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    Tag_Error : exception;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Tags;\n\n")),(0,i.kt)("p",null,"Reason: Tag is a nonlimited, definite subtype, because it needs the equality operators, so that tag checking makes sense. Also, equality, assignment, and object declaration are all useful capabilities for this subtype."),(0,i.kt)("p",null,"For an object X and a type T, \"X'Tag = T'Tag\" is not needed, because a membership test can be used. However, comparing the tags of two objects cannot be done via membership. This is one reason to allow equality for type Tag. "),(0,i.kt)("p",null,"The function Expanded_Name returns the full expanded name of the first subtype of the specific type identified by the tag, in upper case, starting with a root library unit. The result is implementation defined if the type is declared within an unnamed block_statement. "),(0,i.kt)("p",null,"To be honest: This name, as well as each prefix of it, does not denote a renaming_declaration. "),(0,i.kt)("p",null,"Implementation defined: The result of Tags.Expanded_Name for types declared within an unnamed block_statement."),(0,i.kt)("p",null,"The function External_Tag returns a string to be used in an external representation for the given tag. The call External_Tag(S'Tag) is equivalent to the attribute_reference S'External_Tag (see 13.3). "),(0,i.kt)("p",null,"Reason: It might seem redundant to provide both the function External_Tag and the attribute External_Tag. The function is needed because the attribute can't be applied to values of type Tag. The attribute is needed so that it can be specifiable via an attribute_definition_clause. "),(0,i.kt)("p",null,"The function Internal_Tag returns the tag that corresponds to the given external tag, or raises Tag_Error if the given string is not the external tag for any specific type of the partition."),(0,i.kt)("p",null,"For every subtype S of a tagged type T (specific or class-wide), the following attributes are defined: "),(0,i.kt)("p",null,"S'ClassS'Class denotes a subtype of the class-wide type (called T'Class in this document) for the class rooted at T (or if S already denotes a class-wide subtype, then S'Class is the same as S)."),(0,i.kt)("p",null,"S'Class is unconstrained. However, if S is constrained, then the values of S'Class are only those that when converted to the type T belong to S. "),(0,i.kt)("p",null,"Ramification: This attribute is defined for both specific and class-wide subtypes. The definition is such that S'Class'Class is the same as S'Class."),(0,i.kt)("p",null,"Note that if S is constrained, S'Class is only partially constrained, since there might be additional discriminants added in descendants of T which are not constrained. "),(0,i.kt)("p",null,"Reason: The Class attribute is not defined for untagged subtypes (except for incomplete types and private types whose full view is tagged - see 3.10.1 and 7.3.1) so as to preclude implicit conversion in the absence of run-time type information. If it were defined for untagged subtypes, it would correspond to the concept of universal types provided for the predefined numeric classes. "),(0,i.kt)("p",null,"S'TagS'Tag denotes the tag of the type T (or if T is class-wide, the tag of the root type of the corresponding class). The value of this attribute is of type Tag. "),(0,i.kt)("p",null,"Reason: S'Class'Tag equals S'Tag, to avoid generic contract model problems when S'Class is the actual type associated with a generic formal derived type."),(0,i.kt)("p",null,"Given a prefix X that is of a class-wide tagged type ","[(after any implicit dereference)]",", the following attribute is defined: "),(0,i.kt)("p",null,"X'TagX'Tag denotes the tag of X. The value of this attribute is of type Tag. "),(0,i.kt)("p",null,"Reason: X'Tag is not defined if X is of a specific type. This is primarily to avoid confusion that might result about whether the Tag attribute should reflect the tag of the type of X, or the tag of X. No such confusion is possible if X is of a class-wide type. "),(0,i.kt)("h4",{id:"dynamic-semantics-18"},"Dynamic Semantics"),(0,i.kt)("p",null,"The tag associated with an object of a tagged type is determined as follows: "),(0,i.kt)("p",null,"The tag of a stand-alone object, a component, or an aggregate of a specific tagged type T identifies T. "),(0,i.kt)("p",null,"Discussion: The tag of a formal parameter of type T is not necessarily the tag of T, if, for example, the actual was a type conversion. "),(0,i.kt)("p",null,"The tag of an object created by an allocator for an access type with a specific designated tagged type T, identifies T. "),(0,i.kt)("p",null,"Discussion: The tag of an object designated by a value of such an access type might not be T, if, for example, the access value is the result of a type conversion."),(0,i.kt)("p",null,"The tag of an object of a class-wide tagged type is that of its initialization expression. "),(0,i.kt)("p",null,'Ramification: The tag of an object (even a class-wide one) cannot be changed after it is initialized, since a "class-wide" assignment_statement raises Constraint_Error if the tags don\'t match, and a "specific" assignment_statement does not affect the tag. '),(0,i.kt)("p",null,"The tag of the result returned by a function whose result type is a specific tagged type T identifies T. "),(0,i.kt)("p",null,'Implementation Note: This requires a runtime check for limited tagged types, since they are returned "by-reference". For a nonlimited type, a new anonymous object with the appropriate tag is created as part of the function return, and then assigned the value of the return expression. See 6.5, "Return Statements". '),(0,i.kt)("p",null,"The tag of the result returned by a function with a class-wide result type is that of the return expression. "),(0,i.kt)("p",null,"The tag is preserved by type conversion and by parameter passing. The tag of a value is the tag of the associated object (see 6.2)."),(0,i.kt)("h4",{id:"implementation-permissions-6"},"Implementation Permissions"),(0,i.kt)("p",null,"The implementation of the functions in Ada.Tags may raise Tag_Error if no specific type corresponding to the tag passed as a parameter exists in the partition at the time the function is called. "),(0,i.kt)("p",null,'Reason: In most implementations, repeated elaborations of the same type_declaration will all produce the same tag. In such an implementation, Tag_Error will be raised in cases where the internal or external tag was passed from a different partition. However, some implementations might create a new tag value at run time for each elaboration of a type_declaration. In that case, Tag_Error could also be raised if the created type no longer exists because the subprogram containing it has returned, for example. We don\'t require the latter behavior; hence the word "may" in this rule. '),(0,i.kt)("p",null,"Implementation Advice: "),(0,i.kt)("p",null,"NOTE 1   A type declared with the reserved word tagged should normally be declared in a package_specification, so that new primitive subprograms can be declared for it."),(0,i.kt)("p",null,"NOTE 2   Once an object has been created, its tag never changes."),(0,i.kt)("p",null,"NOTE 3   Class-wide types are defined to have unknown discriminants (see 3.7). This means that objects of a class-wide type have to be explicitly initialized (whether created by an object_declaration or an allocator), and that aggregates have to be explicitly qualified with a specific type when their expected type is class-wide."),(0,i.kt)("p",null,"NOTE 4   If S denotes an untagged private type whose full type is tagged, then S'Class is also allowed before the full type definition, but only in the private part of the package in which the type is declared (see 7.3.1). Similarly, the Class attribute is defined for incomplete types whose full type is tagged, but only within the library unit in which the incomplete type is declared (see 3.10.1). "),(0,i.kt)("h4",{id:"examples-20"},"Examples"),(0,i.kt)("p",null,"Examples of tagged record types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Point is tagged\n  record\n    X, Y : Real := 0.0;\n  end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Expression is tagged null record;\n  -- Components will be added by each extension\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-17"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Tagged types are a new concept. "),(0,i.kt)("h3",{id:"391--type-extensions"},"3.9.1  Type Extensions"),(0,i.kt)("p",null,"[ Every type extension is a tagged type, and is either a record extension or a private extension of some other tagged type.]"," "),(0,i.kt)("h4",{id:"language-design-principles-3"},"Language Design Principles"),(0,i.kt)("p",null,"We want to make sure that we can extend a generic formal tagged type, without knowing its discriminants."),(0,i.kt)("p",null,"We don't want to allow components in an extension aggregate to depend on discriminants inherited from the parent value, since such dependence requires staticness in aggregates, at least for variants. "),(0,i.kt)("h4",{id:"syntax-18"},"Syntax"),(0,i.kt)("p",null,"record_extension_part ::= with record_definition"),(0,i.kt)("h4",{id:"legality-rules-15"},"Legality Rules"),(0,i.kt)("p",null,"The parent type of a record extension shall not be a class-wide type. If the parent type is nonlimited, then each of the components of the record_extension_part shall be nonlimited. The accessibility level (see 3.10.2) of a record extension shall not be statically deeper than that of its parent type. In addition to the places where Legality Rules normally apply (see 12.3), these rules apply also in the private part of an instance of a generic unit. "),(0,i.kt)("p",null,"Reason: If the parent is a limited formal type, then the actual might be nonlimited."),(0,i.kt)("p",null,"A similar accessibility rule is not needed for private extensions, because in a package, the rule will apply to the full_type_declaration, and for a generic formal private extension, the actual is all that matters."),(0,i.kt)("p",null,"A type extension shall not be declared in a generic body if the parent type is declared outside that body."),(0,i.kt)("p",null,"Reason: This paragraph ensures that a dispatching call will never attempt to execute an inaccessible subprogram body."),(0,i.kt)("p",null,"The part about generic bodies is necessary in order to preserve the contract model."),(0,i.kt)("p",null,"Since a generic unit can be instantiated at a deeper accessibility level than the generic unit, it is necessary to prevent type extensions whose parent is declared outside the generic unit. The same is true if the parent is a formal of the generic unit . If the parent is declared in the generic_declaration (but is not a formal), we don't run afoul of the accessibility rules, because we know that the instance declaration and body will be at the same accessibility level. However, we still have a problem in that case, because it might have an unknown number of abstract subprograms, as in the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T is tagged null record;\n    function F return T; -- Inherited versions will be abstract.\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type TT is tagged private;\npackage Gp is\n    type NT is abstract new TT with null record;\n    procedure Q(X : in NT) is abstract;\nend Gp;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Gp is\n    type NT2 is new NT with null record; -- Illegal!\n    procedure Q(X : in NT2) is begin null; end Q;\n    -- Is this legal or not? Can't decide because\n    -- we don't know whether TT had any functions that go abstract\n    -- on extension.\nend Gp;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package I is new Gp(TT =&gt P.T);\n\n")),(0,i.kt)("p",null,"I.NT is an abstract type with two abstract subprograms: F (inherited as abstract) and Q (explicitly declared as abstract). But the generic body doesn't know about F, so we don't know that it needs to be overridden to make a nonabstract extension of NT. Furthermore, a formal tagged limited private type can be extended with limited components, but the actual might not be limited, which would allow assignment of limited types, which is bad. Hence, we have to disallow this case as well."),(0,i.kt)("p",null,"If TT were declared as abstract, then we could have the same problem with abstract procedures."),(0,i.kt)("p",null,"We considered disallowing all tagged types in a generic body, for simplicity. We decided not to go that far, in order to avoid unnecessary restrictions."),(0,i.kt)("p",null,'We also considered trying make the accessibility level part of the contract; i.e. invent some way of saying (in the generic_declaration) "all instances of this generic unit will have the same accessibility level as the generic_declaration". Unfortunately, that doesn\'t solve the part of the problem having to do with abstract types.'),(0,i.kt)("p",null,"Children of generic units obviate the need for extension in the body somewhat. "),(0,i.kt)("h4",{id:"dynamic-semantics-19"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a record_extension_part consists of the elaboration of the record_definition. "),(0,i.kt)("p",null,'NOTE 1   The term "type extension" refers to a type as a whole. The term "extension part" refers to the piece of text that defines the additional components (if any) the type extension has relative to its specified ancestor type. '),(0,i.kt)("p",null,'Discussion: We considered other terminology, such as "extended type". However, the terms "private extended type" and "record extended type" did not convey the proper meaning. Hence, we have chosen to uniformly use the term "extension" as the type resulting from extending a type, with "private extension" being one produced by privately extending the type, and "record extension" being one produced by extending the type with an additional record-like set of components. Note also that the term "type extension" refers to the result of extending a type in the language Oberon as well (though there the term "extended type" is also used, interchangeably, perhaps because Oberon doesn\'t have the concept of a "private extension"). '),(0,i.kt)("p",null,"NOTE 2   The accessibility rules imply that a tagged type declared in a library package_specification can be extended only at library level or as a generic formal. When the extension is declared immediately within a package_body, primitive subprograms are inherited and are overridable, but new primitive subprograms cannot be added."),(0,i.kt)("p",null,"NOTE 3   A name that denotes a component (including a discriminant) of the parent type is not allowed within the record_extension_part. Similarly, a name that denotes a component defined within the record_extension_part is not allowed within the record_extension_part. It is permissible to use a name that denotes a discriminant of the record extension, providing there is a new known_discriminant_part in the enclosing type declaration. (The full rule is given in 3.8.) "),(0,i.kt)("p",null,"Reason: The restriction against depending on discriminants of the parent is to simplify the definition of extension aggregates. The restriction against using parent components in other ways is methodological; it presumably simplifies implementation as well. "),(0,i.kt)("p",null,"NOTE 4   Each visible component of a record extension has to have a unique name, whether the component is (visibly) inherited from the parent type or declared in the record_extension_part (see 8.3). "),(0,i.kt)("h4",{id:"examples-21"},"Examples"),(0,i.kt)("p",null,"Examples of record extensions (of types defined above in 3.9): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Painted_Point is new Point with\n  record\n    Paint : Color := White;\n  end record;\n    -- Components X and Y are inherited\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Origin : constant Painted_Point := (X | Y =&gt 0.0, Paint =&gt Black);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Literal is new Expression with\n  record                 -- a leaf in an Expression tree\n    Value : Real;\n  end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Expr_Ptr is access all Expression'Class;\n                               -- see 3.10\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Binary_Operation is new Expression with\n  record                 -- an internal node in an Expression tree\n    Left, Right : Expr_Ptr;\n  end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Addition is new Binary_Operation with null record;\ntype Subtraction is new Binary_Operation with null record;\n  -- No additional components needed for these extensions\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Tree : Expr_Ptr :=         -- A tree representation of \"5.0 + (13.07.0)\"\n   new Addition'(\n      Left  =&gt new Literal'(Value =&gt 5.0),\n      Right =&gt new Subtraction'(\n         Left  =&gt new Literal'(Value =&gt 13.0),\n         Right =&gt new Literal'(Value =&gt 7.0)));\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-18"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Type extension is a new concept. "),(0,i.kt)("h3",{id:"392--dispatching-operations-of-tagged-types"},"3.9.2  Dispatching Operations of Tagged Types"),(0,i.kt)("p",null,"The primitive subprograms of a tagged type are called dispatching operations. ","[A dispatching operation can be called using a statically determined controlling tag, in which case the body to be executed is determined at compile time. Alternatively, the controlling tag can be dynamically determined, in which case the call dispatches to a body that is determined at run time;]"," such a call is termed a dispatching call. ","[As explained below, the properties of the operands and the context of a particular call on a dispatching operation determine how the controlling tag is determined, and hence whether or not the call is a dispatching call. Run-time polymorphism is achieved when a dispatching operation is called by a dispatching call.]"," "),(0,i.kt)("h4",{id:"language-design-principles-4"},"Language Design Principles"),(0,i.kt)("p",null,"The controlling tag determination rules are analogous to the overload resolution rules, except they deal with run-time type identification (tags) rather than compile-time type resolution. As with overload resolution, controlling tag determination may depend on operands or result context. "),(0,i.kt)("h4",{id:"static-semantics-29"},"Static Semantics"),(0,i.kt)("p",null,"A call on a dispatching operation is a call whose name or prefix denotes the declaration of a primitive subprogram of a tagged type, that is, a dispatching operation. A controlling operand in a call on a dispatching operation of a tagged type T is one whose corresponding formal parameter is of type T or is of an anonymous access type with designated type T; the corresponding formal parameter is called a controlling formal parameter. If the controlling formal parameter is an access parameter, the controlling operand is the object designated by the actual parameter, rather than the actual parameter itself. If the call is to a (primitive) function with result type T, then the call has a controlling result - the context of the call can control the dispatching. "),(0,i.kt)("p",null,"Ramification: This definition implies that a call through the dereference of an access-to-subprogram value is never considered a call on a dispatching operation. Note also that if the prefix denotes a renaming_declaration, the place where the renaming occurs determines whether it is primitive; the thing being renamed is irrelevant. "),(0,i.kt)("p",null,"A name or expression of a tagged type is either statically tagged, dynamically tagged, or tag indeterminate, according to whether, when used as a controlling operand, the tag that controls dispatching is determined statically by the operand's (specific) type, dynamically by its tag at run time, or from context. A qualified_expression or parenthesized expression is statically, dynamically, or indeterminately tagged according to its operand. For other kinds of names and expressions, this is determined as follows: "),(0,i.kt)("p",null,"The name or expression is statically tagged if it is of a specific tagged type and, if it is a call with a controlling result, it has at least one statically tagged controlling operand; "),(0,i.kt)("p",null,"Discussion: It is illegal to have both statically tagged and dynamically tagged controlling operands in the same call -- see below. "),(0,i.kt)("p",null,"The name or expression is dynamically tagged if it is of a class-wide type, or it is a call with a controlling result and at least one dynamically tagged controlling operand;"),(0,i.kt)("p",null,"The name or expression is tag indeterminate if it is a call with a controlling result, all of whose controlling operands (if any) are tag indeterminate. "),(0,i.kt)("p",null,"[A type_conversion is statically or dynamically tagged according to whether the type determined by the subtype_mark is specific or class-wide, respectively.]"," For a controlling operand that is designated by an actual parameter, the controlling operand is statically or dynamically tagged according to whether the designated type of the actual parameter is specific or class-wide, respectively. "),(0,i.kt)("p",null,"Ramification: A type_conversion is never tag indeterminate, even if its operand is. A designated object is never tag indeterminate."),(0,i.kt)("h4",{id:"legality-rules-16"},"Legality Rules"),(0,i.kt)("p",null,"A call on a dispatching operation shall not have both dynamically tagged and statically tagged controlling operands. "),(0,i.kt)("p",null,"Reason: This restriction is intended to minimize confusion between whether the dynamically tagged operands are implicitly converted to, or tag checked against the specific type of the statically tagged operand(s). "),(0,i.kt)("p",null,"If the expected type for an expression or name is some specific tagged type, then the expression or name shall not be dynamically tagged unless it is a controlling operand in a call on a dispatching operation. Similarly, if the expected type for an expression is an anonymous access-to-specific tagged type, then the expression shall not be of an access-to-class-wide type unless it designates a controlling operand in a call on a dispatching operation. "),(0,i.kt)("p",null,'Reason: This prevents implicit "truncation" of a dynamically-tagged value to the specific type of the target object/formal. An explicit conversion is required to request this truncation. '),(0,i.kt)("p",null,"Ramification: This rule applies to all expressions or names with a specific expected type, not just those that are actual parameters to a dispatching call. This rule does not apply to a membership test whose expression is class-wide, since any type that covers the tested type is explicitly allowed. See 4.5.2. "),(0,i.kt)("p",null,"In the declaration of a dispatching operation of a tagged type, everywhere a subtype of the tagged type appears as a subtype of the profile (see 6.1), it shall statically match the first subtype of the tagged type. If the dispatching operation overrides an inherited subprogram, it shall be subtype conformant with the inherited subprogram. A dispatching operation shall not be of convention Intrinsic. If a dispatching operation overrides the predefined equals operator, then it shall be of convention Ada ","[(either explicitly or by default - see 6.3.1)]",". "),(0,i.kt)("p",null,"Reason: These rules ensure that constraint checks can be performed by the caller in a dispatching call, and parameter passing conventions match up properly. A special rule on aggregates prevents values of a tagged type from being created that are outside of its first subtype. "),(0,i.kt)("p",null,"The default_expression for a controlling formal parameter of a dispatching operation shall be tag indeterminate. A controlling formal parameter that is an access parameter shall not have a default_expression. "),(0,i.kt)("p",null,'Reason: The first part ensures that the default_expression always produces the "correct" tag when called with or without dispatching, or when inherited by a descendant. If it were statically tagged, the default would be useless for a dispatching call; if it were dynamically tagged, the default would be useless for a nondispatching call.'),(0,i.kt)("p",null,"The second part is consistent with the first part, since designated objects are never tag-indeterminate. "),(0,i.kt)("p",null,"A given subprogram shall not be a dispatching operation of two or more distinct tagged types. "),(0,i.kt)("p",null,"Reason: This restriction minimizes confusion since multiple dispatching is not provided. The normal solution is to replace all but one of the tagged types with their class-wide types. "),(0,i.kt)("p",null,"The explicit declaration of a primitive subprogram of a tagged type shall occur before the type is frozen (see 13.14). ","[For example, new dispatching operations cannot be added after objects or values of the type exist, nor after deriving a record extension from it, nor after a body.]"),(0,i.kt)("p",null,"Reason: This rule is needed because (1) we don't want people dispatching to things that haven't been declared yet, and (2) we want to allow tagged type descriptors to be static (allocated statically, and initialized to link-time-known symbols). Suppose T2 inherits primitive P from T1, and then overrides P. Suppose P is called before the declaration of the overriding P. What should it dispatch to? If the answer is the new P, we've violated the first principle above. If the answer is the old P, we've violated the second principle. (A call to the new one necessarily raises Program_Error, but that's beside the point.)"),(0,i.kt)("p",null,"Note that a call upon a dispatching operation of type T will freeze T."),(0,i.kt)("p",null,"We considered applying this rule to all derived types, for uniformity. However, that would be upward incompatible, so we rejected the idea. As in Ada 83, for an untagged type, the above call upon P will call the old P (which is arguably confusing). "),(0,i.kt)("p",null,"Implementation Note: Because of this rule, the type descriptor can be created (presumably containing linker symbols pointing at the not-yet-compiled bodies) at the first freezing point of the type. It also prevents, for a tagged type declared in a package_specification, overriding in the body or by a child subprogram. "),(0,i.kt)("p",null,"Ramification: A consequence is that for a derived_type_declaration in a declarative_part, only the first primitive subprogram can be declared by a subprogram_body. "),(0,i.kt)("h4",{id:"dynamic-semantics-20"},"Dynamic Semantics"),(0,i.kt)("p",null,"For the execution of a call on a dispatching operation of a type T, the controlling tag value determines which subprogram body is executed. The controlling tag value is defined as follows: "),(0,i.kt)("p",null,"If one or more controlling operands are statically tagged, then the controlling tag value is statically determined to be the tag of T."),(0,i.kt)("p",null,"If one or more controlling operands are dynamically tagged, then the controlling tag value is not statically determined, but is rather determined by the tags of the controlling operands. If there is more than one dynamically tagged controlling operand, a check is made that they all have the same tag. If this check fails, Constraint_Error is raised unless the call is a function_call whose name denotes the declaration of an equality operator (predefined or user defined) that returns Boolean, in which case the result of the call is defined to indicate inequality, and no subprogram_body is executed. This check is performed prior to evaluating any tag-indeterminate controlling operands. "),(0,i.kt)("p",null,'Reason: Tag mismatch is considered an error (except for "=" and "/=") since the corresponding primitive subprograms in each specific type expect all controlling operands to be of the same type. For tag mismatch with an equality operator, rather than raising an exception, "=" returns False and "/=" returns True. No equality operator is actually invoked, since there is no common tag value to control the dispatch. Equality is a special case to be consistent with the existing Ada 83 principle that equality comparisons, even between objects with different constraints, never raise Constraint_Error. '),(0,i.kt)("p",null,"If all of the controlling operands are tag-indeterminate, then: "),(0,i.kt)("p",null,"If the call has a controlling result and is itself a (possibly parenthesized or qualified) controlling operand of an enclosing call on a dispatching operation of type T, then its controlling tag value is determined by the controlling tag value of this enclosing call;"),(0,i.kt)("p",null,"Otherwise, the controlling tag value is statically determined to be the tag of type T. "),(0,i.kt)("p",null,"Ramification: This includes the cases of a tag-indeterminate procedure call, and a tag-indeterminate function_call that is used to initialize a class-wide formal parameter or class-wide object. "),(0,i.kt)("p",null,"For the execution of a call on a dispatching operation, the body executed is the one for the corresponding primitive subprogram of the specific type identified by the controlling tag value. The body for an explicitly declared dispatching operation is the corresponding explicit body for the subprogram. The body for an implicitly declared dispatching operation that is overridden is the body for the overriding subprogram, ","[even if the overriding occurs in a private part.]"," The body for an inherited dispatching operation that is not overridden is the body of the corresponding subprogram of the parent or ancestor type."),(0,i.kt)("p",null,'To be honest: In the unusual case in which a dispatching subprogram is explicitly declared (overridden) by a body (with no preceding subprogram_declaration), the body for that dispatching subprogram is that body; that is, the "corresponding explicit body" in the above rule is the body itself. '),(0,i.kt)("p",null,"Reason: The wording of the above rule is intended to ensure that the same body is executed for a given tag, whether that tag is determined statically or dynamically. For a type declared in a package, it doesn't matter whether a given subprogram is overridden in the visible part or the private part, and it doesn't matter whether the call is inside or outside the package. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P1 is\n    type T1 is tagged null record;\n    procedure Op_A(Arg : in T1);\n    procedure Op_B(Arg : in T1);\nend P1;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with P1; use P1;\npackage P2 is\n    type T2 is new T1 with null record;\n    procedure Op_A(Param : in T2);\nprivate\n    procedure Op_B(Param : in T2);\nend P2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with P1; with P2;\nprocedure Main is\n    X : T2;\n    Y : T1'Class := X;\nbegin\n    P2.Op_A(Param =&gt X); -- Nondispatching call.\n    P1.Op_A(Arg =&gt Y); -- Dispatching call.\n    P2.Op_B(Arg =&gt X); -- Nondispatching call.\n    P1.Op_B(Arg =&gt Y); -- Dispatching call.\nend Main;\n\n")),(0,i.kt)("p",null,"The two calls to Op_A both execute the body of Op_A that has to occur in the body of package P2. Similarly, the two calls to Op_B both execute the body of Op_B that has to occur in the body of package P2, even though Op_B is overridden in the private part of P2. Note, however, that the formal parameter names are different for P2.Op_A versus P2.Op_B. The overriding declaration for P2.Op_B is not visible in Main, so the name in the call actually denotes the implicit declaration of Op_B inherited from T1."),(0,i.kt)("p",null,"If a call occurs in the program text before an overriding, which can happen only if the call is part of a default expression, the overriding will still take effect for that call."),(0,i.kt)("p",null,"Implementation Note: Even when a tag is not statically determined, a compiler might still be able to figure it out and thereby avoid the overhead of run-time dispatching. "),(0,i.kt)("p",null,"NOTE 1   The body to be executed for a call on a dispatching operation is determined by the tag; it does not matter whether that tag is determined statically or dynamically, and it does not matter whether the subprogram's declaration is visible at the place of the call."),(0,i.kt)("p",null,"NOTE 2   This subclause covers calls on primitive subprograms of a tagged type. Rules for tagged type membership tests are described in 4.5.2. Controlling tag determination for an assignment_statement is described in 5.2."),(0,i.kt)("p",null,"NOTE 3   A dispatching call can dispatch to a body whose declaration is not visible at the place of the call."),(0,i.kt)("p",null,"NOTE 4   A call through an access-to-subprogram value is never a dispatching call, even if the access value designates a dispatching operation. Similarly a call whose prefix denotes a subprogram_renaming_declaration cannot be a dispatching call unless the renaming itself is the declaration of a primitive subprogram. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-19"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The concept of dispatching operations is new. "),(0,i.kt)("h3",{id:"393--abstract-types-and-subprograms"},"3.9.3  Abstract Types and Subprograms"),(0,i.kt)("p",null,"[ An abstract type is a tagged type intended for use as a parent type for type extensions, but which is not allowed to have objects of its own. An abstract subprogram is a subprogram that has no body, but is intended to be overridden at some point when inherited. Because objects of an abstract type cannot be created, a dispatching call to an abstract subprogram always dispatches to some overriding body.]"," Version=","[5]",",Kind=(Added),Group=","[T]",",Term=","[abstract type]",", Def=","[a tagged type intended for use as an ancestor of other types, but which is not allowed to have objects of its own]"," "),(0,i.kt)("h4",{id:"language-design-principles-5"},"Language Design Principles"),(0,i.kt)("p",null,"An abstract subprogram has no body, so the rules in this clause are designed to ensure (at compile time) that the body will never be invoked. We do so primarily by disallowing the creation of values of the abstract type. Therefore, since type conversion and parameter passing don't change the tag, we know we will never get a class-wide value with a tag identifying an abstract type. This means that we only have to disallow nondispatching calls on abstract subprograms (dispatching calls will never reach them). "),(0,i.kt)("h4",{id:"legality-rules-17"},"Legality Rules"),(0,i.kt)("p",null,"An abstract type is a specific type that has the reserved word abstract in its declaration.Only a tagged type is allowed to be declared abstract. "),(0,i.kt)("p",null,"Ramification: Untagged types are never abstract, even though they can have primitive abstract subprograms. Such subprograms cannot be called, unless they also happen to be dispatching operations of some tagged type, and then only via a dispatching call."),(0,i.kt)("p",null,"Class-wide types are never abstract. If T is abstract, then it is illegal to declare a stand-alone object of type T, but it is OK to declare a stand-alone object of type T'Class; the latter will get a tag from its initial value, and this tag will necessarily be different from T'Tag. "),(0,i.kt)("p",null,"A subprogram declared by an abstract_subprogram_declaration (see 6.1) is an abstract subprogram. If it is a primitive subprogram of a tagged type, then the tagged type shall be abstract. "),(0,i.kt)("p",null,"Ramification: Note that for a private type, this applies to both views. The following is illegal: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T is abstract tagged private;\n    function Foo (X : T) return Boolean is abstract; -- Illegal!\nprivate\n    type T is tagged null record; -- Illegal!\n    X : T;\n    Y : Boolean := Foo (T'Class (X));\nend P;\n\n")),(0,i.kt)("p",null,'The full view of T is not abstract, but has an abstract operation Foo, which is illegal. The two lines marked "-- Illegal!" are illegal when taken together. '),(0,i.kt)("p",null,"Reason: We considered disallowing untagged types from having abstract primitive subprograms. However, we rejected that plan, because it introduced some silly anomalies, and because such subprograms are harmless (if not terribly useful). For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n   type Field_Size is range 0..100;\n   type T is abstract tagged null record;\n   procedure Print(X : in T; F : in Field_Size := 0) is abstract;\n  . . .\npackage Q is\n   type My_Field_Size is new Field_Size;\n   -- implicit declaration of Print(X : T; F : My_Field_Size := 0) is abstract;\nend Q;\n\n")),(0,i.kt)("p",null,"It seemed silly to make the derivative of My_Field_Size illegal, just because there was an implicitly declared abstract subprogram that was not primitive on some tagged type. Other rules could be formulated to solve this problem, but the current ones seem like the simplest."),(0,i.kt)("p",null,"For a derived type, if the parent or ancestor type has an abstract primitive subprogram, or a primitive function with a controlling result, then: "),(0,i.kt)("p",null,"If the derived type is abstract or untagged, the inherited subprogram is abstract. "),(0,i.kt)("p",null,"Ramification: Note that it is possible to override a concrete subprogram with an abstract one. "),(0,i.kt)("p",null,"Otherwise, the subprogram shall be overridden with a nonabstract subprogram","[; for a type declared in the visible part of a package, the overriding may be either in the visible or the private part]",". However, if the type is a generic formal type, the subprogram need not be overridden for the formal type itself; ","[a nonabstract version will necessarily be provided by the actual type.]"," "),(0,i.kt)("p",null,"Reason: A function that returns the parent type becomes abstract for an abstract type extension (if not overridden) because conversion from a parent type to a type extension is not defined, and function return semantics is defined in terms of conversion. (Note that parameters of mode in out or out do not have this problem, because the tag of the actual is not changed.)"),(0,i.kt)("p",null,"Note that the overriding required above can be in the private part, which allows the following: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Pack1 is\n    type Ancestor is abstract ...;\n    procedure Do_Something(X : in Ancestor) is abstract;\nend Pack1;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Pack1; use Pack1;\npackage Pack2 is\n    type T1 is new Ancestor with record ...;\n        -- A concrete type.\n    procedure Do_Something(X : in T1); -- Have to override.\nend Pack2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Pack1; use Pack1;\nwith Pack2; use Pack2;\npackage Pack3 is\n    type T2 is new Ancestor with private;\n        -- A concrete type.\nprivate\n    type T2 is new T1 with -- Parent different from ancestor.\n      record ... end record;\n    -- Here, we inherit Pack2.Do_Something.\nend Pack3;\n    \n\n")),(0,i.kt)("p",null,"T2 inherits an abstract Do_Something, but T is not abstract, so Do_Something has to be overridden. However, it is OK to override it in the private part. In this case, we override it by inheriting a concrete version from a different type. Nondispatching calls to Pack3.Do_Something are allowed both inside and outside package Pack3."),(0,i.kt)("p",null,"A call on an abstract subprogram shall be a dispatching call; nondispatching calls to an abstract subprogram are not allowed. "),(0,i.kt)("p",null,"Ramification: If an abstract subprogram is not a dispatching operation of some tagged type, then it cannot be called at all. "),(0,i.kt)("p",null,"The type of an aggregate, or of an object created by an object_declaration or an allocator, or a generic formal object of mode in, shall not be abstract. The type of the target of an assignment operation (see 5.2) shall not be abstract. The type of a component shall not be abstract. If the result type of a function is abstract, then the function shall be abstract. "),(0,i.kt)("p",null,"Reason: This ensures that values of an abstract type cannot be created, which ensures that a dispatching call to an abstract subprogram will not try to execute the nonexistent body."),(0,i.kt)("p",null,"Generic formal objects of mode in are like constants; therefore they should be forbidden for abstract types. Generic formal objects of mode in out are like renamings; therefore, abstract types are OK for them, though probably not terribly useful."),(0,i.kt)("p",null,"If a partial view is not abstract, the corresponding full view shall not be abstract. If a generic formal type is abstract, then for each primitive subprogram of the formal that is not abstract, the corresponding primitive subprogram of the actual shall not be abstract. "),(0,i.kt)("p",null,'Discussion: By contrast, we allow the actual type to be nonabstract even if the formal type is declared abstract. Hence, the most general formal tagged type possible is "type T(',"<",">",') is abstract tagged limited private;".'),(0,i.kt)("p",null,"For an abstract private extension declared in the visible part of a package, it is only possible for the full type to be nonabstract if the private extension has no abstract dispatching operations. "),(0,i.kt)("p",null,"For an abstract type declared in a visible part, an abstract primitive subprogram shall not be declared in the private part, unless it is overriding an abstract subprogram implicitly declared in the visible part. For a tagged type declared in a visible part, a primitive function with a controlling result shall not be declared in the private part, unless it is overriding a function implicitly declared in the visible part. "),(0,i.kt)("p",null,'Reason: The "visible part" could be that of a package or a generic package. This rule is needed because a nonabstract type extension declared outside the package would not know about any abstract primitive subprograms or primitive functions with controlling results declared in the private part, and wouldn\'t know that they need to be overridden with nonabstract subprograms. The rule applies to a tagged record type or record extension declared in a visible part, just as to a tagged private type or private extension. The rule applies to explicitly and implicitly declared abstract subprograms: '),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Pack is\n    type T is abstract new T1 with private;\nprivate\n    type T is abstract new T2 with record ... end record;\n    ...\nend Pack;\n\n")),(0,i.kt)("p",null,"The above example would be illegal if T1 has a nonabstract primitive procedure P, but T2 overrides P with an abstract one; the private part should override P with a nonabstract version. On the other hand, if the P were abstract for both T1 and T2, the example would be legal as is. "),(0,i.kt)("p",null,"A generic actual subprogram shall not be an abstract subprogram . The prefix of an attribute_reference for the Access, Unchecked_Access, or Address attributes shall not denote an abstract subprogram. "),(0,i.kt)("p",null,"Ramification: An abstract_subprogram_declaration is not syntactically a subprogram_declaration. Nonetheless, an abstract subprogram is a subprogram, and an abstract_subprogram_declaration is a declaration of a subprogram."),(0,i.kt)("p",null,"The part about generic actual subprograms includes those given by default. "),(0,i.kt)("p",null,"NOTE 1   Abstractness is not inherited; to declare an abstract type, the reserved word abstract has to be used in the declaration of the type extension. "),(0,i.kt)("p",null,"Ramification: A derived type can be abstract even if its parent is not. Similarly, an inherited concrete subprogram can be overridden with an abstract subprogram. "),(0,i.kt)("p",null,"NOTE 2   A class-wide type is never abstract. Even if a class is rooted at an abstract type, the class-wide type for the class is not abstract, and an object of the class-wide type can be created; the tag of such an object will identify some nonabstract type in the class. "),(0,i.kt)("h4",{id:"examples-22"},"Examples"),(0,i.kt)("p",null,"Example of an abstract type representing a set of natural numbers: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Sets is\n    subtype Element_Type is Natural;\n    type Set is abstract tagged null record;\n    function Empty return Set is abstract;\n    function Union(Left, Right : Set) return Set is abstract;\n    function Intersection(Left, Right : Set) return Set is abstract;\n    function Unit_Set(Element : Element_Type) return Set is abstract;\n    procedure Take(Element : out Element_Type;\n                   From : in out Set) is abstract;\nend Sets;\n\n")),(0,i.kt)("p",null,"NOTE 3   Notes on the example: Given the above abstract type, one could then derive various (nonabstract) extensions of the type, representing alternative implementations of a set. One might use a bit vector, but impose an upper bound on the largest element representable, while another might use a hash table, trading off space for flexibility. "),(0,i.kt)("p",null,"Discussion: One way to export a type from a package with some components visible and some components private is as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type Public_Part is abstract tagged\n        record\n            ...\n        end record;\n    type T is new Public_Part with private;\n    ...\nprivate\n    type T is new Public_Part with\n        record\n            ...\n        end record;\nend P;\n\n")),(0,i.kt)("p",null,"The fact that Public_Part is abstract tells clients they have to create objects of type T instead of Public_Part. Note that the public part has to come first; it would be illegal to declare a private type Private_Part, and then a record extension T of it, unless T were in the private part after the full declaration of Private_Part, but then clients of the package would not have visibility to T. "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[interface type]",", Def=","[an abstract tagged type that has no components or concrete operations except possibly null procedures]",", Note1=","[Interface types are used for composing other interfaces and tagged types and thereby provide multiple inheritance. Only an interface type can be used as a progenitor of another type.]"," "),(0,i.kt)("h4",{id:"syntax-19"},"Syntax"),(0,i.kt)("p",null," ::= "),(0,i.kt)("h4",{id:"static-semantics-30"},"Static Semantics"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[synchronized entity]",", Def=","[an entity that can be safely operated on by multiple tasks concurrently]",", Note1=","[A synchronized interface can be an ancestor of a task or a protected type. Such a task or protected type is called a synchronized tagged type.]"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[progenitor of a derived type]",", Def=","[one of the types given in the definition of the derived type other than the first]",", Note1=","[A progenitor is always an interface type. Interfaces, tasks, and protected types can also have progenitors.]"," "),(0,i.kt)("h2",{id:"310--access-types"},"3.10  Access Types"),(0,i.kt)("p",null,"A value of an access type (an access value) provides indirect access to the object or subprogram it designates. Depending on its type, an access value can designate either subprograms, objects created by allocators (see 4.8), or more generally aliased objects of an appropriate type. "),(0,i.kt)("p",null,'Discussion: A name denotes an entity; an access value designates an entity. The "dereference" of an access value X, written "X.all", is a name that denotes the entity designated by X. '),(0,i.kt)("h4",{id:"language-design-principles-6"},"Language Design Principles"),(0,i.kt)("p",null,"Access values should always be well defined (barring uses of certain unchecked features of Section 13). In particular, uninitialized access variables should be prevented by compile-time rules. "),(0,i.kt)("h4",{id:"syntax-20"},"Syntax"),(0,i.kt)("p",null,"access_type_definition ::=\naccess_to_object_definition\n| access_to_subprogram_definition"),(0,i.kt)("p",null,"access_to_object_definition ::=\naccess ","[general_access_modifier]"," subtype_indication"),(0,i.kt)("p",null,"general_access_modifier ::= all | constant"),(0,i.kt)("p",null,"access_to_subprogram_definition ::=\naccess ","[protected]"," procedure parameter_profile\n| access ","[protected]"," function  parameter_and_result_profile"),(0,i.kt)("p",null,"access_definition ::= access subtype_mark"),(0,i.kt)("h4",{id:"static-semantics-31"},"Static Semantics"),(0,i.kt)("p",null,"There are two kinds of access types, access-to-object types, whose values designate objects, and access-to-subprogram types, whose values designate subprograms. Associated with an access-to-object type is a storage pool; several access types may share the same storage pool. A storage pool is an area of storage used to hold dynamically allocated objects (called pool elements) created by allocators",'[; storage pools are described further in 13.11, "Storage Management"]',"."),(0,i.kt)("p",null,"Access-to-object types are further subdivided into pool-specific access types, whose values can designate only the elements of their associated storage pool, and general access types, whose values can designate the elements of any storage pool, as well as aliased objects created by declarations rather than allocators, and aliased subcomponents of other objects. "),(0,i.kt)("p",null,"Implementation Note: The value of an access type will typically be a machine address. However, a value of a pool-specific access type can be represented as an offset (or index) relative to its storage pool, since it can point only to the elements of that pool. "),(0,i.kt)("p",null,"A view of an object is defined to be aliased if it is defined by an object_declaration or component_definition with the reserved word aliased, or by a renaming of an aliased view. In addition, the dereference of an access-to-object value denotes an aliased view, as does a view conversion (see 4.6) of an aliased view. Finally, the current instance of a limited type, and a formal parameter or generic formal object of a tagged type are defined to be aliased. ","[Aliased views are the ones that can be designated by an access value.]"," If the view defined by an object_declaration is aliased, and the type of the object has discriminants, then the object is constrained; if its nominal subtype is unconstrained, then the object is constrained by its initial value. ","[Similarly, if the object created by an allocator has discriminants, the object is constrained, either by the designated subtype, or by its initial value.]"," "),(0,i.kt)("p",null,"Glossary entry: An aliased view of an object is one that can be designated by an access value. Objects allocated by allocators are aliased. Objects can also be explicitly declared as aliased with the reserved word aliased. The Access attribute can be used to create an access value designating an aliased object."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[aliased view]",", Def=","[a view of an object that can be designated by an access value]",", Note1=","[Objects allocated by allocators are aliased. Objects can also be explicitly declared as aliased with the reserved word aliased. The Access attribute can be used to create an access value designating an aliased object.]"," "),(0,i.kt)("p",null,"Ramification: The current instance of a nonlimited type is not aliased."),(0,i.kt)("p",null,"The object created by an allocator is aliased, but not its subcomponents, except of course for those that themselves have aliased in their component_definition."),(0,i.kt)("p",null,"The renaming of an aliased object is aliased."),(0,i.kt)("p",null,"Slices are never aliased. See 4.1.2 for more discussion. "),(0,i.kt)("p",null,"Reason: The current instance of a limited type is defined to be aliased so that an access discriminant of a component can be initialized with T'Access inside the definition of T."),(0,i.kt)("p",null,"A formal parameter of a tagged type is defined to be aliased so that a (tagged) parameter X may be passed to an access parameter P by using P =",">"," X'Access. Access parameters are most important for tagged types because of dispatching-on-access-parameters (see 3.9.2). By restricting this to formal parameters, we minimize problems associated with allowing components that are not declared aliased to be pointed-to from within the same record."),(0,i.kt)("p",null,"A view conversion of an aliased view is aliased so that the type of an access parameter can be changed without first converting to a named access type. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T1 is tagged ...;\nprocedure P(X : access T1);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T2 is new T1 with ...;\nprocedure P(X : access T2) is\nbegin\n    P(T1(X.all)'Access);  -- hand off to T1's P\n    . . .     -- now do extra T2-specific processing\nend P;\n\n")),(0,i.kt)("p",null,"The rule about objects with discriminants is necessary because values of a constrained access subtype can designate an object whose nominal subtype is unconstrained; without this rule, a check on every use of such values would be required to ensure that the discriminants of the object had not changed. With this rule (among others), we ensure that if there might exist aliased views of a discriminated object, then the object is necessarily constrained. Note that this rule is necessary only for untagged types, since a discriminant of a tagged type can't have a default, so all tagged discriminated objects are always constrained anyway. "),(0,i.kt)("p",null,'We considered making more kinds of objects aliased by default. In particular, any object of a by-reference type will pretty much have to be allocated at an addressable location, so it can be passed by reference without using bit-field pointers. Therefore, one might wish to allow the Access and and Unchecked_Access attributes for such objects. However, private parts are transparent to the definition of "by-reference type", so if we made all objects of a by-reference type aliased, we would be violating the privacy of private parts. Instead, we would have to define a concept of "visibly by-reference" and base the rule on that. This seemed to complicate the rules more than it was worth, especially since there is no way to declare an untagged limited private type to be by-reference, since the full type might by nonlimited. '),(0,i.kt)("p",null,'Discussion: Note that we do not use the term "aliased" to refer to formal parameters that are referenced through multiple access paths (see 6.2). '),(0,i.kt)("p",null,"An access_to_object_definition defines an access-to-object type and its first subtype; the subtype_indication defines the designated subtype of the access type. If a general_access_modifier appears, then the access type is a general access type. If the modifier is the reserved word constant, then the type is an access-to-constant type","[; a designated object cannot be updated through a value of such a type]",". If the modifier is the reserved word all, then the type is an access-to-variable type","[; a designated object can be both read and updated through a value of such a type]",". If no general_access_modifier appears in the access_to_object_definition, the access type is a pool-specific access-to-variable type. "),(0,i.kt)("p",null,"To be honest: The type of the designated subtype is called the designated type. "),(0,i.kt)("p",null,'Reason: The modifier all was picked to suggest that values of a general access type could point into "all" storage pools, as well as to objects declared aliased, and that "all" access (both read and update) to the designated object was provided. We couldn\'t think of any use for pool-specific access-to-constant types, so any access type defined with the modifier constant is considered a general access type, and can point into any storage pool or at other (appropriate) aliased objects. '),(0,i.kt)("p",null,"Implementation Note: The predefined generic Unchecked_Deallocation can be instantiated for any named access-to-variable type. There is no (language-defined) support for deallocating objects designated by a value of an access-to-constant type. Because of this, an allocator for an access-to-constant type can allocate out of a storage pool with no support for deallocation. Frequently, the allocation can be done at link-time, if the size and initial value are known then. "),(0,i.kt)("p",null,'Discussion: For the purpose of generic formal type matching, the relevant subclasses of access types are access-to-subprogram types, access-to-constant types, and (named) access-to-variable types, with its subclass (named) general access-to-variable types. Pool-specific access-to-variable types are not a separately matchable subclass of types, since they don\'t have any "extra" operations relative to all (named) access-to-variable types. '),(0,i.kt)("p",null,"An access_to_subprogram_definition defines an access-to-subprogram type and its first subtype; the parameter_profile or parameter_and_result_profile defines the designated profile of the access type. There is a calling convention associated with the designated profile","[; only subprograms with this calling convention can be designated by values of the access type.]",' By default, the calling convention is "protected" if the reserved word protected appears, and "Ada" otherwise. ',"[See Annex B for how to override this default.]"," "),(0,i.kt)("p",null,"Ramification: The calling convention protected is in italics to emphasize that it cannot be specified explicitly by the user. This is a consequence of it being a reserved word. "),(0,i.kt)("p",null,'Implementation Note: For an access-to-subprogram type, the representation of an access value might include implementation-defined information needed to support up-level references - for example, a static link. The accessibility rules (see 3.10.2) ensure that in a "global-display-based" implementation model (as opposed to a static-link-based model), an access-to-(unprotected)-subprogram value need consist only of the address of the subprogram. The global display is guaranteed to be properly set up any time the designated subprogram is called. Even in a static-link-based model, the only time a static link is definitely required is for an access-to-subprogram type declared in a scope nested at least two levels deep within subprogram or task bodies, since values of such a type might designate subprograms nested a smaller number of levels. For the normal case of an access-to-subprogram type declared at the outermost (library) level, a code address by itself should be sufficient to represent the access value in many implementations.'),(0,i.kt)("p",null,'For access-to-protected-subprogram, the access values will necessarily include both an address (or other identification) of the code of the subprogram, as well as the address of the associated protected object. This could be thought of as a static link, but it will be needed even for global-display-based implementation models. It corresponds to the value of the "implicit parameter" that is passed into every call of a protected operation, to identify the current instance of the protected type on which they are to operate.'),(0,i.kt)("p",null,'Any Elaboration_Check is performed when a call is made through an access value, rather than when the access value is first "created" via a \'Access. For implementation models that normally put that check at the call-site, an access value will have to point to a separate entry point that does the check. Alternatively, the access value could point to a "subprogram descriptor" that consisted of two words (or perhaps more), the first being the address of the code, the second being the elaboration bit. Or perhaps more efficiently, just the address of the code, but using the trick that the descriptor is initialized to point to a Raise-Program-Error routine initially, and then set to point to the "real" code when the body is elaborated.'),(0,i.kt)("p",null,'For implementations that share code between generic instantiations, the extra level of indirection suggested above to support Elaboration_Checks could also be used to provide a pointer to the per-instance data area normally required when calling shared code. The trick would be to put a pointer to the per-instance data area into the subprogram descriptor, and then make sure that the address of the subprogram descriptor is loaded into a "known" register whenever an indirect call is performed. Once inside the shared code, the address of the per-instance data area can be retrieved out of the subprogram descriptor, by indexing off the "known" register.'),(0,i.kt)("p",null,'Essentially the same implementation issues arise for calls on dispatching operations of tagged types, except that the static link is always known "statically".'),(0,i.kt)("p",null,'Note that access parameters of an anonymous access-to-subprogram type are not permitted. If there were such parameters, full "downward" closureswould be required, meaning that in an implementation that uses a per-task (global) display, the display would have to be passed as a hidden parameter, and reconstructed at the point of call. This was felt to be an undue implementation burden, given that an equivalent (actually, more general) capability is available via formal subprogram parameters to a generic. '),(0,i.kt)("p",null,"An access_definition defines an anonymous general access-to-variable type; the subtype_mark denotes its designated subtype. ","[An access_definition is used in the specification of an access discriminant (see 3.7) or an access parameter (see 6.1).]"),(0,i.kt)("p",null,"For each (named) access type, there is a literal null which has a null access value designating no entity at all. ","[The null value of a named access type is the default initial value of the type.]"," Other values of an access type are obtained by evaluating an attribute_reference for the Access or Unchecked_Access attribute of an aliased view of an object or nonintrinsic subprogram, or, in the case of a named access-to-object type, an allocator","[, which returns an access value designating a newly created object (see 3.10.2)]","."),(0,i.kt)("p",null,"Ramification: A value of an anonymous access type (that is, the value of an access parameter or access discriminant) cannot be null. "),(0,i.kt)("p",null,"Reason: Access parameters allow dispatching on the tag of the object designated by the actual parameter (which gets converted to the anonymous access type as part of the call). In order for dispatching to work properly, there had better be such an object. Hence, the type conversion will raise Constraint_Error if the value of the actual parameter is null. "),(0,i.kt)("p",null,"[All subtypes of an access-to-subprogram type are constrained.]"," The first subtype of a type defined by an access_type_definition or an access_to_object_definition is unconstrained if the designated subtype is an unconstrained array or discriminated type; otherwise it is constrained. "),(0,i.kt)("p",null,"Proof: The Legality Rules on range_constraints (see 3.5) do not permit the subtype_mark of the subtype_indication to denote an access-to-scalar type, only a scalar type. The Legality Rules on index_constraints (see 3.6.1) and discriminant_constraints (see 3.7.1) both permit access-to-composite types in a subtype_indication with such _constraints. Note that an access-to-access-to-composite is never permitted in a subtype_indication with a constraint. "),(0,i.kt)("p",null,"Reason: Only composite_constraints are permitted for an access type, and only on access-to-composite types. A constraint on an access-to-scalar or access-to-access type might be violated due to assignments via other access paths that were not so constrained. By contrast, if the designated subtype is an array or discriminated type, the constraint could not be violated by unconstrained assignments, since array objects are always constrained, and aliased discriminated objects are also constrained (by fiat, see Static Semantics). "),(0,i.kt)("h4",{id:"dynamic-semantics-21"},"Dynamic Semantics"),(0,i.kt)("p",null,"A composite_constraint is compatible with an unconstrained access subtype if it is compatible with the designated subtype. An access value satisfies a composite_constraint of an access subtype if it equals the null value of its type or if it designates an object whose value satisfies the constraint."),(0,i.kt)("p",null,"The elaboration of an access_type_definition creates the access type and its first subtype. For an access-to-object type, this elaboration includes the elaboration of the subtype_indication, which creates the designated subtype."),(0,i.kt)("p",null,"The elaboration of an access_definition creates an anonymous general access-to-variable type ","[(this happens as part of the initialization of an access parameter or access discriminant)]",". "),(0,i.kt)("p",null,'NOTE 1   Access values are called "pointers" or "references" in some other languages.'),(0,i.kt)("p",null,'NOTE 2   Each access-to-object type has an associated storage pool; several access types can share the same pool. An object can be created in the storage pool of an access type by an allocator (see 4.8) for the access type. A storage pool (roughly) corresponds to what some other languages call a "heap". See 13.11 for a discussion of pools.'),(0,i.kt)("p",null,"NOTE 3   Only index_constraints and discriminant_constraints can be applied to access types (see 3.6.1 and 3.7.1). "),(0,i.kt)("h4",{id:"examples-23"},"Examples"),(0,i.kt)("p",null,"Examples of access-to-object types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Peripheral_Ref is access Peripheral;  --  see 3.8.1\ntype Binop_Ptr is access all Binary_Operation'Class;\n                                           -- general access-to-class-wide, see 3.9.1\n\n")),(0,i.kt)("p",null,"Example of an access subtype: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Drum_Ref is Peripheral_Ref(Drum);  --  see 3.8.1\n\n")),(0,i.kt)("p",null,"Example of an access-to-subprogram type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'type Message_Procedure is access procedure (M : in String := "Error!");\nprocedure Default_Message_Procedure(M : in String);\nGive_Message : Message_Procedure := Default_Message_Procedure\'Access;\n...\nprocedure Other_Procedure(M : in String);\n...\nGive_Message := Other_Procedure\'Access;\n...\nGive_Message("File not found.");  -- call with parameter (.all is optional)\nGive_Message.all;                 -- call with no parameters\n\n')),(0,i.kt)("h4",{id:"extensions-to-ada-83-20"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax for access_type_definition is changed to support general access types (including access-to-constants) and access-to-subprograms. The syntax rules for general_access_modifier and access_definition are new. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-23"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'We use the term "storage pool" to talk about the data area from which allocation takes place. The term "collection" is no longer used. ("Collection" and "storage pool" are not the same thing because multiple unrelated access types can share the same storage pool; see 13.11 for more discussion.) '),(0,i.kt)("h3",{id:"3101--incomplete-type-declarations"},"3.10.1  Incomplete Type Declarations"),(0,i.kt)("p",null,"There are no particular limitations on the designated type of an access type. In particular, the type of a component of the designated type can be another access type, or even the same access type. This permits mutually dependent and recursive access types. An incomplete_type_declaration can be used to introduce a type to be used as a designated type, while deferring its full definition to a subsequent full_type_declaration. "),(0,i.kt)("h4",{id:"syntax-21"},"Syntax"),(0,i.kt)("p",null,"incomplete_type_declaration ::= type defining_identifier ","[discriminant_part]",";"),(0,i.kt)("h4",{id:"legality-rules-18"},"Legality Rules"),(0,i.kt)("p",null,"An incomplete_type_declaration requires a completion, which shall be a full_type_declaration. ","[If the incomplete_type_declaration occurs immediately within either the visible part of a package_specification or a declarative_part, then the full_type_declaration shall occur later and immediately within this visible part or declarative_part. If the incomplete_type_declaration occurs immediately within the private part of a given package_specification, then the full_type_declaration shall occur later and immediately within either the private part itself, or the declarative_part of the corresponding package_body.]"," "),(0,i.kt)("p",null,'Proof: This is implied by the next AARM-only rule, plus the rules in 3.11.1, "Completions of Declarations" which require a completion to appear later and immediately within the same declarative region. '),(0,i.kt)("p",null,"To be honest: If the incomplete_type_declaration occurs immediately within the visible part of a package_specification, then the full_type_declaration shall occur immediately within this visible part. "),(0,i.kt)("p",null,"To be honest: If the implementation supports it, an incomplete_type_declaration can be completed by a pragma Import. "),(0,i.kt)("p",null,"If an incomplete_type_declaration has a known_discriminant_part, then a full_type_declaration that completes it shall have a fully conforming (explicit) known_discriminant_part (see 6.3.1). ","[If an incomplete_type_declaration has no discriminant_part (or an unknown_discriminant_part), then a corresponding full_type_declaration is nevertheless allowed to have discriminants, either explicitly, or inherited via derivation.]"),(0,i.kt)("p",null,"The only allowed uses of a name that denotes an incomplete_type_declaration are as follows: "),(0,i.kt)("p",null,'Discussion: No need to say "prior to the end of the full_type_declaration" since the name would not denote the incomplete_type_declaration after the end of the full_type_declaration. Also, with child library units, it would not be well defined whether they come before or after the full_type_declaration for deferred incomplete types. '),(0,i.kt)("p",null,"as the subtype_mark in the subtype_indication of an access_to_object_definition; ","[the only form of constraint allowed in this subtype_indication is a discriminant_constraint;]"," "),(0,i.kt)("p",null,"Implementation Note: We now allow discriminant_constraints even if the full type is deferred to the package body. However, there is no particular implementation burden because we have dropped the concept of the dependent compatibility check. In other words, we have effectively repealed AI83-00007. "),(0,i.kt)("p",null,"as the subtype_mark defining the subtype of a parameter or result of an access_to_subprogram_definition; "),(0,i.kt)("p",null,"Reason: This allows, for example, a record to have a component designating a subprogram that takes that same record type as a parameter. "),(0,i.kt)("p",null,"as the subtype_mark in an access_definition; "),(0,i.kt)("p",null,"as the prefix of an attribute_reference whose attribute_designator is Class; such an attribute_reference is similarly restricted to the uses allowed here; when used in this way, the corresponding full_type_declaration shall declare a tagged type, and the attribute_reference shall occur in the same library unit as the incomplete_type_declaration. "),(0,i.kt)("p",null,"Reason: This is to prevent children from imposing requirements on their ancestor library units for deferred incomplete types. "),(0,i.kt)("p",null,"A dereference (whether implicit or explicit - see 4.1) shall not be of an incomplete type. "),(0,i.kt)("h4",{id:"static-semantics-32"},"Static Semantics"),(0,i.kt)("p",null,"An incomplete_type_declaration declares an incomplete type and its first subtype; the first subtype is unconstrained if a known_discriminant_part appears. "),(0,i.kt)("p",null,"Reason: If an unknown_discriminant_part or no discriminant_part appears, then the constrainedness of the first subtype doesn't matter for any other rules or semantics, so we don't bother defining it. The case with a known_discriminant_part is the only case in which a constraint could later be given in a subtype_indication naming the incomplete type. "),(0,i.kt)("h4",{id:"dynamic-semantics-22"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an incomplete_type_declaration has no effect. "),(0,i.kt)("p",null,'Reason: An incomplete type has no real existence, so it doesn\'t need to be "created" in the usual sense we do for other types. It is roughly equivalent to a "forward;" declaration in Pascal. Private types are different, because they have a different set of characteristics from their full type. '),(0,i.kt)("p",null,"NOTE 1   Within a declarative_part, an incomplete_type_declaration and a corresponding full_type_declaration cannot be separated by an intervening body. This is because a type has to be completely defined before it is frozen, and a body freezes all types declared prior to it in the same declarative_part (see 13.14)."),(0,i.kt)("h4",{id:"examples-24"},"Examples"),(0,i.kt)("p",null,"Example of a recursive type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Cell;  --  incomplete type declaration\ntype Link is access Cell;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Cell is\n   record\n      Value  : Integer;\n      Succ   : Link;\n      Pred   : Link;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Head   : Link  := new Cell'(0, null, null);\nNext   : Link  := Head.Succ;\n\n")),(0,i.kt)("p",null,"Examples of mutually dependent access types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Person(&lt&gt);    -- incomplete type declaration\ntype Car;           -- incomplete type declaration\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Person_Name is access Person;\ntype Car_Name    is access all Car;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Car is\n   record\n      Number  : Integer;\n      Owner   : Person_Name;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Person(Sex : Gender) is\n   record\n      Name     : String(1 .. 20);\n      Birth    : Date;\n      Age      : Integer range 0 .. 130;\n      Vehicle  : Car_Name;\n      case Sex is\n         when M =&gt Wife           : Person_Name(Sex =&gt F);\n         when F =&gt Husband        : Person_Name(Sex =&gt M);\n      end case;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"My_Car, Your_Car, Next_Car : Car_Name := new Car;  -- see 4.8\nGeorge : Person_Name := new Person(M);\n   ...\nGeorge.Vehicle := Your_Car;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-21"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The full_type_declaration that completes an incomplete_type_declaration may have a known_discriminant_part even if the incomplete_type_declaration does not."),(0,i.kt)("p",null,'A discriminant_constraint may be applied to an incomplete type, even if it its completion is deferred to the package body, because there is no "dependent compatibility check" required any more. Of course, the constraint can be specified only if a known_discriminant_part was given in the incomplete_type_declaration. As mentioned in the previous paragraph, that is no longer required even when the full type has discriminants. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-24"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Dereferences producing incomplete types were not explicitly disallowed in RM83, though AI83-00039 indicated that it was not strictly necessary since troublesome cases would result in Constraint_Error at run time, since the access value would necessarily be null. However, this introduces an undesirable implementation burden, as illustrated by Example 4 of AI83-00039: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Pack is\n    type Pri is private;\nprivate\n    type Sep;\n    type Pri is access Sep;\n    X : Pri;\nend Pack;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Pack is -- Could be separately compiled!\n    type Sep is ...;\n    X := new Sep;\nend Pack;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"pragma Elaborate(Pack);\nprivate package Pack.Child is\n    I : Integer := X.all'Size; -- Legal, by AI-00039.\nend Pack.Child;\n\n")),(0,i.kt)("p",null,"Generating code for the above example could be a serious implementation burden, since it would require all aliased objects to store size dope, and for that dope to be in the same format for all kinds of types (or some other equivalently inefficient implementation). On the contrary, most implementations allocate dope differently (or not at all) for different designated subtypes. "),(0,i.kt)("h3",{id:"3102--operations-of-access-types"},"3.10.2  Operations of Access Types"),(0,i.kt)("p",null,'[The attribute Access is used to create access values designating aliased objects and nonintrinsic subprograms. The "accessibility" rules prevent dangling references (in the absence of uses of certain unchecked features - see Section 13).]'," "),(0,i.kt)("h4",{id:"language-design-principles-7"},"Language Design Principles"),(0,i.kt)("p",null,"It should be possible for an access value to designate an object declared by an object declaration, or a subcomponent thereof. In implementation terms, this means pointing at stack-allocated and statically allocated data structures. However, dangling references should be prevented, primarily via compile-time rules, so long as features like Unchecked_Access and Unchecked_Deallocation are not used."),(0,i.kt)("p",null,"In order to create such access values, we require that the access type be a general access type, that the designated object be aliased, and that the accessibility rules be obeyed. "),(0,i.kt)("h4",{id:"name-resolution-rules-13"},"Name Resolution Rules"),(0,i.kt)("p",null,"For an attribute_reference with attribute_designator Access (or Unchecked_Access - see 13.10), the expected type shall be a single access type","[; the prefix of such an attribute_reference is never interpreted as an implicit_dereference]",". If the expected type is an access-to-subprogram type, then the expected profile of the prefix is the designated profile of the access type. "),(0,i.kt)("p",null,'Discussion: Saying that the expected type shall be a "single access type" is our "new" way of saying that the type has to be determinable from context using only the fact that it is an access type. See 4.2 and 8.6. Specifying the expected profile only implies type conformance. The more stringent subtype conformance is required by a Legality Rule. This is the only Resolution Rule that applies to the name in a prefix of an attribute_reference. In all other cases, the name has to be resolved without using context. See 4.1.4.'),(0,i.kt)("h4",{id:"static-semantics-33"},"Static Semantics"),(0,i.kt)("p",null,"[The accessibility rules, which prevent dangling references, are written in terms of accessibility levels, which reflect the run-time nesting of masters. As explained in 7.6.1, a master is the execution of a ,task_body, a block_statement, a subprogram_body, an entry_body, or an accept_statement. An accessibility level is deeper than another if it is more deeply nested at run time. For example, an object declared local to a called subprogram has a deeper accessibility level than an object declared local to the calling subprogram. The accessibility rules for access types require that the accessibility level of an object designated by an access value be no deeper than that of the access type. This ensures that the object will live at least as long as the access type, which in turn ensures that the access value cannot later designate an object that no longer exists. The Unchecked_Access attribute may be used to circumvent the accessibility rules.]"),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[T]",",Term=","[accessibility level]",", Def=","[a representation of the lifetime of an entity in terms of the level of dynamic nesting within which the entity is known to exist][A given accessibility level is said to be statically deeper than another if the given level is known at compile time (as defined below) to be deeper than the other for all possible executions. In most cases, accessibility is enforced at compile time by Legality Rules. Run-time accessibility checks are also used, since the Legality Rules do not cover certain cases involving access parameters and generic packages.]"),(0,i.kt)("p",null,"Each master, and each entity and view created by it, has an accessibility level: "),(0,i.kt)("p",null,"The accessibility level of a given master is deeper than that of each dynamically enclosing master, and deeper than that of each master upon which the task executing the given master directly depends (see 9.3)."),(0,i.kt)("p",null,"An entity or view created by a declaration has the same accessibility level as the innermost enclosing master except in the cases of renaming and derived access types described below. A parameter of a master has the same accessibility level as the master. "),(0,i.kt)("p",null,"The accessibility level of a view of an object or subprogram defined by a renaming_declaration is the same as that of the renamed view."),(0,i.kt)("p",null,"The accessibility level of a view conversion is the same as that of the operand."),(0,i.kt)("p",null,"For a function whose result type is a return-by-reference type, the accessibility level of the result object is the same as that of the master that elaborated the function body. For any other function, the accessibility level of the result object is that of the execution of the called function."),(0,i.kt)("p",null,"The accessibility level of a derived access type is the same as that of its ultimate ancestor."),(0,i.kt)("p",null,"The accessibility level of the anonymous access type of an access discriminant is the same as that of the containing object or associated constrained subtype."),(0,i.kt)("p",null,"The accessibility level of the anonymous access type of an access parameter is the same as that of the view designated by the actual. If the actual is an allocator, this is the accessibility level of the execution of the called subprogram. "),(0,i.kt)("p",null,"The accessibility level of an object created by an allocator is the same as that of the access type."),(0,i.kt)("p",null,"The accessibility level of a view of an object or subprogram denoted by a dereference of an access value is the same as that of the access type. "),(0,i.kt)("p",null,"The accessibility level of a component, protected subprogram, or entry of (a view of) a composite object is the same as that of (the view of) the composite object. "),(0,i.kt)("p",null,"One accessibility level is defined to be statically deeper than another in the following cases: "),(0,i.kt)("p",null,"For a master that is statically nested within another master, the accessibility level of the inner master is statically deeper than that of the outer master. "),(0,i.kt)("p",null,"To be honest: Strictly speaking, this should talk about the constructs (such as subprogram_bodies) being statically nested within one another; the masters are really the executions of those constructs. "),(0,i.kt)("p",null,"To be honest: If a given accessibility level is statically deeper than another, then each level defined to be the same as the given level is statically deeper than each level defined to be the same as the other level. "),(0,i.kt)("p",null,"The statically deeper relationship does not apply to the accessibility level of the anonymous type of an access parameter; that is, such an accessibility level is not considered to be statically deeper, nor statically shallower, than any other."),(0,i.kt)("p",null,"[For determining whether one level is statically deeper than another when within a generic package body, the generic package is presumed to be instantiated at the same level as where it was declared; runtime checks are needed in the case of more deeply nested instantiations.]"," "),(0,i.kt)("p",null,"For determining whether one level is statically deeper than another when within the declarative region of a type_declaration, the current instance of the type is presumed to be an object created at a deeper level than that of the type. "),(0,i.kt)("p",null,"Ramification: In other words, the rules are checked at compile time of the type_declaration, in an assume-the-worst manner. "),(0,i.kt)("p",null,"The accessibility level of all library units is called the library level; a library-level declaration or entity is one whose accessibility level is the library level. "),(0,i.kt)("p",null,"Ramification: Library_unit_declarations are library level. Nested declarations are library level if they are nested only within packages (possibly more than one), and not within subprograms, tasks, etc. "),(0,i.kt)("p",null,'To be honest: The definition of the accessibility level of the anonymous type of an access parameter cheats a bit, since it refers to the view designated by the actual, but access values designate objects, not views of objects. What we really mean is the view that "would be" denoted by an expression "X.all", where X is the actual, even though such an expression is a figment of our imagination. The definition is intended to be equivalent to the following more verbose version: The accessibility level of the anonymous type of an access parameter is as follows: '),(0,i.kt)("p",null,"if the actual is an expression of a named access type - the accessibility level of that type;"),(0,i.kt)("p",null,"if the actual is an allocator - the accessibility level of the execution of the called subprogram;"),(0,i.kt)("p",null,"if the actual is a reference to the Access attribute - the accessibility level of the view denoted by the prefix;"),(0,i.kt)("p",null,"if the actual is a reference to the Unchecked_Access attribute - library accessibility level;"),(0,i.kt)("p",null,"if the actual is an access parameter - the accessibility level of its type. "),(0,i.kt)("p",null,"Note that the allocator case is explicitly mentioned in the RM95, because otherwise the definition would be circular: the level of the anonymous type is that of the view designated by the actual, which is that of the access type. "),(0,i.kt)("p",null,'Discussion: A deeper accessibility level implies a shorter maximum lifetime. Hence, when a rule requires X to have a level that is "not deeper than" Y\'s level, this requires that X has a lifetime at least as long as Y. (We say "maximum lifetime" here, because the accessibility level really represents an upper bound on the lifetime; an object created by an allocator can have its lifetime prematurely ended by an instance of Unchecked_Deallocation.)'),(0,i.kt)("p",null,"Package elaborations are not masters, and are therefore invisible to the accessibility rules: an object declared immediately within a package has the same accessibility level as an object declared immediately within the declarative region containing the package. This is true even in the body of a package; it jibes with the fact that objects declared in a package_body live as long as objects declared outside the package, even though the body objects are not visible outside the package."),(0,i.kt)("p",null,'Note that the level of the view denoted by X.all can be different from the level of the object denoted by X.all. The former is determined by the type of X; the latter is determined either by the type of the allocator, or by the master in which the object was declared. The former is used in several Legality Rules and runtime checks; the latter is used to define when X.all gets finalized. The level of a view reflects what we can conservatively "know" about the object of that view; for example, due to type_conversions, an access value might designate an object that was allocated by an allocator for a different access type.'),(0,i.kt)("p",null,"Similarly, the level of the view denoted by X.all.Comp can be different from the level of the object denoted by X.all.Comp."),(0,i.kt)("p",null,"If Y is statically deeper than X, this implies that Y will be (dynamically) deeper than X in all possible executions."),(0,i.kt)("p",null,'Most accessibility checking is done at compile time; the rules are stated in terms of "statically deeper than". The exceptions are: '),(0,i.kt)("p",null,'Checks involving access parameters. The fact that "statically deeper than" is not defined for the anonymous access type of an access parameter implies that any rule saying "shall not be statically deeper than" does not apply to such a type, nor to anything defined to have "the same" level as such a type.'),(0,i.kt)("p",null,"Checks involving entities and views within generic packages. This is because an instantiation can be at a level that is more deeply nested than the generic package itself. In implementations that use a macro-expansion model of generics, these violations can be detected at macro-expansion time. For implementations that share generics, run-time code is needed to detect the error."),(0,i.kt)("p",null,"Checks during function return. "),(0,i.kt)("p",null,"Note that runtime checks are not required for access discriminants, because their accessibility is determined statically by the accessibility level of the enclosing object."),(0,i.kt)("p",null,"This The accessibility level of the result object of a function reflects the time when that object will be finalized; we don't allow pointers to the object to survive beyond that time."),(0,i.kt)("p",null,'We sometimes use the terms "accessible" and "inaccessible" to mean that something has an accessibility level that is not deeper, or deeper, respectively, than something else. '),(0,i.kt)("p",null,"Implementation Note: If an accessibility Legality Rule is satisfied, then the corresponding runtime check (if any) cannot fail (and a reasonable implementation will not generate any checking code) unless access parameters or shared generic bodies are involved."),(0,i.kt)("p",null,'Accessibility levels are defined in terms of the relations "the same as" and "deeper than". To make the discussion more concrete, we can assign actual numbers to each level. Here, we assume that library-level accessibility is level 0, and each level defined as "deeper than" is one level deeper. Thus, a subprogram directly called from the environment task (such as the main subprogram) would be at level 1, and so on.'),(0,i.kt)("p",null,'Accessibility is not enforced at compile time for access parameters. The "obvious" implementation of the runtime checks would be inefficient, and would involve distributed overhead; therefore, an efficient method is given below. The "obvious" implementation would be to pass the level of the caller at each subprogram call, task creation, etc. This level would be incremented by 1 for each dynamically nested master. An Accessibility_Check would be implemented as a simple comparison - checking that X is not deeper than Y would involve checking that X ',"<","= Y."),(0,i.kt)("p",null,'A more efficient method is based on passing static nesting levels (within constructs that correspond at run time to masters - packages don\'t count). Whenever an access parameter is passed, an implicit extra parameter is passed with it. The extra parameter represents (in an indirect way) the accessibility level of the anonymous access type, and, therefore, the level of the view denoted by a dereference of the access parameter. This is analogous to the implicit "Constrained" bit associated with certain formal parameters of an unconstrained but definite composite subtype. In this method, we avoid distributed overhead: it is not necessary to pass any extra information to subprograms that have no access parameters. For anything other than an access parameter and its anonymous type, the static nesting level is known at compile time, and is defined analogously to the RM95 definition of accessibility level (e.g. derived access types get their nesting level from their parent). Checking "not deeper than" is a "',"<",'=" test on the levels.'),(0,i.kt)("p",null,"For each access parameter, the static depth passed depends on the actual, as follows: "),(0,i.kt)("p",null,"If the actual is an expression of a named access type, pass the static nesting level of that type."),(0,i.kt)("p",null,"If the actual is an allocator, pass the static nesting level of the caller, plus one."),(0,i.kt)("p",null,"If the actual is a reference to the Access attribute, pass the level of the view denoted by the prefix."),(0,i.kt)("p",null,"If the actual is a reference to the Unchecked_Access attribute, pass 0 (the library accessibility level)."),(0,i.kt)("p",null,"If the actual is an access parameter, usually just pass along the level passed in. However, if the static nesting level of the formal (access) parameter is greater than the static nesting level of the actual (access) parameter, the level to be passed is the minimum of the static nesting level of the access parameter and the actual level passed in. "),(0,i.kt)("p",null,"For the Accessibility_Check associated with a type_conversion of an access parameter of a given subprogram to a named access type, if the target type is statically nested within the subprogram, do nothing; the check can't fail in this case. Otherwise, check that the value passed in is ","<","= the static nesting depth of the target type. The other Accessibility_Checks are handled in a similar manner."),(0,i.kt)("p",null,"This method, using statically known values most of the time, is efficient, and, more importantly, avoids distributed overhead."),(0,i.kt)("p",null,"Discussion: Examples of accessibility: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Lib_Unit is\n    type T is tagged ...;\n    type A0 is access all T;\n    Global: A0 := ...;\n    procedure P(X: T) is\n        Y: aliased T;\n        type A1 is access all T;\n        Ptr0: A0 := Global; -- OK.\n        Ptr1: A1 := X'Access; -- OK.\n    begin\n        Ptr1 := Y'Access; -- OK;\n        Ptr0 := A0(Ptr1); -- Illegal type conversion!\n        Ptr0 := X'Access; -- Illegal reference to Access attribute!\n        Ptr0 := Y'Access; -- Illegal reference to Access attribute!\n        Global := Ptr0; -- OK.\n    end P;\nend Lib_Unit;\n\n")),(0,i.kt)("p",null,"The above illegal statements are illegal because the accessibility level of X and Y are statically deeper than the accessibility level of A0. In every possible execution of any program including this library unit, if P is called, the accessibility level of X will be (dynamically) deeper than that of A0. Note that the accessibility levels of X and Y are the same."),(0,i.kt)("p",null,"Here's an example involving access parameters: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Main is\n    type Level_1_Type is access all Integer;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure P(X: access Integer) is\n        type Nested_Type is access all Integer;\n    begin\n        ... Nested_Type(X) ... -- (1)\n        ... Level_1_Type(X) ... -- (2)\n    end P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Q(X: access Integer) is\n        procedure Nested(X: access Integer) is\n        begin\n            P(X);\n        end Nested;\n    begin\n        Nested(X);\n    end Q;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure R is\n        Level_2: aliased Integer;\n    begin\n        Q(Level_2'Access); -- (3)\n    end R;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    Level_1: aliased Integer;\nbegin\n    Q(Level_1'Access); -- (4)\n    R;\nend Main;\n\n")),(0,i.kt)("p",null,"The run-time Accessibility_Check at (1) can never fail, and no code should be generated to check it. The check at (2) will fail when called from (3), but not when called from (4)."),(0,i.kt)("p",null,"Within a type_declaration, the rules are checked in an assume-the-worst manner. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type Int_Ptr is access all Integer;\n    type Rec(D: access Integer) is limited private;\nprivate\n    type Rec_Ptr is access all Rec;\n    function F(X: Rec_Ptr) return Boolean;\n    function G(X: access Rec) return Boolean;\n    type Rec(D: access Integer) is\n        record\n            C1: Int_Ptr := Int_Ptr(D); -- Illegal!\n            C2: Rec_Ptr := Rec'Access; -- Illegal!\n            C3: Boolean := F(Rec'Access); -- Illegal!\n            C4: Boolean := G(Rec'Access);\n        end record;\nend P;\n\n")),(0,i.kt)("p",null,"C1, C2, and C3 are all illegal, because one might declare an object of type Rec at a more deeply nested place than the declaration of the type. C4 is legal, but the accessibility level of the object will be passed to function G, and constraint checks within G will prevent it from doing any evil deeds."),(0,i.kt)("p",null,"Note that we cannot defer the checks on C1, C2, and C3 until compile-time of the object creation, because that would cause violation of the privacy of private parts. Furthermore, the problems might occur within a task or protected body, which the compiler can't see while compiling an object creation. "),(0,i.kt)("p",null,"The following attribute is defined for a prefix X that denotes an aliased view of an object: "),(0,i.kt)("p",null,"X shall denote an aliased view of an object","[, including possibly the current instance (see 8.6) of a limited type within its definition, or a formal parameter or generic formal object of a tagged type]",". The view denoted by the prefix X shall satisfy the following additional requirements, presuming the expected type for X'Access is the general access type A: "),(0,i.kt)("p",null,"If A is an access-to-variable type, then the view shall be a variable; ","[on the other hand, if A is an access-to-constant type, the view may be either a constant or a variable.]"," "),(0,i.kt)("p",null,"Discussion: The current instance of a limited type is considered a variable. "),(0,i.kt)("p",null,"The view shall not be a subcomponent that depends on discriminants of a variable whose nominal subtype is unconstrained, unless this subtype is indefinite, or the variable is aliased."),(0,i.kt)("p",null,"Discussion: This restriction is intended to be similar to the restriction on renaming discriminant-dependent subcomponents. "),(0,i.kt)("p",null,"Reason: This prevents references to subcomponents that might disappear or move or change constraints after creating the reference. "),(0,i.kt)("p",null,'Implementation Note: There was some thought to making this restriction more stringent, roughly: "X shall not denote a subcomponent of a variable with discriminant-dependent subcomponents, if the nominal subtype of the variable is an unconstrained definite subtype." This was because in some implementations, it is not just the discriminant-dependent subcomponents that might move as the result of an assignment that changed the discriminants of the enclosing object. However, it was decided not to make this change because a reasonable implementation strategy was identified to avoid such problems, as follows: '),(0,i.kt)("p",null,"Place nondiscriminant-dependent components with any aliased parts at offsets preceding any discriminant-dependent components in a discriminated record type with defaulted discriminants."),(0,i.kt)("p",null,"Preallocate the maximum space for unconstrained discriminated variables with aliased subcomponents, rather than allocating the initial size and moving them to a larger (heap-resident) place if they grow as the result of an assignment. "),(0,i.kt)("p",null,"Note that for objects of a by-reference type, it is not an error for a programmer to take advantage of the fact that such objects are passed by reference. Therefore, the above approach is also necessary for discriminated record types with components of a by-reference type."),(0,i.kt)("p",null,"To make the above strategy work, it is important that a component of a derived type is defined to be discriminant-dependent if it is inherited and the parent subtype constraint is defined in terms of a discriminant of the derived type (see 3.7). "),(0,i.kt)("p",null,"If the designated type of A is tagged, then the type of the view shall be covered by the designated type; if A's designated type is not tagged, then the type of the view shall be the same, and either A's designated subtype shall statically match the nominal subtype of the view, or the designated subtype shall be discriminated and unconstrained; "),(0,i.kt)("p",null,"Implementation Note: This ensures that the dope for an aliased array object can always be stored contiguous with it, but need not be if its nominal subtype is constrained. "),(0,i.kt)("p",null,"The accessibility level of the view shall not be statically deeper than that of the access type A. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. "),(0,i.kt)("p",null,"Ramification: In an instance body, a runtime check applies."),(0,i.kt)("p",null,"If A is an anonymousaccess type, then the view can never have a deeper accessibility level than A, except when X'Access is used to initialize an access discriminant of an object created by an allocator. The latter case is illegal if the accessibility level of X is statically deeper than that of the access type of the allocator; a runtime check is needed in the case where the initial value comes from an access parameter. "),(0,i.kt)("p",null,"A check is made that the accessibility level of X is not deeper than that of the access type A. If this check fails, Program_Error is raised. "),(0,i.kt)("p",null,"Ramification: The check is needed for access parameters  and in instance bodies."),(0,i.kt)("p",null,"Implementation Note: This check requires that some indication of lifetime is passed as an implicit parameter along with access parameters.No such requirement applies to access discriminants, since the checks associated with them are all compile-time checks. "),(0,i.kt)("p",null,"If the nominal subtype of X does not statically match the designated subtype of A, a view conversion of X to the designated subtype is evaluated (which might raise Constraint_Error - see 4.6) and the value of X'Access designates that view. "),(0,i.kt)("p",null,"The following attribute is defined for a prefix P that denotes a subprogram: "),(0,i.kt)("p",null,"The accessibility level of P shall not be statically deeper than that of S. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. The profile of P shall be subtype-conformant with the designated profile of S, and shall not be Intrinsic. If the subprogram denoted by P is declared within a generic body, S shall be declared within the generic body."),(0,i.kt)("p",null,"Discussion: The part about generic bodies is worded in terms of the denoted subprogram, not the denoted view; this implies that renaming is invisible to this part of the rule. This rule is partly to prevent contract model problems with respect to the accessibility rules, and partly to ease shared-generic-body implementations, in which a subprogram declared in an instance needs to have a different calling convention from other subprograms with the same profile."),(0,i.kt)("p",null,"Overload resolution ensures only that the profile is type-conformant. This rule specifies that subtype conformance is required (which also requires matching calling conventions). P cannot denote an entry because access-to-subprogram types never have the entry calling convention. P cannot denote an enumeration literal or an attribute function because these have intrinsic calling conventions. "),(0,i.kt)("p",null,"NOTE 1   The Unchecked_Access attribute yields the same result as the Access attribute for objects, but has fewer restrictions (see 13.10). There are other predefined operations that yield access values: an allocator can be used to create an object, and return an access value that designates it (see 4.8); evaluating the literal null yields a null access value that designates no entity at all (see 4.2)."),(0,i.kt)("p",null,"NOTE 2   The predefined operations of an access type also include the assignment operation, qualification, and membership tests. Explicit conversion is allowed between general access types with matching designated subtypes; explicit conversion is allowed between access-to-subprogram types with subtype conformant profiles (see 4.6). Named access types have predefined equality operators; anonymous access types do not(see 4.5.2). "),(0,i.kt)("p",null,'Reason: By not having equality operators for anonymous access types, we eliminate the need to specify exactly where the predefined operators for anonymous access types would be defined, as well as the need for an implementer to insert an implicit declaration for "=", etc. at the appropriate place in their symbol table. Note that \'Access and ".all" are defined, and ":=" is defined though useless since all instances are constant. The literal null is also defined for the purposes of overload resolution, but is disallowed by a Legality Rules of this subclause. '),(0,i.kt)("p",null,"NOTE 3   The object or subprogram designated by an access value can be named with a dereference, either an explicit_dereference or an implicit_dereference. See 4.1."),(0,i.kt)("p",null,"NOTE 4   A call through the dereference of an access-to-subprogram value is never a dispatching call. "),(0,i.kt)("p",null,"Proof: See 3.9.2. "),(0,i.kt)("p",null,'NOTE 5   The accessibility rules imply that it is not possible to use the Access attribute to implement "downward closures" - that is, to pass a more-nested subprogram as a parameter to a less-nested subprogram, as might be desired for example for an iterator abstraction. Instead, downward closures can be implemented using generic formal subprograms (see 12.6). Note that Unchecked_Access is not allowed for subprograms.'),(0,i.kt)("p",null,"NOTE 6   Note that using an access-to-class-wide tagged type with a dispatching operation is a potentially more structured alternative to using an access-to-subprogram type."),(0,i.kt)("p",null,"NOTE 7   An implementation may consider two access-to-subprogram values to be unequal, even though they designate the same subprogram. This might be because one points directly to the subprogram, while the other points to a special prologue that performs an Elaboration_Check and then jumps to the subprogram. See 4.5.2. "),(0,i.kt)("p",null,"Ramification: If equality of access-to-subprogram values is important to the logic of a program, a reference to the Access attribute of a subprogram should be evaluated only once and stored in a global constant for subsequent use and equality comparison. "),(0,i.kt)("h4",{id:"examples-25"},"Examples"),(0,i.kt)("p",null,"Example of use of the Access attribute: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Martha : Person_Name := new Person(F);       -- see 3.10.1\nCars   : array (1..2) of aliased Car;\n   ...\nMartha.Vehicle := Cars(1)'Access;\nGeorge.Vehicle := Cars(2)'Access;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-22"},"Extensions to Ada 83"),(0,i.kt)("p",null,'We no longer make things like \'Last and ".component" (basic) operations of an access type that need to be "declared" somewhere. Instead, implicit dereference in a prefix takes care of them all. This means that there should never be a case when X.all\'Last is legal while X\'Last is not. See AI83-00154. '),(0,i.kt)("h2",{id:"311--declarative-parts"},"3.11  Declarative Parts"),(0,i.kt)("p",null,"[A declarative_part contains declarative_items (possibly none).]"," "),(0,i.kt)("h4",{id:"syntax-22"},"Syntax"),(0,i.kt)("p",null,"declarative_part ::= {declarative_item}"),(0,i.kt)("p",null,"declarative_item ::=\nbasic_declarative_item | body"),(0,i.kt)("p",null,"basic_declarative_item ::=\nbasic_declaration | representation_clause | use_clause"),(0,i.kt)("p",null,"body ::= proper_body | body_stub"),(0,i.kt)("p",null,"proper_body ::=\nsubprogram_body | package_body | task_body | protected_body"),(0,i.kt)("h4",{id:"dynamic-semantics-23"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a declarative_part consists of the elaboration of the declarative_items, if any, in the order in which they are given in the declarative_part."),(0,i.kt)("p",null,"An elaborable construct is in the elaborated state after the normal completion of its elaboration. Prior to that, it is not yet elaborated. "),(0,i.kt)("p",null,"Ramification: The elaborated state is only important for bodies; certain uses of a body raise an exception if the body is not yet elaborated."),(0,i.kt)("p",null,'Note that "prior" implies before the start of elaboration, as well as during elaboration.'),(0,i.kt)("p",null,'The use of the term "normal completion" implies that if the elaboration propagates an exception or is aborted, the declaration is not elaborated. RM83 missed the aborted case. '),(0,i.kt)("p",null,"For a construct that attempts to use a body, a check (Elaboration_Check) is performed, as follows: "),(0,i.kt)("p",null,"For a call to a (non-protected) subprogram that has an explicit body, a check is made that the subprogram_body is already elaborated. This check and the evaluations of any actual parameters of the call are done in an arbitrary order. "),(0,i.kt)("p",null,"Discussion: AI83-00180 specifies that there is no elaboration check for a subprogram defined by a pragma Interface (or equivalently, pragma Import). AI83-00430 specifies that there is no elaboration check for an enumeration literal. AI83-00406 specifies that the evaluation of parameters and the elaboration check occur in an arbitrary order. AI83-00406 applies to generic instantiation as well (see below)."),(0,i.kt)("p",null,"For a call to a protected operation of a protected type (that has a body - no check is performed if a pragma Import applies to the protected type), a check is made that the protected_body is already elaborated. This check and the evaluations of any actual parameters of the call are done in an arbitrary order. "),(0,i.kt)("p",null,'Discussion: A protected type has only one elaboration "bit", rather than one for each operation, because one call may result in evaluating the barriers of other entries, and because there are no elaborable declarations between the bodies of the operations. In fact, the elaboration of a protected_body does not elaborate the enclosed bodies, since they are not considered independently elaborable.'),(0,i.kt)("p",null,"Note that there is no elaboration check when calling a task entry. Task entry calls are permitted even before the associated task_body has been seen. Such calls are simply queued until the task is activated and reaches a corresponding accept_statement. We considered a similar rule for protected entries - simply queuing all calls until the protected_body was seen, but felt it was not worth the possible implementation overhead, particularly given that there might be multiple instances of the protected type. "),(0,i.kt)("p",null,"For the activation of a task, a check is made by the activator that the task_body is already elaborated. If two or more tasks are being activated together (see 9.2), as the result of the elaboration of a declarative_part or the initialization for the object created by an allocator, this check is done for all of them before activating any of them. "),(0,i.kt)("p",null,"Reason: As specified by AI83-00149, the check is done by the activator, rather than by the task itself. If it were done by the task itself, it would be turned into a Tasking_Error in the activator, and the other tasks would still be activated. "),(0,i.kt)("p",null,"For the instantiation of a generic unit that has a body, a check is made that this body is already elaborated. This check and the evaluation of any explicit_generic_actual_parameters of the instantiation are done in an arbitrary order. "),(0,i.kt)("p",null,"The exception Program_Error is raised if any of these checks fails. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-23"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax for declarative_part is modified to remove the ordering restrictions of Ada 83; that is, the distinction between basic_declarative_items and later_declarative_items within declarative_parts is removed. This means that things like use_clauses and variable_declarations can be freely intermixed with things like bodies."),(0,i.kt)("p",null,"The syntax rule for proper_body now allows a protected_body, and the rules for elaboration checks now cover calls on protected operations. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-25"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for later_declarative_item is removed; the syntax rule for declarative_item is new."),(0,i.kt)("p",null,'RM83 defines "elaborated" and "not yet elaborated" for declarative_items here, and for other things in 3.1, "Declarations". That\'s no longer necessary, since these terms are fully defined in 3.1.'),(0,i.kt)("p",null,'In RM83, all uses of declarative_part are optional (except for the one in block_statement with a declare) which is sort of strange, since a declarative_part can be empty, according to the syntax. That is, declarative_parts are sort of "doubly optional". In Ada 95, these declarative_parts are always required (but can still be empty). To simplify description, we go further and say (see 5.6, "Block Statements") that a block_statement without an explicit declarative_part is equivalent to one with an empty one. '),(0,i.kt)("h3",{id:"3111--completions-of-declarations"},"3.11.1  Completions of Declarations"),(0,i.kt)("p",null,"Declarations sometimes come in two parts. A declaration that requires a second part is said to require completion. The second part is called the completion of the declaration (and of the entity declared), and is either another declaration, a body, or a pragma. "),(0,i.kt)("p",null,"Discussion: Throughout the RM95, there are rules about completions that define the following: "),(0,i.kt)("p",null,"Which declarations require a corresponding completion."),(0,i.kt)("p",null,"Which constructs can only serve as the completion of a declaration."),(0,i.kt)("p",null,"Where the completion of a declaration is allowed to be."),(0,i.kt)("p",null,"What kinds of completions are allowed to correspond to each kind of declaration that allows one. "),(0,i.kt)("p",null,"Don't confuse this compile-time concept with the run-time concept of completion defined in 7.6.1."),(0,i.kt)("p",null,"Note that the declaration of a private type (if limited) can be completed with the declaration of a task type, which is then completed with a body. Thus, a declaration can actually come in three parts."),(0,i.kt)("h4",{id:"name-resolution-rules-14"},"Name Resolution Rules"),(0,i.kt)("p",null,"A construct that can be a completion is interpreted as the completion of a prior declaration only if: "),(0,i.kt)("p",null,"The declaration and the completion occur immediately within the same declarative region;"),(0,i.kt)("p",null,"The defining name or defining_program_unit_name in the completion is the same as in the declaration, or in the case of a pragma, the pragma applies to the declaration;"),(0,i.kt)("p",null,"If the declaration is overloadable, then the completion either has a type-conformant profile, or is a pragma. "),(0,i.kt)("h4",{id:"legality-rules-19"},"Legality Rules"),(0,i.kt)("p",null,"An implicit declaration shall not have a completion. For any explicit declaration that is specified to require completion, there shall be a corresponding explicit completion. "),(0,i.kt)("p",null,"Discussion: The implicit declarations of predefined operators are not allowed to have a completion. Enumeration literals, although they are subprograms, are not allowed to have a corresponding subprogram_body. That's because the completion rules are described in terms of constructs (subprogram_declarations) and not entities (subprograms). When a completion is required, it has to be explicit; the implicit null package_body that Section 7 talks about cannot serve as the completion of a package_declaration if a completion is required. "),(0,i.kt)("p",null,"At most one completion is allowed for a given declaration. Additional requirements on completions appear where each kind of completion is defined. "),(0,i.kt)("p",null,"Ramification: A subunit is not a completion; the stub is."),(0,i.kt)("p",null,'If the completion of a declaration is also a declaration, then that declaration might have a completion, too. For example, a limited private type can be completed with a task type, which can then be completed with a task body. This is not a violation of the "at most one completion" rule. '),(0,i.kt)("p",null,"A type is completely defined at a place that is after its full type definition (if it has one) and after all of its subcomponent types are completely defined. A type shall be completely defined before it is frozen (see 13.14 and 7.3). "),(0,i.kt)("p",null,"Reason: Index types are always completely defined - no need to mention them. There is no way for a completely defined type to depend on the value of a (still) deferred constant. "),(0,i.kt)("p",null,"NOTE 1   Completions are in principle allowed for any kind of explicit declaration. However, for some kinds of declaration, the only allowed completion is a pragma Import, and implementations are not required to support pragma Import for every kind of entity. "),(0,i.kt)("p",null,"Discussion: In fact, we expect that implementations will not support pragma Import of things like types - it's hard to even define the semantics of what it would mean. Therefore, in practice, not every explicit declaration can have a completion. In any case, if an implementation chooses to support pragma Import for, say, types, it can place whatever restrictions on the feature it wants to. For example, it might want the pragma to be a freezing point for the type. "),(0,i.kt)("p",null,'NOTE 2   There are rules that prevent premature uses of declarations that have a corresponding completion. The Elaboration_Checks of 3.11 prevent such uses at run time for subprograms, protected operations, tasks, and generic units. The rules of 13.14, "Freezing Rules" prevent, at compile time, premature uses of other entities such as private types and deferred constants. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-26"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"This subclause is new. It is intended to cover all kinds of completions of declarations, be they a body for a spec, a full type for an incomplete or private type, a full constant declaration for a deferred constant declaration, or a pragma Import for any kind of entity."))}p.isMDXComponent=!0}}]);