"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9749],{1716:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(a),u=i,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||o;return a?n.createElement(m,r(r({ref:t},c),{},{components:a})):n.createElement(m,r({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var d=2;d<o;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8272:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var n=a(9440),i=(a(6687),a(1716));const o={sidebar_position:8},r="7 Packages",l={unversionedId:"arm/AA-7",id:"arm/AA-7",title:"7 Packages",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-7.md",sourceDirName:"arm",slug:"/arm/AA-7",permalink:"/docs/arm/AA-7",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"6 Subprograms",permalink:"/docs/arm/AA-6"},next:{title:"8 Visibility Rules",permalink:"/docs/arm/AA-8"}},s={},d=[{value:"7.1  Package Specifications and Declarations",id:"71--package-specifications-and-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"7.2  Package Bodies",id:"72--package-bodies",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"7.3  Private Types and Private Extensions",id:"73--private-types-and-private-extensions",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"7.3.1  Private Operations",id:"731--private-operations",level:3},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"7.4  Deferred Constants",id:"74--deferred-constants",level:2},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"7.5  Limited Types",id:"75--limited-types",level:2},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"7.6  User-Defined Assignment and Finalization",id:"76--user-defined-assignment-and-finalization",level:2},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"7.6.1  Completion and Finalization",id:"761--completion-and-finalization",level:3},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4}],c={toc:d};function p(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"7-packages"},"7 Packages"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"[Packages are program units that allow the specification of groups of logically related entities. Typically, a package contains the declaration of a type (often a private type or private extension) along with the declarations of primitive subprograms of the type, which can be called from outside the package, while their inner workings remain hidden from outside users. ]","Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[package]",", Def=","[a program unit that defines the interface to a group of logically related entities, along with their implementation]",", Note1=","[Typically, a package contains the declaration of a type (often a private type or private extension) along with the declarations of primitive subprograms of the type, which can be called from outside the package, while their inner workings remain hidden from outside users.]"," "),(0,i.kt)("h2",{id:"71--package-specifications-and-declarations"},"7.1  Package Specifications and Declarations"),(0,i.kt)("p",null,"[A package is generally provided in two parts: a package_specification and a package_body. Every package has a package_specification, but not all packages have a package_body.]"," "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"package_declaration ::= package_specification;"),(0,i.kt)("p",null,"package_specification ::=\npackage defining_program_unit_name is\n{basic_declarative_item}\n","[private\n{basic_declarative_item}]","\nend [","[parent_unit_name.]","identifier]"),(0,i.kt)("p",null,"If an identifier or parent_unit_name.identifier appears at the end of a package_specification, then this sequence of lexical elements shall repeat the defining_program_unit_name. "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"A package_declaration or generic_package_declaration requires a completion ","[(a body)]"," if it contains any declarative_item that requires a completion, but whose completion is not in its package_specification. "),(0,i.kt)("p",null,"To be honest: If an implementation supports it, a pragma Import may substitute for the body of a package or generic package. "),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The first list of declarative_items of a package_specification of a package other than a generic formal package is called the visible part of the package. ","[ The optional list of declarative_items after the reserved word private (of any package_specification) is called the private part of the package. If the reserved word private does not appear, the package has an implicit empty private part.]"),(0,i.kt)("p",null,"Ramification: This definition of visible part does not apply to generic formal packages - 12.7 defines the visible part of a generic formal package."),(0,i.kt)("p",null,"The implicit empty private part is important because certain implicit declarations occur there if the package is a child package, and it defines types in its visible part that are derived from, or contain as components, private types declared within the parent package. These implicit declarations are visible in children of the child package. See 10.1.1. "),(0,i.kt)("p",null,"[An entity declared in the private part of a package is visible only within the declarative region of the package itself (including any child units - see 10.1.1). In contrast, expanded names denoting entities declared in the visible part can be used even outside the package; furthermore, direct visibility of such entities can be achieved by means of use_clauses (see 4.1.3 and 8.4).]"," "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a package_declaration consists of the elaboration of its basic_declarative_items in the given order. "),(0,i.kt)("p",null,"NOTE 1   The visible part of a package contains all the information that another program unit is able to know about the package."),(0,i.kt)("p",null,"NOTE 2   If a declaration occurs immediately within the specification of a package, and the declaration has a corresponding completion that is a body, then that body has to occur immediately within the body of the package. "),(0,i.kt)("p",null,"Proof: This follows from the fact that the declaration and completion are required to occur immediately within the same declarative region, and the fact that bodies are disallowed (by the Syntax Rules) in package_specifications. This does not apply to instances of generic units, whose bodies can occur in package_specifications. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Example of a package declaration: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Rational_Numbers is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Rational is\n      record\n         Numerator   : Integer;\n         Denominator : Positive;\n      end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "="(X,Y : Rational) return Boolean;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "/"  (X,Y : Integer)  return Rational;  --  to construct a rational number\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "+"  (X,Y : Rational) return Rational;\n   function "-"  (X,Y : Rational) return Rational;\n   function "*"  (X,Y : Rational) return Rational;\n   function "/"  (X,Y : Rational) return Rational;\nend Rational_Numbers;\n\n')),(0,i.kt)("p",null,"There are also many examples of package declarations in the predefined language environment (see Annex A). "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"In Ada 83, a library package is allowed to have a body even if it doesn't need one. In Ada 95, a library package body is either required or forbidden - never optional. The workaround is to add pragma Elaborate_Body, or something else requiring a body, to each library package that has a body that isn't otherwise required. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'We have moved the syntax into this clause and the next clause from RM83-7.1, "Package Structure", which we have removed.'),(0,i.kt)("p",null,"RM83 was unclear on the rules about when a package requires a body. For example, RM83-7.1(4) and RM83-7.1(8) clearly forgot about the case of an incomplete type declared in a package_declaration but completed in the body. In addition, RM83 forgot to make this rule apply to a generic package. We have corrected these rules. Finally, since we now allow a pragma Import for any explicit declaration, the completion rules need to take this into account as well. "),(0,i.kt)("h2",{id:"72--package-bodies"},"7.2  Package Bodies"),(0,i.kt)("p",null,"[In contrast to the entities declared in the visible part of a package, the entities declared in the package_body are visible only within the package_body itself. As a consequence, a package with a package_body can be used for the construction of a group of related subprograms in which the logical operations available to clients are clearly isolated from the internal entities.]"," "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"package_body ::=\npackage body defining_program_unit_name is\ndeclarative_part\n","[begin\nhandled_sequence_of_statements]","\nend [","[parent_unit_name.]","identifier];"),(0,i.kt)("p",null,"If an identifier or parent_unit_name.identifier appears at the end of a package_body, then this sequence of lexical elements shall repeat the defining_program_unit_name. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"A package_body shall be the completion of a previous package_declaration or generic_package_declaration. A library package_declaration or library generic_package_declaration shall not have a body unless it requires a body","[; pragma Elaborate_Body can be used to require a library_unit_declaration to have a body (see 10.2.1) if it would not otherwise require one]",". "),(0,i.kt)("p",null,"Ramification: The first part of the rule forbids a package_body from standing alone - it has to belong to some previous package_declaration or generic_package_declaration."),(0,i.kt)("p",null,"A nonlibrary package_declaration or nonlibrary generic_package_declaration that does not require a completion may have a corresponding body anyway. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"In any package_body without statements there is an implicit null_statement. For any package_declaration without an explicit completion, there is an implicit package_body containing a single null_statement. For a noninstance, nonlibrary package, this body occurs at the end of the declarative_part of the innermost enclosing program unit or block_statement; if there are several such packages, the order of the implicit package_bodies is unspecified. ","[(For an instance, the implicit package_body occurs at the place of the instantiation (see 12.3). For a library package, the place is partially determined by the elaboration dependences (see Section 10).)]"," "),(0,i.kt)("p",null,"Discussion: Thus, for example, we can refer to something happening just after the begin of a package_body, and we can refer to the handled_sequence_of_statements of a package_body, without worrying about all the optional pieces. The place of the implicit body makes a difference for tasks activated by the package. See also RM83-9.3(5)."),(0,i.kt)("p",null,"The implicit body would be illegal if explicit in the case of a library package that does not require (and therefore does not allow) a body. This is a bit strange, but not harmful. "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"For the elaboration of a nongeneric package_body, its declarative_part is first elaborated, and its handled_sequence_of_statements is then executed. "),(0,i.kt)("p",null,'NOTE 1   A variable declared in the body of a package is only visible within this body and, consequently, its value can only be changed within the package_body. In the absence of local tasks, the value of such a variable remains unchanged between calls issued from outside the package to subprograms declared in the visible part. The properties of such a variable are similar to those of a "static" variable of C.'),(0,i.kt)("p",null,"NOTE 2   The elaboration of the body of a subprogram explicitly declared in the visible part of a package is caused by the elaboration of the body of the package. Hence a call of such a subprogram by an outside program unit raises the exception Program_Error if the call takes place before the elaboration of the package_body (see 3.11). "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Example of a package body (see 7.1): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Rational_Numbers is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Same_Denominator (X,Y : in out Rational) is\n   begin\n      --  reduces X and Y to the same denominator:\n      ...\n   end Same_Denominator;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "="(X,Y : Rational) return Boolean is\n      U : Rational := X;\n      V : Rational := Y;\n   begin\n      Same_Denominator (U,V);\n      return U.Numerator = V.Numerator;\n   end "=";\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "/" (X,Y : Integer) return Rational is\n   begin\n      if Y &gt 0 then\n         return (Numerator =&gt X,  Denominator =&gt Y);\n      else\n         return (Numerator =&gt -X, Denominator =&gt -Y);\n      end if;\n   end "/";\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "+" (X,Y : Rational) return Rational is ... end "+";\n   function "-" (X,Y : Rational) return Rational is ... end "-";\n   function "*" (X,Y : Rational) return Rational is ... end "*";\n   function "/" (X,Y : Rational) return Rational is ... end "/";\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end Rational_Numbers;\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for package_body now uses the syntactic category handled_sequence_of_statements."),(0,i.kt)("p",null,"The declarative_part of a package_body is now required; that doesn't make any real difference, since a declarative_part can be empty."),(0,i.kt)("p",null,"RM83 seems to have forgotten to say that a package_body can't stand alone, without a previous declaration. We state that rule here."),(0,i.kt)("p",null,"RM83 forgot to restrict the definition of elaboration of package_bodies to nongeneric ones. We have corrected that omission."),(0,i.kt)("p",null,"The rule about implicit bodies (from RM83-9.3(5)) is moved here, since it is more generally applicable. "),(0,i.kt)("h2",{id:"73--private-types-and-private-extensions"},"7.3  Private Types and Private Extensions"),(0,i.kt)("p",null,"[The declaration (in the visible part of a package) of a type as a private type or private extension serves to separate the characteristics that can be used directly by outside program units (that is, the logical properties) from other characteristics whose direct use is confined to the package (the details of the definition of the type itself). See 3.9.1 for an overview of type extensions. ]"),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,"A private (untagged) type can be thought of as a record type with the type of its single (hidden) component being the full view."),(0,i.kt)("p",null,"A private tagged type can be thought of as a private extension of an anonymous parent with no components. The only dispatching operation of the parent is equality (although the Size attribute, and, if nonlimited, assignment are allowed, and those will presumably be implemented in terms of dispatching). "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"private_type_declaration ::=\ntype defining_identifier ","[discriminant_part]"," is ","[[abstract] tagged][limited]"," private;"),(0,i.kt)("p",null,"private_extension_declaration ::=\ntype defining_identifier ","[discriminant_part]"," is\n","[abstract]","  new ancestor_subtype_indication with private;"),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"A private_type_declaration or private_extension_declaration declares a partial view of the type; such a declaration is allowed only as a declarative_item of the visible part of a package, and it requires a completion, which shall be a full_type_declaration that occurs as a declarative_item of the private part of the package. ","[ The view of the type declared by the full_type_declaration is called the full view.]"," A generic formal private type or a generic formal private extension is also a partial view. "),(0,i.kt)("p",null,"To be honest: A private type can also becompleted by a pragma Import, if supported by an implementation. "),(0,i.kt)("p",null,'Reason: We originally used the term "private view", but this was easily confused with the view provided from the private part, namely the full view. '),(0,i.kt)("p",null,"[A type shall be completely defined before it is frozen (see 3.11.1 and 13.14). Thus, neither the declaration of a variable of a partial view of a type, nor the creation by an allocator of an object of the partial view are allowed before the full declaration of the type. Similarly, before the full declaration, the name of the partial view cannot be used in a generic_instantiation or in a representation item.]"," "),(0,i.kt)("p",null,'Proof: This rule is stated officially in 3.11.1, "Completions of Declarations". '),(0,i.kt)("p",null,"[A private type is limited if its declaration includes the reserved word limited; a private extension is limited if its ancestor type is limited.]"," If the partial view is nonlimited, then the full view shall be nonlimited. If a tagged partial view is limited, then the full view shall be limited. ","[On the other hand, if an untagged partial view is limited, the full view may be limited or nonlimited.]"),(0,i.kt)("p",null,"If the partial view is tagged, then the full view shall be tagged. ","[On the other hand, if the partial view is untagged, then the full view may be tagged or untagged.]"," In the case where the partial view is untagged and the full view is tagged, no derivatives of the partial view are allowed within the immediate scope of the partial view; ","[derivatives of the full view are allowed.]"," "),(0,i.kt)("p",null,"Ramification: Note that deriving from a partial view within its immediate scope can only occur in a package that is a child of the one where the partial view is declared. The rule implies that in the visible part of a public child package, it is impossible to derive from an untagged private type declared in the visible part of the parent package in the case where the full view of the parent type turns out to be tagged. We considered a model in which the derived type was implicitly redeclared at the earliest place within its immediate scope where characteristics needed to be added. However, we rejected that model, because (1) it would imply that (for an untagged type) subprograms explicitly declared after the derived type could be inherited, and (2) to make this model work for composite types as well, several implicit redeclarations would be needed, since new characteristics can become visible one by one; that seemed like too much mechanism. "),(0,i.kt)("p",null,"Discussion: The rule for tagged partial views is redundant for partial views that are private extensions, since all extensions of a given ancestor tagged type are tagged, and limited if the ancestor is limited. We phrase this rule partially redundantly to keep its structure parallel with the other rules. "),(0,i.kt)("p",null,'To be honest: This rule is checked in a generic unit, rather than using the "assume the best" or "assume the worst" method. '),(0,i.kt)("p",null,"Reason: Tagged limited private types have certain capabilities that are incompatible with having assignment for the full view of the type. In particular, tagged limited private types can be extended with access discriminants and components of a limited type, which works only because assignment is not allowed. Consider the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package P1 is\n    type T1 is tagged limited private;\n    procedure Foo(X : in T1\'Class);\nprivate\n    type T1 is tagged null record; -- Illegal!\n        -- This should say "tagged limited null record".\nend P1;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body P1 is\n    type A is access T1'Class;\n    Global : A;\n    procedure Foo(X : in T1'Class) is\n    begin\n        Global := new T1'Class'(X);\n            -- This would be illegal if the full view of\n            -- T1 were limited, like it's supposed to be.\n    end A;\nend P1;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with P1;\npackage P2 is\n    type T2(D : access Integer) -- Trouble!\n            is new P1.T1 with\n        record\n            My_Task : Some_Task_Type; -- More trouble!\n        end record;\nend P2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with P1;\nwith P2;\nprocedure Main is\n    Local : aliased Integer;\n    Y : P2.T2(A =&gt Local'Access);\nbegin\n    P1.Foo(Y);\nend Main;\n  \n\n")),(0,i.kt)("p",null,"If the above example were legal, we would have succeeded in making an access value that points to Main.Local after Main has been left, and we would also have succeeded in doing an assignment of a task object, both of which are supposed to be no-no's. "),(0,i.kt)("p",null,"This rule is not needed for private extensions, because they inherit their limitedness from their ancestor, and there is a separate rule forbidding limited components of the corresponding record extension if the parent is nonlimited. "),(0,i.kt)("p",null,"Ramification: A type derived from an untagged private type is untagged, even if the full view of the parent is tagged, and even at places that can see the parent: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type Parent is private;\nprivate\n    type Parent is tagged\n        record\n            X: Integer;\n        end record;\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Q is\n    type T is new Parent;\nend Q;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Q; use Q;\npackage body P is\n    ... T'Class ... -- Illegal!\n    Object: T;\n    ... Object.X ... -- Illegal!\n    ... Parent(Object).X ... -- OK.\nend P;\n\n")),(0,i.kt)("p",null,"The declaration of T declares an untagged view. This view is always untagged, so T'Class is illegal, it would be illegal to extend T, and so forth. The component name X is never visible for this view, although the component is still there - one can get one's hands on it via a type_conversion."),(0,i.kt)("p",null,"The ancestor subtype of a private_extension_declaration is the subtype defined by the ancestor_subtype_indication; the ancestor type shall be a specific tagged type. The full view of a private extension shall be derived (directly or indirectly) from the ancestor type. In addition to the places where Legality Rules normally apply (see 12.3), the requirement that the ancestor be specific applies also in the private part of an instance of a generic unit. "),(0,i.kt)("p",null,"Reason: This rule allows the full view to be defined through several intermediate derivations, possibly from a series of types produced by generic_instantiations. "),(0,i.kt)("p",null,"If the declaration of a partial view includes a known_discriminant_part, then the full_type_declaration shall have a fully conforming ","[(explicit)]"," known_discriminant_part ",'[(see 6.3.1, "Conformance Rules")]',". ","[The ancestor subtype may be unconstrained; the parent subtype of the full view is required to be constrained (see 3.7).]"," "),(0,i.kt)("p",null,"Discussion: If the ancestor subtype has discriminants, then it is usually best to make it unconstrained. "),(0,i.kt)("p",null,"Ramification: If the partial view has a known_discriminant_part, then the full view has to be a composite, non-array type, since only such types may have known discriminants. Also, the full view cannot inherit the discriminants in this case; the known_discriminant_part has to be explicit."),(0,i.kt)("p",null,"That is, the following is illegal: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T(D : Integer) is private;\nprivate\n    type T is new Some_Other_Type; -- Illegal!\nend P;\n  \n\n")),(0,i.kt)("p",null,"even if Some_Other_Type has an integer discriminant called D."),(0,i.kt)("p",null,"It is a ramification of this and other rules that in order for a tagged type to privately inherit unconstrained discriminants, the private type declaration has to have an unknown_discriminant_part. "),(0,i.kt)("p",null,"If a private extension inherits known discriminants from the ancestor subtype, then the full view shall also inherit its discriminants from the ancestor subtype, and the parent subtype of the full view shall be constrained if and only if the ancestor subtype is constrained. "),(0,i.kt)("p",null,"Reason: The first part ensures that the full view has the same discriminants as the partial view. The second part ensures that if the partial view is unconstrained, then the full view is also unconstrained; otherwise, a client might constrain the partial view in a way that conflicts with the constraint on the full view. "),(0,i.kt)("p",null,"[If a partial view has unknown discriminants, then the full_type_declaration may define a definite or an indefinite subtype, with or without discriminants.]"),(0,i.kt)("p",null,"If a partial view has neither known nor unknown discriminants, then the full_type_declaration shall define a definite subtype."),(0,i.kt)("p",null,"If the ancestor subtype of a private extension has constrained discriminants, then the parent subtype of the full view shall impose a statically matching constraint on those discriminants. "),(0,i.kt)("p",null,"Ramification: If the parent type of the full view is not the ancestor type, but is rather some descendant thereof, the constraint on the discriminants of the parent type might come from the declaration of some intermediate type in the derivation chain between the ancestor type and the parent type. "),(0,i.kt)("p",null,"Reason: This prevents the following: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T2 is new T1(Discrim =&gt 3) with private;\nprivate\n    type T2 is new T1(Discrim =&gt 999) -- Illegal!\n        with record ...;\nend P;\n\n")),(0,i.kt)("p",null,"The constraints in this example do not statically match."),(0,i.kt)("p",null,"If the constraint on the parent subtype of the full view depends on discriminants of the full view, then the ancestor subtype has to be unconstrained: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type One_Discrim(A: Integer) is tagged ...;\n...\npackage P is\n    type Two_Discrims(B: Boolean; C: Integer) is new One_Discrim with private;\nprivate\n    type Two_Discrims(B: Boolean; C: Integer) is new One_Discrim(A =&gt C) with\n        record\n            ...\n        end record;\nend P;\n\n")),(0,i.kt)("p",null,'The above example would be illegal if the private extension said "is new One_Discrim(A =',">",' C);", because then the constraints would not statically match. (Constraints that depend on discriminants are not static.)'),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"A private_type_declaration declares a private type and its first subtype. Similarly, a private_extension_declaration declares a private extension and its first subtype. "),(0,i.kt)("p",null,"Discussion: A package-private type is one declared by a private_type_declaration; that is, a private type other than a generic formal private type. Similarly, a package-private extension is one declared by a private_extension_declaration. These terms are not used in the RM95 version of this document. "),(0,i.kt)("p",null,"A declaration of a partial view and the corresponding full_type_declaration define two views of a single type. The declaration of a partial view together with the visible part define the operations that are available to outside program units; the declaration of the full view together with the private part define other operations whose direct use is possible only within the declarative region of the package itself. Moreover, within the scope of the declaration of the full view, the characteristics of the type are determined by the full view; in particular, within its scope, the full view determines the classes that include the type, which components, entries, and protected subprograms are visible, what attributes and other predefined operations are allowed, and whether the first subtype is static. See 7.3.1."),(0,i.kt)("p",null,"A private extensioninherits components (including discriminants unless there is a new discriminant_part specified) and user-defined primitive subprograms from its ancestor type, in the same way that a record extension inherits components and user-defined primitive subprograms from its parent type (see 3.4). "),(0,i.kt)("p",null,"To be honest: If an operation of the  parent type is abstract, then the abstractness of the inherited operation is different for nonabstract record extensions than for nonabstract private extensions (see 3.9.3). "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a private_type_declaration creates a partial view of a type. The elaboration of a private_extension_declaration elaborates the ancestor_subtype_indication, and creates a partial view of a type. "),(0,i.kt)("p",null,"NOTE 1   The partial view of a type as declared by a private_type_declaration is defined to be a composite view (in 3.2). The full view of the type might or might not be composite. A private extension is also composite, as is its full view."),(0,i.kt)("p",null,"NOTE 2   Declaring a private type with an unknown_discriminant_part is a way of preventing clients from creating uninitialized objects of the type; they are then forced to initialize each object by calling some operation declared in the visible part of the package. If such a type is also limited, then no objects of the type can be declared outside the scope of the full_type_declaration, restricting all object creation to the package defining the type. This allows complete control over all storage allocation for the type. Objects of such a type can still be passed as parameters, however. "),(0,i.kt)("p",null,"Discussion: Packages with private types are analogous to generic packages with formal private types, as follows: The declaration of a package-private type is like the declaration of a formal private type. The visible part of the package is like the generic formal part; these both specify a contract (that is, a set of operations and other things available for the private type). The private part of the package is like an instantiation of the generic; they both give a full_type_declaration that specifies implementation details of the private type. The clients of the package are like the body of the generic; usage of the private type in these places is restricted to the operations defined by the contract."),(0,i.kt)("p",null,'In other words, being inside the package is like being outside the generic, and being outside the package is like being inside the generic; a generic is like an "inside-out" package.'),(0,i.kt)("p",null,"This analogy also works for private extensions in the same inside-out way."),(0,i.kt)("p",null,"Many of the legality rules are defined with this analogy in mind. See, for example, the rules relating to operations of ","[formal]"," derived types."),(0,i.kt)("p",null,"The completion rules for a private type are intentionally quite similar to the matching rules for a generic formal private type."),(0,i.kt)("p",null,"This analogy breaks down in one respect: a generic actual subtype is a subtype, whereas the full view for a private type is always a new type. (We considered allowing the completion of a private_type_declaration to be a subtype_declaration, but the semantics just won't work.) This difference is behind the fact that a generic actual type can be class-wide, whereas the completion of a private type always declares a specific type. "),(0,i.kt)("p",null,"NOTE 3   The ancestor type specified in a private_extension_declaration and the parent type specified in the corresponding declaration of a record extension given in the private part need not be the same - the parent type of the full view can be any descendant of the ancestor type. In this case, for a primitive subprogram that is inherited from the ancestor type and not overridden, the formal parameter names and default expressions (if any) come from the corresponding primitive subprogram of the specified ancestor type, while the body comes from the corresponding primitive subprogram of the parent type of the full view. See 3.9.2."),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Examples of private type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Key is private;\ntype File_Name is limited private;\n\n")),(0,i.kt)("p",null,"Example of a private extension declaration: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type List is new Ada.Finalization.Controlled with private;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax for a private_type_declaration is augmented to allow the reserved word tagged."),(0,i.kt)("p",null,'In Ada 83, a private type without discriminants cannot be completed with a type with discriminants. Ada 95 allows the full view to have discriminants, so long as they have defaults (that is, so long as the first subtype is definite). This change is made for uniformity with generics, and because the rule as stated is simpler and easier to remember than the Ada 83 rule. In the original version of Ada 83, the same restriction applied to generic formal private types. However, the restriction was removed by the ARG for generics. In order to maintain the "generic contract/private type contract analogy" discussed above, we have to apply the same rule to package-private types. Note that a private untagged type without discriminants can be completed with a tagged type with discriminants only if the full view is constrained, because discriminants of tagged types cannot have defaults. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'RM83-7.4.1(4), "Within the specification of the package that declares a private type and before the end of the corresponding full type declaration, a restriction applies....", is subsumed (and corrected) by the rule that a type shall be completely defined before it is frozen, and the rule that the parent type of a derived type declaration shall be completely defined, unless the derived type is a private extension. '),(0,i.kt)("h3",{id:"731--private-operations"},"7.3.1  Private Operations"),(0,i.kt)("p",null,"[For a type declared in the visible part of a package or generic package, certain operations on the type do not become visible until later in the package - either in the private part or the body. Such private operations are available only inside the declarative region of the package or generic package.]"," "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,'The predefined operators that exist for a given type are determined by the classes to which the type belongs. For example, an integer type has a predefined "+" operator. In most cases, the predefined operators of a type are declared immediately after the definition of the type; the exceptions are explained below. Inherited subprograms are also implicitly declared immediately after the definition of the type, except as stated below.'),(0,i.kt)("p",null,"For a composite type, the characteristics (see 7.3) of the type are determined in part by the characteristics of its component types. At the place where the composite type is declared, the only characteristics of component types used are those characteristics visible at that place. If later within the immediate scope of the composite type additional characteristics become visible for a component type, then any corresponding characteristics become visible for the composite type. Any additional predefined operators are implicitly declared at that place."),(0,i.kt)("p",null,"The corresponding rule applies to a type defined by a derived_type_definition, if there is a place within its immediate scope where additional characteristics of its parent type become visible."),(0,i.kt)("p",null,'[For example, an array type whose component type is limited private becomes nonlimited if the full view of the component type is nonlimited and visible at some later place within the immediate scope of the array type. In such a case, the predefined "=" operator is implicitly declared at that place, and assignment is allowed after that place.]'),(0,i.kt)("p",null,"Inherited primitive subprograms follow a different rule. For a derived_type_definition, each inherited primitive subprogram is implicitly declared at the earliest place, if any, within the immediate scope of the type_declaration, but after the type_declaration, where the corresponding declaration from the parent is visible. If there is no such place, then the inherited subprogram is not declared at all. ","[An inherited subprogram that is not declared at allcannot be named in a call and cannot be overridden, but for a tagged type, it is possible to dispatch to it.]"),(0,i.kt)("p",null,"For a private_extension_declaration, each inherited subprogram is declared immediately after the private_extension_declaration if the corresponding declaration from the ancestor is visible at that place. Otherwise, the inherited subprogram is not declared for the private extension, ","[though it might be for the full type]",". "),(0,i.kt)("p",null,'Reason: There is no need for the "earliest place within the immediate scope" business here, because a private_extension_declaration will be completed with a full_type_declaration, so we can hang the necessary private implicit declarations on the full_type_declaration. '),(0,i.kt)("p",null,"Discussion: The above rules matter only when the component type (or parent type) is declared in the visible part of a package, and the composite type (or derived type) is declared within the declarative region of that package (possibly in a nested package or a child package)."),(0,i.kt)("p",null,"Consider: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Parent is\n    type Root is tagged null record;\n    procedure Op1(X : Root);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type My_Int is range 1..10;\nprivate\n    procedure Op2(X : Root);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Another_Int is new My_Int;\n    procedure Int_Op(X : My_Int);\nend Parent;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Parent; use Parent;\npackage Unrelated is\n    type T2 is new Root with null record;\n    procedure Op2(X : T2);\nend Unrelated;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Parent.Child is\n    type T3 is new Root with null record;\n    -- Op1(T3) implicitly declared here.\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    package Nested is\n        type T4 is new Root with null record;\n    private\n        ...\n    end Nested;\nprivate\n    -- Op2(T3) implicitly declared here.\n    ...\nend Parent.Child;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Unrelated; use Unrelated;\npackage body Parent.Child is\n    package body Nested is\n        -- Op2(T4) implicitly declared here.\n    end Nested;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type T5 is new T2 with null record;\nend Parent.Child;\n\n")),(0,i.kt)("p",null,'Another_Int does not inherit Int_Op, because Int_Op does not "exist" at the place where Another_Int is declared.'),(0,i.kt)("p",null,"Type T2 inherits Op1 and Op2 from Root. However, the inherited Op2 is never declared, because Parent.Op2 is never visible within the immediate scope of T2. T2 explicitly declares its own Op2, but this is unrelated to the inherited one - it does not override the inherited one, and occupies a different slot in the type descriptor."),(0,i.kt)("p",null,"T3 inherits both Op1 and Op2. Op1 is implicitly declared immediately after the type declaration, whereas Op2 is declared at the beginning of the private part. Note that if Child were a private child of Parent, then Op1 and Op2 would both be implicitly declared immediately after the type declaration."),(0,i.kt)("p",null,"T4 is similar to T3, except that the earliest place within T4's immediate scope where Root's Op2 is visible is in the body of Nested."),(0,i.kt)("p",null,"If T3 or T4 were to declare a type-conformant Op2, this would override the one inherited from Root. This is different from the situation with T2."),(0,i.kt)("p",null,"T5 inherits Op1 and two Op2's from T2. Op1 is implicitly declared immediately after the declaration of T5, as is the Op2 that came from Unrelated.Op2. However, the Op2 that originally came from Parent.Op2 is never implicitly declared for T5, since T2's version of that Op2 is never visible (anywhere - it never got declared either)."),(0,i.kt)("p",null,"For all of these rules, implicit private parts and bodies are assumed as needed."),(0,i.kt)("p",null,"It is possible for characteristics of a type to be revealed in more than one place:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type Comp1 is private;\nprivate\n    type Comp1 is new Boolean;\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P.Q is\n    package R is\n        type Comp2 is limited private;\n        type A is array(Integer range &lt&gt) of Comp2;\n    private\n        type Comp2 is new Comp1;\n        -- A becomes nonlimited here.\n        -- \"=\"(A, A) return Boolean is implicitly declared here.\n        ...\n    end R;\nprivate\n    -- Now we find out what Comp1 really is, which reveals\n    -- more information about Comp2, but we're not within\n    -- the immediate scope of Comp2, so we don't do anything\n    -- about it yet.\nend P.Q;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package body P.Q is\n    package body R is\n        -- Things like "xor"(A,A) return A are implicitly\n        -- declared here.\n    end R;\nend P.Q;\n\n')),(0,i.kt)("p",null,"[The Class attribute is defined for tagged subtypes in 3.9. In addition,]"," for every subtype S of an untagged private type whose full view is tagged, the following attribute is defined: "),(0,i.kt)("p",null,"S'ClassDenotes the class-wide subtype corresponding to the full view of S. This attribute is allowed only from the beginning of the private part in which the full view is declared, until the declaration of the full view. ","[After the full view, the Class attribute of the full view can be used.]"," "),(0,i.kt)("p",null,"NOTE 1   Because a partial view and a full view are two different views of one and the same type, outside of the defining package the characteristics of the type are those defined by the visible part. Within these outside program units the type is just a private type or private extension, and any language rule that applies only to another class of types does not apply. The fact that the full declaration might implement a private type with a type of a particular class (for example, as an array type) is relevant only within the declarative region of the package itself including any child units."),(0,i.kt)("p",null,"The consequences of this actual implementation are, however, valid everywhere. For example: any default initialization of components takes place; the attribute Size provides the size of the full view; finalization is still done for controlled components of the full view; task dependence rules still apply to components that are task objects."),(0,i.kt)("p",null,"NOTE 2   Partial views provide assignment (unless the view is limited), membership tests, selected components for the selection of discriminants and inherited components, qualification, and explicit conversion."),(0,i.kt)("p",null,"NOTE 3   For a subtype S of a partial view, S'Size is defined (see 13.3). For an object A of a partial view, the attributes A'Size and A'Address are defined (see 13.3). The Position, First_Bit, and Last_Bit attributes are also defined for discriminants and inherited components. "),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Example of a type with private operations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package Key_Manager is\n   type Key is private;\n   Null_Key : constant Key; -- a deferred constant declaration (see 7.4)\n   procedure Get_Key(K : out Key);\n   function "&lt" (X, Y : Key) return Boolean;\nprivate\n   type Key is new Natural;\n   Null_Key : constant Key := Key\'First;\nend Key_Manager;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Key_Manager is\n   Last_Key : Key := Null_Key;\n   procedure Get_Key(K : out Key) is\n   begin\n      Last_Key := Last_Key + 1;\n      K := Last_Key;\n   end Get_Key;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   function "&lt" (X, Y : Key) return Boolean is\n   begin\n      return Natural(X) &lt Natural(Y);\n   end "&lt";\nend Key_Manager;\n\n')),(0,i.kt)("p",null,'NOTE 4   Notes on the example: Outside of the package Key_Manager, the operations available for objects of type Key include assignment, the comparison for equality or inequality, the procedure Get_Key and the operator "',"<",'"; they do not include other relational operators such as "',">",'=", or arithmetic operators.'),(0,i.kt)("p",null,'The explicitly declared operator "',"<",'" hides the predefined operator "',"<",'" implicitly declared by the full_type_declaration. Within the body of the function, an explicit conversion of X and Y to the subtype Natural is necessary to invoke the "',"<",'" operator of the parent type. Alternatively, the result of the function could be written as not (X ',">",'= Y), since the operator "',">",'=" is not redefined.'),(0,i.kt)("p",null,"The value of the variable Last_Key, declared in the package body, remains unchanged between calls of the procedure Get_Key. (See also the NOTES of 7.2.) "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The phrase in RM83-7.4.2(7), "...after the full type declaration", doesn\'t work in the presence of child units, so we define that rule in terms of visibility.'),(0,i.kt)("p",null,'The definition of the Constrained attribute for private types has been moved to "Obsolescent Features". (The Constrained attribute of an object has not been moved there.) '),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[type invariant]",", Def=","[see invariant]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[invariant]",", Def=","[an assertion that is expected to be True for all objects of a given private type when viewed from outside the defining package]"," "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[default initial condition]",", Def=","[a property that holds for every default-initialized object of a given type]"," "),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[stable property]",", Def=","[a characteristic associated with objects of a given type that is preserved by many of the primitive operations of the type]"," "),(0,i.kt)("h2",{id:"74--deferred-constants"},"7.4  Deferred Constants"),(0,i.kt)("p",null,"[Deferred constant declarations may be used to declare constants in the visible part of a package, but with the value of the constant given in the private part. They may also be used to declare constants imported from other languages (see Annex B).]"," "),(0,i.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,i.kt)("p",null,"[ A deferred constant declaration is an object_declaration with the reserved word constant but no initialization expression.]"," The constant declared by a deferred constant declaration is called a deferred constant. A deferred constant declaration requires a completion, which shall be a full constant declaration (called the full declaration of the deferred constant), or a pragma Import (see Annex B). "),(0,i.kt)("p",null,"Proof: The first sentence is redundant, as it is stated officially in 3.3.1."),(0,i.kt)("p",null,"A deferred constant declaration that is completed by a full constant declaration shall occur immediately within the visible part of a package_specification. For this case, the following additional rules apply to the corresponding full declaration: "),(0,i.kt)("p",null,"The full declaration shall occur immediately within the private part of the same package;"),(0,i.kt)("p",null,"The deferred and full constants shall have the same type; "),(0,i.kt)("p",null,"Ramification: This implies that both the deferred declaration and the full declaration have to have a subtype_indication rather than an array_type_definition, because each array_type_definition would define a new type. "),(0,i.kt)("p",null,"If the subtype defined by the subtype_indication in the deferred declaration is constrained, then the subtype defined by the subtype_indication in the full declaration shall match it statically.","[ On the other hand, if the subtype of the deferred constant is unconstrained, then the full declaration is still allowed to impose a constraint. The constant itself will be constrained, like all constants;]"),(0,i.kt)("p",null,"If the deferred constant declaration includes the reserved word aliased, then the full declaration shall also. "),(0,i.kt)("p",null,"Ramification: On the other hand, the full constant can be aliased even if the deferred constant is not. "),(0,i.kt)("p",null,"[A deferred constant declaration that is completed by a pragma Import need not appear in the visible part of a package_specification, and has no full constant declaration.]"),(0,i.kt)("p",null,"The completion of a deferred constant declaration shall occur before the constant is frozen (see 7.4)."),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a deferred constant declaration elaborates the subtype_indication or (only allowed in the case of an imported constant) the array_type_definition. "),(0,i.kt)("p",null,"NOTE   The full constant declaration for a deferred constant that is of a given private type or private extension is not allowed before the corresponding full_type_declaration. This is a consequence of the freezing rules for types (see 13.14). "),(0,i.kt)("p",null,"Ramification: Multiple or single declarations are allowed for the deferred and the full declarations, provided that the equivalent single declarations would be allowed."),(0,i.kt)("p",null,"Deferred constant declarations are useful for declaring constants of private views, and types with components of private views. They are also useful for declaring access-to-constant objects that designate variables declared in the private part of a package. "),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Examples of deferred constant declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Null_Key : constant Key;      -- see 7.3.1\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'CPU_Identifier : constant String(1..8);\npragma Import(Assembler, CPU_Identifier, Link_Name =&gt "CPU_ID");\n                              -- see B.1\n\n')),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"In Ada 83, a deferred constant is required to be of a private type declared in the same visible part. This restriction is removed for Ada 95; deferred constants can be of any type."),(0,i.kt)("p",null,"In Ada 83, a deferred constant declaration was not permitted to include a constraint, nor the reserved word aliased."),(0,i.kt)("p",null,"In Ada 83, the rules required conformance of type marks; here we require static matching of subtypes if the deferred constant is constrained."),(0,i.kt)("p",null,"A deferred constant declaration can be completed with a pragma Import. Such a deferred constant declaration need not be within a package_specification."),(0,i.kt)("p",null,"The rules for too-early uses of deferred constants are modified in Ada 95 to allow more cases, and catch all errors at compile time. This change is necessary in order to allow deferred constants of a tagged type without violating the principle that for a dispatching call, there is always an implementation to dispatch to. It has the beneficial side effect of catching some Ada-83-erroneous programs at compile time. The new rule fits in well with the new freezing-point rules. Furthermore, we are trying to convert undefined-value problems into bounded errors, and we were having trouble for the case of deferred constants. Furthermore, uninitialized deferred constants cause trouble for the shared variable / tasking rules, since they are really variable, even though they purport to be constant. In Ada 95, they cannot be touched until they become constant."),(0,i.kt)("p",null,"Note that we do not consider this change to be an upward incompatibility, because it merely changes an erroneous execution in Ada 83 into a compile-time error."),(0,i.kt)("p",null,"The Ada 83 semantics are unclear in the case where the full view turns out to be an access type. It is a goal of the language design to prevent uninitialized access objects. One wonders if the implementation is required to initialize the deferred constant to null, and then initialize it (again!) to its real value. In Ada 95, the problem goes away. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Since deferred constants can now be of a nonprivate type, we have made this a stand-alone clause, rather than a subclause of 7.3, "Private Types and Private Extensions".'),(0,i.kt)("p",null,"Deferred constant declarations used to have their own syntax, but now they are simply a special case of object_declarations. "),(0,i.kt)("h2",{id:"75--limited-types"},"7.5  Limited Types"),(0,i.kt)("p",null,"[A limited type is (a view of) a type for which the assignment operation is not allowed. A nonlimited type is a (view of a) type for which the assignment operation is allowed.]"," "),(0,i.kt)("p",null,"Discussion: The concept of the value of a limited type is difficult to define, since the abstract value of a limited type often extends beyond its physical representation. In some sense, values of a limited type cannot be divorced from their object. The value is the object."),(0,i.kt)("p",null,"In Ada 83, in the two places where limited types were defined by the language, namely tasks and files, an implicit level of indirection was implied by the semantics to avoid the separation of the value from an associated object. In Ada 95, most limited types are passed by reference, and even return-ed by reference. "),(0,i.kt)("p",null,"To be honest: For a limited partial view whose full view is nonlimited, assignment is possible on parameter passing and function return. To prevent any copying whatsoever, one should make both the partial and full views limited. "),(0,i.kt)("p",null,"Glossary entry: A limited type is (a view of) a type for which the assignment operation is not allowed. A nonlimited type is a (view of a) type for which the assignment operation is allowed."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[limited type]",", Def=","[a type for which copying (such as in an assignment_statement) is not allowed]",", Note1=","[A nonlimited type is a type for which copying is allowed.]"," "),(0,i.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,i.kt)("p",null,"If a tagged record type has any limited components, then the reserved word limited shall appear in its record_type_definition. "),(0,i.kt)("p",null,"Reason: This prevents tagged limited types from becoming nonlimited. Otherwise, the following could happen: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package P is\n    type T is limited private;\n    type R is tagged\n        record -- Illegal!\n               -- This should say "limited record".\n            X : T;\n        end record;\nprivate\n    type T is new Integer; -- R becomes nonlimited here.\nend P;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Q is\n    type R2(Access_Discrim : access ...) is new R with\n        record\n            Y : Some_Task_Type;\n        end record;\nend Q;\n\n")),(0,i.kt)("p",null,"If the above were legal, then assignment would be defined for R'Class in the body of P, which is bad news, given the access discriminant and the task. "),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"A type is limited if it is a descendant of one of the following: "),(0,i.kt)("p",null,"a type with the reserved word limited in its definition; "),(0,i.kt)("p",null,'Ramification: Note that there is always a "definition", conceptually, even if there is no syntactic category called "..._definition".'),(0,i.kt)("p",null,"a task or protected type;"),(0,i.kt)("p",null,"a composite type with a limited component."),(0,i.kt)("p",null,"Otherwise, the type is nonlimited."),(0,i.kt)("p",null,"[There are no predefined equality operators for a limited type.]"),(0,i.kt)("p",null,"NOTE 1   The following are consequences of the rules for limited types: "),(0,i.kt)("p",null,"An initialization expression is not allowed in an object_declaration if the type of the object is limited."),(0,i.kt)("p",null,"A default expression is not allowed in a component_declaration if the type of the record component is limited."),(0,i.kt)("p",null,"An initialized allocator is not allowed if the designated type is limited."),(0,i.kt)("p",null,"A generic formal parameter of mode in must not be of a limited type. "),(0,i.kt)("p",null,"NOTE 2   Aggregates are not available for a limited composite type. Concatenation is not available for a limited array type."),(0,i.kt)("p",null,"NOTE 3   The rules do not exclude a default_expression for a formal parameter of a limited type; they do not exclude a deferred constant of a limited type if the full declaration of the constant is of a nonlimited type."),(0,i.kt)("p",null,"NOTE 4   As illustrated in 7.3.1, an untagged limited type can become nonlimited under certain circumstances. "),(0,i.kt)("p",null,"Ramification: Limited private types do not become nonlimited; instead, their full view can be nonlimited, which has a similar effect."),(0,i.kt)("p",null,'It is important to remember that a single nonprivate type can be both limited and nonlimited in different parts of its scope. In other words, "limited" is a property that depends on where you are in the scope of the type. We don\'t call this a "view property" because there is no particular declaration to declare the nonlimited view.'),(0,i.kt)("p",null,"Tagged types never become nonlimited. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"Example of a package with a limited type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package IO_Package is\n   type File_Name is limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Open (F : in out File_Name);\n   procedure Close(F : in out File_Name);\n   procedure Read (F : in File_Name; Item : out Integer);\n   procedure Write(F : in File_Name; Item : in  Integer);\nprivate\n   type File_Name is\n      limited record\n         Internal_Name : Integer := 0;\n      end record;\nend IO_Package;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body IO_Package is\n   Limit : constant := 200;\n   type File_Descriptor is record  ...  end record;\n   Directory : array (1 .. Limit) of File_Descriptor;\n   ...\n   procedure Open (F : in out File_Name) is  ...  end;\n   procedure Close(F : in out File_Name) is  ...  end;\n   procedure Read (F : in File_Name; Item : out Integer) is ... end;\n   procedure Write(F : in File_Name; Item : in  Integer) is ... end;\nbegin\n   ...\nend IO_Package;\n\n")),(0,i.kt)("p",null,"NOTE 5   Notes on the example: In the example above, an outside subprogram making use of IO_Package may obtain a file name by calling Open and later use it in calls to Read and Write. Thus, outside the package, a file name obtained from Open acts as a kind of password; its internal properties (such as containing a numeric value) are not known and no other operations (such as addition or comparison of internal names) can be performed on a file name. Most importantly, clients of the package cannot make copies of objects of type File_Name."),(0,i.kt)("p",null,"This example is characteristic of any case where complete control over the operations of a type is desired. Such packages serve a dual purpose. They prevent a user from making use of the internal structure of the type. They also implement the notion of an encapsulated data type where the only operations on the type are those given in the package specification."),(0,i.kt)("p",null,"The fact that the full view of File_Name is explicitly declared limited means that parameter passing and function return will always be by reference (see 6.2 and 6.5)."),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The restrictions in RM83-7.4.4(4), which disallowed out parameters of limited types in certain cases, are removed. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Since limitedness and privateness are orthogonal in Ada 95 (and to some extent in Ada 83), this is now its own clause rather than being a subclause of 7.3, "Private Types and Private Extensions". '),(0,i.kt)("h2",{id:"76--user-defined-assignment-and-finalization"},"7.6  User-Defined Assignment and Finalization"),(0,i.kt)("p",null,"[ Three kinds of actions are fundamental to the manipulation of objects: initialization, finalization, and assignment. Every object is initialized, either explicitly or by default, after being created (for example, by an object_declaration or allocator). Every object is finalized before being destroyed (for example, by leaving a subprogram_body containing an object_declaration, or by a call to an instance of Unchecked_Deallocation). An assignment operation is used as part of assignment_statements, explicit initialization, parameter passing, and other operations. "),(0,i.kt)("p",null,"Default definitions for these three fundamental operations are provided by the language, but a controlled type gives the user additional control over parts of these operations. In particular, the user can define, for a controlled type, an Initialize procedure which is invoked immediately after the normal default initialization of a controlled object, a Finalize procedure which is invoked immediately before finalization of any of the components of a controlled object, and an Adjust procedure which is invoked as the last step of an assignment to a (nonlimited) controlled object.] "),(0,i.kt)("p",null,"Glossary entry: A controlled type supports user-defined assignment and finalization. Objects are always finalized before being destroyed."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[controlled type]",", Def=","[a type that supports user-defined assignment and finalization]",", Note1=","[Objects are always finalized before being destroyed.]"," "),(0,i.kt)("p",null,"Ramification: Here's the basic idea of initialization, value adjustment, and finalization, whether or not user defined: When an object is created, if it is explicitly assigned an initial value, the assignment copies and adjusts the initial value. Otherwise, Initialize is applied to it (except in the case of an aggregate as a whole). An assignment_statement finalizes the target before copying in and adjusting the new value. Whenever an object goes away, it is finalized. Calls on Initialize and Adjust happen bottom-up; that is, components first, followed by the containing object. Calls on Finalize happens top-down; that is, first the containing object, and then its components. These ordering rules ensure that any components will be in a well-defined state when Initialize, Adjust, or Finalize is applied to the containing object. "),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Finalization is\n    pragma Preelaborate(Finalization);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Controlled is abstract tagged private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Initialize (Object : in out Controlled);\n    procedure Adjust     (Object : in out Controlled);\n    procedure Finalize   (Object : in out Controlled);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    type Limited_Controlled is abstract tagged limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Initialize (Object : in out Limited_Controlled);\n    procedure Finalize   (Object : in out Limited_Controlled);\nprivate\n    ... -- not specified by the language\nend Ada.Finalization;\n\n")),(0,i.kt)("p",null,'A controlled type is a descendant of Controlled or Limited_Controlled. The (default) implementations of Initialize, Adjust, and Finalize have no effect. The predefined "=" operator of type Controlled always returns True, ',"[since this operator is incorporated into the implementation of the predefined equality operator of types derived from Controlled, as explained in 4.5.2.]"," The type Limited_Controlled is like Controlled, except that it is limited and it lacks the primitive subprogram Adjust. "),(0,i.kt)("p",null,'Discussion: We say "nonlimited controlled type" (rather than just "controlled type";) when we want to talk about descendants of Controlled only. '),(0,i.kt)("p",null,"Reason: We considered making Adjust and Finalize abstract. However, a reasonable coding convention is e.g. for Finalize to always call the parent's Finalize after doing whatever work is needed for the extension part. (Unlike CLOS, we have no way to do that automatically in Ada 95.) For this to work, Finalize cannot be abstract. In a generic unit, for a generic formal abstract derived type whose ancestor is Controlled or Limited_Controlled, calling the ancestor's Finalize would be illegal if it were abstract, even though the actual type might have a concrete version."),(0,i.kt)("p",null,'Types Controlled and Limited_Controlled are abstract, even though they have no abstract primitive subprograms. It is not clear that they need to be abstract, but there seems to be no harm in it, and it might make an implementation\'s life easier to know that there are no objects of these types - in case the implementation wishes to make them "magic" in some way.'),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"During the elaboration of an object_declaration, for every controlled subcomponent of the object that is not assigned an initial value (as defined in 3.3.1), Initialize is called on that subcomponent. Similarly, if the object as a whole is controlled and is not assigned an initial value, Initialize is called on the object. The same applies to the evaluation of an allocator, as explained in 4.8."),(0,i.kt)("p",null,"For an extension_aggregate whose ancestor_part is a subtype_mark, Initialize is called on all controlled subcomponents of the ancestor part; if the type of the ancestor part is itself controlled, the Initialize procedure of the ancestor type is called, unless that Initialize procedure is abstract. "),(0,i.kt)("p",null,"Discussion: Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T1 is new Controlled with\n    record\n        ... -- some components might have defaults\n    end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T2 is new Controlled with\n    record\n        X : T1; -- no default\n        Y : T1 := ...; -- default\n    end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"A : T2;\nB : T2 := ...;\n\n")),(0,i.kt)("p",null,"As part of the elaboration of A's declaration, A.Y is assigned a value; therefore Initialize is not applied to A.Y. Instead, Adjust is applied to A.Y as part of the assignment operation. Initialize is applied to A.X and to A, since those objects are not assigned an initial value. The assignment to A.Y is not considered an assignment to A."),(0,i.kt)("p",null,"For the elaboration of B's declaration, Initialize is not called at all. Instead the assignment adjusts B's value; that is, it applies Adjust to B.X, B.Y, and B."),(0,i.kt)("p",null,"Initialize and other initialization operations are done in an arbitrary order, except as follows. Initialize is applied to an object after initialization of its subcomponents, if any ","[(including both implicit initialization and Initialize calls)]",". If an object has a component with an access discriminant constrained by a per-object expression, Initialize is applied to this component after any components that do not have such discriminants. For an object with several components with such a discriminant, Initialize is applied to them in order of their component_declarations. For an allocator, any task activations follow all calls on Initialize. "),(0,i.kt)("p",null,"Reason: The fact that Initialize is done for subcomponents first allows Initialize for a composite object to refer to its subcomponents knowing they have been properly initialized."),(0,i.kt)("p",null,"The fact that Initialize is done for components with access discriminants after other components allows the Initialize operation for a component with a self-referential access discriminant to assume that other components of the enclosing object have already been properly initialized. For multiple such components, it allows some predictability. "),(0,i.kt)("p",null,"When a target object with any controlled parts is assigned a value, ","[either when created or in a subsequent assignment_statement,]"," the assignment operation proceeds as follows: "),(0,i.kt)("p",null,"The value of the target becomes the assigned value."),(0,i.kt)("p",null,"The value of the target is adjusted. "),(0,i.kt)("p",null,"Ramification: If any parts of the object are controlled, abort is deferred during the assignment operation. "),(0,i.kt)("p",null,"To adjust the value of a ","[(nonlimited)]"," composite object, the values of the components of the object are first adjusted in an arbitrary order, and then, if the object is controlled, Adjust is called. Adjusting the value of an elementary object has no effect","[, nor does adjusting the value of a composite object with no controlled parts.]"," "),(0,i.kt)("p",null,"Ramification: Adjustment is never performed for values of a by-reference limited type, since these types do not support copying. "),(0,i.kt)("p",null,"Reason: The verbiage in the Initialize rule about access discriminants constrained by per-object expressions is not necessary here, since such types are limited, and therefore are never adjusted. "),(0,i.kt)("p",null,"For an assignment_statement, ","[ after the name and expression have been evaluated, and any conversion (including constraint checking) has been done,]"," an anonymous object is created, and the value is assigned into it; ","[that is, the assignment operation is applied]",". ","[(Assignment includes value adjustment.)]"," The target of the assignment_statement is then finalized. The value of the anonymous object is then assigned into the target of the assignment_statement. Finally, the anonymous object is finalized. ",'[As explained below, the implementation may eliminate the intermediate anonymous object, so this description subsumes the one given in 5.2, "Assignment Statements".]'," "),(0,i.kt)("p",null,"Reason: An alternative design for user-defined assignment might involve an Assign operation instead of Adjust: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Assign(Target : in out Controlled; Source : in out Controlled);\n\n")),(0,i.kt)("p",null,"Or perhaps even a syntax like this: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'procedure ":="(Target : in out Controlled; Source : in out Controlled);\n\n')),(0,i.kt)("p",null,'Assign (or ":=") would have the responsibility of doing the copy, as well as whatever else is necessary. This would have the advantage that the Assign operation knows about both the target and the source at the same time - it would be possible to do things like reuse storage belonging to the target, for example, which Adjust cannot do. However, this sort of design would not work in the case of unconstrained discriminated variables, because there is no way to change the discriminants individually. For example: '),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Mutable(D : Integer := 0) is\n    record\n        X : Array_Of_Controlled_Things(1..D);\n        case D is\n            when 17 =&gt Y : Controlled_Thing;\n            when others =&gt null;\n        end D;\n    end record;\n\n")),(0,i.kt)("p",null,"An assignment to an unconstrained variable of type Mutable can cause some of the components of X, and the component Y, to appear and/or disappear. There is no way to write the Assign operation to handle this sort of case."),(0,i.kt)("p",null,"Forbidding such cases is not an option - it would cause generic contract model violations. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation is allowed to relax the above rules ","[(for nonlimited controlled types)]"," in the following ways: "),(0,i.kt)("p",null,'Proof: The phrase "for nonlimited controlled types" follows from the fact that all of the following permissions apply to cases involving assignment. It is important because the programmer can count on a stricter semantics for limited controlled types. '),(0,i.kt)("p",null,"For an assignment_statement that assigns to an object the value of that same object, the implementation need not do anything. "),(0,i.kt)("p",null,"Ramification: In other words, even if an object is controlled and a combination of Finalize and Adjust on the object might have a net side effect, they need not be performed. "),(0,i.kt)("p",null,"For an assignment_statement for a noncontrolled type, the implementation may finalize and assign each component of the variable separately (rather than finalizing the entire variable and assigning the entire new value) unless a discriminant of the variable is changed by the assignment. "),(0,i.kt)("p",null,"Reason: For example, in a slice assignment, an anonymous object is not necessary if the slice is copied component-by-component in the right direction, since array types are not controlled (although their components may be). Note that the direction, and even the fact that it's a slice assignment, can in general be determined only at run time. "),(0,i.kt)("p",null,"For an aggregate or function call whose value is assigned into a target object, the implementation need not create a separate anonymous object if it can safely create the value of the aggregate or function call directly in the target object. Similarly, for an assignment_statement, the implementation need not create an anonymous object if the value being assigned is the result of evaluating a name denoting an object (the source object) whose storage cannot overlap with the target. If the source object might overlap with the target object, then the implementation can avoid the need for an intermediary anonymous object by exercising one of the above permissions and perform the assignment one component at a time (for an overlapping array assignment), or not at all (for an assignment where the target and the source of the assignment are the same object). Even if an anonymous object is created, the implementation may move its value to the target object as part of the assignment without re-adjusting so long as the anonymous object has no aliased subcomponents. "),(0,i.kt)("p",null,"Ramification: In the aggregate case, only one value adjustment is necessary, and there is no anonymous object to be finalized."),(0,i.kt)("p",null,"In the assignment_statement case as well, no finalization of the anonymous object is needed. On the other hand, if the target has aliased subcomponents, then an adjustment takes place directly on the target object as the last step of the assignment, since some of the subcomponents may be self-referential or otherwise position-dependent. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Controlled types and user-defined finalization are new to Ada 95. (Ada 83 had finalization semantics only for masters of tasks.) "),(0,i.kt)("h3",{id:"761--completion-and-finalization"},"7.6.1  Completion and Finalization"),(0,i.kt)("p",null,"[This subclause defines completion and leaving of the execution of constructs and entities. A master is the execution of a construct that includes finalization of local objects after it is complete (and after waiting for any local tasks - see 9.3), but before leaving. Other constructs and entities are left immediately upon completion. ]"),(0,i.kt)("h4",{id:"dynamic-semantics-5"},"Dynamic Semantics"),(0,i.kt)("p",null,"The execution of a construct or entity is complete when the end of that execution has been reached, or when a transfer of control (see 5.1) causes it to be abandoned. Completion due to reaching the end of execution, or due to the transfer of control of an exit",(0,i.kt)("em",{parentName:"p"},", return"),", goto_, or requeue_statement or of the selection of a terminate_alternative is normal completion. Completion is abnormal otherwise ","[- when control is transferred out of a construct due to abort or the raising of an exception]",". "),(0,i.kt)("p",null,"Discussion: Don't confuse the run-time concept of completion with the compile-time concept of completion defined in 3.11.1. "),(0,i.kt)("p",null,"After execution of a construct or entity is complete, it is left, meaning that execution continues with the next action, as defined for the execution that is taking place. Leaving an execution happens immediately after its completion, except in the case of a master: the execution of a task_body, a block_statement, a subprogram_body, an entry_body, or an accept_statement. A master is finalized after it is complete, and before it is left."),(0,i.kt)("p",null,"Reason: Note that although an accept_statement has no declarative_part, it can call functions and evaluate aggregates, possibly causing anonymous controlled objects to be created, and we don't want those objects to escape outside the rendezvous."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[R]",",Term=","[master]",", Def=","[the execution of a master construct]",", Note1=","[Each object and task is associated with a master. When a master is left, associated tasks are awaited and associated objects are finalized.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[master construct]",", Def=","[one of certain executable constructs for which there can be objects or tasks whose lifetime ends when the construct completes]",", Note1=","[Execution of a master construct is a master, with which objects and tasks are associated for the purposes of waiting and finalization.]"," For the finalization of a master, dependent tasks are first awaited, as explained in 9.3. Then each object whose accessibility level is the same as that of the master is finalized if the object was successfully initialized and still exists. ","[These actions are performed whether the master is left by reaching the last statement or via a transfer of control.]"," When a transfer of control causes completion of an execution, each included master is finalized in order, from innermost outward. "),(0,i.kt)("p",null,"Ramification: As explained in 3.10.2, the set of objects with the same accessibility level as that of the master includes objects declared immediately within the master, objects declared in nested packages, objects created by allocators (if the ultimate ancestor access type is declared in one of those places) and subcomponents of all of these things. If an object was already finalized by Unchecked_Deallocation, then it is not finalized again when the master is left."),(0,i.kt)("p",null,"Note that any object whose accessibility level is deeper than that of the master would no longer exist; those objects would have been finalized by some inner master. Thus, after leaving a master, the only objects yet to be finalized are those whose accessibility level is less deep than that of the master."),(0,i.kt)("p",null,"To be honest: Subcomponents of objects due to be finalized are not finalized by the finalization of the master; they are finalized by the finalization of the containing object. "),(0,i.kt)("p",null,"Reason: We need to finalize subcomponents of objects even if the containing object is not going to get finalized because it was not fully initialized. But if the containing object is finalized, we don't want to require repeated finalization of the subcomponents, as might normally be implied by the recursion in finalization of a master and the recursion in finalization of an object. "),(0,i.kt)("p",null,'To be honest: Formally, completion and leaving refer to executions of constructs or entities. However, the standard sometimes (informally) refers to the constructs or entities whose executions are being completed. Thus, for example, "the subprogram call or task is complete" really means "the execution of the subprogram call or task is complete". '),(0,i.kt)("p",null,"For the finalization of an object: "),(0,i.kt)("p",null,"If the object is of an elementary type, finalization has no effect; "),(0,i.kt)("p",null,"If the object is of a controlled type, the Finalize procedure is called;"),(0,i.kt)("p",null,"If the object is of a protected type, the actions defined in 9.4 are performed;"),(0,i.kt)("p",null,"If the object is of a composite type, then after performing the above actions, if any, every component of the object is finalized in an arbitrary order, except as follows: if the object has a component with an access discriminant constrained by a per-object expression, this component is finalized before any components that do not have such discriminants; for an object with several components with such a discriminant, they are finalized in the reverse of the order of their component_declarations. "),(0,i.kt)("p",null,"Reason: This allows the finalization of a component with an access discriminant to refer to other components of the enclosing object prior to their being finalized. "),(0,i.kt)("p",null,"Immediately before an instance of Unchecked_Deallocation reclaims the storage of an object, the object is finalized. ","[If an instance of Unchecked_Deallocation is never applied to an object created by an allocator, the object will still exist when the corresponding master completes, and it will be finalized then.]"),(0,i.kt)("p",null,"The order in which the finalization of a master performs finalization of objects is as follows: Objects created by declarations in the master are finalized in the reverse order of their creation. For objects that were created by allocators for an access type whose ultimate ancestor is declared in the master, this rule is applied as though each such object that still exists had been created in an arbitrary order at the first freezing point (see 13.14) of the ultimate ancestor type. "),(0,i.kt)("p",null,"Reason: Note that we talk about the type of the allocator here. There may be access values of a (general) access type pointing at objects created by allocators for some other type; these are not finalized at this point."),(0,i.kt)("p",null,"The freezing point of the ultimate ancestor access type is chosen because before that point, pool elements cannot be created, and after that point, access values designating (parts of) the pool elements can be created. This is also the point after which the pool object cannot have been declared. We don't want to finalize the pool elements until after anything finalizing objects that contain access values designating them. Nor do we want to finalize pool elements after finalizing the pool object itself. "),(0,i.kt)("p",null,'Ramification: Finalization of allocated objects is done according to the (ultimate ancestor) allocator type, not according to the storage pool in which they are allocated. Pool finalization might reclaim storage (see 13.11, "Storage Management"), but has nothing (directly) to do with finalization of the pool elements.'),(0,i.kt)("p",null,"Note that finalization is done only for objects that still exist; if an instance of Unchecked_Deallocation has already gotten rid of a given pool element, that pool element will not be finalized when the master is left."),(0,i.kt)("p",null,"Note that a deferred constant declaration does not create the constant; the full constant declaration creates it. Therefore, the order of finalization depends on where the full constant declaration occurs, not the deferred constant declaration."),(0,i.kt)("p",null,"An imported object is not created by its declaration. It is neither initialized nor finalized. "),(0,i.kt)("p",null,"Implementation Note: An implementation has to ensure that the storage for an object is not reclaimed when references to the object are still possible (unless, of course, the user explicitly requests reclamation via an instance of Unchecked_Deallocation). This implies, in general, that objects cannot be deallocated one by one as they are finalized; a subsequent finalization might reference an object that has been finalized, and that object had better be in its (well-defined) finalized state. "),(0,i.kt)("p",null,"The target of an assignment statement is finalized before copying in the new value, as explained in 7.6."),(0,i.kt)("p",null,"The anonymous objects created by function calls and by aggregates are finalized no later than the end of the innermost enclosing declarative_item or statement; if that is a compound_statement, they are finalized before starting the execution of any statement within the compound_statement. "),(0,i.kt)("p",null,"To be honest: This is not to be construed as permission to call Finalize asynchronously with respect to normal user code. For example, "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"declare\n    X : Some_Controlled_Type := F(G(...));\n    -- The anonymous objects created for F and G are finalized\n    -- no later than this point.\n    Y : ...\nbegin\n    ...\nend;\n\n")),(0,i.kt)("p",null,"The anonymous object for G should not be finalized at some random point in the middle of the body of F, because F might manipulate the same data structures as the Finalize operation, resulting in erroneous access to shared variables. "),(0,i.kt)("p",null,"Reason: It might be quite inconvenient for the implementation to defer finalization of the anonymous object for G until after copying the value of F into X, especially if the size of the result is not known at the call site."),(0,i.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,i.kt)("p",null,"It is a bounded error for a call on Finalize or Adjust to propagate an exception. The possible consequences depend on what action invoked the Finalize or Adjust operation: "),(0,i.kt)("p",null,"Ramification: It is not a bounded error for Initialize to propagate an exception. If Initialize propagates an exception, then no further calls on Initialize are performed, and those components that have already been initialized (either explicitly or by default) are finalized in the usual way."),(0,i.kt)("p",null,"For a Finalize invoked as part of an assignment_statement, Program_Error is raised at that point."),(0,i.kt)("p",null,"For an Adjust invoked as part of an assignment operation, any other adjustments due to be performed are performed, and then Program_Error is raised. "),(0,i.kt)("p",null,"For a Finalize invoked as part of a call on an instance of Unchecked_Deallocation, any other finalizations due to be performed are performed, and then Program_Error is raised. "),(0,i.kt)("p",null,"For a Finalize invoked by the transfer of control of an exit",(0,i.kt)("em",{parentName:"p"},", return"),", goto_, or requeue_statement, Program_Error is raised no earlier than after the finalization of the master being finalized when the exception occurred, and no later than the point where normal execution would have continued. Any other finalizations due to be performed up to that point are performed before raising Program_Error. "),(0,i.kt)("p",null,"Ramification: For example, upon leaving a block_statement due to a goto_statement, the Program_Error would be raised at the point of the target statement denoted by the label, or else in some more dynamically nested place, but not so nested as to allow an exception_handler that has visibility upon the finalized object to handle it. For example, "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Main is\nbegin\n    &lt&ltThe_Label&gt&gt\n    Outer_Block_Statement : declare\n        X : Some_Controlled_Type;\n    begin\n        Inner_Block_Statement : declare\n            Y : Some_Controlled_Type;\n            Z : Some_Controlled_Type;\n        begin\n            goto The_Label;\n        exception\n            when Program_Error =&gt ... -- Handler number 1.\n        end;\n    exception\n        when Program_Error =&gt ... -- Handler number 2.\n    end;\nexception\n    when Program_Error =&gt ... -- Handler number 3.\nend Main;\n\n")),(0,i.kt)("p",null,"The goto_statement will first cause Finalize(Y) to be called. Suppose that Finalize(Y) propagates an exception. Program_Error will be raised after leaving Inner_Block_Statement, but before leaving Main. Thus, handler number 1 cannot handle this Program_Error; it will be handled either by handler number 2 or handler number 3. If it is handled by handler number 2, then Finalize(Z) will be done before executing the handler. If it is handled by handler number 3, then Finalize(Z) and Finalize(X) will both be done before executing the handler. "),(0,i.kt)("p",null,"For a Finalize invoked by a transfer of control that is due to raising an exception, any other finalizations due to be performed for the same master are performed; Program_Error is raised immediately after leaving the master. "),(0,i.kt)("p",null,"Ramification: If, in the above example, the goto_statement were replaced by a raise_statement, then the Program_Error would be handled by handler number 2, and Finalize(Z) would be done before executing the handler. "),(0,i.kt)("p",null,'Reason: We considered treating this case in the same way as the others, but that would render certain exception_handlers useless. For example, suppose the only exception_handler is one for others in the main subprogram. If some deeply nested call raises an exception, causing some Finalize operation to be called, which then raises an exception, then normal execution "would have continued" at the beginning of the exception_handler. Raising Program_Error at that point would cause that handler\'s code to be skipped. One would need two nested exception_handlers to be sure of catching such cases!'),(0,i.kt)("p",null,"On the other hand, the exception_handler for a given master should not be allowed to handle exceptions raised during finalization of that master. "),(0,i.kt)("p",null,"For a Finalize invoked by a transfer of control due to an abort or selection of a terminate alternative, the exception is ignored; any other finalizations due to be performed are performed. "),(0,i.kt)("p",null,"Ramification: This case includes an asynchronous transfer of control. "),(0,i.kt)("p",null,"To be honest: This violates the general principle that it is always possible for a bounded error to raise Program_Error (see ). "),(0,i.kt)("p",null,"NOTE 1   The rules of Section 10 imply that immediately prior to partition termination, Finalize operations are applied to library-level controlled objects (including those created by allocators of library-level access types, except those already finalized). This occurs after waiting for library-level tasks to terminate. "),(0,i.kt)("p",null,"Discussion: We considered defining a pragma that would apply to a controlled type that would suppress Finalize operations for library-level objects of the type upon partition termination. This would be useful for types whose finalization actions consist of simply reclaiming global heap storage, when this is already provided automatically by the environment upon program termination. "),(0,i.kt)("p",null,"NOTE 2   A constant is only constant between its initialization and finalization. Both initialization and finalization are allowed to change the value of a constant."),(0,i.kt)("p",null,"NOTE 3   Abort is deferred during certain operations related to controlled types, as explained in 9.8. Those rules prevent an abort from causing a controlled object to be left in an ill-defined state."),(0,i.kt)("p",null,"NOTE 4   The Finalize procedure is called upon finalization of a controlled object, even if Finalize was called earlier, either explicitly or as part of an assignment; hence, if a controlled type is visibly controlled (implying that its Finalize primitive is directly callable), or is nonlimited (implying that assignment is allowed), its Finalize procedure should be designed to have no ill effect if it is applied a second time to the same object. "),(0,i.kt)("p",null,'Discussion: Or equivalently, a Finalize procedure should be "idempotent"; applying it twice to the same object should be equivalent to applying it once. '),(0,i.kt)("p",null,'Reason: A user-written Finalize procedure should be idempotent since it can be called explicitly by a client (at least if the type is "visibly" controlled). Also, Finalize is used implicitly as part of the assignment_statement if the type is nonlimited, and an abort is permitted to disrupt an assignment_statement between finalizing the left-hand side and assigning the new value to it (an abort is not permitted to disrupt an assignment operation between copying in the new value and adjusting it). '),(0,i.kt)("p",null,"Discussion: Either Initialize or Adjust, but not both, is applied to (almost) every controlled object when it is created: Initialize is done when no initial value is assigned to the object, whereas Adjust is done as part of assigning the initial value. The one exception is the anonymous object created by an aggregate; Initialize is not applied to the aggregate as a whole, nor is the value of the aggregate adjusted."),(0,i.kt)("p",null,"All of the following use the assignment operation, and thus perform value adjustment: "),(0,i.kt)("p",null,"the assignment_statement (see 5.2);"),(0,i.kt)("p",null,"explicit initialization of a stand-alone object (see 3.3.1) or of a pool element (see 4.8);"),(0,i.kt)("p",null,"default initialization of a component of a stand-alone object or pool element (in this case, the value of each component is assigned, and therefore adjusted, but the value of the object as a whole is not adjusted);"),(0,i.kt)("p",null,"function return, when the result type is not a return-by-reference type (see 6.5); (adjustment of the result happens before finalization of the function; values of return-by-reference types are not adjusted);"),(0,i.kt)("p",null,"predefined operators (although the only one that matters is concatenation; see 4.5.3);"),(0,i.kt)("p",null,"generic formal objects of mode in (see 12.4); these are defined in terms of constant declarations; and"),(0,i.kt)("p",null,"aggregates (see 4.3) (in this case, the value of each component, and the parent part, for an extension_aggregate, is assigned, and therefore adjusted, but the value of the aggregate as a whole is not adjusted; neither is Initialize called); "),(0,i.kt)("p",null,"The following also use the assignment operation, but adjustment never does anything interesting in these cases: "),(0,i.kt)("p",null,"By-copy parameter passing uses the assignment operation (see 6.4.1), but controlled objects are always passed by reference, so the assignment operation never does anything interesting in this case. If we were to allow by-copy parameter passing for controlled objects, we would need to make sure that the actual is finalized before doing the copy back for ","[in]"," out parameters. The finalization of the parameter itself needs to happen after the copy back (if any), similar to the finalization of an anonymous function return object or aggregate object."),(0,i.kt)("p",null,"For loops use the assignment operation (see 5.5), but since the type of the loop parameter is never controlled, nothing interesting happens there, either."),(0,i.kt)("p",null,'Because Controlled and Limited_Controlled are library-level tagged types, all controlled types will be library-level types, because of the accessibility rules (see 3.10.2 and 3.9.1). This ensures that the Finalize operations may be applied without providing any "display" or "static-link". This simplifies finalization as a result of garbage collection, abort, and asynchronous transfer of control.'),(0,i.kt)("p",null,"Finalization of the parts of a protected object are not done as protected actions. It is possible (in pathological cases) to create tasks during finalization that access these parts in parallel with the finalization itself. This is an erroneous use of shared variables. "),(0,i.kt)("p",null,"Implementation Note: One implementation technique for finalization is to chain the controlled objects together on a per-task list. When leaving a master, the list can be walked up to a marked place. The links needed to implement the list can be declared (privately) in types Controlled and Limited_Controlled, so they will be inherited by all controlled types."),(0,i.kt)("p",null,'Another implementation technique, which we refer to as the "PC-map" approach essentially implies inserting exception handlers at various places, and finalizing objects based on where the exception was raised.'),(0,i.kt)("p",null,"The PC-map approach is for the compiler/linker to create a map of code addresses; when an exception is raised, or abort occurs, the map can be consulted to see where the task was executing, and what finalization needs to be performed. This approach was given in the Ada 83 Rationale as a possible implementation strategy for exception handling - the map is consulted to determine which exception handler applies."),(0,i.kt)("p",null,"If the PC-map approach is used, the implementation must take care in the case of arrays. The generated code will generally contain a loop to initialize an array. If an exception is raised part way through the array, the components that have been initialized must be finalized, and the others must not be finalized."),(0,i.kt)("p",null,"It is our intention that both of these implementation methods should be possible. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"Finalization depends on the concepts of completion and leaving, and on the concept of a master. Therefore, we have moved the definitions of these concepts here, from where they used to be in Section 9. These concepts also needed to be generalized somewhat. Task waiting is closely related to user-defined finalization; the rules here refer to the task-waiting rules of Section 9."))}p.isMDXComponent=!0}}]);