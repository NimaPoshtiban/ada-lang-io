"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4687],{73393:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var t=i(58168),a=(i(96540),i(15680));const s={title:"4.2 Visibility"},o=void 0,r={unversionedId:"style-guide/s4/02",id:"style-guide/s4/02",title:"4.2 Visibility",description:"Ada's ability to enforce information hiding and separation of concerns",source:"@site/docs/style-guide/s4/02.mdx",sourceDirName:"style-guide/s4",slug:"/style-guide/s4/02",permalink:"/docs/style-guide/s4/02",draft:!1,tags:[],version:"current",frontMatter:{title:"4.2 Visibility"},sidebar:"styleGuideSidebar",previous:{title:"4.1 High-Level Structure",permalink:"/docs/style-guide/s4/01"},next:{title:"4.3 Exceptions",permalink:"/docs/style-guide/s4/03"}},l={},c=[{value:"Minimization of Interfaces",id:"minimization-of-interfaces",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Nested Packages",id:"nested-packages",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Restricting Visibility",id:"restricting-visibility",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-1",level:4},{value:"Hiding Tasks",id:"hiding-tasks",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4}],u={toc:c},d="wrapper";function p(e){let{components:n,...i}=e;return(0,a.yg)(d,(0,t.A)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,'Ada\'s ability to enforce information hiding and separation of concerns\nthrough its visibility controlling features is one of the most important\nadvantages of the language, particularly when "pieces of a large system\nare being developed separately." Subverting these features, for example,\nby excessive reliance on the use clause, is wasteful and dangerous. See\nalso Guidelines 5.7 and 9.4.1.'),(0,a.yg)("h3",{id:"minimization-of-interfaces"},"Minimization of Interfaces"),(0,a.yg)("h4",{id:"guideline"},"guideline"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Put only what is needed for the use of a package into its\nspecification."),(0,a.yg)("li",{parentName:"ul"},"Minimize the number of declarations in package specifications."),(0,a.yg)("li",{parentName:"ul"},"Do not include extra operations simply because they are easy to\nbuild."),(0,a.yg)("li",{parentName:"ul"},"Minimize the context (with) clauses in a package specification."),(0,a.yg)("li",{parentName:"ul"},"Reconsider subprograms that seem to require large numbers of\nparameters."),(0,a.yg)("li",{parentName:"ul"},"Do not manipulate global data within a subprogram or package merely\nto limit the number of parameters."),(0,a.yg)("li",{parentName:"ul"},"Avoid unnecessary visibility; hide the implementation details of a\nprogram unit from its users."),(0,a.yg)("li",{parentName:"ul"},"Use child library units to control the visibility of parts of a\nsubsystem interface."),(0,a.yg)("li",{parentName:"ul"},"Use private child packages for those declarations that should not be\nused outside the subsystem."),(0,a.yg)("li",{parentName:"ul"},"Use child library units present different views of an entity to\ndifferent clients."),(0,a.yg)("li",{parentName:"ul"},"Design (and redesign) interfaces after having worked out the logic\nof various expected clients of the interface.")),(0,a.yg)("h4",{id:"example"},"example"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ada"},"-------------------------------------------------------------------------\npackage Telephone_Book is\n   type Listing is limited private;\n   procedure Set_Name (New_Name : in     String;\n                       Current  : in out Listing);\n   procedure Insert (Name    : in     String;\n                     Current : in out Listing);\n   procedure Delete (Obsolete : in     String;\n                     Current  : in out Listing);\nprivate\n   type Information;\n   type Listing is access Information;\nend Telephone_Book;\n-------------------------------------------------------------------------\npackage body Telephone_Book is\n   -- Full details of record for a listing\n   type Information is\n      record\n         ...\n         Next : Listing;\n      end record;\n   First : Listing;\n   procedure Set_Name (New_Name : in     String;\n                       Current  : in out Listing) is separate;\n   procedure Insert (Name    : in      String;\n                     Current : in out  Listing) is separate;\n   procedure Delete (Obsolete : in     String;\n                     Current  : in out Listing) is separate;\nend Telephone_Book;\n-------------------------------------------------------------------------\n")),(0,a.yg)("h4",{id:"rationale"},"rationale"),(0,a.yg)("p",null,'For each entity in the specification, give careful consideration to\nwhether it could be moved to a child package or to the parent package\nbody. The fewer the extraneous details, the more understandable the\nprogram, package, or subprogram. It is important to maintainers to know\nexactly what a package interface is so that they can understand the\neffects of changes. Interfaces to a subprogram extend beyond the\nparameters. Any modification of global data from within a package or\nsubprogram is an undocumented interface to the "outside" as well.'),(0,a.yg)("p",null,"Minimize the context clauses on a specification by moving unnecessary\nclauses to the body. This technique makes the reader's job easier,\nlocalizes the recompilation required when library units change, and\nhelps prevent a ripple effect during modifications. See also Guideline\n4.2.3."),(0,a.yg)("p",null,"Subprograms with large numbers of parameters often indicate poor design\ndecisions (e.g., the functional boundaries of the subprogram are\ninappropriate or parameters are structured poorly). Conversely,\nsubprograms with no parameters are likely to be accessing global data."),(0,a.yg)("p",null,"Objects visible within package specifications can be modified by any\nunit that has visibility to them. The object cannot be protected or\nrepresented abstractly by its enclosing package. Objects that must\npersist should be declared in package bodies. Objects whose value\ndepends on program units external to their enclosing package are\nprobably either in the wrong package or are better accessed by a\nsubprogram specified in the package specification."),(0,a.yg)("p",null,"Child library units can provide distinct views of the hierarchical\nlibrary. The engineer can provide a different view for the client than\nfor the implementor (Rationale 1995, \xa710.1). By creating private child\npackages, the engineer can provide facilities that are only available\ninside the subsystem rooted at the parent library unit. The declarations\ninside a private child package specification are not exported outside\nthe subsystem. Thus, the engineer can declare utilities needed to\nimplement an abstraction in a private child package (e.g., debugging\nutilities ","[","Cohen et al. 1993","]",") and be certain that users of the\nabstraction (i.e., the clients) cannot access these utilities."),(0,a.yg)("p",null,"Different clients may have different needs for essentially the same\nresource. Instead of having multiple versions of the resources, consider\nhaving child units that export different views for different purposes."),(0,a.yg)("p",null,'Designing an interface based strictly on predicting what clients "might"\nneed can produce a bloated and inappropriate interface. What then\nhappens is that clients try to "live" with the interface and work around\nthe inappropriate interfaces, repeating code that logically should be\npart of the shared abstraction. See Guideline 8.3.1 for a discussion of\ninterfaces from the reusability perspective.'),(0,a.yg)("h4",{id:"notes"},"notes"),(0,a.yg)("p",null,"In some cases, subroutine libraries look like large, monolithic\npackages. In such cases, it may be beneficial to break these up into\nsmaller packages, grouping them according to category (e.g.,\ntrigonometric functions)."),(0,a.yg)("h3",{id:"nested-packages"},"Nested Packages"),(0,a.yg)("h4",{id:"guideline-1"},"guideline"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Use child packages rather than nested packages to present different\nviews of the same abstraction."),(0,a.yg)("li",{parentName:"ul"},"Nest package specifications within another package specification\nonly for grouping operations or hiding common implementation\ndetails.")),(0,a.yg)("h4",{id:"example-1"},"example"),(0,a.yg)("p",null,"Annex A of the Ada Reference Manual (1995) gives an example of package\nspecification nesting. The specification of the generic package\nGeneric_Bounded_Length is nested inside the specification of package\nAda.Strings.Bounded. The nested package is a generic, grouping closely\nrelated operations."),(0,a.yg)("h4",{id:"rationale-1"},"rationale"),(0,a.yg)("p",null,"Grouping package specifications into an encompassing package emphasizes\na relationship of commonality among those packages. It also allows them\nto share common implementation details resulting from the relationship.\nNesting packages allows you to organize the name space of the package in\ncontrast to the semantic effect of nesting inside of subprograms or task\nbodies."),(0,a.yg)("p",null,"An abstraction occasionally needs to present different views to\ndifferent classes of users. Building one view upon another as an\nadditional abstraction does not always suffice because the functionality\nof the operations presented by the views may be only partially\ndisjointed. Nesting specifications groups the facilities of the various\nviews, yet associates them with the abstraction they present. Abusive\nmixing of the views by another unit would be easy to detect due to the\nmultiple use clauses or an incongruous mix of qualified names."),(0,a.yg)("p",null,"See the rationale discussed in Guideline 4.2.1."),(0,a.yg)("h3",{id:"restricting-visibility"},"Restricting Visibility"),(0,a.yg)("h4",{id:"guideline-2"},"guideline"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Consider using private child packages in lieu of nesting."),(0,a.yg)("li",{parentName:"ul"},"Restrict the visibility of program units as much as possible by\nnesting them inside package bodies (Nissen and Wallis 1984) if you\ncannot use a private child package."),(0,a.yg)("li",{parentName:"ul"},"Minimize nesting program units inside subprograms and tasks."),(0,a.yg)("li",{parentName:"ul"},"Minimize the scope within which with clauses apply."),(0,a.yg)("li",{parentName:"ul"},"Only with those units directly needed.")),(0,a.yg)("h4",{id:"example-2"},"example"),(0,a.yg)("p",null,"This program illustrates the use of child library units to restrict\nvisibility. The procedure Rational_Numbers.Reduce is nested inside the\nbody of Rational_Numbers to restrict its visibility to the\nimplementation of this abstraction. Rather than make the text\ninput/output facilities visible to the entire rational number hierarchy,\nit is only available to the body of the child library\nRational_Numbers.IO. This example is adapted from the Ada Reference\nManual (1995, \xa7\xa77.1, 7.2, and 10.1.1):"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ada"},'-------------------------------------------------------------------------\npackage Rational_Numbers is\n   type Rational is private;\n   function "=" (X, Y: Rational) return Boolean;\n   function "/" (X, Y: Integer)  return Rational;  -- construct a rational number\n   function "+" (X, Y: Rational) return Rational;\n   function "-" (X, Y: Rational) return Rational;\n   function "*" (X, Y: Rational) return Rational;\n   function "/" (X, Y: Rational) return Rational;  -- rational division\nprivate\n   ...\nend Rational_Numbers;\npackage body Rational_Numbers is\n   procedure Reduce (R :in out Rational) is . . . end Reduce;\n   . . .\nend Rational_Numbers;\npackage Rational_Numbers.IO is\n   procedure Put (R : in  Rational);\n   procedure Get (R : out Rational);\nend Rational_Numbers.IO;\nwith Ada.Text_IO;\nwith Ada.Integer_Text_IO;\npackage body Rational_Numbers.IO is   -- has visibility to parent private type declaration\n   procedure Put (R : in  Rational) is\n   begin\n      Ada.Integer_Text_IO.Put (Item => R.Numerator, Width => 0);\n      Ada.Text_IO.Put ("/");\n      Ada.Integer_Text_IO.Put (Item => R.Denominator, Width => 0);\n   end Put;\n   procedure Get (R : out Rational) is . . . end Get;\nend Rational_Numbers.IO;\n')),(0,a.yg)("h4",{id:"rationale-2"},"rationale"),(0,a.yg)("p",null,"Restricting visibility of a program unit ensures that the program unit\nis not called from some part of the system other than that which was\nintended. This is done by nesting it inside the only unit that uses it,\nby hiding it inside a package body rather than declaring it in the\npackage specification, or by declaring it as a private child unit. This\navoids errors and eases the job of maintainers by guaranteeing that a\nlocal change in that unit will not have an unforeseen global effect."),(0,a.yg)("p",null,"Restricting visibility of a library unit by using with clauses on\nsubunits rather than on the entire parent unit is useful in the same\nway. In the example above, it is clear that the package Text_IO is used\nonly by the Listing_Facilities package of the compiler."),(0,a.yg)("p",null,"Nesting inside subprograms and tasks is discouraged because it leads to\nunreusable components. These components are essentially unreusable\nbecause they make undesirable up-level references into the defining\ncontext. Unless you truly want to ensure that the program unit is not\ncalled from some unintended part of the system, you should minimize this\nform of nesting."),(0,a.yg)("p",null,"See also Guideline 4.2.1 for a discussion of the use of child units."),(0,a.yg)("h4",{id:"notes-1"},"notes"),(0,a.yg)("p",null,"One way to minimize the coverage of a with clause is to use it only with\nsubunits that really need it. Consider making those subunits separate\ncompilation units when the need for visibility to a library unit is\nrestricted to a subprogram or two."),(0,a.yg)("h3",{id:"hiding-tasks"},"Hiding Tasks"),(0,a.yg)("h4",{id:"guideline-3"},"guideline"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Carefully consider encapsulation of tasks.")),(0,a.yg)("h4",{id:"example-3"},"example"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ada"},"-------------------------------------------------------------------------\npackage Disk_Head_Scheduler is\n   type Words        is ...\n   type Track_Number is ...\n   procedure Transmit (Track : in     Track_Number;\n                       Data  : in     Words);\n   ...\nend Disk_Head_Scheduler;\n-------------------------------------------------------------------------\npackage body Disk_Head_Scheduler is\n   ...\n   task Control is\n      entry Sign_In (Track : in     Track_Number);\n      ...\n   end Control;\n   ----------------------------------------------------------------------\n   task Track_Manager is\n      entry Transfer(Track_Number) (Data : in     Words);\n   end Track_Manager;\n   ----------------------------------------------------------------------\n   ...\n   procedure Transmit (Track : in     Track_Number;\n                       Data  : in     Words) is\n   begin\n      Control.Sign_In(Track);\n      Track_Manager.Transfer(Track)(Data);\n   end Transmit;\n   ----------------------------------------------------------------------\n   ...\nend Disk_Head_Scheduler;\n-------------------------------------------------------------------------\n")),(0,a.yg)("h4",{id:"rationale-3"},"rationale"),(0,a.yg)("p",null,"The decision whether to declare a task in the specification or body of\nan enclosing package is not a simple one. There are good arguments for\nboth."),(0,a.yg)("p",null,"Hiding a task specification in a package body and exporting (via\nsubprograms ) only required entries reduces the amount of extraneous\ninformation in the package specification. It allows your subprograms to\nenforce any order of entry calls necessary to the proper operation of\nthe tasks. It also allows you to impose defensive task communication\npractices (see Guideline 6.2.2) and proper use of conditional and timed\nentry calls. Finally, it allows the grouping of entries into sets for\nexport to different classes of users (e.g., producers versus consumers)\nor the concealment of entries that should not be made public at all\n(e.g., initialization, completion, signals). Where performance is an\nissue and there are no ordering rules to enforce, the entries can be\nrenamed as subprograms to avoid the overhead of an extra procedure call."),(0,a.yg)("p",null,"An argument, which can be viewed as an advantage or disadvantage, is\nthat hiding the task specification in a package body hides the fact of a\ntasking implementation from the user. If the application is such that a\nchange to or from a tasking implementation or a reorganization of\nservices among tasks need not concern users of the package, then this is\nan advantage. However, if the package user must know about the tasking\nimplementation to reason about global tasking behavior, then it is\nbetter not to hide the task completely. Either move it to the package\nspecification or add comments stating that there is a tasking\nimplementation, describing when a call may block, etc. Otherwise, it is\nthe package implementor's responsibility to ensure that users of the\npackage do not have to concern themselves with behaviors such as\ndeadlock, starvation, and race conditions."),(0,a.yg)("p",null,"Finally, keep in mind that hiding tasks behind a procedural interface\nprevents the usage of conditional and timed entry calls and entry\nfamilies, unless you add parameters and extra code to the procedures to\nmake it possible for callers to direct the procedures to use these\ncapabilities."))}p.isMDXComponent=!0}}]);