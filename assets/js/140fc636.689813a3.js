"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6157],{1646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>A,default:()=>b,frontMatter:()=>k,metadata:()=>h,toc:()=>y});var a=n(1716),o=n(7556),l=n(9464),r=Object.defineProperty,i=Object.defineProperties,s=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,p=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))m.call(t,n)&&p(e,n,t[n]);if(u)for(var n of u(t))d.call(t,n)&&p(e,n,t[n]);return e};const k={sidebar_position:106},A="13.4 Enumeration Representation Clauses",h={unversionedId:"arm/AA-13/AA-13.4",id:"arm/AA-13/AA-13.4",title:"13.4 Enumeration Representation Clauses",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-13/AA-13.4.mdx",sourceDirName:"arm/AA-13",slug:"/arm/AA-13/AA-13.4",permalink:"/docs/arm/AA-13/AA-13.4",draft:!1,tags:[],version:"current",sidebarPosition:106,frontMatter:{sidebar_position:106},sidebar:"referenceManualSidebar",previous:{title:"13.3 Operational and Representation Attributes",permalink:"/docs/arm/AA-13/AA-13.3"},next:{title:"13.5 Record Layout",permalink:"/docs/arm/AA-13/AA-13.5"}},f={},y=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4}],g={toc:y};function b(e){var t,n=e,{components:r}=n,p=((e,t)=>{var n={};for(var a in e)m.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&u)for(var a of u(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},g),p),i(t,s({components:r,mdxType:"MDXLayout"}))),(0,a.kt)("h1",c({},{id:"134-enumeration-representation-clauses"}),"13.4 Enumeration Representation Clauses"),(0,a.kt)("admonition",c({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,a.kt)("a",c({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause"))," specifies the internal codes for enumeration literals.] ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"enumeration_representation_clause"),(0,a.kt)("a",{id:"S0350"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"    ",(0,a.kt)("strong",null,"for")," ",(0,a.kt)("em",null,"first_subtype_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0345"},"local_name"))," ",(0,a.kt)("strong",null,"use")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0351"},"enumeration_aggregate")),";",(0,a.kt)("br",null)),(0,a.kt)("p",null,(0,a.kt)("code",null,"enumeration_aggregate"),(0,a.kt)("a",{id:"S0351"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0113"},"array_aggregate")),(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0351"},"enumeration_aggregate"))," shall be written as a one-dimensional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0113"},"array_aggregate")),", for which the index subtype is the unconstrained subtype of the enumeration type, and each component expression is expected to be of any integer type. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'The "full coverage rules" for ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),"s applies. An ",(0,a.kt)("strong",null,"others")," is not allowed - there is no applicable index constraint in this context. ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",null,"first_subtype_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0345"},"local_name"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause"))," shall denote an enumeration subtype. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"As for all type-related representation items, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0345"},"local_name"))," is required to denote a first subtype. ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00287-01"),"}"," Each component of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0113"},"array_aggregate"))," shall be given by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," rather than a ","<",">",". The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s given in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0113"},"array_aggregate"))," shall be static, and shall specify distinct integer codes for each value of the enumeration type; the associated integer codes shall satisfy the predefined ordering relation of the type. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Each value of the enumeration type has to be given an internal code, even if the first subtype of the enumeration type is constrained to only a subrange (this is only possible if the enumeration type is a derived type). This \"full coverage\" requirement is important because one may refer to Enum'Base'First and Enum'Base'Last, which need to have defined representations. ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause"))," specifies the ",(0,a.kt)("em",null,"coding")," aspect of representation. The coding consists of the ",(0,a.kt)("em",null,"internal code")," for each enumeration literal, that is, the integral value used internally to represent each literal.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Coding: "),"Internal representation of enumeration literals. Specified by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),", not by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),".",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"implementation-requirements"}),"Implementation Requirements"),(0,a.kt)("p",null,"For nonboolean enumeration types, if the coding is not specified for the type, then for each value of the type, the internal code shall be equal to its position number. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"This default representation is already used by all known Ada compilers for nonboolean enumeration types. Therefore, we make it a requirement so users can depend on it, rather than feeling obliged to supply for every enumeration type an enumeration representation clause that is equivalent to this default rule. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"For boolean types, it is relatively common to use all ones for True, and all zeros for False, since some hardware supports that directly. Of course, for a one-bit Boolean object (like in a packed array), False is presumably zero and True is presumably one (choosing the reverse would be extremely unfriendly!). ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"implementation-advice"}),"Implementation Advice"),(0,a.kt)("p",null,"The recommended level of support for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),"s is: ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0444-1"),"}"," An implementation should support at least the internal codes in the range System.Min_Int .. System.Max_Int. An implementation is not required to support ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),"s for boolean types. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The implementation may support numbers outside the above range, such as numbers greater than System.Max_Int. See AI83-00564. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The benefits of specifying the internal coding of a boolean type do not outweigh the implementation costs. Consider, for example, the implementation of the logical operators on a packed array of booleans with strange internal codes. It's implementable, but not worth it. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},(0,a.kt)("strong",null),"The recommended level of support for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),"s should be followed.",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0237-1"),"}"," For every discrete subtype S, the following attributes are defined: ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"S'Enum_Rep","{",(0,a.kt)("em",null,"AI12-0237-1"),"}"," S'Enum_Rep denotes a function with the following specification: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"function S'Enum_Rep (Arg : S'Base) return universal_integer","\n"),(0,a.kt)("p",null,"This function returns the representation value of the value of Arg, as a value of type ",(0,a.kt)("em",null,"universal_integer"),". The ",(0,a.kt)("em",null,"representation value")," is the internal code specified in an enumeration representation clause, if any, for the type corresponding to the value of Arg, and otherwise is the position number of the value.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"S'Enum_Val","{",(0,a.kt)("em",null,"AI12-0237-1"),"}"," S'Enum_Val denotes a function with the following specification: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"function S'Enum_Val (Arg : universal_integer) return S'Base","\n"),(0,a.kt)("p",null,"This function returns a value of the type of S whose representation value equals the value of Arg. For the evaluation of a call on S'Enum_Val, if there is no value in the base range of its type with the given representation value, Constraint_Error is raised.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"We define these on all discrete types so that they can be used inside of a generic unit on a subtype of a generic formal discrete type. They're not useful on integer types (they have the same effect as S'Pos and S'Val). ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE   ","{",(0,a.kt)("em",null,"8652/0009"),"}"," ","{",(0,a.kt)("em",null,"AI95-00137-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0237-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," Attribute Enum_Rep can be used to query the internal codes used for an enumeration type; attribute Enum_Val can be used to convert from an internal code to an enumeration value. The other attributes of the type, such as Succ, Pred, and Pos, are unaffected by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),". For example, Pos always returns the position number, ",(0,a.kt)("em",null,"not")," an internal integer code that was specified in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),". ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Suppose the enumeration type in question is derived: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"type T1 is (Red, Green, Blue);","\n","subtype S1 is T1 range Red .. Green;","\n","type S2 is new S1;","\n","for S2 use (Red =",">"," 10, Green =",">"," 20, Blue =",">"," 30);","\n"),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"8652/0009"),"}"," ","{",(0,a.kt)("em",null,"AI95-00137-01"),"}"," The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause"))," has to specify values for all enumerals, even ones that are not in S2 (such as Blue). The Base attribute can be used to get at these values. For example: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"for I in S2'Base loop","\n","    ... -- When I equals Blue, the internal code is 30.","\n","end loop;","\n"),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'We considered allowing or requiring "',(0,a.kt)("strong",null,"for")," S2'Base ",(0,a.kt)("strong",null,"use")," ...\" in cases like this, but it didn't seem worth the trouble. ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"examples"}),"Examples"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0312-1"),"}"," ",(0,a.kt)("em",null,"Examples of enumeration representation clauses:")," ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);","\n","for Mix_Code use","\n","   (ADD =",">"," 1, SUB =",">"," 2, MUL =",">"," 3, LDA =",">"," 8, STA =",">"," 24, STZ =",">","33);","\n","--  ","{","AI12-0312-1","}","\n"," -- See 3.5.2.","\n","for Roman_Digit use ('I' =",">"," 1,","\n","                     'V' =",">"," 5,","\n","                     'X' =",">"," 10,","\n","                     'L' =",">"," 50,","\n","                     'C' =",">"," 100,","\n","                     'D' =",">"," 500,","\n","                     'M' =",">"," 1000);","\n","--  ","{","AI12-0312-1","}","\n"," -- For an example of the use of attribute Enum_Rep, see 4.2.1.","\n"),(0,a.kt)("h4",c({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"As in other similar contexts, Ada 95 allows expressions of any integer type, not just expressions of type ",(0,a.kt)("em",null,"universal_integer"),", for the component expressions in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0351"},"enumeration_aggregate")),". The preference rules for the predefined operators of ",(0,a.kt)("em",null,"root_integer")," eliminate any ambiguity.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'For portability, we now require that the default coding for an enumeration type be the "obvious" coding using position numbers. This is satisfied by all known implementations. ',(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"8652/0009"),"}"," ","{",(0,a.kt)("em",null,"AI95-00137-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Updated to reflect that we no longer have something called ",(0,a.kt)("code",null,"representation_clause"),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00287-01"),"}"," Added wording to prevent the use of ","<",">"," in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.4#S0350"},"enumeration_representation_clause")),". (","<",">"," is newly added to ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0113"},"array_aggregate")),"s.) ",(0,a.kt)("br",null)),(0,a.kt)("h4",c({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0237-1"),"}"," Attributes Enum_Rep and Enum_Val are new. ",(0,a.kt)("br",null)))}b.isMDXComponent=!0}}]);