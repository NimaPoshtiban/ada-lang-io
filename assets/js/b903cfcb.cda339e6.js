"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7855],{1716:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>d});var n=a(6687);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),c=l(a),d=r,u=c["".concat(p,".").concat(d)]||c[d]||m[d]||i;return a?n.createElement(u,s(s({ref:t},h),{},{components:a})):n.createElement(u,s({ref:t},h))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8224:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var n=a(9440),r=(a(6687),a(1716));const i={sidebar_position:89},s="11.3  Raise Statements and Raise Expressions",o={unversionedId:"arm/AA-11.3",id:"arm/AA-11.3",title:"11.3  Raise Statements and Raise Expressions",description:"A [raise_statement raises an exception.]",source:"@site/docs/arm/AA-11.3.md",sourceDirName:"arm",slug:"/arm/AA-11.3",permalink:"/docs/arm/AA-11.3",draft:!1,tags:[],version:"current",sidebarPosition:89,frontMatter:{sidebar_position:89},sidebar:"tutorialSidebar",previous:{title:"11.2  Exception Handlers",permalink:"/docs/arm/AA-11.2"},next:{title:"11.4  Exception Handling",permalink:"/docs/arm/AA-11.4"}},p={},l=[{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4}],h={toc:l};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"113--raise-statements-and-raise-expressions"},"11.3  Raise Statements and Raise Expressions"),(0,r.kt)("p",null,"[A ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," raises an exception.] "),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"{AI95-00361-01} raise",(0,r.kt)("em",{parentName:"p"},"statement",(0,r.kt)("a",{id:"S0308"})," ::= raise;\n| raise exception"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," [with string_",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"];"),(0,r.kt)("p",null,"{AI12-0022-1} {AI12-0152-1} raise",(0,r.kt)("em",{parentName:"p"},"expression",(0,r.kt)("a",{id:"S0309"})," ::= raise exception"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," [with string_",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"]"),(0,r.kt)("p",null,"{AI12-0152-1} If a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," appears within the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of one of the following contexts, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," shall appear within a pair of parentheses within the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),": "),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.3#S0032"},"object_declaration"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),";"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-4.3#S0112"},"ancestor_part"),". "),(0,r.kt)("p",null,'Reason: Unlike conditional expressions, this doesn\'t say "immediately surrounded"; the only requirement is that it is somehow within a pair of parentheses that is part of the ',(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),". We need this restriction in order that ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression"),"s cannot be syntactically confused with immediately following constructs (such as ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s). "),(0,r.kt)("p",null,"Discussion: We only need to require that a right parenthesis appear somewhere between the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," and the surrounding context; that's all we need to specify in order to eliminate the ambiguities. Moreover, we don't care at all where the left parenthesis is (so long as it is legal, of course)."),(0,r.kt)("p",null,"For instance, the following is illegal by this rule: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Obj : Boolean := Func_Call or else raise TBD_Error with Atomic;\n\n")),(0,r.kt)("p",null,'as the "with Atomic" could be part of the raise_expression or part of the object declaration. Both of the following are legal: '),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Obj : Boolean := Func_Call or else (raise TBD_Error) with Atomic;\nObj : Boolean := (Func_Call or else raise TBD_Error) with Atomic;\n\n")),(0,r.kt)("p",null,"and if the with belongs to the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression"),", then both of the following are legal: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Obj : Boolean := Func_Call or else (raise TBD_Error with Atomic);\nObj : Boolean := (Func_Call or else raise TBD_Error with Atomic);\n\n")),(0,r.kt)("p",null,"This rule only requires parentheses for ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression"),'s that are part of the "top-level" of an ',(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," in one of the named contexts; the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," is either the entire ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),", or part of a chain of logical operations. In practice, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," will almost always be last in interesting top-level ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s; anything that follows it could never be executed, so that should be rare. Other contexts such as conditional expressions, qualified expressions, aggregates, and even function calls, provide the needed parentheses. All of the following are legal, no additional parens are needed: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Pre : Boolean  := (if not Is_Valid(Param) then raise Not_Valid_Error);\nA : A_Tagged   := (Some_Tagged'(raise TBD_Error) with Comp =&gt 'A');\nB : Some_Array := (1, 2, 3, others =&gt raise Not_Valid_Error);\nC : Natural    := Func (Val =&gt raise TBD_Error);\n\n")),(0,r.kt)("p",null,"Parentheses that are part of the context of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," don't count. For instance, the parentheses around the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," are required in the following: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"D : A_Tagged   := ((raise TBD_Error) with Comp =&gt 'A');\n\n")),(0,r.kt)("p",null,"as ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.3#S0112"},"ancestor_part")," is one of the contexts that triggers the rule."),(0,r.kt)("p",null,"This English-language rule could have been implemented instead by adding nonterminals initial_expression and initial_relation, which are the same as ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0133"},"choice_expression")," and ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0134"},"choice_relation")," except for the inclusion of membership in initial_relation. Then, initial_expresion could be used in place of ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," in all of the contexts noted. We did not do that because of the large amount of change required, both to the grammar and to language rules that refer to the grammar. A complete grammar is given in AI12-0152-1."),(0,r.kt)("p",null,"The use of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," is illegal in each of ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition"),", ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition"),", ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition"),", and ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition")," as these uses are required to be static and a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," is never static. We include these in this rule so that Ada text has an unambiguous syntax in these cases. "),(0,r.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,r.kt)("p",null,"{AI12-0022-1} {AI12-0159-1} The exception",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"./AA-4.1#S0091"},"name"),", if any, of a ",(0,r.kt)("a",{parentName:"em",href:"./AA-11.3#S0308"},"raise_statement")," or ",(0,r.kt)("a",{parentName:"em",href:"./AA-11.3#S0309"},"raise_expression")," shall denote an exception. A ",(0,r.kt)("a",{parentName:"em",href:"./AA-11.3#S0308"},"raise_statement")," with no exception"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," (that is, a re-raise statement) shall be within a handler, but not within a body enclosed by that handler. "),(0,r.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,r.kt)("p",null,"{AI95-00361-01} {AI12-0022-1} {AI12-0152-1} The string",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," or string"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),", if any, of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," or ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," is expected to be of type String."),(0,r.kt)("p",null,"{AI12-0022-1} {AI12-0159-1} The expected type for a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," shall be any single type. "),(0,r.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,r.kt)("p",null,"{AI95-00361-01} {AI12-0022-1} {AI12-0152-1} To raise an exception is to raise a new occurrence of that exception","[, as explained in 11.4]",". For the execution of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," with an exception",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"./AA-4.1#S0091"},"name"),", the named exception is raised. Similarly, for the evaluation of a ",(0,r.kt)("a",{parentName:"em",href:"./AA-11.3#S0309"},"raise_expression"),", the named exception is raised. [In both of these cases, if a string"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," or string_",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," is present, the expression is evaluated and its value is associated with the exception occurrence.] For the execution of a re-raise statement, the exception occurrence that caused transfer of control to the innermost enclosing handler is raised ","[again]",". "),(0,r.kt)("p",null,"Proof: {AI95-00361-01} The definition of Exceptions.Exception_Message includes a statement that the string is returned (see 11.4.1). We describe the use of the string here so that we don't have an unexplained parameter in this subclause. "),(0,r.kt)("p",null,"Implementation Note: For a re-raise statement, the implementation does not create a new Exception_Occurrence, but instead propagates the same Exception_Occurrence value. This allows the original cause of the exception to be determined. "),(0,r.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[E]",",Term=","[raise an exception]",", Def=","[to abandon normal program execution so as to draw attention to the fact that the corresponding situation has arisen]"," "),(0,r.kt)("p",null,"NOTE 1   {AI12-0062-1} {AI12-0152-1} {AI12-0159-1} If the evaluation of a string",(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," or string"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," raises an exception, that exception is propagated instead of the one denoted by the exception_",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," or ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression"),". "),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Examples of raise statements: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},'{AI95-00433-01} raise Ada.IO_Exceptions.Name_Error;   -- see A.13\nraise Queue_Error with "Buffer Full"; -- see 9.11\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"raise;                                -- re-raise the current exception\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} -- For an example of a raise expression, see the Streams Subsystem definitions in 13.13.1.\n\n")),(0,r.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"The fact that the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," in a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," has to denote an exception is not clear from RM83. Clearly that was the intent, since the italicized part of the syntax rules so indicate, but there was no explicit rule. RM83-1.5(11) doesn't seem to give the italicized parts of the syntax any force. "),(0,r.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,r.kt)("p",null,"{AI95-00361-01} The syntax of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0308"},"raise_statement")," is extended to include a string message. This is more convenient than calling Exceptions.Exception",(0,r.kt)("em",{parentName:"p"},"Message (exception"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name"),"'Identity, string_",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"), and should encourage the use of message strings when raising exceptions. "),(0,r.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,r.kt)("p",null,"{AI12-0022-1} {AI12-0152-1} {AI12-0159-1} Corrigendum: The ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," is new. This construct is necessary to allow conversion of existing specifications to use preconditions and predicates without changing the exceptions raised. It is considered important enough to be added to Ada 2012 rather than waiting for Ada 2022."))}m.isMDXComponent=!0}}]);