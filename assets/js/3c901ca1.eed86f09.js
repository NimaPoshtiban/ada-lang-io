"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8028],{609:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>T,frontMatter:()=>f,metadata:()=>y,toc:()=>x});var n=a(1716),o=a(3050),r=a(8604),i=a(7318),l=a(4768),s=Object.defineProperty,d=Object.defineProperties,p=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,k=(e,t)=>{for(var a in t||(t={}))A.call(t,a)&&m(e,a,t[a]);if(u)for(var a of u(t))c.call(t,a)&&m(e,a,t[a]);return e};const f={sidebar_position:56},h="6.6 Overloading of Operators",y={unversionedId:"arm/AA-6/AA-6.6",id:"arm/AA-6/AA-6.6",title:"6.6 Overloading of Operators",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-6/AA-6.6.mdx",sourceDirName:"arm/AA-6",slug:"/arm/AA-6/AA-6.6",permalink:"/docs/arm/AA-6/AA-6.6",draft:!1,tags:[],version:"current",sidebarPosition:56,frontMatter:{sidebar_position:56},sidebar:"referenceManualSidebar",previous:{title:"6.5 Return Statements",permalink:"/docs/arm/AA-6/AA-6.5"},next:{title:"6.7 Null Procedures",permalink:"/docs/arm/AA-6/AA-6.7"}},g={},x=[{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}],b={toc:x};function T(e){var t,a=e,{components:s}=a,m=((e,t)=>{var a={};for(var n in e)A.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&u)for(var n of u(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=k(k({},b),m),d(t,p({components:s,mdxType:"MDXLayout"}))),(0,n.kt)("h1",k({},{id:"66-overloading-of-operators"}),"6.6 Overloading of Operators"),(0,n.kt)("admonition",k({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.kt)("a",k({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)(i.Z,{mdxType:"MarginText"},"1"),(0,n.kt)("p",null,"An ",(0,n.kt)("em",null,"operator")," is a function whose ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0199"},"designator"))," is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),". [Operators, like other functions, may be overloaded.] ",(0,n.kt)("br",null)),(0,n.kt)("h4",k({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"2"),(0,n.kt)("p",null,"Each use of a unary or binary operator is equivalent to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," with ",(0,n.kt)("em",null,"function_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," being the corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),", and with (respectively) one or two positional actual parameters being the operand(s) of the operator (in order). ",(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"2.a/3"),(0,n.kt)(l.Z,{items:["AI05-0299-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"To be honest: "),"We also use the term operator (in Clause 4 and in ",(0,n.kt)("a",{href:"../AA-6/AA-6.1"},"6.1"),") to refer to one of the syntactic categories defined in ",(0,n.kt)("a",{href:"../AA-4/AA-4.5"},"4.5"),", \u201c",(0,n.kt)("a",{href:"../AA-4/AA-4.5"},"Operators and Expression Evaluation"),"\u201d whose names end with \u201c_operator:\u201d ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0142"},"logical_operator")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0143"},"relational_operator")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0144"},"binary_adding_operator")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0145"},"unary_adding_operator")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0146"},"multiplying_operator")),", and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0147"},"highest_precedence_operator")),". ",(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"2.b/3"),(0,n.kt)(l.Z,{items:["AI05-0005-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This equivalence extends to uses of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," in most other language rules. However, as often happens, the equivalence is not perfect, as operator calls are not a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", while a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". Thus, operator calls cannot be used in contexts that require a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," (such as a rename of an object). A direct fix for this problem would be very disruptive, and thus we have not done that. However, qualifying an operator call can be used as a workaround in contexts that require a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",k({},{id:"legality-rules"}),"Legality Rules"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"3/3"),(0,n.kt)(l.Z,{items:["AI05-0143-1"],mdxType:"MarginInfo"}),(0,n.kt)("p",null,"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," of a unary or binary operator shall have one or two parameters, respectively. The parameters shall be of mode ",(0,n.kt)("strong",null,"in"),". A generic function instantiation whose ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0199"},"designator"))," is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," is only allowed if the specification of the generic function has the corresponding number of parameters, and they are all of mode ",(0,n.kt)("strong",null,"in"),".",(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"4"),(0,n.kt)("p",null,(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"Default_expression")),"s are not allowed for the parameters of an operator (whether the operator is declared with an explicit ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," or by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.3#S0315"},"generic_instantiation")),").",(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"5"),(0,n.kt)("p",null,'An explicit declaration of "/=" shall not have a result type of the predefined type Boolean. ',(0,n.kt)("br",null)),(0,n.kt)("h4",k({},{id:"static-semantics"}),"Static Semantics"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"6/3"),(0,n.kt)(l.Z,{items:["AI05-0128-1"],mdxType:"MarginInfo"}),(0,n.kt)("p",null,'An explicit declaration of "=" whose result type is Boolean implicitly declares an operator "/=" that gives the complementary result. ',(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"6.a/3"),(0,n.kt)(l.Z,{items:["AI05-0128-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,n.kt)("strong",null),'A "/=" defined by this rule is considered user-defined, which means that it will be inherited by a derived type. \u201cUser-defined\u201d means \u201cnot language-defined\u201d for the purposes of inheritance, that is anything other than predefined operators. ',(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"7/5"),(0,n.kt)(l.Z,{items:["AI12-0440-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'NOTE 1   The operators "+" and "\u2013" are both unary and binary operators, and hence can  be overloaded with both one- and two-parameter functions. ',(0,n.kt)("br",null)),(0,n.kt)("h4",k({},{id:"examples"}),"Examples"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"8"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of user-defined operators:")," ",(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"9"),(0,n.kt)(r.Z,{language:"ada",mdxType:"CodeBlock"},'function "+" (Left, Right : Matrix) return Matrix;',"\n",'function "+" (Left, Right : Vector) return Vector;',"\n","\n","--  assuming that A, B, and C are of the type Vector","\n","--  the following two statements are equivalent:","\n","\n","A := B + C;","\n",'A := "+"(B, C);',"\n"),(0,n.kt)("h4",k({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"9.a"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'Explicit declarations of "=" are now permitted for any combination of parameter and result types.',(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"9.b"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'Explicit declarations of "/=" are now permitted, so long as the result type is not Boolean. ',(0,n.kt)("br",null)),(0,n.kt)("h4",k({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(i.Z,{mdxType:"MarginText"},"9.c/3"),(0,n.kt)(l.Z,{items:["AI05-0128-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},(0,n.kt)("strong",null),' Corrected the wording so that only explicit declarations of "=" cause an implicit declaration of "/="; otherwise, we could get multiple implicit definitions of "/=" without an obvious way to chose between them.',(0,n.kt)("br",null)),(0,n.kt)(i.Z,{mdxType:"MarginText"},"9.d/3"),(0,n.kt)(l.Z,{items:["AI05-0143-1"],mdxType:"MarginInfo"}),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Added wording so that operators only allow parameters of mode ",(0,n.kt)("strong",null,"in"),". This was made necessary by the elimination elsewhere of the restriction that function parameters be only of mode ",(0,n.kt)("strong",null,"in"),". ",(0,n.kt)("br",null)))}T.isMDXComponent=!0}}]);