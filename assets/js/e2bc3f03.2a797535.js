"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1248],{1716:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=l(a),u=i,y=h["".concat(p,".").concat(u)]||h[u]||d[u]||s;return a?n.createElement(y,r(r({ref:t},c),{},{components:a})):n.createElement(y,r({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var l=2;l<s;l++)r[l]=a[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9311:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var n=a(9440),i=(a(6687),a(1716));const s={sidebar_position:18},r="3.2  Types and Subtypes",o={unversionedId:"arm/AA-3.2",id:"arm/AA-3.2",title:"3.2  Types and Subtypes",description:"Static Semantics",source:"@site/docs/arm/AA-3.2.md",sourceDirName:"arm",slug:"/arm/AA-3.2",permalink:"/docs/arm/AA-3.2",draft:!1,tags:[],version:"current",sidebarPosition:18,frontMatter:{sidebar_position:18},sidebar:"tutorialSidebar",previous:{title:"3.1  Declarations",permalink:"/docs/arm/AA-3.1"},next:{title:"3.3  Objects and Named Numbers",permalink:"/docs/arm/AA-3.3"}},p={},l=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"3.2.1  Type Declarations",id:"321--type-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"3.2.2  Subtype Declarations",id:"322--subtype-declarations",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"3.2.3  Classification of Operations",id:"323--classification-of-operations",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"3.2.4  Subtype Predicates",id:"324--subtype-predicates",level:2},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-2",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],c={toc:l};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"32--types-and-subtypes"},"3.2  Types and Subtypes"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"A type is characterized by a set of values, and a set of primitive operations which implement the fundamental aspects of its semantics. An object of a given type is a run-time entity that contains (has) a value of the type. "),(0,i.kt)("p",null,"Glossary entry: Each object has a type. A type has an associated set of values, and a set of primitive operations which implement the fundamental aspects of its semantics. Types are grouped into categories. Most language-defined categories of types are also classes of types."),(0,i.kt)("p",null,"Glossary entry: A subtype is a type together with optional constraints, null exclusions, and predicates, which constrain the values of the subtype to satisfy certain conditions. The values of a subtype are a subset of the values of its type."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[type]",", Def=","[a defining characteristic of each object and expression of the language, with an associated set of values, and a set of primitive operations that implement the fundamental aspects of its semantics]",", Note1=","[Types are grouped into categories. Most language-defined categories of types are also classes of types.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[subtype]",", Def=","[a type together with optional constraints, null exclusions, and predicates, which constrain the values of the type to the subset that satisfies the implied conditions]"),(0,i.kt)("p",null,"{AI95-00442-01} Types are grouped into categories of types. There exist several language-defined categories of types (see NOTES below), reflecting the similarity of their values and primitive operations. ","[Most categories of types form classes of types.]"," Elementary types are those whose values are logically indivisible; composite types are those whose values are composed of component values. "),(0,i.kt)("p",null,"Proof: {AI95-00442-01} The formal definition of category and class is found in 3.4. "),(0,i.kt)("p",null,"Glossary entry: A class is a set of types that is closed under derivation, which means that if a given type is in the class, then all types derived from that type are also in the class. The set of types of a class share common properties, such as their primitive operations."),(0,i.kt)("p",null,"Glossary entry: A category of types is a set of types with one or more common properties, such as primitive operations. A category of types that is closed under derivation is also known as a class."),(0,i.kt)("p",null,"Glossary entry: An elementary type is a type that does not have components."),(0,i.kt)("p",null,"Glossary entry: A composite type may have components."),(0,i.kt)("p",null,"Glossary entry: A scalar type is either a discrete type or a real type."),(0,i.kt)("p",null,'Glossary entry: An access type has values that designate aliased objects. Access types correspond to "pointer types" or "reference types" in some other languages.'),(0,i.kt)("p",null,"Glossary entry: A discrete type is either an integer type or an enumeration type. Discrete types may be used, for example, in ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),"s and as array indices."),(0,i.kt)("p",null,"Glossary entry: A real type has values that are approximations of the real numbers. Floating point and fixed point types are real types."),(0,i.kt)("p",null,'Glossary entry: Integer types comprise the signed integer types and the modular types. A signed integer type has a base range that includes both positive and negative numbers, and has operations that may raise an exception when the result is outside the base range. A modular type has a base range whose lower bound is zero, and has operations with "wraparound" semantics. Modular types subsume what are called "unsigned types" in some other languages.'),(0,i.kt)("p",null,"Glossary entry: An enumeration type is defined by an enumeration of its values, which may be named by identifiers or character literals."),(0,i.kt)("p",null,"Glossary entry: A character type is an enumeration type whose values include characters."),(0,i.kt)("p",null,"Glossary entry: A record type is a composite type consisting of zero or more named components, possibly of different types."),(0,i.kt)("p",null,"Glossary entry: A record extension is a type that extends another type by adding additional components."),(0,i.kt)("p",null,"Glossary entry: An array type is a composite type whose components are all of the same type. Components are selected by indexing."),(0,i.kt)("p",null,"Glossary entry: A task type is a composite type used to represent active entities which execute concurrently and which can communicate via queued task entries. The top-level task of a partition is called the environment task."),(0,i.kt)("p",null,"Glossary entry: A protected type is a composite type whose components are accessible only through one of its protected operations which synchronize concurrent access by multiple tasks."),(0,i.kt)("p",null,"Glossary entry: A private type gives a view of a type that reveals only some of its properties. The remaining properties are provided by the full view given elsewhere. Private types can be used for defining abstractions that hide unnecessary details from their clients."),(0,i.kt)("p",null,"Glossary entry: A private extension is a type that extends another type, with the additional properties hidden from its clients."),(0,i.kt)("p",null,"Glossary entry: An incomplete type gives a view of a type that reveals only some of its properties. The remaining properties are provided by the full view given elsewhere. Incomplete types can be used for defining recursive data structures."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[class of types]",", Def=","[a set of types that is closed under derivation, which means that if a given type is in the class, then all types derived from that type are also in the class]",", Note1=","[The set of types of a class share common properties, such as their primitive operations.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[category of types]",", Def=","[a set of types with one or more common properties, such as primitive operations]",", Note1=","[A category of types that is closed under derivation is also known as a class.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[elementary type]",", Def=","[a type that does not have components]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[composite type]",", Def=","[a type with components, such as an array or record]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[scalar type]",", Def=","[either a discrete type or a real type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[access type]",", Def=","[a type that has values that designate aliased objects]",", Note1=",'[Access types correspond to "pointer types" or "reference types" in some other languages.]'," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[discrete type]",", Def=","[a type that is either an integer type or an enumeration type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[real type]",", Def=","[a type that has values that are approximations of the real numbers]",", Note1=","[Floating point and fixed point types are real types.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[integer type]",", Def=","[a type that represents signed or modular integers]",", Note1=",'[A signed integer type has a base range that includes both positive and negative numbers, and has operations that can raise an exception when the result is outside the base range. A modular type has a base range whose lower bound is zero, and has operations with "wraparound" semantics. Modular types subsume what are called "unsigned types" in some other languages.]'," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[enumeration type]",", Def=","[a type defined by an enumeration of its values, which can be denoted by identifiers or character literals]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[character type]",", Def=","[an enumeration type whose values include characters]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[record type]",", Def=","[a composite type consisting of zero or more named components, possibly of different types]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[record extension]",", Def=","[a type that extends another type optionally with additional components]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[array type]",", Def=","[a composite type whose components are all of the same type]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[task type]",", Def=","[a composite type used to represent active entities which execute concurrently and that can communicate via queued task entries]",", Note1=","[The top-level task of a partition is called the environment task.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[protected type]",", Def=","[a composite type whose components are accessible only through one of its protected operations, which synchronize concurrent access by multiple tasks]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[private type]",", Def=","[a view of a type that reveals only some of its properties]",", Note1=","[The remaining properties are provided by the full view given elsewhere. Private types can be used for defining abstractions that hide unnecessary details from their clients.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[private extension]",", Def=","[a type that extends another type, with the additional properties hidden from its clients]"," Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[incomplete type]",", Def=","[a view of a type that reveals only a few of its properties]",", Note1=","[The remaining properties are provided by the full view given elsewhere.]",", Note2=","[Incomplete types can be used for defining recursive data structures.]"),(0,i.kt)("p",null,"The elementary types are the scalar types (discrete and real) and the access types (whose values provide access to objects or subprograms). Discrete types are either integer types or are defined by enumeration of their values (enumeration types). Real types are either floating point types or fixed point types."),(0,i.kt)("p",null,"{AI95-00251-01} {AI95-00326-01} The composite types are the record types, record extensions, array types, interface types, task types, and protected types. "),(0,i.kt)("p",null,"This paragraph was deleted.{AI95-00442-01} "),(0,i.kt)("p",null,"{AI95-00326-01} There can be multiple views of a type with varying sets of operations. ","[An incomplete type represents an incomplete view (see 3.10.1) of a type with a very restricted usage, providing support for recursive data structures. A private type or private extension represents a partial view (see 7.3) of a type, providing support for data abstraction. The full view (see 3.2.1) of a type represents its complete definition.]"," An incomplete or partial view is considered a composite type","[, even if the full view is not]",". "),(0,i.kt)("p",null,"Proof: {AI05-0299-1} The real definitions of the views are in the referenced subclauses. "),(0,i.kt)("p",null,"{AI95-00326-01} Certain composite types (and views thereof) have special components called discriminants whose values affect the presence, constraints, or initialization of other components. Discriminants can be thought of as parameters of the type."),(0,i.kt)("p",null,"{AI95-00366-01} The term subcomponent is used in this Reference Manual in place of the term component to indicate either a component, or a component of another subcomponent. Where other subcomponents are excluded, the term component is used instead. Similarly, a part of an object or value is used to mean the whole object or value, or any set of its subcomponents. The terms component, subcomponent, and part are also applied to a type meaning the component, subcomponent, or part of objects and values of the type. "),(0,i.kt)("p",null,'Discussion: The definition of "part" here is designed to simplify rules elsewhere. By design, the intuitive meaning of "part" will convey the correct result to the casual reader, while this formalistic definition will answer the concern of the compiler-writer.'),(0,i.kt)("p",null,'We use the term "part" when talking about the parent part, ancestor part, or extension part of a type extension. In contexts such as these, the part might represent an empty set of subcomponents (e.g. in a null record extension, or a nonnull extension of a null record). We also use "part" when specifying rules such as those that apply to an object with a "controlled part" meaning that it applies if the object as a whole is controlled, or any subcomponent is. '),(0,i.kt)("p",null,"{AI95-00231-01} The set of possible values for an object of a given type can be subjected to a condition that is called a constraint (the case of a null constraint that specifies no restriction is also included)[; the rules for which values satisfy a given kind of constraint are given in 3.5 for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"s, 3.6.1 for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint"),"s, and 3.7.1 for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0064"},"discriminant_constraint"),"s]. The set of possible values for an object of an access type can also be subjected to a condition that excludes the null value (see 3.10)."),(0,i.kt)("p",null,'Ramification: {AI12-0140-1} "Null constraint" includes the cases of no explicit constraint, as well as unknown discriminants and unconstrained array type declarations (which are explicit ways to declare no constraint). '),(0,i.kt)("p",null,"{AI95-00231-01} {AI95-00415-01} {AI12-0445-1} A subtype of a given type is a combination of the type, a constraint on values of the type, and certain attributes specific to the subtype. The given type is called the type of the subtype. Similarly, the associated constraint is called the constraint of the subtype.  The set of values of a subtype consists of the values of its type that satisfy its constraint and any exclusion of the null value. Such values belong to the subtype. The other values of the type are outside the subtype. "),(0,i.kt)("p",null,"Discussion: We make a strong distinction between a type and its subtypes. In particular, a type is not a subtype of itself. There is no constraint associated with a type (not even a null one), and type-related attributes are distinct from subtype-specific attributes. "),(0,i.kt)("p",null,'Discussion: We no longer use the term "base type." All types were "base types" anyway in Ada 83, so the term was redundant, and occasionally confusing. In the RM95 we say simply "the type of the subtype" instead of "the base type of the subtype." '),(0,i.kt)("p",null,"Ramification: The value subset for a subtype might be empty, and need not be a proper subset. "),(0,i.kt)("p",null,'To be honest: {AI95-00442-01} Any name of a category of types (such as "discrete", "real", or "limited") is also used to qualify its subtypes, as well as its objects, values, declarations, and definitions, such as an "integer type declaration" or an "integer value". In addition, if a term such as "parent subtype" or "index subtype" is defined, then the corresponding term for the type of the subtype is "parent type" or "index type". '),(0,i.kt)("p",null,"Discussion: We use these corresponding terms without explicitly defining them, when the meaning is obvious. "),(0,i.kt)("p",null,"A subtype is called an unconstrained subtype if its type has unknown discriminants, or if its type allows range, index, or discriminant constraints, but the subtype does not impose such a constraint; otherwise, the subtype is called a constrained subtype (since it has no unconstrained characteristics). "),(0,i.kt)("p",null,'Discussion: In an earlier version of Ada 9X, "constrained" meant "has a nonnull constraint." However, we changed to this definition since we kept having to special case composite non-array/nondiscriminated types. It also corresponds better to the (now obsolescent) attribute \'Constrained.'),(0,i.kt)("p",null,'For scalar types, "constrained" means "has a nonnull constraint". For composite types, in implementation terms, "constrained" means that the size of all objects of the subtype is the same, assuming a typical implementation model.'),(0,i.kt)("p",null,"Class-wide subtypes are always unconstrained. "),(0,i.kt)("p",null,'NOTE   {AI95-00442-01} Any set of types can be called a "category" of types, and any set of types that is closed under derivation (see 3.4) can be called a "class" of types. However, only certain categories and classes are used in the description of the rules of the language - generally those that have their own particular set of primitive operations (see 3.2.3), or that correspond to a set of types that are matched by a given kind of generic formal type (see 12.5). The following are examples of "interesting" language-defined classes: elementary, scalar, discrete, enumeration, character, boolean, integer, signed integer, modular, real, floating point, fixed point, ordinary fixed point, decimal fixed point, numeric, access, access-to-object, access-to-subprogram, composite, array, string, (untagged) record, tagged, task, protected, nonlimited. Special syntax is provided to define types in each of these classes. In addition to these classes, the following are examples of "interesting" language-defined categories: abstract, incomplete, interface, limited, private, record. '),(0,i.kt)("p",null,"Discussion: A value is a run-time entity with a given type which can be assigned to an object of an appropriate subtype of the type. An operation is a program entity that operates on zero or more operands to produce an effect, or yield a result, or both. "),(0,i.kt)("p",null,"Ramification: {AI95-00442-01} Note that a type's category (and class) depends on the place of the reference - a private type is composite outside and possibly elementary inside. It's really the view that is elementary or composite. Note that although private types are composite, there are some properties that depend on the corresponding full view - for example, parameter passing modes, and the constraint checks that apply in various places."),(0,i.kt)("p",null,"{AI95-00345-01} {AI95-00442-01} Every property of types forms a category, but not every property of types represents a class. For example, the set of all abstract types does not form a class, because this set is not closed under derivation. Similarly, the set of all interface types does not form a class."),(0,i.kt)("p",null,'{AI95-00442-01} The set of limited types does not form a class (since nonlimited types can inherit from limited interfaces), but the set of nonlimited types does. The set of tagged record types and the set of tagged private types do not form a class (because each of them can be extended to create a type of the other category); that implies that the set of record types and the set of private types also do not form a class (even though untagged record types and untagged private types do form a class). In all of these cases, we can talk about the category of the type; for instance, we can talk about the "category of limited types".'),(0,i.kt)("p",null,"{AI95-00442-01} Normatively, the language-defined classes are those that are defined to be inherited on derivation by 3.4; other properties either aren't interesting or form categories, not classes. "),(0,i.kt)("p",null,"{AI95-00442-01} These language-defined categories are organized like this: "),(0,i.kt)("p",null,"{AI95-00345-01} all types\nelementary\nscalar\ndiscrete\nenumeration\ncharacter\nboolean\nother enumeration\ninteger\nsigned integer\nmodular integer\nreal\nfloating point\nfixed point\nordinary fixed point\ndecimal fixed point\naccess\naccess-to-object\naccess-to-subprogram\ncomposite\nuntagged\narray\nstring\nother array\nrecord\ntask\nprotected\ntagged (including interfaces)\nnonlimited tagged record\nlimited tagged\nlimited tagged record\nsynchronized tagged\ntagged task\ntagged protected"),(0,i.kt)("p",null,'{AI95-00345-01} {AI95-00442-01} There are other categories, such as "numeric" and "discriminated", which represent other categorization dimensions, but do not fit into the above strictly hierarchical picture. '),(0,i.kt)("p",null,'Discussion: {AI95-00345-01} {AI95-00442-01} Note that this is also true for some categories mentioned in the chart. The category "task" includes both untagged tasks and tagged tasks. Similarly for "protected", "limited", and "nonlimited" (note that limited and nonlimited are not shown for untagged composite types). '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"{AI05-0299-1} This subclause now precedes the subclauses on objects and named numbers, to cut down on the number of forward references."),(0,i.kt)("p",null,'We have dropped the term "base type" in favor of simply "type" (all types in Ada 83 were "base types" so it wasn\'t clear when it was appropriate/necessary to say "base type"). Given a subtype S of a type T, we call T the "type of the subtype S." '),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00231-01} Added a mention of null exclusions when we're talking about constraints (these are not constraints, but they are similar)."),(0,i.kt)("p",null,"{AI95-00251-01} Defined an interface type to be a composite type."),(0,i.kt)("p",null,"{AI95-00326-01} Revised the wording so that it is clear that an incomplete view is similar to a partial view in terms of the language."),(0,i.kt)("p",null,"{AI95-00366-01} Added a definition of component of a type, subcomponent of a type, and part of a type. These are commonly used in the standard, but they were not previously defined."),(0,i.kt)("p",null,"{AI95-00442-01} {AI05-0299-1} Reworded most of this subclause to use category rather than class, since so many interesting properties are not, strictly speaking, classes. Moreover, there was no normative description of exactly which properties formed classes, and which did not. The real definition of class, along with a list of properties, is now in 3.4. "),(0,i.kt)("h2",{id:"321--type-declarations"},"3.2.1  Type Declarations"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," declares a type and its first subtype. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"type_declaration",(0,i.kt)("a",{id:"S0023"})," ::=  ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0085"},"incomplete_type_declaration"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.3#S0232"},"private_type_declaration"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.3#S0233"},"private_extension_declaration")),(0,i.kt)("p",null,"{AI05-0183-1} full_type_declaration",(0,i.kt)("a",{id:"S0024"})," ::=\ntype ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," [",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part"),"] is ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0025"},"type_definition"),"\n[",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"];\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0244"},"task_type_declaration"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.4#S0249"},"protected_type_declaration")),(0,i.kt)("p",null,"{AI95-00251-01} type_definition",(0,i.kt)("a",{id:"S0025"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition"),"\t| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0044"},"real_type_definition"),"\t| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0066"},"record_type_definition"),"\t| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0079"},"access_type_definition"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition"),"\t| ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.9#S0077"},"interface_type_definition")),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"A given type shall not have a subcomponent whose type is the given type itself. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," denotes the first subtype of the type. The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part"),', if any, defines the discriminants of the type (see 3.7, "Discriminants"). The remainder of the ',(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," defines the remaining characteristics of (the view of) the type."),(0,i.kt)("p",null,"{AI95-00230-01} A type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," is a named type; such a type has one or more nameable subtypes. Certain other forms of declaration also include type definitions as part of the declaration for an object. The type defined by such a declaration is anonymous - it has no nameable subtypes. For explanatory purposes, this document sometimes refers to an anonymous type by a pseudo-name, written in italics, and uses such pseudo-names at places where the syntax normally requires an ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),'. For a named type whose first subtype is T, this document sometimes refers to the type of T as simply "the type T". '),(0,i.kt)("p",null,"Ramification: {AI95-00230-01} The only user-defined types that can be anonymous in the above sense are array, access, task, and protected types. An anonymous array, task, or protected type can be defined as part of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0032"},"object_declaration"),". An anonymous access type can be defined as part of numerous other constructs. "),(0,i.kt)("p",null,"{AI95-00230-01} {AI95-00326-01} A named type that is declared by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),", or an anonymous type that is defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition")," or as part of declaring an object of the type, is called a full type. The declaration of a full type also declares the full view of the type. The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0025"},"type_definition"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0246"},"task_definition"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.4#S0251"},"protected_definition"),", or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition")," that defines a full type is called a full type definition. [Types declared by other forms of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," are not separate types; they are partial or incomplete views of some full type.] "),(0,i.kt)("p",null,"To be honest: Class-wide, universal, and root numeric types are full types. "),(0,i.kt)("p",null,"Reason: {AI95-00230-01} We need to mention ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition")," separately, as it may occur in renames, which do not declare objects. "),(0,i.kt)("p",null,'The definition of a type implicitly declares certain predefined operators that operate on the type, according to what classes the type belongs, as specified in 4.5, "Operators and Expression Evaluation". '),(0,i.kt)("p",null,"Discussion: We no longer talk about the implicit declaration of basic operations. These are treated like an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.3#S0175"},"if_statement")," - they don't need to be declared, but are still applicable to only certain classes of types."),(0,i.kt)("p",null,"The predefined types ","[(for example the types Boolean, Wide_Character, Integer, root_integer, and universal_integer)]"," are the types that are defined in ","[a predefined library package called]"," Standard[; this package also includes the ","[(implicit)]"," declarations of their predefined operators]. ","[The package Standard is described in A.1.]"," "),(0,i.kt)("p",null,'Ramification: We use the term "predefined" to refer to entities declared in the visible part of Standard, to implicitly declared operators of a type whose semantics are defined by the language, to Standard itself, and to the "predefined environment". We do not use this term to refer to library packages other than Standard. For example Text_IO is a language-defined package, not a predefined package, and Text_IO.Put_Line is not a predefined operation. '),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," consists of the elaboration of the full type definition. Each elaboration of a full type definition creates a distinct type and its first subtype. "),(0,i.kt)("p",null,"Reason: The creation is associated with the type definition, rather than the type declaration, because there are types that are created by full type definitions that are not immediately contained within a type declaration (e.g. an array object declaration, a singleton task declaration, etc.). "),(0,i.kt)("p",null,"Ramification: Any implicit declarations that occur immediately following the full type definition are elaborated where they (implicitly) occur. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of type definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"(White, Red, Yellow, Green, Blue, Brown, Black)\nrange 1 .. 72\narray(1 .. 10) of Integer\n\n")),(0,i.kt)("p",null,"Examples of type declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);\ntype Column is range 1 .. 72;\ntype Table  is array(1 .. 10) of Integer;\n\n")),(0,i.kt)("p",null,"NOTE 1   Each of the above examples declares a named type. The identifier given denotes the first subtype of the type. Other named subtypes of the type can be declared with ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration"),'s (see 3.2.2). Although names do not directly denote types, a phrase like "the type Column" is sometimes used in this document to refer to the type of Column, where Column denotes the first subtype of the type. For an example of the definition of an anonymous type, see the declaration of the array Color_Table in 3.3.1; its type is anonymous - it has no nameable subtypes. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntactic category ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," now includes task and protected type declarations."),(0,i.kt)("p",null,'We have generalized the concept of first-named subtype (now called simply "first subtype") to cover all kinds of types, for uniformity of description elsewhere. RM83 defined first-named subtype in Section 13. We define first subtype here, because it is now a more fundamental concept. We renamed the term, because in Ada 95 some first subtypes have no name.'),(0,i.kt)("p",null,"{AI95-00230-01} We no longer elaborate ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0059"},"discriminant_part"),"s, because there is nothing to do, and it was complex to say that you only wanted to elaborate it once for a private or incomplete type. This is also consistent with the fact that subprogram specifications are not elaborated (neither in Ada 83 nor in Ada 95). Note, however, that an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition")," appearing in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0059"},"discriminant_part")," is elaborated at the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," (for a nonlimited type) or when an object with such a discriminant is created (for a limited type). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00230-01} Added wording so that anonymous access types are always full types, even if they appear in renames."),(0,i.kt)("p",null,"{AI95-00251-01} Added interface types (see 3.9.4) to the syntax."),(0,i.kt)("p",null,"{AI95-00326-01} Added a definition of full view, so that all types have a well-defined full view. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0183-1} An optional ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," can be used in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),". This is described in 13.1.1. "),(0,i.kt)("h2",{id:"322--subtype-declarations"},"3.2.2  Subtype Declarations"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration")," declares a subtype of some previously declared type, as defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"{AI05-0183-1} subtype_declaration",(0,i.kt)("a",{id:"S0026"})," ::=\nsubtype ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," is ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"\n[",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"];"),(0,i.kt)("p",null,"{AI95-00231-01} subtype_indication",(0,i.kt)("a",{id:"S0027"})," ::=  ","[[null_exclusion](./AA-3.10#S0083)][subtype_mark]","(./AA-3.2#S0028) [",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint"),"]"),(0,i.kt)("p",null,"subtype",(0,i.kt)("em",{parentName:"p"},"mark",(0,i.kt)("a",{id:"S0028"})," ::= subtype"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")),(0,i.kt)("p",null,"Ramification: Note that ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," includes ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),"; thus, S'Base can be used as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),". "),(0,i.kt)("p",null,"Reason: We considered changing ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),' to subtype_name. However, existing users are used to the word "mark," so we\'re keeping it. '),(0,i.kt)("p",null,"constraint",(0,i.kt)("a",{id:"S0029"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0030"},"scalar_constraint")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0031"},"composite_constraint")),(0,i.kt)("p",null,"scalar_constraint",(0,i.kt)("a",{id:"S0030"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint")),(0,i.kt)("p",null,"composite_constraint",(0,i.kt)("a",{id:"S0031"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0064"},"discriminant_constraint")),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," shall resolve to denote a subtype. The type determined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," is the type of the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),". "),(0,i.kt)("p",null,"Ramification: {AI05-0005-1} Types are never directly named; all ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),"s denote subtypes - possibly an unconstrained (base) subtype, but never the type. When we use the term anonymous type we really mean a type with no nameable subtypes. "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," creates a new subtype. If the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," does not include a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint"),", the new subtype has the same (possibly null) constraint as that denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),". The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," that includes a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," proceeds as follows: "),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," is first elaborated."),(0,i.kt)("p",null,"A check is then made that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," is compatible with the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),". "),(0,i.kt)("p",null,"Ramification: The checks associated with constraint compatibility are all Range_Checks. Discriminant_Checks and Index_Checks are associated only with checks that a value satisfies a constraint. "),(0,i.kt)("p",null,"The condition imposed by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," is the condition obtained after elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint"),". The rules defining compatibility are given for each form of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," in the appropriate subclause. These rules are such that if a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," is compatible with a subtype, then the condition imposed by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," cannot contradict any condition already imposed by the subtype on its values. The exception Constraint_Error is raised if any check of compatibility fails. "),(0,i.kt)("p",null,"To be honest: The condition imposed by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," is named after it - a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," imposes a range constraint, etc. "),(0,i.kt)("p",null,"Ramification: A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," causes freezing of its type. Other ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint"),"s do not. "),(0,i.kt)("p",null,"NOTE 1   {AI12-0440-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0030"},"scalar_constraint")," can be applied to a subtype of an appropriate scalar type (see 3.5, 3.5.9, and J.3), even if the subtype is already constrained. On the other hand, a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0031"},"composite_constraint")," can be applied to a composite subtype (or an access-to-composite subtype) only if the composite subtype is unconstrained (see 3.6.1 and 3.7.1). "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Examples of subtype declarations: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00433-01} subtype Rainbow   is Color range Red .. Blue;        --  see 3.2.1\nsubtype Red_Blue  is Rainbow;\nsubtype Int       is Integer;\nsubtype Small_Int is Integer range -10 .. 10;\nsubtype Up_To_K   is Column range 1 .. K;            --  see 3.2.1\nsubtype Square    is Matrix(1 .. 10, 1 .. 10);       --  see 3.6\nsubtype Male      is Person(Sex =&gt M);               --  see 3.10.1\nsubtype Binop_Ref is not null Binop_Ptr;             --  see 3.10\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"In Ada 95, all ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"s cause freezing of their type. Hence, a type-related representation item for a scalar type has to precede any ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"s whose type is the scalar type. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"Subtype_mark"),"s allow only subtype names now, since types are never directly named. There is no need for RM83-3.3.2(3), which says a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," can denote both the type and the subtype; in Ada 95, you denote an unconstrained (base) subtype if you want, but never the type."),(0,i.kt)("p",null,"The syntactic category type_mark is now called ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),", since it always denotes a subtype. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00231-01} An optional ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion")," can be used in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". This is described in 3.10. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0183-1} An optional ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," can be used in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration"),". This is described in 13.1.1. "),(0,i.kt)("h2",{id:"323--classification-of-operations"},"3.2.3  Classification of Operations"),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"{AI95-00416-01} An operation operates on a type T if it yields a value of type T, if it has an operand whose expected type (see 8.6) is T, or if it has an access parameter or access result type (see 6.1) designating T. A predefined operator, or other language-defined operation such as assignment or a membership test, that operates on a type, is called a predefined operation of the type. The primitive operations of a type are the predefined operations of the type, plus any user-defined primitive subprograms. "),(0,i.kt)("p",null,"Glossary entry: The primitive operations of a type are the operations (such as subprograms) declared together with the type declaration. They are inherited by other types in the same class of types. For a tagged type, the primitive subprograms are dispatching subprograms, providing run-time polymorphism. A dispatching subprogram may be called with statically tagged operands, in which case the subprogram body invoked is determined at compile time. Alternatively, a dispatching subprogram may be called using a dispatching call, in which case the subprogram body invoked is determined at run time."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(Added),Group=","[T]",",Term=","[primitive operations of a type]",", Def=","[the operations (such as subprograms) declared together with the type declarations]",", Note1=","[Primitive operations are inherited by other types in the same derivation class of types.]"),(0,i.kt)("p",null,'To be honest: Protected subprograms are not considered to be "primitive subprograms", even though they are subprograms, and they are inherited by derived types. '),(0,i.kt)("p",null,'Discussion: We use the term "primitive subprogram" in most of the rest of the manual. The term "primitive operation" is used mostly in conceptual discussions. '),(0,i.kt)("p",null,"The primitive subprograms of a specific type are defined as follows: "),(0,i.kt)("p",null,"The predefined operators of the type (see 4.5);"),(0,i.kt)("p",null,"For a derived type, the inherited (see 3.4) user-defined subprograms;"),(0,i.kt)("p",null,"For an enumeration type, the enumeration literals (which are considered parameterless functions - see 3.5.1);"),(0,i.kt)("p",null,"For a specific type declared immediately within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.1#S0230"},"package_specification"),", any subprograms (in addition to the enumeration literals) that are explicitly declared immediately within the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.1#S0230"},"package_specification")," and that operate on the type;"),(0,i.kt)("p",null,'{AI05-0128-1} For a specific type with an explicitly declared primitive "=" operator whose result type is Boolean, the corresponding "/=" operator (see 6.6);'),(0,i.kt)("p",null,"{AI95-00200-01} For a nonformal type, any subprograms not covered above ","[that are explicitly declared immediately within the same declarative region as the type]"," and that override (see 8.3) other implicitly declared primitive subprograms of the type. "),(0,i.kt)("p",null,'Discussion: In Ada 83, only subprograms declared in the visible part were "primitive" (i.e. derivable). In Ada 95, mostly because of child library units, we include all operations declared in the private part as well, and all operations that override implicit declarations. '),(0,i.kt)("p",null,"Ramification: It is possible for a subprogram to be primitive for more than one type, though it is illegal for a subprogram to be primitive for more than one tagged type. See 3.9. "),(0,i.kt)("p",null,'Discussion: The order of the implicit declarations when there are both predefined operators and inherited subprograms is described in 3.4, "Derived Types and Classes". '),(0,i.kt)("p",null,"Ramification: {AI95-00200-01} Subprograms declared in a generic package specification are never primitive for a formal type, even if they happen to override an operation of the formal type. This includes formal subprograms, which are never primitive operations (that's true even for an abstract formal subprogram). "),(0,i.kt)("p",null,"A primitive subprogram whose designator is an ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0202"},"operator_symbol")," is called a primitive operator."),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"The attribute S'Base is no longer defined for nonscalar subtypes. Since this was only permitted as the prefix of another attribute, and there are no interesting nonscalar attributes defined for an unconstrained composite or access subtype, this should not affect any existing programs. "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The primitive subprograms (derivable subprograms) include subprograms declared in the private part of a package specification as well, and those that override implicitly declared subprograms, even if declared in a body. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have dropped the confusing term operation of a type in favor of the more useful primitive operation of a type and the phrase operates on a type."),(0,i.kt)("p",null,'The description of S\'Base has been moved to 3.5, "Scalar Types" because it is now defined only for scalar types. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-2"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00200-01} Clarified that a formal subprogram that happens to override a primitive operation of a formal type is not a primitive operation (and thus not a dispatching operation) of the formal type."),(0,i.kt)("p",null,"{AI95-00416-01} Added wording to include access result types in the kinds of operations that operate on a type T. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,'{AI05-0128-1} Correction: The implicitly declared "/=" for a primitive "=" operator is also primitive; this makes it eligible to be made visible by a use type clause. '),(0,i.kt)("h2",{id:"324--subtype-predicates"},"3.2.4  Subtype Predicates"),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0269-1} {AI05-0299-1} {AI12-0396-1} {AI12-0419-1} The language-defined predicate aspects Static_Predicate and Dynamic_Predicate may be used to define properties of subtypes. A predicate specification is an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," for one of the two predicate aspects. General rules for aspects and ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s are found in Clause 13 (13.1 and 13.1.1 respectively). The predicate aspects are assertion aspects (see 11.4.2). ","[The predicate aspects are not inherited, but their effects are additive, as defined below.]"," "),(0,i.kt)("p",null,"Aspect Description for Static_Predicate: Condition that will hold true for objects of a given subtype; the subtype may be static."),(0,i.kt)("p",null,"Aspect Description for Dynamic_Predicate: Condition that will hold true for objects of a given subtype; the subtype is not static."),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI05-0153-3} The expected type for a predicate aspect ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is any boolean type."),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"{AI05-0153-3} A predicate specification may be given on a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration"),", and applies to the declared subtype. In addition, predicate specifications apply to certain other subtypes: "),(0,i.kt)("p",null,"{AI12-0071-1} {AI12-0099-1} For a (first) subtype defined by a type declaration, any predicates of parent or progenitor subtypes apply."),(0,i.kt)("p",null,"For a subtype created by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", the predicate of the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," applies. "),(0,i.kt)("p",null,"This paragraph was deleted.{AI05-0153-3} {AI12-0071-1} "),(0,i.kt)("p",null,"{AI05-0290-1} Predicate checks are defined to be enabled or disabled for a given subtype as follows:"),(0,i.kt)("p",null,"If a subtype is declared by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0026"},"subtype_declaration")," that includes a predicate specification, then: "),(0,i.kt)("p",null,"if performing checks is required by the Static_Predicate assertion policy (see 11.4.2) and the declaration includes a Static_Predicate specification, then predicate checks are enabled for the subtype;"),(0,i.kt)("p",null,"if performing checks is required by the Dynamic_Predicate assertion policy (see 11.4.2) and the declaration includes a Dynamic_Predicate specification, then predicate checks are enabled for the subtype;"),(0,i.kt)("p",null,"otherwise, predicate checks are disabled for the subtype","[, regardless of whether predicate checking is enabled for any other subtypes mentioned in the declaration]","; "),(0,i.kt)("p",null,"{AI12-0099-1} If a subtype is defined by a type declaration that does not include a predicate specification, then predicate checks are enabled for the subtype if and only if any predicate checks are enabled for parent or progenitor subtypes;"),(0,i.kt)("p",null,"If a subtype is created by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," other than in one of the previous cases, then predicate checks are enabled for the subtype if and only if predicate checks are enabled for the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),";"),(0,i.kt)("p",null,"Otherwise, predicate checks are disabled for the given subtype."),(0,i.kt)("p",null,'Discussion: In this case, no predicate specifications can apply to the subtype and so it doesn\'t typically matter whether predicate checks are enabled. This rule does make a difference, however, when determining whether predicate checks are enabled for another type when this type is one of multiple progenitors. See the "derived type declaration" wording above.'),(0,i.kt)("p",null,"{AI12-0071-1} Even when predicate checks are disabled, a predicate can affect various Legality Rules, the results of membership tests, the items in a for loop, and the result of the Valid attribute. "),(0,i.kt)("p",null,"{AI12-0054-2} For a subtype with a directly-specified predicate aspect, the following additional language-defined aspect may be specified with an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," (see 13.1.1):"),(0,i.kt)("p",null,"Predicate_FailureThis aspect shall be specified by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),", which determines the action to be performed when a predicate check fails because a directly-specified predicate aspect of the subtype evaluates to False, as explained below. "),(0,i.kt)("p",null,"Aspect Description for Predicate_Failure: Action to be performed when a predicate check fails."),(0,i.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI12-0054-2} The expected type for the Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is String. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0269-1} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of a Static_Predicate specification shall be predicate-static; that is, one of the following: "),(0,i.kt)("p",null,"a static expression;"),(0,i.kt)("p",null,"{AI12-0039-1} a membership test whose tested_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," is the current instance, and whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0136"},"membership_choice_list")," meets the requirements for a static membership test (see 4.9);"),(0,i.kt)("p",null,"a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0151"},"case_expression")," whose selecting",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," is the current instance, and whose dependent"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s are static expressions;"),(0,i.kt)("p",null,"a call to a predefined equality or ordering operator, where one operand is the current instance, and the other is a static expression;"),(0,i.kt)("p",null,"{AI05-0262-1} {AI12-0099-1} a call to a predefined boolean operator and, or, xor, or not, where each operand is predicate-static;"),(0,i.kt)("p",null,"{AI05-0269-1} a short-circuit control form where both operands are predicate-static; or"),(0,i.kt)("p",null,"a parenthesized predicate-static ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),". "),(0,i.kt)("p",null,"{AI05-0262-1} A predicate shall not be specified for an incomplete subtype."),(0,i.kt)("p",null,"Reason: The expression of such a predicate could not depend on the properties of the value of the type (since it doesn't have any), so it is useless and we don't want to require the added complexity needed to support it. "),(0,i.kt)("p",null,"{AI05-0287-1} If a predicate applies to a subtype, then that predicate shall not mention any other subtype to which the same predicate applies."),(0,i.kt)("p",null,"Reason: This is intended to prevent recursive predicates, which cause definitional problems for static predicates. Inside of the predicate, the subtype name refers to the current instance of the subtype, which is an object, so a direct use of the subtype name cannot be recursive. But other subtypes naming the same type might: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Really_Ugly is private;\nprivate\n   subtype Ugly is Really_Ugly;\n   type Really_Ugly is new Integer\n      with Static_Predicate =&gt Really_Ugly not in Ugly; -- Illegal!\n\n")),(0,i.kt)("p",null,"{AI05-0153-3} An index subtype, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0097"},"slice"),", or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.5#S0257"},"entry_declaration"),", or ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.5#S0263"},"entry_index_specification")," shall not denote a subtype to which predicate specifications apply."),(0,i.kt)("p",null,"{AI05-0153-3} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," is First, Last, or Range shall not denote a scalar subtype to which predicate specifications apply."),(0,i.kt)("p",null,"Reason: {AI05-0297-1} This is to prevent confusion about whether the First value is the lowest value of the subtype (which does not depend on the predicate) or the lowest value of the subtype which meets the predicate. (For a dynamic predicate, determining this latter value is expensive as it would usually require a loop.) For a static subtype that has a static predicate, the First_Valid and Last_Valid attributes (see 3.5.5) can be used instead. "),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0262-1} {AI05-0287-1} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.5#S0181"},"loop_parameter_specification")," shall not denote a nonstatic subtype to which predicate specifications apply or any subtype to which Dynamic_Predicate specifications apply."),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0262-1} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0074"},"discrete_choice")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0116"},"named_array_aggregate")," shall not denote a nonstatic subtype to which predicate specifications apply."),(0,i.kt)("p",null,"Reason: {AI05-0262-1} This rule prevents noncontiguous dynamically bounded array aggregates, which could be expensive to check for. (Array aggregates have rules to prevent problems with static subtypes.) We define this rule here so that the runtime generic body check applies. "),(0,i.kt)("p",null,"{AI05-0262-1} In addition to the places where Legality Rules normally apply (see 12.3), these rules apply also in the private part of an instance of a generic unit. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"{AI12-0071-1} If any of the above Legality Rules is violated in an instance of a generic unit, Program_Error is raised at the point of the violation."),(0,i.kt)("p",null,'Discussion: This is the usual way around the contract model; this applies even in instance bodies. Note that errors in instance specifications will be detected at compile time by the "recheck" of the specification; only errors in the body should raise Program_Error. '),(0,i.kt)("p",null,"{AI12-0071-1} To determine whether a value satisfies the predicates of a subtype S, the following tests are performed in the following order, until one of the tests fails, in which case the predicates are not satisfied and no further tests are performed, or all of the tests succeed, in which case the predicates are satisfied:"),(0,i.kt)("p",null,"the value is first tested to determine whether it satisfies any constraints or any null exclusion of S;"),(0,i.kt)("p",null,"then:"),(0,i.kt)("p",null,"{AI12-0419-1} if S is a first subtype, the value is tested to determine whether it satisfies the predicates of the parent and progenitor subtypes (if any) of S (in an arbitrary order), after a (view) conversion of the value to the corresponding parent or progenitor type;"),(0,i.kt)("p",null,"Ramification: This rule has an effect for derived types (which have a parent subtype and may have progenitors) and for task and protected types (which may have progentitors). Other kinds of type declarations can have neither, and no test is required for other first subtypes. "),(0,i.kt)("p",null,"if S is defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", the value is tested to determine whether it satisfies the predicates of the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"; "),(0,i.kt)("p",null,"finally, if S is defined by a declaration to which one or more predicate specifications apply, the predicates are evaluated (in an arbitrary order) to test that all of them yield True for the given value. "),(0,i.kt)("p",null,"Discussion: It is important to stop on the first of the above steps that fails, as later steps might presume that the earlier steps had succeeded. "),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0290-1} If predicate checks are enabled for a given subtype, then: "),(0,i.kt)("p",null,"{AI12-0054-2} {AI12-0071-1} {AI12-0301-1} {AI12-0333-1} {AI12-0432-1} ","[On a subtype conversion, a check is performed that the operand satisfies the predicates of the target subtype, except for certain view conversions (see 4.6).]"," In addition, after normal completion and leaving of a subprogram, for each in out or out parameter that is passed by reference, a check is performed that the value of the parameter satisfies the predicates of the subtype of the actual. For an object created by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0032"},"object_declaration")," with no explicit initialization ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),", or by an uninitialized ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.8#S0164"},"allocator"),", if the types of any parts have specified Default_Value or Default_Component_Value aspects, or any subcomponents have ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s, a check is performed that the value of the created object satisfies the predicates of the nominal subtype."),(0,i.kt)("p",null,"Ramification: {AI12-0333-1} Most parameter passing is covered by the subtype conversion rule: all inbound in and in out parameters are converted to the formal subtype, and the copy-back for by-copy out and in out parameters includes a conversion to the actual subtype. The remaining parameter-passing cases are covered by special rules: by-reference out and in out parameters by the rule given above, and we don't want any predicate checks on inbound out parameters, accomplished in part by a special rule in 4.6. "),(0,i.kt)("p",null,"{AI12-0054-2} If any of the predicate checks fail, Assertion_Error is raised, unless the subtype whose directly-specified predicate aspect evaluated to False also has a directly-specified Predicate_Failure aspect. In that case, the specified Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is evaluated; if the evaluation of the Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," propagates an exception occurrence, then this occurrence is propagated for the failure of the predicate check; otherwise, Assertion_Error is raised, with an associated message string defined by the value of the Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),". In the absence of such a Predicate_Failure aspect, an implementation-defined message string is associated with the Assertion_Error exception."),(0,i.kt)("p",null,"Ramification: Predicates are not evaluated at the point of the (sub)type declaration. "),(0,i.kt)("p",null,"Implementation Note: Static_Predicate checks can be removed even in the presence of potentially invalid values, just as constraint checks can be removed. "),(0,i.kt)("p",null,"Implementation defined: The message string associated with the Assertion_Error exception raised by the failure of a predicate check if there is no applicable Predicate_Failure aspect."),(0,i.kt)("p",null,"Paragraphs 32 and 33 were moved above "),(0,i.kt)("p",null,"This paragraph was deleted."),(0,i.kt)("p",null,"NOTE 1   {AI05-0153-3} A predicate specification does not cause a subtype to be considered constrained."),(0,i.kt)("p",null,"NOTE 2   {AI05-0153-3} A Static_Predicate, like a constraint, always remains True for all objects of the subtype, except in the case of uninitialized variables and other invalid values. A Dynamic_Predicate, on the other hand, is checked as specified above, but can become False at other times. For example, the predicate of a record subtype is not checked when a subcomponent is modified."),(0,i.kt)("p",null,"NOTE 3   {AI12-0071-1} No predicates apply to the base subtype of a scalar type; every value of a scalar type T is considered to satisfy the predicates of T'Base."),(0,i.kt)("p",null,"NOTE 4   {AI12-0054-2} Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s are never evaluated during the evaluation of a membership test (see 4.5.2) or Valid attribute (see 13.9.2)."),(0,i.kt)("p",null,"NOTE 5   {AI12-0054-2} A Predicate_Failure ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," can be a ",(0,i.kt)("a",{parentName:"p",href:"./AA-11.3#S0309"},"raise_expression")," (see 11.3). "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"{AI12-0429-1} Examples of predicates applied to scalar types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0054-2} subtype Basic_Letter is Character -- See A.3.2 for \"basic letter\".\n   with Static_Predicate =&gt Basic_Letter in 'A'..'Z' | 'a'..'z' | '\ufffd' | \n                                '\ufffd' | '\ufffd' | '\ufffd' | '\ufffd' | '\ufffd' | '\ufffd';\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'{AI12-0054-2} subtype Even_Integer is Integer\n   with Dynamic_Predicate =&gt Even_Integer mod 2 = 0,\n        Predicate_Failure =&gt "Even_Integer must be a multiple of 2";\n\n')),(0,i.kt)("p",null,"{AI12-0054-2} Text_IO (see A.10.1) could have used predicates to describe some common exceptional conditions as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.IO_Exceptions;\npackage Ada.Text_IO is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type File_Type is limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'   subtype Open_File_Type is File_Type\n      with Dynamic_Predicate =&gt Is_Open (Open_File_Type),\n           Predicate_Failure =&gt raise Status_Error with "File not open";\n   subtype Input_File_Type is Open_File_Type\n      with Dynamic_Predicate =&gt Mode (Input_File_Type) = In_File,\n           Predicate_Failure =&gt raise Mode_Error with "Cannot read file: "\n              & Name (Input_File_Type);\n   subtype Output_File_Type is Open_File_Type\n      with Dynamic_Predicate =&gt Mode (Output_File_Type) /= In_File,\n           Predicate_Failure =&gt raise Mode_Error with "Cannot write file: "\n              & Name (Output_File_Type);\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Mode (File : in Open_File_Type) return File_Mode;\n   function Name (File : in Open_File_Type) return String;\n   function Form (File : in Open_File_Type) return String;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Get (File : in Input_File_Type; Item : out Character);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Put (File : in Output_File_Type; Item : in Character);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   ...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   -- Similarly for all of the other input and output subprograms.\n\n")),(0,i.kt)("p",null,"Discussion: We didn't change the language-defined Text_IO this way for Ada 2022 as it would be incompatible in marginal cases: these subprogram specifications would not be subtype conformant with existing access-to-subprogram types, so Put_Line'Access (for instance) would become illegal in existing code. The gain would not be worth the disruption. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005-2"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0262-1} {AI05-0276-1} {AI05-0290-1} Predicate aspects are new in Ada 2012. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-2012"},"Inconsistencies With Ada 2012"),(0,i.kt)("p",null,"{AI12-0301-1} Correction: Predicate checks are now performed on default-initialized objects with parts that have Default_Value or Default_Component_Value specified. This is consistent with the handling of constraint checks for such objects; it is thought that the omission was unintended. However, a program that declares such an object and depends on there not being a predicate check in original Ada 2012 will fail in Ada 2022. As these attributes were new in Ada 2012, their use is uncommon, so we believe that this inconsistency will be rare and more likely to catch a bug than create one. "),(0,i.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0054-2} Corrigendum: The Predicate_Failure aspect is new. We can consider this a correction as it is always possible for implementers to add implementation-defined aspects, so the same is true for language-defined aspects. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,'{AI12-0071-1} Corrigendum: Specified the order of evaluation of most predicates, by defining the new term "satisfies the predicates of the subtype". This is not inconsistent, as the order previously was unspecified, so any code depending on the order was incorrect. The change is necessary so that the Predicate_Failure aspect has consistent results in cases where multiple predicates and aspects apply; see the Ada.Text_IO example above for such a case.'),(0,i.kt)("p",null,"{AI12-0099-1} Corrigendum: Revised wording to ensure all kinds of types are covered, including the anonymous task associated with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.1#S0245"},"single_task_declaration"),", and generalized it."),(0,i.kt)("p",null,"{AI12-0099-1} Corrigendum: Revised wording to list the boolean operators that can be predicate-static, to eliminate confusion about whether not is included."),(0,i.kt)("p",null,"{AI12-0333-1} {AI12-0432-1} Correction: Predicate checks are no longer made for any inbound out parameters nor for the target of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.2#S0173"},"assignment_statement")," when it is a view conversion. The rule change for this is found in 4.6, so the inconsistency is documented there."))}d.isMDXComponent=!0}}]);