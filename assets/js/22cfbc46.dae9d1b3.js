"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6659],{44791:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>A,contentTitle:()=>h,default:()=>x,frontMatter:()=>d,metadata:()=>l,toc:()=>f});var s=t(74848),n=t(28453),a=t(13842),r=t(91435),o=(t(21432),t(79162)),c=t(34421);const d={sidebar_position:202},h="J.9 The Storage_Size Attribute",l={id:"arm/AA-J/AA-J.9",title:"J.9 The Storage_Size Attribute",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-J/AA-J.9.mdx",sourceDirName:"arm/AA-J",slug:"/arm/AA-J/AA-J.9",permalink:"/docs/arm/AA-J/AA-J.9",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:202,frontMatter:{sidebar_position:202},sidebar:"referenceManualSidebar",previous:{title:"J.8 Mod Clauses",permalink:"/docs/arm/AA-J/AA-J.8"},next:{title:"J.10 Specific Suppression of Checks",permalink:"/docs/arm/AA-J/AA-J.10"}},A={},f=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4}];function p(e){const i={a:"a",admonition:"admonition",h1:"h1",h4:"h4",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.h1,{id:"j9-the-storage_size-attribute",children:"J.9 The Storage_Size Attribute"}),"\n",(0,s.jsx)(i.admonition,{type:"warning",children:(0,s.jsxs)(i.p,{children:["This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,s.jsx)(i.a,{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20",children:"tracking issue"})]})}),"\n","\n","\n",(0,s.jsx)(i.h4,{id:"static-semantics",children:"Static Semantics"}),"\n",(0,s.jsx)(o.A,{children:"1"}),"\n",(0,s.jsxs)("p",{children:["For any task subtype T, the following attribute is defined: ",(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(o.A,{children:"2"}),"\n",(0,s.jsxs)("dt",{children:[(0,s.jsx)("br",{}),"T'Storage","_","Size "]}),"\n",(0,s.jsx)("dl",{children:(0,s.jsxs)("dd",{children:["Denotes an implementation-defined value of type ",(0,s.jsxs)("em",{children:["universal","_","integer"]})," representing the number of storage elements reserved for a task of the subtype T. ",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(o.A,{children:"2.a/3"}),(0,s.jsx)(c.A,{items:["AI05-0229-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)("strong",{children:"To be honest: "}),"T'Storage","_","Size cannot be particularly meaningful in the presence of the specification of the aspect Storage","_","Size, especially when the expression is dynamic, or depends on a discriminant of the task, because the Storage","_","Size will be different for different objects of the type. Even without such a specification, the Storage","_","Size can be different for different objects of the type, and in any case, the value is implementation defined. Hence, it is always implementation defined. ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(o.A,{children:"3/3"}),"\n",(0,s.jsx)(c.A,{items:["AI95-00345-01","AI05-0229-1"]}),"\n",(0,s.jsx)("dl",{children:(0,s.jsxs)("dd",{children:["Storage","_","Size may be specified for a task first subtype that is not an interface via an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),". When the attribute is specified, the Storage","_","Size aspect is specified to be the value of the given ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.4#S0132",children:"expression"})}),". ",(0,s.jsx)("br",{})]})}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(o.A,{children:"3.a/3"}),(0,s.jsx)(c.A,{items:["AI05-0229-1"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"ramification",children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)("strong",{}),"When this attribute is specified with an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),", the associated aspect is set to the ",(0,s.jsx)("em",{children:"value"})," of the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.4#S0132",children:"expression"})})," given in the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-13/AA-13.3#S0349",children:"attribute_definition_clause"})}),", rather than the ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-4/AA-4.4#S0132",children:"expression"})})," itself. This value is therefore the same for all objects of the type; in particular, it is not re-evaluated when objects are created. This is different than when the aspect is specified with an ",(0,s.jsx)("code",{children:(0,s.jsx)("a",{href:"../AA-13/AA-13.1#S0346",children:"aspect_specification"})})," (see ",(0,s.jsx)("a",{href:"../AA-13/AA-13.3",children:"13.3"}),"). ",(0,s.jsx)("br",{})]})})]}),"\n",(0,s.jsx)(r.A,{children:(0,s.jsx)(i.h4,{id:"wording-changes-from-ada-95",children:"Wording Changes from Ada 95"})}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(o.A,{children:"3.b/2"}),(0,s.jsx)(c.A,{items:["AI95-00345-01"]}),(0,s.jsx)(a.A,{type:"aarm",aarm:"note",children:(0,s.jsxs)(i.p,{children:["We don't allow specifying Storage","_","Size on task interfaces. We don't need to mention class-wide task types, because these cannot be a first subtype. ",(0,s.jsx)("br",{})]})})]})]})}function x(e={}){const{wrapper:i}={...(0,n.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);