"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4198],{30266:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>m,default:()=>b,frontMatter:()=>c,metadata:()=>y,toc:()=>g});var a=n(91716),i=Object.defineProperty,s=Object.defineProperties,r=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&d(e,n,t[n]);if(o)for(var n of o(t))p.call(t,n)&&d(e,n,t[n]);return e};const c={title:"5.3 Types"},m=void 0,y={unversionedId:"style-guide/s5/03",id:"style-guide/s5/03",title:"5.3 Types",description:"In addition to determining the possible values for variables and subtype",source:"@site/docs/style-guide/s5/03.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/03",permalink:"/docs/style-guide/s5/03",draft:!1,tags:[],version:"current",frontMatter:{title:"5.3 Types"},sidebar:"styleGuideSidebar",previous:{title:"5.2 Parameter Lists",permalink:"/docs/style-guide/s5/02"},next:{title:"5.4 Data Structures",permalink:"/docs/style-guide/s5/04"}},h={},g=[{value:"Derived Types and Subtypes",id:"derived-types-and-subtypes",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Anonymous Types",id:"anonymous-types",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes-1",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Private Types",id:"private-types",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-2",level:4},{value:"Subprogram Access Types",id:"subprogram-access-types",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4}],f={toc:g};function b(e){var t,n=e,{components:i}=n,d=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&o)for(var a of o(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},f),d),s(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"In addition to determining the possible values for variables and subtype\nnames, type distinctions can be very valuable aids in developing safe,\nreadable, and understandable code. Types clarify the structure of your\ndata and can limit or restrict the operations performed on that data."),(0,a.kt)("i",null,'"Keeping types distinct has been found to be a very powerful means of detecting logical mistakes when a program is written and to give valuable assistance whenever the program is being subsequently maintained"')," (Pyle 1985 ). Take advantage of Ada's strong typing capability in the form of subtypes, derived types, task types, protected types, private types, and limited private types.",(0,a.kt)("p",null,"The guidelines encourage much code to be written to ensure strong\ntyping. While it might appear that there would be execution penalties\nfor this amount of code, this is usually not the case. In contrast to\nother conventional languages, Ada has a less direct relationship between\nthe amount of code that is written and the size of the resulting\nexecutable program. Most of the strong type checking is performed at\ncompilation time rather than execution time, so the size of the\nexecutable code is not greatly affected."),(0,a.kt)("p",null,"For guidelines on specific kinds of data structures and tagged types,\nsee 9.2.1 , respectively."),(0,a.kt)("h3",u({},{id:"derived-types-and-subtypes"}),"Derived Types and Subtypes"),(0,a.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use existing types as building blocks by deriving new types from\nthem."),(0,a.kt)("li",{parentName:"ul"},"Use range constraints on subtypes."),(0,a.kt)("li",{parentName:"ul"},"Define new types, especially derived types, to include the largest\nset of possible values, including boundary values."),(0,a.kt)("li",{parentName:"ul"},"Constrain the ranges of derived types with subtypes, excluding\nboundary values."),(0,a.kt)("li",{parentName:"ul"},"Use type derivation rather than type extension when there are no\nmeaningful components to add to the type.")),(0,a.kt)("h4",u({},{id:"example"}),"example"),(0,a.kt)("p",null,"Type ",(0,a.kt)("inlineCode",{parentName:"p"},"Table")," is a building block for the creation of new types:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Table is\n   record\n      Count : List_Size  := Empty;\n      List  : Entry_List := Empty_List;\n   end record;\ntype Telephone_Directory  is new Table;\ntype Department_Inventory is new Table;\n")),(0,a.kt)("p",null,"The following are distinct types that cannot be intermixed in operations\nthat are not programmed explicitly to use them both:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Dollars is new Number;\ntype Cents   is new Number;\n")),(0,a.kt)("p",null,"Below, ",(0,a.kt)("inlineCode",{parentName:"p"},"Source_Tail")," has a value outside the range of ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper"),"\nwhen the line is empty. All the indices can be mixed in expressions, as\nlong as the results fall within the correct subtypes:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Columns          is range First_Column - 1 .. Listing_Width + 1;\n\nsubtype Listing_Paper is Columns range First_Column .. Listing_Width;\nsubtype Dumb_Terminal is Columns range First_Column .. Dumb_Terminal_Width;\ntype Line             is array (Columns range <>) of Bytes;\nsubtype Listing_Line  is Line (Listing_Paper);\nsubtype Terminal_Line is Line (Dumb_Terminal);\nSource_Tail : Columns       := Columns'First;\nSource      : Listing_Line;\nDestination : Terminal_Line;\n...\nDestination(Destination'First .. Source_Tail - Destination'Last) :=\n      Source(Columns'Succ(Destination'Last) .. Source_Tail);\n")),(0,a.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"The name of a derived type can make clear its intended use and avoid\nproliferation of similar type definitions. Objects of two derived types,\neven though derived from the same type, cannot be mixed in operations\nunless such operations are supplied explicitly or one is converted to\nthe other explicitly. This prohibition is an enforcement of strong\ntyping."),(0,a.kt)("p",null,"Define new types, derived types, and subtypes cautiously and\ndeliberately. The concepts of subtype and derived type are not\nequivalent, but they can be used to advantage in concert. A subtype\nlimits the range of possible values for a type but does not define a new\ntype."),(0,a.kt)("p",null,"Types can have highly constrained sets of values without eliminating\nuseful values. Used in concert, derived types and subtypes can eliminate\nmany flag variables and type conversions within executable statements.\nThis renders the program more readable, enforces the abstraction, and\nallows the compiler to enforce strong typing constraints."),(0,a.kt)("p",null,"Many algorithms begin or end with values just outside the normal range.\nIf boundary values are not compatible within subexpressions, algorithms\ncan be needlessly complicated. The program can become cluttered with\nflag variables and special cases when it could just test for zero or\nsome other sentinel value just outside normal range."),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"Columns")," and the subtype ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper")," in the example above\ndemonstrate how to allow sentinel values. The subtype ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper"),"\ncould be used as the type for parameters of subprograms declared in the\nspecification of a package. This would restrict the range of values that\ncould be specified by the caller. Meanwhile, the type ",(0,a.kt)("inlineCode",{parentName:"p"},"Columns")," could be\nused to store such values internally to the body of the package,\nallowing ",(0,a.kt)("inlineCode",{parentName:"p"},"First_Column - 1")," to be used as a sentinel value. This\ncombination of types and subtypes allows compatibility between subtypes\nwithin subexpressions without type conversions as would happen with\nderived types."),(0,a.kt)("p",null,"The choice between type derivation and type extension depends on what\nkind of changes you expect to occur to objects in the type. In general,\ntype derivation is a very simple form of inheritance: the derived types\ninherit the structure, operations, and values of the parent type\n(Rationale 1995, \xa74.2 ). Although you can add operations, you cannot\naugment the data structure. You can derive from either scalar or\ncomposite types."),(0,a.kt)("p",null,"Type extension is a more powerful form of inheritance, only applied to\n",(0,a.kt)("inlineCode",{parentName:"p"},"tagged")," records, in which you can augment both the type's components\nand operations. When the record implements an abstraction with the\npotential for reuse and/or extension, it is a good candidate for making\nit ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged"),". Similarly, if the abstraction is a member of a family of\nabstractions with well-defined variable and common properties, you\nshould consider a ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged")," record."),(0,a.kt)("h4",u({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"The price of the reduction in the number of independent type\ndeclarations is that subtypes and derived types change when the base\ntype is redefined. This trickle-down of changes is sometimes a blessing\nand sometimes a curse. However, usually it is intended and beneficial."),(0,a.kt)("h3",u({},{id:"anonymous-types"}),"Anonymous Types"),(0,a.kt)("h4",u({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid anonymous array types."),(0,a.kt)("li",{parentName:"ul"},"Use anonymous array types for array variables only when no suitable\ntype exists or can be created and the array will not be referenced\nas a whole (e.g., used as a subprogram parameter)."),(0,a.kt)("li",{parentName:"ul"},"Use access parameters and access discriminants to guarantee that the\nparameter or discriminant is treated as a constant.")),(0,a.kt)("h4",u({},{id:"example-1"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Buffer_Index is range 1 .. 80;\ntype Buffer       is array (Buffer_Index) of Character;\nInput_Line : Buffer;\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Input_Line : array (Buffer_Index) of Character;\n")),(0,a.kt)("h4",u({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Although Ada allows anonymous types, they have limited usefulness and\ncomplicate program modification. For example, except for arrays, a\nvariable of anonymous type can never be used as an actual parameter\nbecause it is not possible to define a formal parameter of the same\ntype. Even though this may not be a limitation initially, it precludes a\nmodification in which a piece of code is changed to a subprogram.\nAlthough you can declare the anonymous array to be aliased, you cannot\nuse this access value as an actual parameter in a subprogram because the\nsubprogram's formal parameter declaration requires a type mark. Also,\ntwo variables declared using the same anonymous type declaration are\nactually of different types."),(0,a.kt)("p",null,"Even though the implicit conversion of array types during parameter\npassing is supported in Ada, it is difficult to justify not using the\ntype of the parameter. In most situations, the type of the parameter is\nvisible and easily substituted in place of an anonymous array type. The\nuse of an anonymous array type implies that the array is only being used\nas a convenient way to implement a collection of values. It is\nmisleading to use an anonymous type, and then treat the variable as an\nobject."),(0,a.kt)("p",null,"When you use an access parameter or access discriminant, the anonymous\ntype is essentially declared inside the subprogram or object itself\n(Rationale 1995, \xa73.7.1 ). Thus, you have no way of declaring another\nobject of the same type, and the object is treated as a constant. In the\ncase of a self-referential data structure (see"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," Guideline 5.4.6 ), you need the access parameter to be able to")),(0,a.kt)("p",null,"manipulate the data the discriminant accesses (Rationale 1995, \xa73.7.1 )."),(0,a.kt)("h4",u({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"For anonymous task types, see Guideline 6.1.4 ."),(0,a.kt)("h4",u({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"If you are creating a unique table, for example, the periodic table of\nthe elements, consider using an anonymous array type."),(0,a.kt)("h3",u({},{id:"private-types"}),"Private Types"),(0,a.kt)("h4",u({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Derive from controlled types in preference to using limited private\ntypes."),(0,a.kt)("li",{parentName:"ul"},"Use limited private types in preference to private types."),(0,a.kt)("li",{parentName:"ul"},"Use private types in preference to nonprivate types."),(0,a.kt)("li",{parentName:"ul"},"Explicitly export needed operations rather than easing restrictions.")),(0,a.kt)("h4",u({},{id:"example-2"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"------------------------------------------------------------------------\nwith Ada.Finalization;\npackage Packet_Telemetry is\n   type Frame_Header is new Ada.Finalization.Controlled with private;\n   type Frame_Data   is private;\n   type Frame_Codes  is (Main_Bus_Voltage, Transmitter_1_Power);\n   ...\nprivate\n   type Frame_Header is new Ada.Finalization.Controlled with\n      record\n         ...\n      end record;\n   -- override adjustment and finalization to get correct assignment semantics\n   procedure Adjust (Object : in out Frame_Header);\n   procedure Finalize (Object : in out Frame_Header);\n   type Frame_Data is\n      record\n         ...\n      end record;\n   ...\nend Packet_Telemetry;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",u({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Limited private types and private types support abstraction and\ninformation hiding better than nonprivate types. The more restricted the\ntype, the better information hiding is served. This, in turn, allows the\nimplementation to change without affecting the rest of the program.\nWhile there are many valid reasons to export types, it is better to try\nthe preferred route first, loosening the restrictions only as necessary.\nIf it is necessary for a user of the package to use a few of the\nrestricted operations, it is better to export the operations explicitly\nand individually via exported subprograms than to drop a level of\nrestriction. This practice retains the restrictions on other operations."),(0,a.kt)("p",null,"Limited private types have the most restricted set of operations\navailable to users of a package. Of the types that must be made\navailable to users of a package, as many as possible should be derived\nfrom the controlled types or limited private. Controlled types give you\nthe ability to adjust assignment and to finalize values, so you no\nlonger need to create limited private types to guarantee a client that\nassignment and equality obey deep copy/comparison semantics. Therefore,\nit is possible to export a slightly less restrictive type (i.e., private\ntype that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Finalization.Controlled"),") that has an adjustable\nassignment operator and overridable equality operator. See also\nGuideline 5.4.5 ."),(0,a.kt)("p",null,"The operations available to limited private types are membership tests,\nselected components, components for the selections of any discriminant,\nqualification and explicit conversion, and attributes ",(0,a.kt)("inlineCode",{parentName:"p"},"'Base")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"'Size"),". Objects of a limited private type also have the attribute\n",(0,a.kt)("inlineCode",{parentName:"p"},"'Constrained")," if there are discriminants. None of these operations\nallows the user of the package to manipulate objects in a way that\ndepends on the structure of the type."),(0,a.kt)("h4",u({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"The predefined packages ",(0,a.kt)("inlineCode",{parentName:"p"},"Direct_IO")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Sequential_IO"),"do not accept\nlimited private types as generic parameters. This restriction should be\nconsidered when I/O operations are needed for a type."),(0,a.kt)("p",null,"See Guideline 8.3.3 for a discussion of the use of private and limited\nprivate types in generic units."),(0,a.kt)("h3",u({},{id:"subprogram-access-types"}),"Subprogram Access Types"),(0,a.kt)("h4",u({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access-to-subprogram types for indirect access to subprograms."),(0,a.kt)("li",{parentName:"ul"},"Wherever possible, use abstract tagged types and dispatching rather\nthan access-to-subprogram types to implement dynamic selection and\ninvocation of subprograms.")),(0,a.kt)("h4",u({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"The following example is taken from the Rationale (1995, \xa73.7.2) :"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"generic\n   type Float_Type is digits <>;\npackage Generic_Integration is\n   type Integrand is access function (X : Float_Type) return Float_Type;\n   function Integrate (F        : Integrand;\n                       From     : Float_Type;\n                       To       : Float_Type;\n                       Accuracy : Float_Type := 10.0*Float_Type'Model_Epsilon)\n     return Float_Type;\nend Generic_Integration;\nwith Generic_Integration;\nprocedure Try_Estimate (External_Data : in     Data_Type;\n                        Lower         : in     Float;\n                        Upper         : in     Float;\n                        Answer        :    out Float) is\n   -- external data set by other means\n   function Residue (X : Float) return Float is\n      Result : Float;\n   begin  -- Residue\n      -- compute function value dependent upon external data\n      return Result;\n   end Residue;\n   package Float_Integration is\n      new Generic_Integration (Float_Type => Float);\n\n   use Float_Integration;\nbegin -- Try_Estimate\n   ...\n   Answer := Integrate (F    => Residue'Access,\n                        From => Lower,\n                        To   => Upper);\nend Try_Estimate;\n")),(0,a.kt)("h4",u({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"Access-to-subprogram types allow you to create data structures that\ncontain subprogram references. There are many uses for this feature, for\ninstance, implementing state machines, call backs in the X Window\nSystem, iterators (the operation to be applied to each element of a\nlist), and numerical algorithms (e.g., integration function) (Rationale\n1995, \xa73.7.2 )."),(0,a.kt)("p",null,"You can achieve the same effect as access-to-subprogram types for\ndynamic selection by using abstract tagged types. You declare an\nabstract type with one abstract operation and then use an\naccess-to-class-wide type to get the dispatching effect. This technique\nprovides greater flexibility and type safety than access-to-subprogram\ntypes (Ada Reference Manual 1995, \xa73.10.2 )."),(0,a.kt)("p",null,"Access-to-subprogram types are useful in implementing dynamic selection.\nReferences to the subprograms can be stored directly in the data\nstructure. In a finite state machine, for example, a single data\nstructure can describe the action to be taken on state transitions.\nStrong type checking is maintained because Ada 95 requires that the\ndesignated subprogram has the same parameter/result profile as the one\nspecified in the subprogram access type."),(0,a.kt)("p",null,"See also Guideline 7.3.2 ."))}b.isMDXComponent=!0}}]);