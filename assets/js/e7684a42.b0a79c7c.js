"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5996],{1716:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(6687);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r=a.createContext({}),c=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(r.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,r=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=s,p=u["".concat(r,".").concat(h)]||u[h]||d[h]||i;return n?a.createElement(p,o(o({ref:t},m),{},{components:n})):a.createElement(p,o({ref:t},m))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:s,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1979:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(9440),s=(n(6687),n(1716));const i={sidebar_position:6},o="5 Statements",l={unversionedId:"arm/AA-5",id:"arm/AA-5",title:"5 Statements",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-5.md",sourceDirName:"arm",slug:"/arm/AA-5",permalink:"/docs/arm/AA-5",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"4 Names and Expressions",permalink:"/docs/arm/AA-4"},next:{title:"6 Subprograms",permalink:"/docs/arm/AA-6"}},r={},c=[{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"5.1  Simple and Compound Statements - Sequences of Statements",id:"51--simple-and-compound-statements---sequences-of-statements",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"5.2  Assignment Statements",id:"52--assignment-statements",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"5.3  If Statements",id:"53--if-statements",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"5.4  Case Statements",id:"54--case-statements",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"5.5  Loop Statements",id:"55--loop-statements",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"5.6  Block Statements",id:"56--block-statements",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"5.7  Exit Statements",id:"57--exit-statements",level:2},{value:"Syntax",id:"syntax-6",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-6",level:4},{value:"Examples",id:"examples-6",level:4},{value:"5.8  Goto Statements",id:"58--goto-statements",level:2},{value:"Syntax",id:"syntax-7",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-5",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-7",level:4},{value:"Examples",id:"examples-7",level:4}],m={toc:c};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"5-statements"},"5 Statements"),(0,s.kt)("admonition",{type:"warning"},(0,s.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,s.kt)("p",null,"[A statement defines an action to be performed upon its execution.]"),(0,s.kt)("p",null,'[This section describes the general rules applicable to all statements. Some statements are discussed in later sections: Procedure_call_statements and return_statements are described in 6, "Subprograms". Entry_call_statements, requeue_statements, delay_statements, accept_statements, select_statements, and abort_statements are described in 9, "Tasks and Synchronization". Raise_statements are described in 11, "Exceptions", and code_statements in 13. The remaining forms of statements are presented in this section.]'," "),(0,s.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,'The description of return_statements has been moved to 6.5, "Return Statements", so that it is closer to the description of subprograms. '),(0,s.kt)("h2",{id:"51--simple-and-compound-statements---sequences-of-statements"},"5.1  Simple and Compound Statements - Sequences of Statements"),(0,s.kt)("p",null,"[A statement is either simple or compound. A simple_statement encloses no other statement. A compound_statement can enclose simple_statements and other compound_statements.]"),(0,s.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[parallel construct]",", Def=","[an executable construct that defines multiple activities of a single task that can proceed in parallel, via the execution of multiple logical threads of control]"," "),(0,s.kt)("h4",{id:"syntax"},"Syntax"),(0,s.kt)("p",null,"sequence_of_statements ::= statement {statement}"),(0,s.kt)("p",null,"statement ::=\n{label} simple_statement | {label} compound_statement"),(0,s.kt)("p",null,"simple_statement ::= null_statement\n| assignment_statement\t| exit_statement\n| goto_statement\t| procedure_call_statement\n| return_statement\t| entry_call_statement\n| requeue_statement\t| delay_statement\n| abort_statement\t| raise_statement\n| code_statement"),(0,s.kt)("p",null,"compound_statement ::=\nif_statement\t| case_statement\n| loop_statement\t| block_statement\n| accept_statement\t| select_statement"),(0,s.kt)("p",null,"null_statement ::= null;"),(0,s.kt)("p",null,"label ::= ","<","<","label_statement_identifier",">",">"),(0,s.kt)("p",null,"statement_identifier ::= direct_name"),(0,s.kt)("p",null,"The direct_name of a statement_identifier shall be an identifier (not an operator_symbol). "),(0,s.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,s.kt)("p",null,"The direct_name of a statement_identifier shall resolve to denote its corresponding implicit declaration (see below). "),(0,s.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,s.kt)("p",null,"Distinct identifiers shall be used for all statement_identifiers that appear in the same body, including inner block_statements but excluding inner program units. "),(0,s.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,s.kt)("p",null,"For each statement_identifier, there is an implicit declaration (with the specified identifier) at the end of the declarative_part of the innermost block_statement or body that encloses the statement_identifier. The implicit declarations occur in the same order as the statement_identifiers occur in the source text. If a usage name denotes such an implicit declaration, the entity it denotes is the label, loop_statement, or block_statement with the given statement_identifier. "),(0,s.kt)("p",null,"Reason: We talk in terms of individual statement_identifiers here rather than in terms of the corresponding statements, since a given statement may have multiple statement_identifiers."),(0,s.kt)("p",null,"A block_statement that has no explicit declarative_part has an implicit empty declarative_part, so this rule can safely refer to the declarative_part of a block_statement."),(0,s.kt)("p",null,"The scope of a declaration starts at the place of the declaration itself (see 8.2). In the case of a label, loop, or block name, it follows from this rule that the scope of the implicit declaration starts before the first explicit occurrence of the corresponding name, since this occurrence is either in a statement label, a loop_statement, a block_statement, or a goto_statement. An implicit declaration in a block_statement may hide a declaration given in an outer program unit or block_statement (according to the usual rules of hiding explained in 8.3)."),(0,s.kt)("p",null,"The syntax rule for label uses statement_identifier which is a direct_name (not a defining_identifier), because labels are implicitly declared. The same applies to loop and block names. In other words, the label itself is not the defining occurrence; the implicit declaration is."),(0,s.kt)("p",null,"We cannot consider the label to be a defining occurrence. An example that can tell the difference is this: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"declare\n    -- Label Foo is implicitly declared here.\nbegin\n    for Foo in ... loop\n        ...\n        &lt&ltFoo&gt&gt -- Illegal.\n        ...\n    end loop;\nend;\n  \n\n")),(0,s.kt)("p",null,"The label in this example is hidden from itself by the loop parameter with the same name; the example is illegal. We considered creating a new syntactic category name, separate from direct_name and selector_name, for use in the case of statement labels. However, that would confuse the rules in Section 8, so we didn't do it. "),(0,s.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,s.kt)("p",null,"The execution of a null_statement has no effect."),(0,s.kt)("p",null,"A transfer of control is the run-time action of an exit_statement, return_statement, goto_statement, or requeue_statement, selection of a terminate_alternative, raising of an exception, or an abort, which causes the next action performed to be one other than what would normally be expected from the other rules of the language. ","[As explained in 7.6.1, a transfer of control can cause the execution of constructs to be completed and then left, which may trigger finalization.]"),(0,s.kt)("p",null,"The execution of a sequence",(0,s.kt)("em",{parentName:"p"},"of_statements consists of the execution of the individual statements in succession until the sequence")," is completed. "),(0,s.kt)("p",null,"Ramification: It could be completed by reaching the end of it, or by a transfer of control. "),(0,s.kt)("p",null,"NOTE   A statement_identifier that appears immediately within the declarative region of a named loop_statement or an accept_statement is nevertheless implicitly declared immediately within the declarative region of the innermost enclosing body or block_statement; in other words, the expanded name for a named statement is not affected by whether the statement occurs inside or outside a named loop or an accept_statement - only nesting within block_statements is relevant to the form of its expanded name. "),(0,s.kt)("p",null,"Discussion: Each comment in the following example gives the expanded name associated with an entity declared in the task body: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"task body Compute is\n   Sum : Integer := 0;                       -- Compute.Sum\nbegin\n Outer:                                      -- Compute.Outer\n   for I in 1..10 loop     -- Compute.Outer.I\n    Blk:                                     -- Compute.Blk\n      declare\n         Sum : Integer := 0;                 -- Compute.Blk.Sum\n      begin\n         accept Ent(I : out Integer; J : in Integer) do\n                                             -- Compute.Ent.I, Compute.Ent.J\n            Compute.Ent.I := Compute.Outer.I;\n          Inner:                             -- Compute.Blk.Inner\n            for J in 1..10 loop\n                                             -- Compute.Blk.Inner.J\n               Sum := Sum + Compute.Blk.Inner.J * Compute.Ent.J;\n            end loop Inner;\n         end Ent;\n         Compute.Sum := Compute.Sum + Compute.Blk.Sum;\n      end Blk;\n   end loop Outer;\n   Record_Result(Sum);\nend Compute;\n\n")),(0,s.kt)("h4",{id:"examples"},"Examples"),(0,s.kt)("p",null,"Examples of labeled statements: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"&lt&ltHere&gt&gt &lt&ltIci&gt&gt &lt&ltAqui&gt&gt &lt&ltHier&gt&gt null;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"&lt&ltAfter&gt&gt X := 1;\n\n")),(0,s.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,s.kt)("p",null,"The requeue_statement is new. "),(0,s.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,"We define the syntactic category statement_identifier to simplify the description. It is used for labels, loop names, and block names. We define the entity associated with the implicit declarations of statement names."),(0,s.kt)("p",null,"Completion includes completion caused by a transfer of control, although RM83-5.1(6) did not take this view. "),(0,s.kt)("h2",{id:"52--assignment-statements"},"5.2  Assignment Statements"),(0,s.kt)("p",null,"[An assignment_statement replaces the current value of a variable with the result of evaluating an expression.]"," "),(0,s.kt)("h4",{id:"syntax-1"},"Syntax"),(0,s.kt)("p",null,"assignment_statement ::=\nvariable_name := expression;"),(0,s.kt)("p",null,"The execution of an assignment_statement includes the evaluation of the expression and the assignment of the value of the expression into the target. ","[An assignment operation (as opposed to an assignment_statement) is performed in other contexts as well, including object initialization and by-copy parameter passing.]"," The target of an assignment operation is the view of the object to which a value is being assigned; the target of an assignment_statement is the variable denoted by the variable_name. "),(0,s.kt)("p",null,'Discussion: Don\'t confuse this notion of the "target" of an assignment with the notion of the "target object" of an entry call or requeue.'),(0,s.kt)("p",null,'Don\'t confuse the term "assignment operation" with the assignment_statement. The assignment operation is just one part of the execution of an assignment_statement. The assignment operation is also a part of the execution of various other constructs; see 7.6.1, "Completion and Finalization" for a complete list. Note that when we say, "such-and-such is assigned to so-and-so", we mean that the assignment operation is being applied, and that so-and-so is the target of the assignment operation. '),(0,s.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,s.kt)("p",null,"The variable_name of an assignment_statement is expected to be of any nonlimited type. The expected type for the expression is the type of the target. "),(0,s.kt)("p",null,'Implementation Note: An assignment_statement as a whole is a "complete context", so if the variable_name of an assignment_statement is overloaded, the expression can be used to help disambiguate it. For example: '),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"  type P1 is access R1;\n  type P2 is access R2;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"  function F return P1;\n  function F return P2;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"  X : R1;\nbegin\n  F.all := X;  -- Right hand side helps resolve left hand side\n\n")),(0,s.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,s.kt)("p",null,"The target ","[denoted by the variable_name]"," shall be a variable."),(0,s.kt)("p",null,"If the target is of a tagged class-wide type T'Class, then the expression shall either be dynamically tagged, or of type T and tag-indeterminate (see 3.9.2). "),(0,s.kt)("p",null,"Reason: This is consistent with the general rule that a single dispatching operation shall not have both dynamically tagged and statically tagged operands. Note that for an object initialization (as opposed to the assignment_statement), a statically tagged initialization expression is permitted, since there is no chance for confusion (or Tag_Check failure). Also, in an object initialization, tag-indeterminate expressions of any type covered by T'Class would be allowed, but with an assignment_statement, that might not work if the tag of the target was for a type that didn't have one of the dispatching operations in the tag-indeterminate expression. "),(0,s.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,s.kt)("p",null,"For the execution of an assignment_statement, the variable_name and the expression are first evaluated in an arbitrary order. "),(0,s.kt)("p",null,"Ramification: Other rules of the language may require that the bounds of the variable be determined prior to evaluating the expression, but that does not necessarily require evaluation of the variable_name, as pointed out by the ACID. "),(0,s.kt)("p",null,"When the type of the target is class-wide: "),(0,s.kt)("p",null,"If the expression is tag-indeterminate (see 3.9.2), then the controlling tag value for the expression is the tag of the target; "),(0,s.kt)("p",null,'Ramification: See 3.9.2, "Dispatching Operations of Tagged Types". '),(0,s.kt)("p",null,"Otherwise ","[(the expression is dynamically tagged)]",", a check is made that the tag of the value of the expression is the same as that of the target; if this check fails, Constraint_Error is raised. "),(0,s.kt)("p",null,"The value of the expression is converted to the subtype of the target. ","[The conversion might raise an exception (see 4.6).]"," "),(0,s.kt)("p",null,'Ramification: 4.6, "Type Conversions" defines what actions and checks are associated with subtype conversion. For non-array subtypes, it is just a constraint check presuming the types match. For array subtypes, it checks the lengths and slides if the target is constrained. "Sliding" means the array doesn\'t have to have the same bounds, so long as it is the same length. '),(0,s.kt)("p",null,'In cases involving controlled types, the target is finalized, and an anonymous object might be used as an intermediate in the assignment, as described in 7.6.1, "Completion and Finalization". In any case, the converted value of the expression is then assigned to the target, which consists of the following two steps: '),(0,s.kt)("p",null,"To be honest: 7.6.1 actually says that finalization happens always, but unless controlled types are involved, this finalization during an assignment_statement does nothing. "),(0,s.kt)("p",null,"The value of the target becomes the converted value."),(0,s.kt)("p",null,"If any part of the target is controlled, its value is adjusted as explained in clause 7.6. "),(0,s.kt)("p",null,"Ramification: If any parts of the object are controlled, abort is deferred during the assignment operation itself, but not during the rest of the execution of an assignment_statement. "),(0,s.kt)("p",null,"NOTE   The tag of an object never changes; in particular, an assignment_statement does not change the tag of the target."),(0,s.kt)("p",null,"NOTE   The values of the discriminants of an object designated by an access value cannot be changed (not even by assigning a complete value to the object itself) since such objects are always constrained; however, subcomponents of such objects may be unconstrained. "),(0,s.kt)("p",null,"Ramification: The implicit subtype conversion described above for assignment_statements is performed only for the value of the right-hand side expression as a whole; it is not performed for subcomponents of the value."),(0,s.kt)("p",null,'The determination of the type of the variable of an assignment_statement may require consideration of the expression if the variable name can be interpreted as the name of a variable designated by the access value returned by a function call, and similarly, as a component or slice of such a variable (see 8.6, "The Context of Overload Resolution"). '),(0,s.kt)("h4",{id:"examples-1"},"Examples"),(0,s.kt)("p",null,"Examples of assignment statements: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Value := Max_Value - 1;\nShade := Blue;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Next_Frame(F)(M, N) := 2.5;        --  see 4.1.1\nU := Dot_Product(V, W);            --  see 6.3\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Writer := (Status =&gt Open, Unit =&gt Printer, Line_Count =&gt 60);  -- see 3.8.1\nNext_Car.all := (72074, null);    --  see 3.10.1\n\n")),(0,s.kt)("p",null,"Examples involving scalar subtype conversions: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"I, J : Integer range 1 .. 10 := 5;\nK    : Integer range 1 .. 20 := 15;\n ...\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"I := J;  --  identical ranges\nK := J;  --  compatible ranges\nJ := K;  --  will raise Constraint_Error if K &gt 10\n\n")),(0,s.kt)("p",null,"Examples involving array subtype conversions: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"A : String(1 .. 31);\nB : String(3 .. 33);\n ...\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"A := B;  --  same number of components\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},'A(1 .. 9)  := "tar sauce";\nA(4 .. 12) := A(1 .. 9);  --  A(1 .. 12) = "tartar sauce"\n\n')),(0,s.kt)("p",null,'NOTE 1   Notes on the examples: Assignment_statements are allowed even in the case of overlapping slices of the same array, because the variable_name and expression are both evaluated before copying the value into the variable. In the above example, an implementation yielding A(1 .. 12) = "tartartartar" would be incorrect. '),(0,s.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,s.kt)("p",null,'We now allow user-defined finalization and value adjustment actions as part of assignment_statements (see 7.6, "User-Defined Assignment and Finalization"). '),(0,s.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,'The special case of array assignment is subsumed by the concept of a subtype conversion, which is applied for all kinds of types, not just arrays. For arrays it provides "sliding". For numeric types it provides conversion of a value of a universal type to the specific type of the target. For other types, it generally has no run-time effect, other than a constraint check.'),(0,s.kt)("p",null,"We now cover in a general way in 3.7.2 the erroneous execution possible due to changing the value of a discriminant when the variable in an assignment_statement is a subcomponent that depends on discriminants. "),(0,s.kt)("h2",{id:"53--if-statements"},"5.3  If Statements"),(0,s.kt)("p",null,"[An if_statement selects for execution at most one of the enclosed sequences_of_statements, depending on the (truth) value of one or more corresponding conditions.]"," "),(0,s.kt)("h4",{id:"syntax-2"},"Syntax"),(0,s.kt)("p",null,"if_statement ::=\nif condition then\nsequence_of_statements\n{elsif condition then\nsequence_of_statements}\n","[else\nsequence_of_statements]","\nend if;"),(0,s.kt)("p",null,"condition ::= boolean_expression"),(0,s.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,s.kt)("p",null,"A condition is expected to be of any boolean type. "),(0,s.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,s.kt)("p",null,"For the execution of an if_statement, the condition specified after if, and any conditions specified after elsif, are evaluated in succession (treating a final else as elsif True then), until one evaluates to True or all conditions are evaluated and yield False. If a condition evaluates to True, then the corresponding sequence_of_statements is executed; otherwise none of them is executed. "),(0,s.kt)("p",null,"Ramification: The part about all evaluating to False can't happen if there is an else, since that is herein considered equivalent to elsif True then. "),(0,s.kt)("h4",{id:"examples-2"},"Examples"),(0,s.kt)("p",null,"Examples of if statements: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"if Month = December and Day = 31 then\n   Month := January;\n   Day   := 1;\n   Year  := Year + 1;\nend if;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"if Line_Too_Short then\n   raise Layout_Error;\nelsif Line_Full then\n   New_Line;\n   Put(Item);\nelse\n   Put(Item);\nend if;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},'if My_Car.Owner.Vehicle /= My_Car then            --  see 3.10.1\n   Report ("Incorrect data");\nend if;\n\n')),(0,s.kt)("h2",{id:"54--case-statements"},"5.4  Case Statements"),(0,s.kt)("p",null,"[A case_statement selects for execution one of a number of alternative sequences_of_statements; the chosen alternative is defined by the value of an expression.]"," "),(0,s.kt)("h4",{id:"syntax-3"},"Syntax"),(0,s.kt)("p",null,"case_statement ::=\ncase expression is\ncase_statement_alternative\n{case_statement_alternative}\nend case;"),(0,s.kt)("p",null,"case_statement_alternative ::=\nwhen discrete_choice_list =",">","\nsequence_of_statements"),(0,s.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,s.kt)("p",null,"The expression is expected to be of any discrete type. The expected type for each discrete_choice is the type of the expression. "),(0,s.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,s.kt)("p",null,"The expressions and discrete_ranges given as discrete_choices of a case_statement shall be static. ","[A discrete_choice others, if present, shall appear alone and in the last discrete_choice_list.]"),(0,s.kt)("p",null,"The possible values of the expression shall be covered as follows: "),(0,s.kt)("p",null,"If the expression is a name ","[(including a type_conversion or a function_call)]"," having a static and constrained nominal subtype, or is a qualified_expression whose subtype_mark denotes a static and constrained scalar subtype, then each non-others discrete_choice shall cover only values in that subtype, and each value of that subtype shall be covered by some discrete_choice ","[(either explicitly or by others)]",". "),(0,s.kt)("p",null,"Ramification: Although not official names of objects, a value conversion still has a defined nominal subtype, namely its target subtype. See 4.6. "),(0,s.kt)("p",null,"If the type of the expression is root_integer, universal_integer, or a descendant of a formal scalar type, then the case_statement shall have an others discrete_choice. "),(0,s.kt)("p",null,"Reason: This is because the base range is implementation defined for root_integer and universal_integer, and not known statically in the case of a formal scalar type. "),(0,s.kt)("p",null,"Otherwise, each value of the base range of the type of the expression shall be covered ","[(either explicitly or by others)]",". "),(0,s.kt)("p",null,"Two distinct discrete_choices of a case_statement shall not cover the same value. "),(0,s.kt)("p",null,"Ramification: The goal of these coverage rules is that any possible value of the expression of a case_statement should be covered by exactly one discrete_choice of the case_statement, and that this should be checked at compile time. The goal is achieved in most cases, but there are two minor loopholes: "),(0,s.kt)("p",null,"If the expression reads an object with an invalid representation (e.g. an uninitialized object), then the value can be outside the covered range. This can happen for static constrained subtypes, as well as nonstatic or unconstrained subtypes. It cannot, however, happen if the case_statement has the discrete_choice others, because others covers all values, even those outside the subtype."),(0,s.kt)("p",null,"If the compiler chooses to represent the value of an expression of an unconstrained subtype in a way that includes values outside the bounds of the subtype, then those values can be outside the covered range. For example, if X: Integer := Integer'Last;, and the case expression is X+1, then the implementation might choose to produce the correct value, which is outside the bounds of Integer. (It might raise Constraint_Error instead.) This case can only happen for nongeneric subtypes that are either unconstrained or non-static (or both). It can only happen if there is no others discrete_choice. "),(0,s.kt)("p",null,"In the uninitialized variable case, the value might be anything; hence, any alternative can be chosen, or Constraint_Error can be raised. (We intend to prevent, however, jumping to random memory locations and the like.) In the out-of-range case, the behavior is more sensible: if there is an others, then the implementation may choose to raise Constraint_Error on the evaluation of the expression (as usual), or it may choose to correctly evaluate the expression and therefore choose the others alternative. Otherwise (no others), Constraint_Error is raised either way - on the expression evaluation, or for the case_statement itself."),(0,s.kt)("p",null,'For an enumeration type with a discontiguous set of internal codes (see 13.4), the only way to get values in between the proper values is via an object with an invalid representation; there is no "out-of-range" situation that can produce them. '),(0,s.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,s.kt)("p",null,"For the execution of a case_statement the expression is first evaluated."),(0,s.kt)("p",null,"If the value of the expression is covered by the discrete_choice_list of some case_statement_alternative, then the sequence_of_statements of the _alternative is executed."),(0,s.kt)("p",null,"Otherwise (the value is not covered by any discrete_choice_list, perhaps due to being outside the base range), Constraint_Error is raised. "),(0,s.kt)("p",null,"Ramification: In this case, the value is outside the base range of its type, or is an invalid representation."),(0,s.kt)("p",null,"NOTE 1   The execution of a case_statement chooses one and only one alternative. Qualification of the expression of a case_statement by a static subtype can often be used to limit the number of choices that need be given explicitly. "),(0,s.kt)("h4",{id:"examples-3"},"Examples"),(0,s.kt)("p",null,"Examples of case statements: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"case Sensor is\n   when Elevation   =&gt Record_Elevation(Sensor_Value);\n   when Azimuth =&gt Record_Azimuth  (Sensor_Value);\n   when Distance    =&gt Record_Distance (Sensor_Value);\n   when others  =&gt null;\nend case;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"case Today is\n   when Mon =&gt Compute_Initial_Balance;\n   when Fri =&gt Compute_Closing_Balance;\n   when Tue .. Thu  =&gt Generate_Report(Today);\n   when Sat .. Sun  =&gt null;\nend case;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"case Bin_Number(Count) is\n   when 1   =&gt Update_Bin(1);\n   when 2   =&gt Update_Bin(2);\n   when 3 | 4   =&gt\n      Empty_Bin(1);\n      Empty_Bin(2);\n   when others  =&gt raise Error;\nend case;\n\n")),(0,s.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,s.kt)("p",null,"In Ada 83, the expression in a case_statement is not allowed to be of a generic formal type. This restriction is removed in Ada 95; an others discrete_choice is required instead."),(0,s.kt)("p",null,'In Ada 95, a function call is the name of an object; this was not true in Ada 83 (see 4.1, "Names"). This change makes the following case_statement legal: '),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"subtype S is Integer range 1..2;\nfunction F return S;\ncase F is\n   when 1 =&gt ...;\n   when 2 =&gt ...;\n   -- No others needed.\nend case;\n\n")),(0,s.kt)("p",null,'Note that the result subtype given in a function renaming_declaration is ignored; for a case_statement whose expression calls a such a function, the full coverage rules are checked using the result subtype of the original function. Note that predefined operators such as "+" have an unconstrained result subtype (see 4.5.1). Note that generic formal functions do not have static result subtypes. Note that the result subtype of an inherited subprogram need not correspond to any namable subtype; there is still a perfectly good result subtype, though. '),(0,s.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,'Ada 83 forgot to say what happens for "legally" out-of-bounds values.'),(0,s.kt)("p",null,'We take advantage of rules and terms (e.g. cover a value) defined for discrete_choices and discrete_choice_lists in 3.8.1, "Variant Parts and Discrete Choices".'),(0,s.kt)("p",null,'In the Name Resolution Rule for the case expression, we no longer need RM83-5.4(3)\'s "which must be determinable independently of the context in which the expression occurs, but using the fact that the expression must be of a discrete type", because the expression is now a complete context. See 8.6, "The Context of Overload Resolution".'),(0,s.kt)("p",null,"Since type_conversions are now defined as names, their coverage rule is now covered under the general rule for names, rather than being separated out along with qualified_expressions. "),(0,s.kt)("h2",{id:"55--loop-statements"},"5.5  Loop Statements"),(0,s.kt)("p",null,"[A loop_statement includes a sequence_of_statements that is to be executed repeatedly, zero or more times.]"," "),(0,s.kt)("h4",{id:"syntax-4"},"Syntax"),(0,s.kt)("p",null,"loop_statement ::=\n","[loop_statement_identifier:][iteration_scheme]"," loop\nsequence_of_statements\nend loop ","[loop_identifier]",";"),(0,s.kt)("p",null,"iteration_scheme ::= while condition\n| for loop_parameter_specification"),(0,s.kt)("p",null,"loop_parameter_specification ::=\ndefining_identifier in ","[reverse]"," discrete_subtype_definition"),(0,s.kt)("p",null,"If a loop_statement has a loop_statement_identifier, then the identifier shall be repeated after the end loop; otherwise, there shall not be an identifier after the end loop."),(0,s.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,s.kt)("p",null,"A loop_parameter_specification declares a loop parameter, which is an object whose subtype is that defined by the discrete_subtype_definition. "),(0,s.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,s.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[iterator filter]",", Def=","[a construct that is used to restrict the elements produced by an iteration to those for which a boolean condition evaluates to True]"),(0,s.kt)("p",null,"For the execution of a loop_statement, the sequence_of_statements is executed repeatedly, zero or more times, until the loop_statement is complete. The loop_statement is complete when a transfer of control occurs that transfers control out of the loop, or, in the case of an iteration_scheme, as specified below."),(0,s.kt)("p",null,"For the execution of a loop_statement with a while iteration_scheme, the condition is evaluated before each execution of the sequence_of_statements; if the value of the condition is True, the sequence_of_statements is executed; if False, the execution of the loop_statement is complete."),(0,s.kt)("p",null,"For the execution of a loop_statement with a for iteration_scheme, the loop_parameter_specification is first elaborated. This elaboration creates the loop parameter and elaborates the discrete_subtype_definition. If the discrete_subtype_definition defines a subtype with a null range, the execution of the loop_statement is complete. Otherwise, the sequence_of_statements is executed once for each value of the discrete subtype defined by the discrete_subtype_definition (or until the loop is left as a consequence of a transfer of control). Prior to each such iteration, the corresponding value of the discrete subtype is assigned to the loop parameter. These values are assigned in increasing order unless the reserved word reverse is present, in which case the values are assigned in decreasing order. "),(0,s.kt)("p",null,"Ramification: The order of creating the loop parameter and evaluating the discrete_subtype_definition doesn't matter, since the creation of the loop parameter has no side effects (other than possibly raising Storage_Error, but anything can do that)."),(0,s.kt)("p",null,"NOTE 1   A loop parameter is a constant; it cannot be updated within the sequence_of_statements of the loop (see 3.3)."),(0,s.kt)("p",null,"NOTE 2   An object_declaration should not be given for a loop parameter, since the loop parameter is automatically declared by the loop_parameter_specification. The scope of a loop parameter extends from the loop_parameter_specification to the end of the loop_statement, and the visibility rules are such that a loop parameter is only visible within the sequence_of_statements of the loop. "),(0,s.kt)("p",null,"Implementation Note: An implementation could give a warning if a variable is hidden by a loop_parameter_specification. "),(0,s.kt)("p",null,"NOTE 3   The discrete_subtype_definition of a for loop is elaborated just once. Use of the reserved word reverse does not alter the discrete subtype defined, so that the following iteration_schemes are not equivalent; the first has a null range. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"for J in reverse 1 .. 0\nfor J in 0 .. 1\n\n")),(0,s.kt)("p",null,"Ramification: If a loop_parameter_specification has a static discrete range, the subtype of the loop parameter is static. "),(0,s.kt)("h4",{id:"examples-4"},"Examples"),(0,s.kt)("p",null,"Example of a loop statement without an iteration scheme: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"loop\n   Get(Current_Character);\n   exit when Current_Character = '*';\nend loop;\n\n")),(0,s.kt)("p",null,"Example of a loop statement with a while iteration scheme: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"while Bid(N).Price &lt Cut_Off.Price loop\n   Record_Bid(Bid(N).Price);\n   N := N + 1;\nend loop;\n\n")),(0,s.kt)("p",null,"Example of a loop statement with a for iteration scheme: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"for J in Buffer'Range loop     --  works even with a null range\n   if Buffer(J) /= Space then\n      Put(Buffer(J));\n   end if;\nend loop;\n\n")),(0,s.kt)("p",null,"Example of a loop statement with a name: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Summation:\n   while Next /= Head loop       -- see 3.10.1\n      Sum  := Sum + Next.Value;\n      Next := Next.Succ;\n   end loop Summation;\n\n")),(0,s.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,'The constant-ness of loop parameters is specified in 3.3, "Objects and Named Numbers". '),(0,s.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,s.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[iterable container type]",", Def=","[a type that has user-defined behavior for iteration, via the Default_Iterator and Iterator_Element aspects]"),(0,s.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,s.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[iterator]",", Def=","[a construct that is used to loop over the elements of an array or container]",", Note1=","[Iterators can be user defined, and can perform arbitrary computations to access elements from a container.]"),(0,s.kt)("h2",{id:"56--block-statements"},"5.6  Block Statements"),(0,s.kt)("p",null,"[A block_statement encloses a handled_sequence_of_statements optionally preceded by a declarative_part.]"," "),(0,s.kt)("h4",{id:"syntax-5"},"Syntax"),(0,s.kt)("p",null,"block_statement ::=\n","[block_statement_identifier:][declare\n            declarative_part]","\nbegin\nhandled_sequence_of_statements\nend ","[block_identifier]",";"),(0,s.kt)("p",null,"If a block_statement has a block_statement_identifier, then the identifier shall be repeated after the end; otherwise, there shall not be an identifier after the end. "),(0,s.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,s.kt)("p",null,"A block_statement that has no explicit declarative_part has an implicit empty declarative_part. "),(0,s.kt)("p",null,"Ramification: Thus, other rules can always refer to the declarative_part of a block_statement. "),(0,s.kt)("h4",{id:"dynamic-semantics-5"},"Dynamic Semantics"),(0,s.kt)("p",null,"The execution of a block_statement consists of the elaboration of its declarative_part followed by the execution of its handled_sequence_of_statements. "),(0,s.kt)("h4",{id:"examples-5"},"Examples"),(0,s.kt)("p",null,"Example of a block statement with a local variable: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Swap:\n   declare\n      Temp : Integer;\n   begin\n      Temp := V; V := U; U := Temp;\n   end Swap;\n\n")),(0,s.kt)("p",null,"Ramification: If task objects are declared within a block_statement whose execution is completed, the block_statement is not left until all its dependent tasks are terminated (see 7.6). This rule applies to completion caused by a transfer of control."),(0,s.kt)("p",null,"Within a block_statement, the block name can be used in expanded names denoting local entities such as Swap.Temp in the above example (see 4.1.3). "),(0,s.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,s.kt)("p",null,"The syntax rule for block_statement now uses the syntactic category handled_sequence_of_statements. "),(0,s.kt)("h2",{id:"57--exit-statements"},"5.7  Exit Statements"),(0,s.kt)("p",null,"[An exit_statement is used to complete the execution of an enclosing loop_statement; the completion is conditional if the exit_statement includes a condition.]"," "),(0,s.kt)("h4",{id:"syntax-6"},"Syntax"),(0,s.kt)("p",null,"exit_statement ::=\nexit ","[loop_name][when condition]",";"),(0,s.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,s.kt)("p",null,"The loop_name, if any, in an exit_statement shall resolve to denote a loop_statement. "),(0,s.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,s.kt)("p",null,"Each exit_statement applies to a loop_statement; this is the loop_statement being exited. An exit_statement with a name is only allowed within the loop_statement denoted by the name, and applies to that loop_statement. An exit_statement without a name is only allowed within a loop_statement, and applies to the innermost enclosing one. An exit_statement that applies to a given loop_statement shall not appear within a body or accept_statement, if this construct is itself enclosed by the given loop_statement. "),(0,s.kt)("h4",{id:"dynamic-semantics-6"},"Dynamic Semantics"),(0,s.kt)("p",null,"For the execution of an exit_statement, the condition, if present, is first evaluated. If the value of the condition is True, or if there is no condition, a transfer of control is done to complete the loop_statement. If the value of the condition is False, no transfer of control takes place. "),(0,s.kt)("p",null,"NOTE 1   Several nested loops can be exited by an exit_statement that names the outer loop. "),(0,s.kt)("h4",{id:"examples-6"},"Examples"),(0,s.kt)("p",null,"Examples of loops with exit statements: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"for N in 1 .. Max_Num_Items loop\n   Get_New_Item(New_Item);\n   Merge_Item(New_Item, Storage_File);\n   exit when New_Item = Terminal_Item;\nend loop;\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"Main_Cycle:\n   loop\n      --  initial statements\n      exit Main_Cycle when Found;\n      --  final statements\n   end loop Main_Cycle;\n\n")),(0,s.kt)("h2",{id:"58--goto-statements"},"5.8  Goto Statements"),(0,s.kt)("p",null,"[A goto_statement specifies an explicit transfer of control from this statement to a target statement with a given label.]"," "),(0,s.kt)("h4",{id:"syntax-7"},"Syntax"),(0,s.kt)("p",null,"goto_statement ::= goto label_name;"),(0,s.kt)("h4",{id:"name-resolution-rules-5"},"Name Resolution Rules"),(0,s.kt)("p",null,"The label_name shall resolve to denote a label; the statement with that label is the target statement. "),(0,s.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,s.kt)("p",null,"The innermost sequence_of_statements that encloses the target statement shall also enclose the goto_statement. Furthermore, if a goto_statement is enclosed by an accept_statement or a body, then the target statement shall not be outside this enclosing construct. "),(0,s.kt)("p",null,"Ramification: The goto",(0,s.kt)("em",{parentName:"p"},"statement can be a statement of an inner sequence"),"."),(0,s.kt)("p",null,"It follows from the second rule that if the target statement is enclosed by such a construct, then the goto_statement cannot be outside. "),(0,s.kt)("h4",{id:"dynamic-semantics-7"},"Dynamic Semantics"),(0,s.kt)("p",null,"The execution of a goto_statement transfers control to the target statement, completing the execution of any compound_statement that encloses the goto_statement but does not enclose the target. "),(0,s.kt)("p",null,"NOTE 1   The above rules allow transfer of control to a statement of an enclosing sequence_of_statements but not the reverse. Similarly, they prohibit transfers of control such as between alternatives of a case_statement, if_statement, or select_statement; between exception_handlers; or from an exception_handler of a handled_sequence_of_statements back to its sequence_of_statements. "),(0,s.kt)("h4",{id:"examples-7"},"Examples"),(0,s.kt)("p",null,"Example of a loop containing a goto statement: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ada"},"&lt&ltSort&gt&gt\nfor I in 1 .. N-1 loop\n   if A(I) &gt A(I+1) then\n      Exchange(A(I), A(I+1));\n      goto Sort;\n   end if;\nend loop;\n\n")))}d.isMDXComponent=!0}}]);