"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2352],{1716:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var n=a(6687);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,f=u["".concat(o,".").concat(d)]||u[d]||h[d]||i;return a?n.createElement(f,l(l({ref:t},c),{},{components:a})):n.createElement(f,l({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1143:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(9440),r=(a(6687),a(1716));const i={sidebar_position:30},l="4.2  Literals",s={unversionedId:"arm/AA-4.2",id:"arm/AA-4.2",title:"4.2  Literals",description:"A literal represents a value literally, that is, by means of notation suited to its kind.] A literal is either a [numericliteral, a characterliteral, the literal null, or a string_literal.",source:"@site/docs/arm/AA-4.2.md",sourceDirName:"arm",slug:"/arm/AA-4.2",permalink:"/docs/arm/AA-4.2",draft:!1,tags:[],version:"current",sidebarPosition:30,frontMatter:{sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"4.1  Names",permalink:"/docs/arm/AA-4.1"},next:{title:"4.3  Aggregates",permalink:"/docs/arm/AA-4.3"}},o={},p=[{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"4.2.1  User-Defined Literals",id:"421--user-defined-literals",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4}],c={toc:p};function h(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"42--literals"},"4.2  Literals"),(0,r.kt)("p",null,"[ A literal represents a value literally, that is, by means of notation suited to its kind.]"," A literal is either a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal"),", a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", the literal null, or a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal"),". "),(0,r.kt)("p",null,"Discussion: An enumeration literal that is an ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," rather than a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),' is not considered a literal in the above sense, because it involves no special notation "suited to its kind". It might more properly be called an enumeration_identifier, except for historical reasons. '),(0,r.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00230-01} "),(0,r.kt)("p",null,"For a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that consists of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", either its expected type shall be a single character type, in which case it is interpreted as a parameterless ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call")," that yields the corresponding value of the character type, or its expected profile shall correspond to a parameterless function with a character result type, in which case it is interpreted as the name of the corresponding parameterless function declared as part of the character type's definition (see 3.5.1). In either case, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," denotes the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0039"},"enumeration_literal_specification"),". "),(0,r.kt)("p",null,"Discussion: See 4.1.3 for the resolution rules for a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," that is a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),". "),(0,r.kt)("p",null,"{AI12-0325-1} {AI12-0373-1} The expected type for a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0141"},"primary")," that is a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," shall be a single string type or a type with a specified String_Literal aspect (see 4.2.1). In either case, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," is interpreted to be of its expected type. If the expected type of an integer literal is a type with a specified Integer_Literal aspect (see 4.2.1), the literal is interpreted to be of its expected type; otherwise it is interpreted to be of type universal_integer. If the expected type of a real literal is a type with a specified Real_Literal aspect (see 4.2.1), it is interpreted to be of its expected type; otherwise, it is interpreted to be of type universal_real. "),(0,r.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," that is a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," shall correspond to a ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")," of the expected type, or of the result type of the expected profile."),(0,r.kt)("p",null,"{AI12-0295-1} {AI12-0325-1} If the expected type for a string_literal is a string type, then for each character of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," there shall be a corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")," of the component type of the expected string type."),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00230-01} {AI95-00231-01} "),(0,r.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,r.kt)("p",null,"{AI95-00230-01} {AI12-0373-1} The literal null is of type universal_access. "),(0,r.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,r.kt)("p",null,"{AI12-0249-1} If its expected type is a numeric type, the evaluation of a numeric literal yields the represented value. ","[In other cases, the effect of evaluating a numeric literal is determined by the Integer_Literal or Real_Literal aspect that applies (see 4.2.1).]"),(0,r.kt)("p",null,"{AI12-0249-1} The evaluation of the literal null yields the null value of the expected type."),(0,r.kt)("p",null,"{AI12-0295-1} {AI12-0325-1} The evaluation of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," that is a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0141"},"primary")," and has an expected type that is a string type, yields an array value containing the value of each character of the sequence of characters of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal"),", as defined in 2.6. The bounds of this array value are determined according to the rules for ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.3#S0114"},"positional_array_aggregate"),"s (see 4.3.3), except that for a null string literal, the upper bound is the predecessor of the lower bound. [In other cases, the effect of evaluating a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," is determined by the String_Literal aspect that applies (see 4.2.1).]"),(0,r.kt)("p",null,"{AI12-0295-1} {AI12-0325-1} For the evaluation of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," of a string type T, a check is made that the value of each character of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," belongs to the component subtype of T. For the evaluation of a null string literal of a string type, a check is made that its lower bound is greater than the lower bound of the base range of the index type. The exception Constraint_Error is raised if either of these checks fails. "),(0,r.kt)("p",null,"Ramification: {AI12-0005-1} If no predicates apply to the component subtype, the checks on the characters need not involve more than two checks altogether, since one need only check the characters of the string with the lowest and highest position numbers against the range of the component subtype. "),(0,r.kt)("p",null,"NOTE 1   Enumeration literals that are ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),"s rather than ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),"s follow the normal rules for ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier"),"s when used in a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," (see 4.1 and 4.1.3). ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"Character_literal"),"s used as ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name"),"s follow the normal rules for expanded names (see 4.1.3). "),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Examples of literals: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"3.14159_26536   --  a real literal\n1_345   --  an integer literal\n'A'     --  a character literal\n\"Some Text\"     --  a string literal \n\n")),(0,r.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,r.kt)("p",null,"Because ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),"s are now treated like other literals, in that they are resolved using context rather than depending on direct visibility, additional qualification might be necessary when passing a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," to an overloaded subprogram. "),(0,r.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"Character_literal"),"s are now treated analogously to null and ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal"),"s, in that they are resolved using context, rather than their content; the declaration of the corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")," need not be directly visible. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"Name Resolution rules for enumeration literals that are not ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),'s are not included anymore, since they are neither syntactically nor semantically "literals" but are rather names of parameterless functions. '),(0,r.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,r.kt)("p",null,"{AI95-00230-01} {AI95-00231-01} Null now has type universal_access, which is similar to other literals. Null can be used with anonymous access types. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0295-1} The rules in this subclause are adjusted to allow for the possibility of user-defined literals. These are fully documented in the next subclause. "),(0,r.kt)("h2",{id:"421--user-defined-literals"},"4.2.1  User-Defined Literals"),(0,r.kt)("p",null,"{AI12-0249-1} Using one or more of the aspects defined below, a type may be specified to allow the use of one or more kinds of literals as values of the type. "),(0,r.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0342-1} The following type-related operational aspects (collectively known as user-defined literal aspects) may be specified for a type T:"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0342-1} {AI12-0373-1} Integer",(0,r.kt)("em",{parentName:"p"},"LiteralThis aspect is specified by a function"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that statically denotes a function with a result type of T and one in parameter that is of type String and is not explicitly aliased."),(0,r.kt)("p",null,"Aspect Description for Integer_Literal: Defines a function to implement user-defined integer literals."),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0342-1} {AI12-0373-1} {AI12-0394-1} Real",(0,r.kt)("em",{parentName:"p"},"LiteralThis aspect is specified by a function"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that statically denotes a function with a result type of T and one in parameter that is of type String and is not explicitly aliased, and optionally a second function ","[(overloading the first) ]","with a result type of T and two in parameters of type String that are not explicitly aliased."),(0,r.kt)("p",null,"Aspect Description for Real_Literal: Defines a function or functions to implement user-defined real literals."),(0,r.kt)("p",null,"{AI12-0295-1} {AI12-0342-1} {AI12-0373-1} String",(0,r.kt)("em",{parentName:"p"},"LiteralThis aspect is specified by a function"),(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that statically denotes a function with a result type of T and one in parameter that is of type Wide_Wide_String and is not explicitly aliased."),(0,r.kt)("p",null,"Aspect Description for String_Literal: Defines a function to implement user-defined string literals."),(0,r.kt)("p",null,"Ramification: {AI12-0342-1} The following example is legal because the resolution of an ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0348"},"aspect_definition")," for an aspect that is defined to be a subprogram is based on the profile required for that aspect (see 13.1.1): "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package Pkg1 is\n   type T is record X, Y : Integer; end record\n     with Integer_Literal =&gt Int_Lit;\n   function Int_Lit (X, Y : T) return Duration;    -- Wrong profile.\n   function Int_Lit (Lit_Image : String) return T; -- Right profile.\nend Pkg1;\n\n")),(0,r.kt)("p",null,"{AI12-0342-1} {AI12-0419-1} User-defined literal aspects are nonoverridable (see 13.1.1). "),(0,r.kt)("p",null,"Discussion: This means that in this example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package Pkg2 is\n   type T1 is record\n      X, Y : Integer;\n   end record with Integer_Literal =&gt I_L;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"   function I_L (S : String) return T1 is ((0, 0));\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"   type T2 is new T1;\n   function I_L (S : String) return T2 is ((1, 1));\n   X : T2 := 123;\nend Pkg2;\n\n")),(0,r.kt)("p",null,"{AI12-0005-1} {AI12-0342-1} {AI12-0419-1} the initial value of Pkg2.X is (1,1), not (0,0). "),(0,r.kt)("p",null,"{AI12-0342-1} {AI12-0427-1} When a numeric literal is interpreted as a value of a non-numeric type T or a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," is interpreted as a value of a type T that is not a string type (see 4.2), it is equivalent to a call to the subprogram denoted by the corresponding aspect of T: the Integer_Literal aspect for an integer literal, the Real_Literal aspect for a real literal, and the String_Literal aspect for a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal"),". The actual parameter of this notional call is a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," representing a sequence of characters that is the same as the sequence of characters in the original numeric literal, or the sequence represented by the original string literal."),(0,r.kt)("p",null,"Discussion: This equivalence defines, for example, the nominal type, the nominal subtype, and the accessibility level of a user-defined literal. It also has the consequence that a user-defined literal shall not be of an abstract type (because that would be equivalent to a nondispatching call to an abstract function). This equivalence also defines the Dynamic Semantics of evaluating a user-defined literal."),(0,r.kt)("p",null,"The (sub)type of the actual parameter to this call is determined by the profile of the appropriate aspect, and the bounds of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," are defined by the usual rules for the bounds of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal"),". "),(0,r.kt)("p",null,"{AI12-0342-1} Such a literal is said to be a user-defined literal."),(0,r.kt)("p",null,"{AI12-0394-1} When a named number that denotes a value of type universal_integer is interpreted as a value of a non-numeric type T, it is equivalent to a call to the function denoted by the Integer_Literal aspect of T. The actual parameter of this notional call is a String having a textual representation of a decimal integer literal optionally preceded by a minus sign, representing the same value as the named number."),(0,r.kt)("p",null,"{AI12-0394-1} When a named number that denotes a value of type universal_real is interpreted as a value of a non-numeric type T, it is equivalent to a call to the two-parameter function denoted by the Real_Literal aspect of T, if any. The actual parameters of this notional call are each a String with the textual representation of a decimal integer literal, with the first optionally preceded by a minus sign, where the first String represents the same value as the numerator, and the second the same value as the denominator, of the named number when represented as a rational number in lowest terms, with a positive denominator."),(0,r.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0295-1} {AI12-0325-1} {AI12-0342-1} The Integer_Literal or Real_Literal aspect shall not be specified for a type T if the full view of T is a numeric type. The String_Literal aspect shall not be specified for a type T if the full view of T is a string type."),(0,r.kt)("p",null,"{AI12-0342-1} For a nonabstract type, the function directly specified for a user-defined literal aspect shall not be abstract."),(0,r.kt)("p",null,"{AI12-0342-1} For a tagged type with a partial view, a user-defined literal aspect shall not be directly specified on the full type."),(0,r.kt)("p",null,"{AI12-0342-1} {AI12-0394-1} If a nonabstract tagged type inherits any user-defined literal aspect, then each inherited aspect shall be directly specified as a nonabstract function for the type unless the inherited aspect denotes a nonabstract function, or functions, and the type is a null extension."),(0,r.kt)("p",null,"{AI12-0394-1} If a named number that denotes a value of type universal_integer is interpreted as a value of a non-numeric type T, T shall have an Integer_Literal aspect. If a named number that denotes a value of type universal_real is interpreted as a value of a non-numeric type T, T shall have a Real_Literal aspect, and the aspect shall denote a function that has two in parameters, both of type String, with result of type T."),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0342-1} In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit. "),(0,r.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0325-1} {AI12-0342-1} {AI12-0394-1} It is a bounded error if the evaluation of a literal or named number that has an expected type with a specified user-defined literal aspect propagates an exception. Either Program_Error or the exception propagated by the evaluation is raised at the point of use of the value of the literal or named number. If it is recognized prior to run time that evaluation of such a literal or named number will inevitably (if executed) result in such a bounded error, then this may be reported as an error prior to run time."),(0,r.kt)("p",null,'Implementation Note: {AI12-0249-1} As always, an implementation may apply "as-if" optimizations (those that result in the same external effects in the absence of erroneous execution) to the function calls associated with user-defined literals. In particular, if the function associated with a user-defined literal aspect has a Global aspect that indicates no references to global variables, then a number of optimizations are available to the implementation: '),(0,r.kt)("p",null,"The implementation can evaluate a user-defined literal function at compile-time if it has access to the body of the function (for example, if it is inlined), and that body doesn't reference anything evaluated at runtime. If the compile-time evaluation results in an exception, this bounded error allows the compilation unit to be rejected."),(0,r.kt)("p",null,'Implementations can use existing permissions (see 6.1.2) to avoid evaluating the function associated with a user-defined literal more than once for a particular literal value. This evaluation can be "hoisted" (done once per compilation unit during the elaboration of the unit) if the compiler can prove that the function doesn\'t depend on any constants or locals with a runtime value not yet elaborated.'),(0,r.kt)("p",null,"If the literal value is not needed by the execution of the program, the function call can be omitted even if it might have side-effects (again, see 6.1.2). "),(0,r.kt)("h4",{id:"examples-1"},"Examples"),(0,r.kt)("p",null,"{AI12-0429-1} Examples of the specification and use of user-defined literals:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} subtype Roman_Character is Wide_Wide_Character\n   with Static_Predicate =&gt\n      Roman_Character in 'I' | 'V' | 'X' | 'L' | 'C' | 'D' | 'M';\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} Max_Roman_Number : constant := 3_999;  -- MMMCMXCIX\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} type Roman_Number is range 1 .. Max_Roman_Number\n   with String_Literal =&gt To_Roman_Number;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} function To_Roman_Number (S : Wide_Wide_String) return Roman_Number\n   with Pre =&gt S'Length &gt 0 and then\n      (for all Char of S =&gt Char in Roman_Character);\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0312-1} {AI12-0386-1} function To_Roman_Number (S : Wide_Wide_String) return Roman_Number is\n   (declare\n      R : constant array (Integer range &lt&gt) of Roman_Number :=\n         (for D in S'Range =&gt Roman_Digit'Enum_Rep\n             (Roman_Digit'Wide_Wide_Value (''' & S(D) & ''')));\n                     -- See 3.5.2 and 13.4\n    begin\n      [for I in R'Range =&gt\n         (if I &lt R'Last and then R(I) &lt R(I + 1) then -1 else 1) * R(I)]\n            'Reduce(\"+\", 0)\n   );\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},'{AI12-0312-1} X : Roman_Number := "III" * "IV" * "XII"; -- 144 (that is, CXLIV)\n\n')),(0,r.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,r.kt)("p",null,"{AI12-0249-1} {AI12-0295-1} {AI12-0325-1} {AI12-0342-1} The user-defined literal aspects Integer_Literal, Real_Literal, and String_Literal are new."))}h.isMDXComponent=!0}}]);