"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8988],{5590:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>A,contentTitle:()=>p,default:()=>g,frontMatter:()=>f,metadata:()=>k,toc:()=>y});var n=a(1716),l=a(8604),o=a(2787),r=Object.defineProperty,i=Object.defineProperties,s=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,h=(e,t,a)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,m=(e,t)=>{for(var a in t||(t={}))c.call(t,a)&&h(e,a,t[a]);if(d)for(var a of d(t))u.call(t,a)&&h(e,a,t[a]);return e};const f={sidebar_position:61},p="7.4 Deferred Constants",k={unversionedId:"arm/AA-7/AA-7.4",id:"arm/AA-7/AA-7.4",title:"7.4 Deferred Constants",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-7/AA-7.4.mdx",sourceDirName:"arm/AA-7",slug:"/arm/AA-7/AA-7.4",permalink:"/docs/arm/AA-7/AA-7.4",draft:!1,tags:[],version:"current",sidebarPosition:61,frontMatter:{sidebar_position:61},sidebar:"referenceManualSidebar",previous:{title:"7.3 Private Types and Private Extensions",permalink:"/docs/arm/AA-7/AA-7.3"},next:{title:"7.5 Limited Types",permalink:"/docs/arm/AA-7/AA-7.5"}},A={},y=[{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}],b={toc:y};function g(e){var t,a=e,{components:r}=a,h=((e,t)=>{var a={};for(var n in e)c.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&d)for(var n of d(e))t.indexOf(n)<0&&u.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=m(m({},b),h),i(t,s({components:r,mdxType:"MDXLayout"}))),(0,n.kt)("h1",m({},{id:"74-deferred-constants"}),"7.4 Deferred Constants"),(0,n.kt)("admonition",m({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.kt)("a",m({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"[Deferred constant declarations may be used to declare constants in the visible part of a package, but with the value of the constant given in the private part. They may also be used to declare constants imported from other languages (see Annex B).] ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"legality-rules"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0269-1"),"}"," ",(0,n.kt)("br",null),"[ A ",(0,n.kt)("em",null,"deferred constant declaration")," is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," with the reserved word ",(0,n.kt)("strong",null,"constant")," but no initialization expression.] The constant declared by a deferred constant declaration is called a ",(0,n.kt)("em",null,"deferred constant"),". [Unless the Import aspect (see B.1) is True for a deferred constant declaration, the ] deferred constant declaration requires a completion, which shall be a full constant declaration (called the ",(0,n.kt)("em",null,"full declaration")," of the deferred constant). ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"proof",title:"Proof: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"The first sentence is redundant, as it is stated officially in 3.3.1.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0269-1"),"}"," ",(0,n.kt)("br",null),"The first part of the last sentence is redundant, as no imported entity may have a completion, as stated in B.1. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"A deferred constant declaration that is completed by a full constant declaration shall occur immediately within the visible part of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-7/AA-7.1#S0230"},"package_specification")),". For this case, the following additional rules apply to the corresponding full declaration: ",(0,n.kt)("br",null)),(0,n.kt)("ul",null,(0,n.kt)("li",null,"The full declaration shall occur immediately within the private part of the same package;",(0,n.kt)("br",null)),(0,n.kt)("li",null,"{",(0,n.kt)("em",null,"AI95-00385-01"),"}"," ",(0,n.kt)("br",null),"The deferred and full constants shall have the same type, or shall have statically matching anonymous access subtypes; ",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI95-00385-01"),"}"," ",(0,n.kt)("br",null),"This implies that both the deferred declaration and the full declaration have to have a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," rather than an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition")),", because each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition"))," would define a new type. ",(0,n.kt)("br",null)),(0,n.kt)("ul",null,(0,n.kt)("li",null,"{",(0,n.kt)("em",null,"AI95-00385-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0062-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ",(0,n.kt)("br",null),"If the deferred constant declaration includes a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," ",(0,n.kt)("em",null,"S")," that defines a constrained subtype, then the constraint defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," in the full declaration shall match the constraint defined by ",(0,n.kt)("em",null,"S")," statically.[ On the other hand, if the subtype of the deferred constant is unconstrained, then the full declaration is still allowed to impose a constraint. The constant itself will be constrained, like all constants;]",(0,n.kt)("br",null)),(0,n.kt)("li",null,"{",(0,n.kt)("em",null,"AI95-00231-01"),"}"," ",(0,n.kt)("br",null),"If the deferred constant declaration includes the reserved word ",(0,n.kt)("strong",null,"aliased"),", then the full declaration shall also; ",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"On the other hand, the full constant can be aliased even if the deferred constant is not. ",(0,n.kt)("br",null)),(0,n.kt)("ul",null,(0,n.kt)("li",null,"{",(0,n.kt)("em",null,"AI95-00231-01"),"}"," ",(0,n.kt)("br",null),"If the subtype of the deferred constant declaration excludes null, the subtype of the full declaration shall also exclude null. ",(0,n.kt)("br",null))),(0,n.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"On the other hand, the full constant can exclude null even if the deferred constant does not. But that can only happen for a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),", as anonymous access types are required to statically match (which includes any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"). ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0444-1"),"}"," ",(0,n.kt)("br",null),"[A deferred constant declaration for which the Import aspect is True can appear anywhere that an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," is allowed, and has no full constant declaration.]",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00256-01"),"}"," ",(0,n.kt)("br",null),"The completion of a deferred constant declaration shall occur before the constant is frozen (see 13.14).",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0004-1"),"}"," ",(0,n.kt)("br",null),"The elaboration of a deferred constant declaration elaborates the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", or (only allowed in the case of an imported constant) the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0051"},"array_type_definition")),". ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI05-0004-1"),"}"," ",(0,n.kt)("br",null),"For nonimported constants, these elaborations cannot require any code or checks for a legal program, because the given ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," has to be indefinite or statically match that of the full constant, meaning that either it is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," or it has static constraints. If the deferred constant instead has an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", the designated subtype must be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),". We still say that these are elaborated, however, because part of elaboration is creating the type, which is clearly needed for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),"s. (A deferred constant and its full constant have different types when they are specified by an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", although there is no visible effect of these types being different as neither can be named.) ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE   The full constant declaration for a deferred constant that is of a given private type or private extension is not allowed before the corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration")),". This is a consequence of the freezing rules for types (see 13.14). ",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"Multiple or single declarations are allowed for the deferred and the full declarations, provided that the equivalent single declarations would be allowed.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Deferred constant declarations are useful for declaring constants of private views, and types with components of private views. They are also useful for declaring access-to-constant objects that designate variables declared in the private part of a package. ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of deferred constant declarations:")," ",(0,n.kt)("br",null)),(0,n.kt)(l.Z,{mdxType:"CodeBlock"},"Null_Key : constant Key;      -- see 7.3.1","\n","--  ","{","AI05-0229-1","}","\n"," CPU_Identifier : constant String(1..8)","\n","   with Import =",">"," True, Convention =",">"," Assembler, Link_Name =",">",' "CPU_ID";',"\n","                              -- see B.1","\n"),(0,n.kt)("h4",m({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"In Ada 83, a deferred constant is required to be of a private type declared in the same visible part. This restriction is removed for Ada 95; deferred constants can be of any type.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"In Ada 83, a deferred constant declaration was not permitted to include a constraint, nor the reserved word ",(0,n.kt)("strong",null,"aliased"),".",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"In Ada 83, the rules required conformance of type marks; here we require static matching of subtypes if the deferred constant is constrained.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"A deferred constant declaration can be completed with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Import. Such a deferred constant declaration need not be within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-7/AA-7.1#S0230"},"package_specification")),".",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The rules for too-early uses of deferred constants are modified in Ada 95 to allow more cases, and catch all errors at compile time. This change is necessary in order to allow deferred constants of a tagged type without violating the principle that for a dispatching call, there is always an implementation to dispatch to. It has the beneficial side effect of catching some Ada-83-erroneous programs at compile time. The new rule fits in well with the new freezing-point rules. Furthermore, we are trying to convert undefined-value problems into bounded errors, and we were having trouble for the case of deferred constants. Furthermore, uninitialized deferred constants cause trouble for the shared variable / tasking rules, since they are really variable, even though they purport to be constant. In Ada 95, they cannot be touched until they become constant.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Note that we do not consider this change to be an upward incompatibility, because it merely changes an erroneous execution in Ada 83 into a compile-time error.",(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The Ada 83 semantics are unclear in the case where the full view turns out to be an access type. It is a goal of the language design to prevent uninitialized access objects. One wonders if the implementation is required to initialize the deferred constant to null, and then initialize it (again!) to its real value. In Ada 95, the problem goes away. ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," ",(0,n.kt)("br",null),'Since deferred constants can now be of a nonprivate type, we have made this a stand-alone subclause, rather than a subclause of 7.3, "Private Types and Private Extensions".',(0,n.kt)("br",null)),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Deferred constant declarations used to have their own syntax, but now they are simply a special case of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),"s. ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI95-00385-01"),"}"," ",(0,n.kt)("br",null),"Deferred constants were enhanced to allow the use of anonymous access types in them. ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,n.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI95-00231-01"),"}"," ",(0,n.kt)("br",null),"Added matching rules for subtypes that exclude null. ",(0,n.kt)("br",null)),(0,n.kt)("h4",m({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(o.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0062-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null))," Corrected rules so that the intent that a full constant may have a null exclusion even if the deferred constant does not is actually met. ",(0,n.kt)("br",null)))}g.isMDXComponent=!0}}]);