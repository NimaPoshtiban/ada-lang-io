"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4661],{52:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>k,frontMatter:()=>p,metadata:()=>m,toc:()=>f});var a=n(1716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,d=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&u(e,n,t[n]);if(s)for(var n of s(t))c.call(t,n)&&u(e,n,t[n]);return e};const p={title:"Program Structure",sidebar_position:4},h=void 0,m={unversionedId:"style-guide/Program_Structure",id:"style-guide/Program_Structure",title:"Program Structure",description:"Proper structure improves program clarity. This is analogous to",source:"@site/docs/style-guide/Program_Structure.mdx",sourceDirName:"style-guide",slug:"/style-guide/Program_Structure",permalink:"/docs/style-guide/Program_Structure",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Program Structure",sidebar_position:4},sidebar:"styleGuideSidebar",previous:{title:"Readability",permalink:"/docs/style-guide/Readability"},next:{title:"Programming Practices",permalink:"/docs/style-guide/Programming_Practices"}},g={},f=[{value:"High-Level Structure",id:"high-level-structure",level:2},{value:"Separate Compilation Capabilities",id:"separate-compilation-capabilities",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Configuration Pragmas",id:"configuration-pragmas",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Subprograms",id:"subprograms",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes",level:4},{value:"Functions",id:"functions",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Packages",id:"packages",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"notes",id:"notes-1",level:4},{value:"Child Library Units",id:"child-library-units",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"Cohesion",id:"cohesion",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-2",level:4},{value:"Data Coupling",id:"data-coupling",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"notes",id:"notes-3",level:4},{value:"Tasks",id:"tasks",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Protected Types",id:"protected-types",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"Visibility",id:"visibility",level:2},{value:"Minimization of Interfaces",id:"minimization-of-interfaces",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"notes",id:"notes-4",level:4},{value:"Nested Packages",id:"nested-packages",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Restricting Visibility",id:"restricting-visibility",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"notes",id:"notes-5",level:4},{value:"Hiding Tasks",id:"hiding-tasks",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"Exceptions",id:"exceptions-1",level:2},{value:"Using Exceptions to Help Define an Abstraction",id:"using-exceptions-to-help-define-an-abstraction",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"Summary",id:"summary",level:2},{value:"high-level structure",id:"high-level-structure-1",level:3},{value:"visibility",id:"visibility-1",level:3},{value:"exceptions",id:"exceptions-2",level:4}],b={toc:f};function k(e){var t,n=e,{components:i}=n,u=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=d(d({},b),u),o(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Proper structure improves program clarity. This is analogous to\nreadability on lower levels and facilitates the use of the readability\nguidelines (Chapter 3). The various program structuring facilities\nprovided by Ada were designed to enhance overall clarity of design.\nThese guidelines show how to use these facilities for their intended\npurposes."),(0,a.kt)("p",null,"The concept of child packages supports the concept of subsystem, where a\nsubsystem is represented in Ada as a hierarchy of library units. In\ngeneral, a large system should be structured as a series of subsystems.\nSubsystems should be used to represent logically related library units,\nwhich together implement a single, high-level abstraction or framework."),(0,a.kt)("p",null,"Abstraction and encapsulation are supported by the package concept and\nby private types. Related data and subprograms can be grouped together\nand seen by a higher level as a single entity. Information hiding is\nenforced via strong typing and by the separation of package and\nsubprogram specifications from their bodies. Exceptions and tasks are\nadditional Ada language elements that impact program structure."),(0,a.kt)("h2",d({},{id:"high-level-structure"}),"High-Level Structure"),(0,a.kt)("p",null,"Well-structured programs are easily understood, enhanced, and\nmaintained. Poorly structured programs are frequently restructured\nduring maintenance just to make the job easier. Many of the guidelines\nlisted below are often given as general program design guidelines."),(0,a.kt)("h3",d({},{id:"separate-compilation-capabilities"}),"Separate Compilation Capabilities"),(0,a.kt)("h4",d({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Place the specification of each library unit package in a separate\nfile from its body."),(0,a.kt)("li",{parentName:"ul"},"Avoid defining library unit subprograms that are not intended to be\nused as main programs. If such subprograms are defined, then create\nan explicit specification, in a separate file, for each library unit\nsubprogram."),(0,a.kt)("li",{parentName:"ul"},"Minimize the use of subunits."),(0,a.kt)("li",{parentName:"ul"},"In preference to subunits, use child library units to structure a\nsubsystem into manageable units."),(0,a.kt)("li",{parentName:"ul"},"Place each subunit in a separate file."),(0,a.kt)("li",{parentName:"ul"},"Use a consistent file naming convention."),(0,a.kt)("li",{parentName:"ul"},"In preference to nesting in a package body, use a private child and\nwith it to the parent body."),(0,a.kt)("li",{parentName:"ul"},"Use private child unit specifications for data and subprograms that\nare required by (other) child units that extend a parent unit's\nabstraction or services.")),(0,a.kt)("h4",d({},{id:"example"}),"example"),(0,a.kt)("p",null,"The file names below illustrate one possible file organization and\nassociated consistent naming convention. The library unit name uses the\nadb suffix for the body. The suffix ads indicates the specification, and\nany files containing subunits use names constructed by separating the\nbody name from the subunit name with an underscore:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"text_io.ads \u2014 the specification"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io.adb \u2014 the body"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io_integer_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io_fixed_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io_float_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io_enumeration_io.adb \u2014 a subunit")),(0,a.kt)("p",null,'Depending on what characters your file system allows you to use in file\nnames, you could show the distinction between parent and subunit name\nmore clearly in the file name. If your file system allows the "',"#",'"\ncharacter, for example, you could separate the body name from the\nsubunit name with a ',"#",":"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"text_io.ads \u2014 the specification"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io.adb \u2014 the body"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io#integer_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io#fixed_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io#float_io.adb \u2014 a subunit"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"text_io#enumeration_io.adb \u2014 a subunit")),(0,a.kt)("p",null,"Some operating systems are case-sensitive, although Ada itself is not a\ncase-sensitive language. For example, you could choose a convention of\nall lowercase file names."),(0,a.kt)("h4",d({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"The main reason for the emphasis on separate files in this guideline is\nto minimize the amount of recompilation required after each change.\nTypically, during software development, bodies of units are updated far\nmore often than specifications. If the body and specification reside in\nthe same file, then the specification will be compiled each time the\nbody is compiled, even though the specification has not changed. Because\nthe specification defines the interface between the unit and all of its\nusers, this recompilation of the specification typically makes\nrecompilation of all users necessary in order to verify compliance with\nthe specification. If the specifications and bodies of the users also\nreside together, then any users of these units will also have to be\nrecompiled and so on. The ripple effect can force a huge number of\ncompilations that could have been avoided, severely slowing the\ndevelopment and test phase of a project. This is why you should place\nspecifications of all library units (nonnested units) in separate files\nfrom their bodies."),(0,a.kt)("p",null,"Library unit subprograms should be minimized. The only real use for\nlibrary unit subprograms is as the main subprogram. In almost all other\ncases, it is better to embed the subprogram into a package. This\nprovides a place (the package body) to localize data needed by the\nsubprogram. Moreover, it cuts down on the number of separate modules in\nthe system."),(0,a.kt)("p",null,"In general, you should use a separate specification for any library\nsubprogram that is mentioned in a with clause. This makes the with'ing\nunit dependent on the library subprogram specification, not its body."),(0,a.kt)("p",null,"You should minimize the use of subunits because they create maintenance\nproblems. Declarations appearing in the parent body are visible in the\nsubunit, increasing the amount of data global to the subunit and, thus,\nincreasing the potential ripple effect of changes. Subunits hinder reuse\nbecause they provide an incentive to put otherwise reusable code in the\nsubunit directly rather than in a common routine called from multiple\nsubprograms."),(0,a.kt)("p",null,"With the availability of child library units in Ada 95, you can avoid\nmost uses of subunits. For example, instead of using a subunit for a\nlarge nested body, you should try to encapsulate this code in a child\nlibrary unit and add the necessary context clauses. You can modify the\nbody of the child unit without having to recompile any of the other\nunits in a subsystem."),(0,a.kt)("p",null,"An additional benefit of using multiple, separate files is that it\nallows different implementors to modify different parts of the system at\nthe same time with conventional editors, which do not allow multiple\nconcurrent updates to a single file."),(0,a.kt)("p",null,"Finally, keeping bodies and specifications separate makes it possible to\nhave multiple bodies for the same specification or multiple\nspecifications for the same body. Although Ada requires that there be\nexactly one specification per body in a system at any given time, it can\nstill be useful to maintain multiple bodies or multiple specifications\nfor use in different builds of a system. For example, a single\nspecification may have multiple bodies, each of which implements the\nsame functionality with a different tradeoff of time versus space\nefficiency, or, for machine-dependent code, there may be one body for\neach target machine. Maintaining multiple package specifications can\nalso be useful during development and test. You may develop one\nspecification for delivery to your customer and another for unit\ntesting. The first one would export only those subprograms intended to\nbe called from outside of the package during normal operation of the\nsystem. The second one would export all subprograms of the package so\nthat each of them could be independently tested."),(0,a.kt)("p",null,"A consistent file naming convention is recommended to make it easier to\nmanage the large number of files that may result from following this\nguideline."),(0,a.kt)("p",null,"In implementing the abstraction defined in a package specification, you\noften need to write supporting subprograms that manipulate the internal\nrepresentation of the data. These subprograms should not be exported on\nthe interface. You have a choice of whether to place them in the package\nbody of the parent program or in a child package named in a context\nclause of the parent package body. When you place them in the parent\npackage body, you make them inaccessible to all clients of the parent,\nincluding extensions of the parent declared in child packages. If these\nsubprograms are needed to implement extensions of the parent\nabstraction, you would be forced to modify both the parent specification\nand the body because you would have to declare the extensions within the\nparent specification. This technique would then force recompilation of\nthe entire package (specification and body) as well as all its clients."),(0,a.kt)("p",null,"Alternatively, you can implement the supporting subprograms in a private\nchild package. Because the parent unit's specification is not modified,\nneither it nor its clients need to be recompiled. The data and\nsubprograms that might have declared in the parent unit body must now be\ndeclared in the private child unit's specification to make them visible\nto both the parent unit body and to any child units that extend the\nparent unit's services or abstractions. (See also Guidelines 4.1.6 and\n4.2.) This use of private child units will generally minimize\nrecompilations within the unit family and among its clients."),(0,a.kt)("p",null,"In declaring the child package private, you achieve a similar effect to\ndeclaring it in the parent package body to the extent that clients of\nthe parent cannot name the private child in a context clause. You gain\nflexibility because now you can extend the parent abstraction using\nchild packages without having to recompile the parent specification or\nits body, assuming that you do not otherwise modify the parent or its\nbody. This added flexibility will usually compensate for the increased\ndependency between units, in this case, the additional context clause on\nthe parent body (and other child package bodies) that names the private\nchild package of supporting subprograms."),(0,a.kt)("h3",d({},{id:"configuration-pragmas"}),"Configuration Pragmas"),(0,a.kt)("h4",d({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When possible, express configuration pragmas through compiler\noptions or other means that do not require modifications to the\nsource code."),(0,a.kt)("li",{parentName:"ul"},"When configuration pragmas must be placed in source code, consider\nisolating them to one compilation unit per partition; if specified,\nthe main subprogram for the partition is recommended.")),(0,a.kt)("h4",d({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Configuration pragmas are generally used to select a partition-wide or\nsystem-wide option. Usually, they reflect either high-level software\narchitecture decisions (e.g., pragma Task_Dispatching_Policy) or the\nuse of the software in a particular application domain (e.g.,\nsafety-critical software). If a configuration pragma is embedded within\na software component and that component is reused in a different context\nwhere the pragma is no longer appropriate, then it may cause problems in\nthe new application. Such problems can include the rejection by the\ncompilation system of otherwise legal source code or unexpected behavior\nat run-time. These problems can be significant given the wide scope of a\nconfiguration pragma. In addition, maintenance of the original system\nmay require that some of these system-wide decisions be changed. If the\nconfiguration pragmas are scattered throughout the software, it may be\ndifficult to locate the lines that need to change."),(0,a.kt)("p",null,"As a result, it is recommended that all configuration pragmas be kept in\na single compilation unit if possible to make them easy to locate and\nmodify as needed. If this compilation unit is unlikely to be reused\n(e.g., a main subprogram), then the likelihood of conflicts with future\nreusers is reduced. Finally, if these system-wide decisions are\nindicated without embedding them in the code at all, such as through a\ncompiler option, then the problems described above are even less likely\nto occur."),(0,a.kt)("h4",d({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"Certain pragmas (e.g., pragma Suppress) can be used in several forms,\nincluding as a configuration pragma. This guideline does not apply to\nsuch pragmas when they are not used as a configuration pragma."),(0,a.kt)("h3",d({},{id:"subprograms"}),"Subprograms"),(0,a.kt)("h4",d({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use subprograms to enhance abstraction."),(0,a.kt)("li",{parentName:"ul"},"Restrict each subprogram to the performance of a single action.")),(0,a.kt)("h4",d({},{id:"example-1"}),"example"),(0,a.kt)("p",null,"Your program is required to draw a menu of user options as part of a\nmenu-driven user interface package. Because the contents of the menu can\nvary depending on the user state, the proper way to do this is to write\na subprogram to draw the menu. This way, the output subprogram has one\npurpose and the way to determine the menu content is described\nelsewhere."),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),'...\n----------------------------------------------------------------------\nprocedure Draw_Menu\n      (Title   : in    String;\n       Options : in    Menu) is\n   ...\nbegin  -- Draw_Menu\n   Ada.Text_IO.New_Page;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Set_Col (Right_Column);\n   Ada.Text_IO.Put_Line (Title);\n   Ada.Text_IO.New_Line;\n   for Choice in Alpha_Numeric loop\n     if Options (Choice) /= Empty_Line then\n         Valid_Option (Choice) := True;\n         Ada.Text_IO.Set_Col (Left_Column);\n         Ada.Text_IO.Put (Choice & " -- ");\n         Ada.Text_IO.Put_Line (Options (Choice));\n     end if;\n     ...\n   end loop;\nend Draw_Menu;\n----------------------------------------------------------------------\n')),(0,a.kt)("h4",d({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Subprograms are an extremely effective and well-understood abstraction\ntechnique. Subprograms increase program readability by hiding the\ndetails of a particular activity. It is not necessary that a subprogram\nbe called more than once to justify its existence."),(0,a.kt)("h4",d({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"Guideline 10.7.1 discusses dealing with the overhead of subroutine\ncalls."),(0,a.kt)("h3",d({},{id:"functions"}),"Functions"),(0,a.kt)("h4",d({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use a function when the subprogram's primary purpose is to provide a\nsingle value."),(0,a.kt)("li",{parentName:"ul"},"Minimize the side effect of a function."),(0,a.kt)("li",{parentName:"ul"},"Consider using a parameterless function when the value does not need\nto be static."),(0,a.kt)("li",{parentName:"ul"},"Use a parameterless function (instead of a constant) if the value\nshould be inherited by types derived from the type."),(0,a.kt)("li",{parentName:"ul"},"Use a parameterless function if the value itself is subject to\nchange.")),(0,a.kt)("h4",d({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"Although reading a character from a file will change what character is\nread next, this is accepted as a minor side effect compared to the\nprimary purpose of the following function:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"function Next_Character return Character is separate;\n")),(0,a.kt)("p",null,"However, the use of a function like this could lead to a subtle problem.\nAny time the order of evaluation is undefined, the order of the values\nreturned by the function will effectively be undefined. In this example,\nthe order of the characters placed in Word and the order that the\nfollowing two characters are given to the Suffix parameters are unknown.\nNo implementation of the Next_Character function can guarantee which\ncharacter will go where:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"   Word : constant String := String'(1 .. 5 => Next_Character);\nbegin  -- Start_Parsing\n   Parse(Keyword => Word,\n         Suffix1 => Next_Character,\n         Suffix2 => Next_Character);\nend Start_Parsing;\n")),(0,a.kt)("p",null,"Of course, if the order is unimportant (as in a random number\ngenerator), then the order of evaluation is unimportant."),(0,a.kt)("p",null,"The following example shows the use of a parameterless function instead\nof a constant:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"type T is private;\nfunction Nil return T;        -- This function is a derivable operation of type T\nfunction Default return T;    -- Also derivable, and the value can be changed by\n                              -- recompiling the body of the function\n")),(0,a.kt)("p",null,"This same example could have been written using constants:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"type T is private;\nNil : constant T;\nDefault : constant T;\n")),(0,a.kt)("h4",d({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"A side effect is a change to any variable that is not local to the\nsubprogram. This includes changes to variables by other subprograms and\nentries during calls from the function if the changes persist after the\nfunction returns. Side effects are discouraged because they are\ndifficult to understand and maintain. Additionally, the Ada language\ndoes not define the order in which functions are evaluated when they\noccur in expressions or as actual parameters to subprograms. Therefore,\na program that depends on the order in which side effects of functions\noccur is erroneous. Avoid using side effects anywhere."),(0,a.kt)("h3",d({},{id:"packages"}),"Packages"),(0,a.kt)("h4",d({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use packages for information hiding."),(0,a.kt)("li",{parentName:"ul"},"Use packages with tagged types and private types for abstract data\ntypes."),(0,a.kt)("li",{parentName:"ul"},"Use packages to model abstract entities appropriate to the problem\ndomain."),(0,a.kt)("li",{parentName:"ul"},"Use packages to group together related type and object declarations\n(e.g., common declarations for two or more library units)."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate machine dependencies in packages. Place a software\ninterface to a particular device in a package to facilitate a change\nto a different device."),(0,a.kt)("li",{parentName:"ul"},"Place low-level implementation decisions or interfaces in\nsubprograms within packages."),(0,a.kt)("li",{parentName:"ul"},"Use packages and subprograms to encapsulate and hide program details\nthat may change (Nissen and Wallis 1984).")),(0,a.kt)("h4",d({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"Reading the names and other attributes of external files is highly\nmachine dependent. A package called Directory could contain type and\nsubprogram declarations to support a generalized view of an external\ndirectory that contains external files. Its internals may, in turn,\ndepend on other packages more specific to the hardware or operating\nsystem:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"package Directory is\n\n   type Directory_Listing is limited private;\n\n   procedure Read_Current_Directory (D : in out Directory_Listing);\n\n   generic\n      with procedure Process (Filename : in String);\n   procedure Iterate (Over : in Directory_Listing);\n\n   ...\n\nprivate\n\n   type Directory_Listing is ...\n\nend Directory;\n\n---------------------------------------------------------------\n\npackage body Directory is\n\n   -- This procedure is machine dependent\n   procedure Read_Current_Directory (D : in out Directory_Listing) is separate;\n\n   procedure Iterate (Over : in Directory_Listing) is\n      ...\n   begin\n      ...\n\n      Process (Filename);\n\n      ...\n   end Iterate;\n\n   ...\n\nend Directory;\n")),(0,a.kt)("h4",d({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"Packages are the principal structuring facility in Ada. They are\nintended to be used as direct support for abstraction, information\nhiding, and modularization. For example, they are useful for\nencapsulating machine dependencies as an aid to portability. A single\nspecification can have multiple bodies isolating implementation-specific\ninformation so other parts of the code do not need to change."),(0,a.kt)("p",null,"Encapsulating areas of potential change helps to minimize the effort\nrequired to implement that change by preventing unnecessary dependencies\namong unrelated parts of the system."),(0,a.kt)("h4",d({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"The most prevalent objection to this guideline usually involves\nperformance penalties. See Guideline 10.7.1 for a discussion about\nsubprogram overhead."),(0,a.kt)("h3",d({},{id:"child-library-units"}),"Child Library Units"),(0,a.kt)("h4",d({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If a new library unit represents a logical extension to the original\nabstraction, define it as a child library unit."),(0,a.kt)("li",{parentName:"ul"},"If a new library unit is independent (e.g., introduces a new\nabstraction that depends only in part on the existing one), then\nencapsulate the new abstraction in a separate library unit."),(0,a.kt)("li",{parentName:"ul"},"Use child packages to implement a subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use public child units for those parts of a subsystem that should be\nvisible to clients of the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use private child units for those parts of a subsystem that should\nnot be visible to clients of the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use private child units for local declarations used only in\nimplementing the package specification."),(0,a.kt)("li",{parentName:"ul"},"Use child packages to implement constructors, even when they return\naccess values.")),(0,a.kt)("h4",d({},{id:"example-4"}),"example"),(0,a.kt)("p",null,"The following example of a windowing system is taken from Cohen et al.\n(1993) and illustrates some of the uses of child units in designing\nsubsystems. The parent (root) package declares the types, subtypes, and\nconstants that its clients and subsystems need. Individual child\npackages provide specific parts of the windowing abstraction, such as\natoms, fonts, graphic output, cursors, and keyboard information:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"package X_Windows is\n   ...\nprivate\n   ...\nend X_Windows;\n\npackage X_Windows.Atoms is\n   type Atom is private;\n   ...\nprivate\n   ...\nend X_Windows.Atoms;\n\npackage X_Windows.Fonts is\n   type Font is private;\n   ...\nprivate\n   ...\nend X_Windows.Fonts;\n\npackage X_Windows.Graphic_Output is\n   type Graphic_Context is private;\n   type Image is private;\n   ...\nprivate\n   ...\nend X_Windows.Graphic_Output;\n\npackage X_Windows.Cursors is\n   ...\nend X_Windows.Cursors;\n\npackage X_Windows.Keyboard is\n   ...\nend X_Windows.Keyboard;\n")),(0,a.kt)("h4",d({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"The user can create more precise packages with less cluttered\ninterfaces, using child library packages to extend the interfaces as\nneeded. The parent contains only the relevant functionality. The parent\nprovides a general-purpose interface, while the child units provide more\ncomplete programming interfaces, tailored to that aspect of an\nabstraction that they are extending or defining."),(0,a.kt)("p",null,'Child packages build on the modular strength of Ada where "the distinct\nspecification and body decouple the user interface to a package (the\nspecification) from its implementation (the body)" (Rationale 1995,\n\xa7II.7). Child packages provide the added capability of being able to\nextend a parent package without recompiling the parent or the parent\'s\nclients.'),(0,a.kt)("p",null,"Child packages allow you to write logically distinct packages that share\na private type. The visibility rules give the private part of the child\nspecification and the body of the child visibility into the private part\nof the parent. Thus, you can avoid creating a monolithic package for the\nsake of developing abstractions that share a private type and need to\nknow its representation. The private representation is not available to\nclients of the package, so the abstraction in the package and its\nchildren is maintained."),(0,a.kt)("p",null,"Using private child packages for local declarations enables you to have\navailable the support declarations you need when implementing both the\nparent package and extensions to the parent package. You enhance the\nmaintainability of your program by using a common set of support\ndeclarations (data representations, data manipulation subprograms). You\ncan modify the internal representation and the implementation of the\nsupport subprograms without modifying or recompiling the rest of your\nsubsystem because these support subprograms are implemented in the body\nof the private child package. See also Guidelines 4.1.1, 4.2.1, 8.4.1,\nand 8.4.8."),(0,a.kt)("p",null,"See also Guideline 9.4.1 for a discussion of the use of child library\nunits in creating a tagged type hierarchy."),(0,a.kt)("h3",d({},{id:"cohesion"}),"Cohesion"),(0,a.kt)("h4",d({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make each package serve a single purpose."),(0,a.kt)("li",{parentName:"ul"},"Use packages to group related data, types, and subprograms."),(0,a.kt)("li",{parentName:"ul"},"Avoid collections of unrelated objects and subprograms (NASA 1987;\nNissen and Wallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Consider restructuring a system to move two highly related units\ninto the same package (or package hierarchy) or to move relatively\nindependent units into separate packages.")),(0,a.kt)("h4",d({},{id:"example-5"}),"example"),(0,a.kt)("p",null,'As a bad example, a package named Project_Definitions is obviously a\n"catch all" for a particular project and is likely to be a jumbled mess.\nIt probably has this form to permit project members to incorporate a\nsingle with clause into their software.'),(0,a.kt)("p",null,"Better examples are packages called Display_Format_Definitions,\ncontaining all the types and constants needed by some specific display\nin a specific format, and Cartridge_Tape_Handler, containing all the\ntypes, constants, and subprograms that provide an interface to a\nspecial-purpose device."),(0,a.kt)("h4",d({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"The degree to which the entities in a package are related has a direct\nimpact on the ease of understanding packages and programs made up of\npackages. There are different criteria for grouping, and some criteria\nare less effective than others. Grouping the class of data or activity\n(e.g., initialization modules) or grouping data or activities based on\ntheir timing characteristics is less effective than grouping based on\nfunction or need to communicate through data (Charette 1986)."),(0,a.kt)("p",null,'The "correct" structuring of a system can make a tremendous difference\nin the maintainability of a system. Although it may seem painful at the\ntime, it is important to restructure if the initial structuring is not\nquite right.'),(0,a.kt)("p",null,"See also Guideline 5.4.2 on heterogeneous data."),(0,a.kt)("h4",d({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"Traditional subroutine libraries often group functionally unrelated\nsubroutines. Even such libraries should be broken into a collection of\npackages, each containing a logically cohesive set of subprograms."),(0,a.kt)("h3",d({},{id:"data-coupling"}),"Data Coupling"),(0,a.kt)("h4",d({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid declaring variables in package specifications.")),(0,a.kt)("h4",d({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"This is part of a compiler. Both the package handling error messages and\nthe package containing the code generator need to know the current line\nnumber. Rather than storing this in a shared variable of type Natural,\nthe information is stored in a package that hides the details of how\nsuch information is represented and makes it available with access\nroutines:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"-------------------------------------------------------------------------\npackage Compilation_Status is\n   type Line_Number is range 1 .. 2_500_000;\n   function Source_Line_Number return Line_Number;\nend Compilation_Status;\n-------------------------------------------------------------------------\nwith Compilation_Status;\npackage Error_Message_Processing is\n   -- Handle compile-time diagnostic.\nend Error_Message_Processing;\n-------------------------------------------------------------------------\nwith Compilation_Status;\n\npackage Code_Generation is\n   -- Operations for code generation.\nend Code_Generation;\n-------------------------------------------------------------------------\n")),(0,a.kt)("h4",d({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"Strongly coupled program units can be difficult to debug and very\ndifficult to maintain. By protecting shared data with access functions,\nthe coupling is lessened. This prevents dependence on the data\nstructure, and access to the data can be controlled."),(0,a.kt)("h4",d({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"The most prevalent objection to this guideline usually involves\nperformance penalties. When a variable is moved to the package body,\nsubprograms to access the variable must be provided and the overhead\ninvolved during each call to those subprograms is introduced. See\nGuideline 10.7.1 for a discussion about subprogram overhead."),(0,a.kt)("h3",d({},{id:"tasks"}),"Tasks"),(0,a.kt)("h4",d({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use tasks to model abstract, asynchronous entities within the\nproblem domain."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to define concurrent algorithms for multiprocessor\narchitectures."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to perform concurrent, cyclic, or prioritized activities\n(NASA 1987).")),(0,a.kt)("h4",d({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"The rationale for this guideline is given under Guideline 6.1.2. Chapter\n6 discusses tasking in more detail."),(0,a.kt)("h3",d({},{id:"protected-types"}),"Protected Types"),(0,a.kt)("h4",d({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use protected types to control or synchronize access to data or\ndevices."),(0,a.kt)("li",{parentName:"ul"},"Use protected types to implement synchronization tasks, such as a\npassive resource monitor.")),(0,a.kt)("h4",d({},{id:"example-7"}),"example"),(0,a.kt)("p",null,"See example in Guideline 6.1.1."),(0,a.kt)("h4",d({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"The rationale for this guideline is given under Guideline 6.1.1. Chapter\n6 discusses concurrency and protected types in more detail."),(0,a.kt)("h2",d({},{id:"visibility"}),"Visibility"),(0,a.kt)("p",null,'Ada\'s ability to enforce information hiding and separation of concerns\nthrough its visibility controlling features is one of the most important\nadvantages of the language, particularly when "pieces of a large system\nare being developed separately." Subverting these features, for example,\nby excessive reliance on the use clause, is wasteful and dangerous. See\nalso Guidelines 5.7 and 9.4.1.'),(0,a.kt)("h3",d({},{id:"minimization-of-interfaces"}),"Minimization of Interfaces"),(0,a.kt)("h4",d({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put only what is needed for the use of a package into its\nspecification."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of declarations in package specifications."),(0,a.kt)("li",{parentName:"ul"},"Do not include extra operations simply because they are easy to\nbuild."),(0,a.kt)("li",{parentName:"ul"},"Minimize the context (with) clauses in a package specification."),(0,a.kt)("li",{parentName:"ul"},"Reconsider subprograms that seem to require large numbers of\nparameters."),(0,a.kt)("li",{parentName:"ul"},"Do not manipulate global data within a subprogram or package merely\nto limit the number of parameters."),(0,a.kt)("li",{parentName:"ul"},"Avoid unnecessary visibility; hide the implementation details of a\nprogram unit from its users."),(0,a.kt)("li",{parentName:"ul"},"Use child library units to control the visibility of parts of a\nsubsystem interface."),(0,a.kt)("li",{parentName:"ul"},"Use private child packages for those declarations that should not be\nused outside the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use child library units present different views of an entity to\ndifferent clients."),(0,a.kt)("li",{parentName:"ul"},"Design (and redesign) interfaces after having worked out the logic\nof various expected clients of the interface.")),(0,a.kt)("h4",d({},{id:"example-8"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"-------------------------------------------------------------------------\npackage Telephone_Book is\n   type Listing is limited private;\n   procedure Set_Name (New_Name : in     String;\n                       Current  : in out Listing);\n   procedure Insert (Name    : in     String;\n                     Current : in out Listing);\n   procedure Delete (Obsolete : in     String;\n                     Current  : in out Listing);\nprivate\n   type Information;\n   type Listing is access Information;\nend Telephone_Book;\n-------------------------------------------------------------------------\npackage body Telephone_Book is\n   -- Full details of record for a listing\n   type Information is\n      record\n         ...\n         Next : Listing;\n      end record;\n   First : Listing;\n   procedure Set_Name (New_Name : in     String;\n                       Current  : in out Listing) is separate;\n   procedure Insert (Name    : in      String;\n                     Current : in out  Listing) is separate;\n   procedure Delete (Obsolete : in     String;\n                     Current  : in out Listing) is separate;\nend Telephone_Book;\n-------------------------------------------------------------------------\n")),(0,a.kt)("h4",d({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,'For each entity in the specification, give careful consideration to\nwhether it could be moved to a child package or to the parent package\nbody. The fewer the extraneous details, the more understandable the\nprogram, package, or subprogram. It is important to maintainers to know\nexactly what a package interface is so that they can understand the\neffects of changes. Interfaces to a subprogram extend beyond the\nparameters. Any modification of global data from within a package or\nsubprogram is an undocumented interface to the "outside" as well.'),(0,a.kt)("p",null,"Minimize the context clauses on a specification by moving unnecessary\nclauses to the body. This technique makes the reader's job easier,\nlocalizes the recompilation required when library units change, and\nhelps prevent a ripple effect during modifications. See also Guideline\n4.2.3."),(0,a.kt)("p",null,"Subprograms with large numbers of parameters often indicate poor design\ndecisions (e.g., the functional boundaries of the subprogram are\ninappropriate or parameters are structured poorly). Conversely,\nsubprograms with no parameters are likely to be accessing global data."),(0,a.kt)("p",null,"Objects visible within package specifications can be modified by any\nunit that has visibility to them. The object cannot be protected or\nrepresented abstractly by its enclosing package. Objects that must\npersist should be declared in package bodies. Objects whose value\ndepends on program units external to their enclosing package are\nprobably either in the wrong package or are better accessed by a\nsubprogram specified in the package specification."),(0,a.kt)("p",null,"Child library units can provide distinct views of the hierarchical\nlibrary. The engineer can provide a different view for the client than\nfor the implementor (Rationale 1995, \xa710.1). By creating private child\npackages, the engineer can provide facilities that are only available\ninside the subsystem rooted at the parent library unit. The declarations\ninside a private child package specification are not exported outside\nthe subsystem. Thus, the engineer can declare utilities needed to\nimplement an abstraction in a private child package (e.g., debugging\nutilities ","[","Cohen et al. 1993","]",") and be certain that users of the\nabstraction (i.e., the clients) cannot access these utilities."),(0,a.kt)("p",null,"Different clients may have different needs for essentially the same\nresource. Instead of having multiple versions of the resources, consider\nhaving child units that export different views for different purposes."),(0,a.kt)("p",null,'Designing an interface based strictly on predicting what clients "might"\nneed can produce a bloated and inappropriate interface. What then\nhappens is that clients try to "live" with the interface and work around\nthe inappropriate interfaces, repeating code that logically should be\npart of the shared abstraction. See Guideline 8.3.1 for a discussion of\ninterfaces from the reusability perspective.'),(0,a.kt)("h4",d({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"In some cases, subroutine libraries look like large, monolithic\npackages. In such cases, it may be beneficial to break these up into\nsmaller packages, grouping them according to category (e.g.,\ntrigonometric functions)."),(0,a.kt)("h3",d({},{id:"nested-packages"}),"Nested Packages"),(0,a.kt)("h4",d({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use child packages rather than nested packages to present different\nviews of the same abstraction."),(0,a.kt)("li",{parentName:"ul"},"Nest package specifications within another package specification\nonly for grouping operations or hiding common implementation\ndetails.")),(0,a.kt)("h4",d({},{id:"example-9"}),"example"),(0,a.kt)("p",null,"Annex A of the Ada Reference Manual (1995) gives an example of package\nspecification nesting. The specification of the generic package\nGeneric_Bounded_Length is nested inside the specification of package\nAda.Strings.Bounded. The nested package is a generic, grouping closely\nrelated operations."),(0,a.kt)("h4",d({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,"Grouping package specifications into an encompassing package emphasizes\na relationship of commonality among those packages. It also allows them\nto share common implementation details resulting from the relationship.\nNesting packages allows you to organize the name space of the package in\ncontrast to the semantic effect of nesting inside of subprograms or task\nbodies."),(0,a.kt)("p",null,"An abstraction occasionally needs to present different views to\ndifferent classes of users. Building one view upon another as an\nadditional abstraction does not always suffice because the functionality\nof the operations presented by the views may be only partially\ndisjointed. Nesting specifications groups the facilities of the various\nviews, yet associates them with the abstraction they present. Abusive\nmixing of the views by another unit would be easy to detect due to the\nmultiple use clauses or an incongruous mix of qualified names."),(0,a.kt)("p",null,"See the rationale discussed in Guideline 4.2.1."),(0,a.kt)("h3",d({},{id:"restricting-visibility"}),"Restricting Visibility"),(0,a.kt)("h4",d({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using private child packages in lieu of nesting."),(0,a.kt)("li",{parentName:"ul"},"Restrict the visibility of program units as much as possible by\nnesting them inside package bodies (Nissen and Wallis 1984) if you\ncannot use a private child package."),(0,a.kt)("li",{parentName:"ul"},"Minimize nesting program units inside subprograms and tasks."),(0,a.kt)("li",{parentName:"ul"},"Minimize the scope within which with clauses apply."),(0,a.kt)("li",{parentName:"ul"},"Only with those units directly needed.")),(0,a.kt)("h4",d({},{id:"example-10"}),"example"),(0,a.kt)("p",null,"This program illustrates the use of child library units to restrict\nvisibility. The procedure Rational_Numbers.Reduce is nested inside the\nbody of Rational_Numbers to restrict its visibility to the\nimplementation of this abstraction. Rather than make the text\ninput/output facilities visible to the entire rational number hierarchy,\nit is only available to the body of the child library\nRational_Numbers.IO. This example is adapted from the Ada Reference\nManual (1995, \xa7\xa77.1, 7.2, and 10.1.1):"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),'-------------------------------------------------------------------------\npackage Rational_Numbers is\n   type Rational is private;\n   function "=" (X, Y: Rational) return Boolean;\n   function "/" (X, Y: Integer)  return Rational;  -- construct a rational number\n   function "+" (X, Y: Rational) return Rational;\n   function "-" (X, Y: Rational) return Rational;\n   function "*" (X, Y: Rational) return Rational;\n   function "/" (X, Y: Rational) return Rational;  -- rational division\nprivate\n   ...\nend Rational_Numbers;\npackage body Rational_Numbers is\n   procedure Reduce (R :in out Rational) is . . . end Reduce;\n   . . .\nend Rational_Numbers;\npackage Rational_Numbers.IO is\n   procedure Put (R : in  Rational);\n   procedure Get (R : out Rational);\nend Rational_Numbers.IO;\nwith Ada.Text_IO;\nwith Ada.Integer_Text_IO;\npackage body Rational_Numbers.IO is   -- has visibility to parent private type declaration\n   procedure Put (R : in  Rational) is\n   begin\n      Ada.Integer_Text_IO.Put (Item => R.Numerator, Width => 0);\n      Ada.Text_IO.Put ("/");\n      Ada.Integer_Text_IO.Put (Item => R.Denominator, Width => 0);\n   end Put;\n   procedure Get (R : out Rational) is . . . end Get;\nend Rational_Numbers.IO;\n')),(0,a.kt)("h4",d({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"Restricting visibility of a program unit ensures that the program unit\nis not called from some part of the system other than that which was\nintended. This is done by nesting it inside the only unit that uses it,\nby hiding it inside a package body rather than declaring it in the\npackage specification, or by declaring it as a private child unit. This\navoids errors and eases the job of maintainers by guaranteeing that a\nlocal change in that unit will not have an unforeseen global effect."),(0,a.kt)("p",null,"Restricting visibility of a library unit by using with clauses on\nsubunits rather than on the entire parent unit is useful in the same\nway. In the example above, it is clear that the package Text_IO is used\nonly by the Listing_Facilities package of the compiler."),(0,a.kt)("p",null,"Nesting inside subprograms and tasks is discouraged because it leads to\nunreusable components. These components are essentially unreusable\nbecause they make undesirable up-level references into the defining\ncontext. Unless you truly want to ensure that the program unit is not\ncalled from some unintended part of the system, you should minimize this\nform of nesting."),(0,a.kt)("p",null,"See also Guideline 4.2.1 for a discussion of the use of child units."),(0,a.kt)("h4",d({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"One way to minimize the coverage of a with clause is to use it only with\nsubunits that really need it. Consider making those subunits separate\ncompilation units when the need for visibility to a library unit is\nrestricted to a subprogram or two."),(0,a.kt)("h3",d({},{id:"hiding-tasks"}),"Hiding Tasks"),(0,a.kt)("h4",d({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Carefully consider encapsulation of tasks.")),(0,a.kt)("h4",d({},{id:"example-11"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"-------------------------------------------------------------------------\npackage Disk_Head_Scheduler is\n   type Words        is ...\n   type Track_Number is ...\n   procedure Transmit (Track : in     Track_Number;\n                       Data  : in     Words);\n   ...\nend Disk_Head_Scheduler;\n-------------------------------------------------------------------------\npackage body Disk_Head_Scheduler is\n   ...\n   task Control is\n      entry Sign_In (Track : in     Track_Number);\n      ...\n   end Control;\n   ----------------------------------------------------------------------\n   task Track_Manager is\n      entry Transfer(Track_Number) (Data : in     Words);\n   end Track_Manager;\n   ----------------------------------------------------------------------\n   ...\n   procedure Transmit (Track : in     Track_Number;\n                       Data  : in     Words) is\n   begin\n      Control.Sign_In(Track);\n      Track_Manager.Transfer(Track)(Data);\n   end Transmit;\n   ----------------------------------------------------------------------\n   ...\nend Disk_Head_Scheduler;\n-------------------------------------------------------------------------\n")),(0,a.kt)("h4",d({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"The decision whether to declare a task in the specification or body of\nan enclosing package is not a simple one. There are good arguments for\nboth."),(0,a.kt)("p",null,"Hiding a task specification in a package body and exporting (via\nsubprograms ) only required entries reduces the amount of extraneous\ninformation in the package specification. It allows your subprograms to\nenforce any order of entry calls necessary to the proper operation of\nthe tasks. It also allows you to impose defensive task communication\npractices (see Guideline 6.2.2) and proper use of conditional and timed\nentry calls. Finally, it allows the grouping of entries into sets for\nexport to different classes of users (e.g., producers versus consumers)\nor the concealment of entries that should not be made public at all\n(e.g., initialization, completion, signals). Where performance is an\nissue and there are no ordering rules to enforce, the entries can be\nrenamed as subprograms to avoid the overhead of an extra procedure call."),(0,a.kt)("p",null,"An argument, which can be viewed as an advantage or disadvantage, is\nthat hiding the task specification in a package body hides the fact of a\ntasking implementation from the user. If the application is such that a\nchange to or from a tasking implementation or a reorganization of\nservices among tasks need not concern users of the package, then this is\nan advantage. However, if the package user must know about the tasking\nimplementation to reason about global tasking behavior, then it is\nbetter not to hide the task completely. Either move it to the package\nspecification or add comments stating that there is a tasking\nimplementation, describing when a call may block, etc. Otherwise, it is\nthe package implementor's responsibility to ensure that users of the\npackage do not have to concern themselves with behaviors such as\ndeadlock, starvation, and race conditions."),(0,a.kt)("p",null,"Finally, keep in mind that hiding tasks behind a procedural interface\nprevents the usage of conditional and timed entry calls and entry\nfamilies, unless you add parameters and extra code to the procedures to\nmake it possible for callers to direct the procedures to use these\ncapabilities."),(0,a.kt)("h2",d({},{id:"exceptions-1"}),"Exceptions"),(0,a.kt)("p",null,"This section addresses the issue of exceptions in the context of program\nstructures. It discusses how exceptions should be used as part of the\ninterface to a unit, including what exceptions to declare and raise and\nunder what conditions to raise them. Information on how to handle,\npropagate, and avoid raising exceptions is found in Guideline 5.8.\nGuidelines on how to deal with portability issues are in Guideline 7.5."),(0,a.kt)("h3",d({},{id:"using-exceptions-to-help-define-an-abstraction"}),"Using Exceptions to Help Define an Abstraction"),(0,a.kt)("h4",d({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For unavoidable internal errors for which no user recovery is\npossible, declare a single user-visible exception. Inside the\nabstraction, provide a way to distinguish between the different\ninternal errors."),(0,a.kt)("li",{parentName:"ul"},"Do not borrow an exception name from another context."),(0,a.kt)("li",{parentName:"ul"},"Export (declare visibly to the user) the names of all exceptions\nthat can be raised."),(0,a.kt)("li",{parentName:"ul"},"In a package, document which exceptions can be raised by each\nsubprogram and task entry."),(0,a.kt)("li",{parentName:"ul"},"Do not raise exceptions for internal errors that can be avoided or\ncorrected within the unit."),(0,a.kt)("li",{parentName:"ul"},"Do not raise the same exception to report different kinds of errors\nthat are distinguishable by the user of the unit."),(0,a.kt)("li",{parentName:"ul"},"Provide interrogative functions that allow the user of a unit to\navoid causing exceptions to be raised."),(0,a.kt)("li",{parentName:"ul"},"When possible, avoid changing state information in a unit before\nraising an exception."),(0,a.kt)("li",{parentName:"ul"},"Catch and convert or handle all predefined and compiler-defined\nexceptions at the earliest opportunity."),(0,a.kt)("li",{parentName:"ul"},"Do not explicitly raise predefined or implementation-defined\nexceptions."),(0,a.kt)("li",{parentName:"ul"},"Never let an exception propagate beyond its scope.")),(0,a.kt)("h4",d({},{id:"example-12"}),"example"),(0,a.kt)("p",null,"This package specification defines two exceptions that enhance the\nabstraction:"),(0,a.kt)("pre",null,(0,a.kt)("code",d({parentName:"pre"},{className:"language-ada"}),"-------------------------------------------------------------------------\ngeneric\n   type Element is private;\npackage Stack is\n\n   function Stack_Empty return Boolean;\n   function Stack_Full  return Boolean;\n\n   procedure Pop  (From_Top :    out Element);\n   procedure Push (Onto_Top : in     Element);\n\n   -- Raised when Pop is used on empty stack.\n   Underflow : exception;\n\n   -- Raised when Push is used on full stack.\n   Overflow  : exception;\n\nend Stack;\n-------------------------------------------------------------------------\n...\n----------------------------------------------------------------------\nprocedure Pop (From_Top :    out Element) is\nbegin\n   ...\n\n   if Stack_Empty then\n      raise Underflow;\n\n   else -- Stack contains at least one element\n      Top_Index := Top_Index - 1;\n      From_Top  := Data(Top_Index + 1);\n\n   end if;\nend Pop;\n--------------------------------------------------------------------\n...\n")),(0,a.kt)("h4",d({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"Exceptions should be used as part of an abstraction to indicate error\nconditions that the abstraction is unable to prevent or correct. Because\nthe abstraction is unable to correct such an error, it must report the\nerror to the user. In the case of a usage error (e.g., attempting to\ninvoke operations in the wrong sequence or attempting to exceed a\nboundary condition), the user may be able to correct the error. In the\ncase of an error beyond the control of the user, the user may be able to\nwork around the error if there are multiple mechanisms available to\nperform the desired operation. In other cases, the user may have to\nabandon use of the unit, dropping into a degraded mode of limited\nfunctionality. In any case, the user must be notified."),(0,a.kt)("p",null,"Exceptions are a good mechanism for reporting such errors because they\nprovide an alternate flow of control for dealing with errors. This\nallows error-handling code to be kept separate from the code for normal\nprocessing. When an exception is raised, the current operation is\naborted and control is transferred directly to the appropriate exception\nhandler."),(0,a.kt)("p",null,"Several of the guidelines above exist to maximize the ability of the\nuser to distinguish and correct different kinds of errors. Declaring new\nexception names, rather than raising exceptions declared in other\npackages, reduces the coupling between packages and also makes different\nexceptions more distinguishable. Exporting the names of all exceptions\nthat a unit can raise, rather than declaring them internally to the\nunit, makes it possible for users of the unit to refer to the names in\nexception handlers. Otherwise, the user would be able to handle the\nexception only with an others handler. Finally, use comments to document\nexactly which of the exceptions declared in a package can be raised by\neach subprogram or task entry making it possible for the user to know\nwhich exception handlers are appropriate in each situation."),(0,a.kt)("p",null,"In situations where there are errors for which the abstraction user can\ntake no intelligent action (e.g., there is no workaround or degraded\nmode), it is better to export a single internal error exception. Within\nthe package, you should consider distinguishing between the different\ninternal errors. For instance, you could record or handle different\nkinds of internal error in different ways. When you propagate the error\nto the user, however, you should use a special internal error exception,\nindicating that no user recovery is possible. You should also provide\nrelevant information when you propagate the error, using the facilities\nprovided in Ada.Exceptions. Thus, for any abstraction, you effectively\nprovide N + 1 different exceptions: N different recoverable errors and\none irrecoverable error for which there is no mapping to the\nabstraction. Both the application requirements and what the client\nneeds/wants in terms of error information help you identify the\nappropriate exceptions for an abstraction."),(0,a.kt)("p",null,"Because they cause an immediate transfer of control, exceptions are\nuseful for reporting unrecoverable errors, which prevent an operation\nfrom being completed, but not for reporting status or modes incidental\nto the completion of an operation. They should not be used to report\ninternal errors that a unit was able to correct invisibly to the user."),(0,a.kt)("p",null,"To provide the user with maximum flexibility, it is a good idea to\nprovide interrogative functions that the user can call to determine\nwhether an exception would be raised if a subprogram or task entry were\ninvoked. The function Stack_Empty in the above example is such a\nfunction. It indicates whether Underflow would be raised if Pop were\ncalled. Providing such functions makes it possible for the user to avoid\ntriggering exceptions."),(0,a.kt)("p",null,"To support error recovery by its user, a unit should try to avoid\nchanging state during an invocation that raises an exception. If a\nrequested operation cannot be completely and correctly performed, then\nthe unit should either detect this before changing any internal state\ninformation or should revert to the state at the time of the request.\nFor example, after raising the exception Underflow, the stack package in\nthe above example should remain in exactly the same state it was in when\nPop was called. If it were to partially update its internal data\nstructures for managing the stack, then future Push and Pop operations\nwould not perform correctly. This is always desirable, but not always\npossible."),(0,a.kt)("p",null,"User-defined exceptions should be used instead of predefined or\ncompiler-defined exceptions because they are more descriptive and more\nspecific to the abstraction. The predefined exceptions are very general\nand can be triggered by many different situations. Compiler-defined\nexceptions are nonportable and have meanings that are subject to change\neven between successive releases of the same compiler. This introduces\ntoo much uncertainty for the creation of useful handlers."),(0,a.kt)("p",null,"If you are writing an abstraction, remember that the user does not know\nabout the units you use in your implementation. That is an effect of\ninformation hiding. If any exception is raised within your abstraction,\nyou must catch it and handle it. The user is not able to provide a\nreasonable handler if the original exception is allowed to propagate out\nof the body of your abstraction. You can still convert the exception\ninto a form intelligible to the user if your abstraction cannot\neffectively recover on its own."),(0,a.kt)("p",null,"Converting an exception means raising a user-defined exception in the\nhandler for the original exception. This introduces a meaningful name\nfor export to the user of the unit. Once the error situation is couched\nin terms of the application, it can be handled in those terms."),(0,a.kt)("h2",d({},{id:"summary"}),"Summary"),(0,a.kt)("h3",d({},{id:"high-level-structure-1"}),"high-level structure"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Place the specification of each library unit package in a separate\nfile from its body."),(0,a.kt)("li",{parentName:"ul"},"Avoid defining library unit subprograms that are not intended to be\nused as main programs. If such subprograms are defined, then create\nan explicit specification, in a separate file, for each library unit\nsubprogram."),(0,a.kt)("li",{parentName:"ul"},"Minimize the use of subunits."),(0,a.kt)("li",{parentName:"ul"},"In preference to subunits, use child library units to structure a\nsubsystem into manageable units."),(0,a.kt)("li",{parentName:"ul"},"Place each subunit in a separate file."),(0,a.kt)("li",{parentName:"ul"},"Use a consistent file naming convention."),(0,a.kt)("li",{parentName:"ul"},"In preference to nesting in a package body, use a private child and\nwith it to the parent body."),(0,a.kt)("li",{parentName:"ul"},"Use private child unit specifications for data and subprograms that\nare required by (other) child units that extend a parent unit's\nabstraction or services."),(0,a.kt)("li",{parentName:"ul"},"When possible, express configuration pragmas through compiler\noptions or other means that do not require modifications to the\nsource code. ."),(0,a.kt)("li",{parentName:"ul"},"When configuration pragmas must be placed in source code, consider\nisolating them to one compilation unit per partition; if specified,\nthe main subprogram for the partition is recommended."),(0,a.kt)("li",{parentName:"ul"},"Use subprograms to enhance abstraction."),(0,a.kt)("li",{parentName:"ul"},"Restrict each subprogram to the performance of a single action."),(0,a.kt)("li",{parentName:"ul"},"Use a function when the subprogram's primary purpose is to provide a\nsingle value."),(0,a.kt)("li",{parentName:"ul"},"Minimize the side effect of a function."),(0,a.kt)("li",{parentName:"ul"},"Consider using a parameterless function when the value does not need\nto be static."),(0,a.kt)("li",{parentName:"ul"},"Use a parameterless function (instead of a constant) if the value\nshould be inherited by types derived from the type."),(0,a.kt)("li",{parentName:"ul"},"Use a parameterless function if the value itself is subject to\nchange."),(0,a.kt)("li",{parentName:"ul"},"Use packages for information hiding."),(0,a.kt)("li",{parentName:"ul"},"Use packages with tagged types and private types for abstract data\ntypes."),(0,a.kt)("li",{parentName:"ul"},"Use packages to model abstract entities appropriate to the problem\ndomain."),(0,a.kt)("li",{parentName:"ul"},"Use packages to group together related type and object declarations\n(e.g., common declarations for two or more library units)."),(0,a.kt)("li",{parentName:"ul"},"Encapsulate machine dependencies in packages. Place a software\ninterface to a particular device in a package to facilitate a change\nto a different device."),(0,a.kt)("li",{parentName:"ul"},"Place low-level implementation decisions or interfaces in\nsubprograms within packages."),(0,a.kt)("li",{parentName:"ul"},"Use packages and subprograms to encapsulate and hide program details\nthat may change (Nissen and Wallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"If a new library unit represents a logical extension to the original\nabstraction, define it as a child library unit."),(0,a.kt)("li",{parentName:"ul"},"If a new library unit is independent (e.g., introduces a new\nabstraction that depends only in part on the existing one), then\nencapsulate the new abstraction in a separate library unit."),(0,a.kt)("li",{parentName:"ul"},"Use child packages to implement a subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use public child units for those parts of a subsystem that should be\nvisible to clients of the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use private child units for those parts of a subsystem that should\nnot be visible to clients of the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use private child units for local declarations used only in\nimplementing the package specification."),(0,a.kt)("li",{parentName:"ul"},"Use child packages to implement constructors, even when they return\naccess values."),(0,a.kt)("li",{parentName:"ul"},"Make each package serve a single purpose."),(0,a.kt)("li",{parentName:"ul"},"Use packages to group related data, types, and subprograms."),(0,a.kt)("li",{parentName:"ul"},"Avoid collections of unrelated objects and subprograms (NASA 1987;\nNissen and Wallis 1984)."),(0,a.kt)("li",{parentName:"ul"},"Consider restructuring a system to move two highly related units\ninto the same package (or package hierarchy) or to move relatively\nindependent units into separate packages."),(0,a.kt)("li",{parentName:"ul"},"Avoid declaring variables in package specifications."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to model abstract, asynchronous entities within the\nproblem domain."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to define concurrent algorithms for multiprocessor\narchitectures."),(0,a.kt)("li",{parentName:"ul"},"Use tasks to perform concurrent, cyclic, or prioritized activities\n(NASA 1987)."),(0,a.kt)("li",{parentName:"ul"},"Use protected types to control or synchronize access to data or\ndevices."),(0,a.kt)("li",{parentName:"ul"},"Use protected types to implement synchronization tasks, such as a\npassive resource monitor.")),(0,a.kt)("h3",d({},{id:"visibility-1"}),"visibility"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put only what is needed for the use of a package into its\nspecification."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of declarations in package specifications."),(0,a.kt)("li",{parentName:"ul"},"Do not include extra operations simply because they are easy to\nbuild."),(0,a.kt)("li",{parentName:"ul"},"Minimize the context (with) clauses in a package specification."),(0,a.kt)("li",{parentName:"ul"},"Reconsider subprograms that seem to require large numbers of\nparameters."),(0,a.kt)("li",{parentName:"ul"},"Do not manipulate global data within a subprogram or package merely\nto limit the number of parameters."),(0,a.kt)("li",{parentName:"ul"},"Avoid unnecessary visibility; hide the implementation details of a\nprogram unit from its users."),(0,a.kt)("li",{parentName:"ul"},"Use child library units to control the visibility of parts of a\nsubsystem interface."),(0,a.kt)("li",{parentName:"ul"},"Use private child packages for those declarations that should not be\nused outside the subsystem."),(0,a.kt)("li",{parentName:"ul"},"Use child library units to present different views of an entity to\ndifferent clients."),(0,a.kt)("li",{parentName:"ul"},"Design (and redesign) interfaces after having worked out the logic\nof various expected clients of the interface."),(0,a.kt)("li",{parentName:"ul"},"Use child packages rather than nested packages to present different\nviews of the same abstraction."),(0,a.kt)("li",{parentName:"ul"},"Nest package specifications within another package specification\nonly for grouping operations or hiding common implementation\ndetails."),(0,a.kt)("li",{parentName:"ul"},"Consider using private child packages in lieu of nesting."),(0,a.kt)("li",{parentName:"ul"},"Restrict the visibility of program units as much as possible by\nnesting them inside package bodies (Nissen and Wallis 1984) if you\ncannot use a private child package."),(0,a.kt)("li",{parentName:"ul"},"Minimize nesting program units inside subprograms and tasks."),(0,a.kt)("li",{parentName:"ul"},"Minimize the scope within which with clauses apply."),(0,a.kt)("li",{parentName:"ul"},"Only with those units directly needed."),(0,a.kt)("li",{parentName:"ul"},"Carefully consider encapsulation of tasks.")),(0,a.kt)("h4",d({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For unavoidable internal errors for which no user recovery is\npossible, declare a single user-visible exception. Inside the\nabstraction, provide a way to distinguish between the different\ninternal errors."),(0,a.kt)("li",{parentName:"ul"},"Do not borrow an exception name from another context."),(0,a.kt)("li",{parentName:"ul"},"Export (declare visibly to the user) the names of all exceptions\nthat can be raised."),(0,a.kt)("li",{parentName:"ul"},"In a package, document which exceptions can be raised by each\nsubprogram and task entry."),(0,a.kt)("li",{parentName:"ul"},"Do not raise exceptions for internal errors that can be avoided or\ncorrected within the unit."),(0,a.kt)("li",{parentName:"ul"},"Do not raise the same exception to report different kinds of errors\nthat are distinguishable by the user of the unit."),(0,a.kt)("li",{parentName:"ul"},"Provide interrogative functions that allow the user of a unit to\navoid causing exceptions to be raised."),(0,a.kt)("li",{parentName:"ul"},"When possible, avoid changing state information in a unit before\nraising an exception."),(0,a.kt)("li",{parentName:"ul"},"Catch and convert or handle all predefined and compiler-defined\nexceptions at the earliest opportunity."),(0,a.kt)("li",{parentName:"ul"},"Do not explicitly raise predefined or implementation-defined\nexceptions."),(0,a.kt)("li",{parentName:"ul"},"Never let an exception propagate beyond its scope.")),(0,a.kt)("admonition",d({},{type:"note"}),(0,a.kt)("p",{parentName:"admonition"},'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",d({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",d({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work.")))}k.isMDXComponent=!0}}]);