"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3835],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),u=i,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||s;return a?n.createElement(m,r(r({ref:t},p),{},{components:a})):n.createElement(m,r({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<s;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6708:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const s={sidebar_position:37},r="4.9  Static Expressions and Static Subtypes",o={unversionedId:"arm/AA-4.9",id:"arm/AA-4.9",title:"4.9  Static Expressions and Static Subtypes",description:"Certain expressions of a scalar or string type are defined to be static. Similarly, certain discrete ranges are defined to be static, and certain scalar and string subtypes are defined to be static subtypes. [ Static means determinable at compile time, using the declared properties or values of the program entities.]",source:"@site/docs/arm/AA-4.9.md",sourceDirName:"arm",slug:"/arm/AA-4.9",permalink:"/docs/arm/AA-4.9",draft:!1,tags:[],version:"current",sidebarPosition:37,frontMatter:{sidebar_position:37},sidebar:"tutorialSidebar",previous:{title:"4.8  Allocators",permalink:"/docs/arm/AA-4.8"},next:{title:"4.10  Image Attributes",permalink:"/docs/arm/AA-4.10"}},l={},c=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"4.9.1  Statically Matching Constraints and Subtypes",id:"491--statically-matching-constraints-and-subtypes",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4}],p={toc:c};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"49--static-expressions-and-static-subtypes"},"4.9  Static Expressions and Static Subtypes"),(0,i.kt)("p",null,"Certain expressions of a scalar or string type are defined to be static. Similarly, certain discrete ranges are defined to be static, and certain scalar and string subtypes are defined to be static subtypes. ","[ Static means determinable at compile time, using the declared properties or values of the program entities.]"," "),(0,i.kt)("p",null,"Discussion: As opposed to more elaborate data flow analysis, etc. "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,"For an expression to be static, it has to be calculable at compile time."),(0,i.kt)("p",null,"Only scalar and string expressions are static."),(0,i.kt)("p",null,"To be static, an expression cannot have any nonscalar, nonstring subexpressions (though it can have nonscalar constituent ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name"),"s). A static scalar expression cannot have any nonscalar subexpressions. There is one exception - a membership test for a string subtype can be static, and the result is scalar, even though a subexpression is nonscalar."),(0,i.kt)("p",null,"The rules for evaluating static expressions are designed to maximize portability of static calculations."),(0,i.kt)("p",null,"Reason: {AI12-0201-1} We support static string expressions so that, for example, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0348"},"aspect_definition")," for a Link_Name aspect can contain a concatenation. We don't support static aggregates (even for string types) or non-string static nonscalar types; we're trying to keep it cheap and simple (from the implementer's viewpoint). "),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"A static expression is ","[a scalar or string expression that is]"," one of the following:"),(0,i.kt)("p",null,"{AI12-0249-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal")," of a numeric type; "),(0,i.kt)("p",null,"Ramification: {AI12-0249-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal")," of a numeric type is always a static expression, even if its expected type is not that of a static subtype. However, if its value is explicitly converted to, or qualified by, a nonstatic subtype, the resulting expression is nonstatic. Non-numeric types can have numeric literals if aspect Integer_Literal or Real_Literal is used; these are never static. "),(0,i.kt)("p",null,"a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.6#S0016"},"string_literal")," of a static string subtype; "),(0,i.kt)("p",null,"Ramification: That is, the constrained subtype defined by the index range of the string is static. Note that elementary values don't generally have subtypes, while composite values do (since the bounds or discriminants are inherent in the value). "),(0,i.kt)("p",null,"{AI12-0394-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes the declaration of a static constant;"),(0,i.kt)("p",null,"{AI12-0394-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that denotes a named number, and that is interpreted as a value of a numeric type;"),(0,i.kt)("p",null,'To be honest: {AI12-0394-1} This is referring the resolution of the named number and not the Static Semantics (for which all named numbers are values of a universal numeric type). The word "interpreted" is intended to make the distinction. '),(0,i.kt)("p",null,"Ramification: Note that enumeration literals are covered by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call")," case. "),(0,i.kt)("p",null,"a ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call")," whose function",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.1#S0091"},"name")," or function"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," statically denotes a static function, and whose actual parameters, if any (whether given explicitly or by default), are all static expressions; "),(0,i.kt)("p",null,"Ramification: This includes uses of operators that are equivalent to ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call"),"s. "),(0,i.kt)("p",null,"an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," that denotes a scalar value, and whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," denotes a static scalar subtype;"),(0,i.kt)("p",null,"Ramification: Note that this does not include the case of an attribute that is a function; a reference to such an attribute is not even an expression. See above for function calls."),(0,i.kt)("p",null,"An implementation may define the staticness and other properties of implementation-defined attributes. "),(0,i.kt)("p",null,"{AI12-0368-1} an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," statically names a statically constrained array object or array subtype, and whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," is First, Last, or Length, with an optional dimension;"),(0,i.kt)("p",null,"{AI12-0064-2} an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," denotes a non-generic entity that is not declared in a generic unit, and whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," is Nonblocking;"),(0,i.kt)("p",null,"{AI12-0201-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.6#S0162"},"type_conversion")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," denotes a static ","[(scalar or string)]"," subtype, and whose operand is a static expression;"),(0,i.kt)("p",null,"a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.7#S0163"},"qualified_expression")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," denotes a static ","[(scalar or string)]"," subtype, and whose operand is a static expression; "),(0,i.kt)("p",null,"Ramification: This rules out the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),"'",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0106"},"aggregate")," case. "),(0,i.kt)("p",null,"Reason: Adding qualification to an expression shouldn't make it nonstatic, even for strings. "),(0,i.kt)("p",null,"{AI05-0158-1} {AI05-0269-1} {AI12-0039-1} a membership test whose tested",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0138"},"simple_expression")," is a static expression, and whose ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0136"},"membership_choice_list")," consists only of ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0137"},"membership_choice"),"s that are either static choice"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s, static ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),"s, or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),"s that denote a static ","[(scalar or string)]"," subtype; "),(0,i.kt)("p",null,"Reason: Clearly, we should allow membership tests in exactly the same cases where we allow ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.7#S0163"},"qualified_expression"),"s. "),(0,i.kt)("p",null,"a short-circuit control form both of whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0135"},"relation"),"s are static expressions;"),(0,i.kt)("p",null,"{AI05-0147-1} {AI05-0188-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0148"},"conditional_expression")," all of whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition"),"s, selecting",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression"),"s, and dependent"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s are static expressions;"),(0,i.kt)("p",null,"{AI12-0368-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0156"},"declare_expression")," whose body",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," is static and each of whose declarations, if any, is either the declaration of a static constant or is an ",(0,i.kt)("a",{parentName:"em",href:"./AA-8.5#S0239"},"object_renaming_declaration")," with an object"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that statically names the renamed object;"),(0,i.kt)("p",null,"a static expression enclosed in parentheses. "),(0,i.kt)("p",null,"Discussion: Informally, we talk about a static value. When we do, we mean a value specified by a static expression. "),(0,i.kt)("p",null,"Ramification: {AI12-0005-1} The language requires a static expression in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0034"},"number_declaration"),", a numeric type definition, certain representation items, and a number of other contexts. "),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically denotes an entity if it denotes the entity and: "),(0,i.kt)("p",null,"It is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name"),", expanded name, or ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", and it denotes a declaration other than a ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.5#S0238"},"renaming_declaration"),"; or"),(0,i.kt)("p",null,"It is an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," statically denotes some entity; or"),(0,i.kt)("p",null,"{AI12-0322-1} It is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.2#S0174"},"target_name")," (see 5.2.1) in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.2#S0173"},"assignment_statement")," whose variable_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically denotes some entity; or"),(0,i.kt)("p",null,"It denotes a ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.5#S0238"},"renaming_declaration")," with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," that statically denotes the renamed entity. "),(0,i.kt)("p",null,"Ramification: ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0098"},"Selected_component"),"s that are not expanded names and ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0096"},"indexed_component"),"s do not statically denote things. "),(0,i.kt)("p",null,"{AI12-0368-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically names an object if it: "),(0,i.kt)("p",null,"{AI12-0368-1} statically denotes the declaration of an object ","[(possibly through one or more renames)]","; "),(0,i.kt)("p",null,"Proof: Follows from the definition of statically denotes. "),(0,i.kt)("p",null,"{AI12-0368-1} {AI12-0373-1} is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0098"},"selected_component")," whose prefix statically names an object, there is no implicit dereference of the prefix, and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," does not denote a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0070"},"component_declaration")," occurring within a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),"; or "),(0,i.kt)("p",null,"Reason: We disallow components in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part")," so that no discriminant checks are needed to evaluate the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0098"},"selected_component"),". Note that other kinds of discriminant-dependent components do not need any checks on access (only when they are changed). "),(0,i.kt)("p",null,"{AI12-0368-1} is an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0096"},"indexed_component")," whose prefix statically names an object, there is no implicit dereference of the prefix, the object is statically constrained, and the index expressions of the object are static and have values that are within the range of the index constraint. "),(0,i.kt)("p",null,"{AI12-0368-1} For an entity other than an object, a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically names an entity if the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically denotes the entity."),(0,i.kt)("p",null,"A static function is one of the following: "),(0,i.kt)("p",null,"Ramification: These are the functions whose calls can be static expressions. "),(0,i.kt)("p",null,"a predefined operator whose parameter and result types are all scalar types none of which are descendants of formal scalar types;"),(0,i.kt)("p",null,"{AI12-0201-1} a predefined relational operator whose parameters are of a string type that is not a descendant of a formal array type;"),(0,i.kt)("p",null,"{AI12-0201-1} a predefined concatenation operator whose result type is a string type that is not a descendant of a formal array type;"),(0,i.kt)("p",null,"{AI12-0385-1} a shifting or rotating function associated with a modular type declared in package Interfaces (see B.2);"),(0,i.kt)("p",null,"an enumeration literal;"),(0,i.kt)("p",null,"{AI12-0075-1} a static expression function (see 6.8);"),(0,i.kt)("p",null,"a language-defined attribute that is a function, if the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," denotes a static scalar subtype, and if the parameter and result types are scalar. "),(0,i.kt)("p",null,"In any case, a generic formal subprogram is not a static function."),(0,i.kt)("p",null,"{AI12-0201-1} {AI12-0393-1} A static constant is a constant view declared by a full constant declaration or an ",(0,i.kt)("a",{parentName:"p",href:"./AA-8.5#S0239"},"object_renaming_declaration")," with a static nominal subtype, having a value defined by a static scalar expression or by a static string expression, and which satisfies any constraint or predicate that applies to the nominal subtype. "),(0,i.kt)("p",null,"Ramification: A deferred constant is not static; the view introduced by the corresponding full constant declaration can be static. "),(0,i.kt)("p",null,"This paragraph was deleted.{AI05-0229-1} {AI12-0201-1} "),(0,i.kt)("p",null,"This paragraph was deleted.{AI12-0201-1} "),(0,i.kt)("p",null,"A static range is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," whose bounds are static expressions, [or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference")," that is equivalent to such a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),".] A static ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," is one that is a static range or is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," that defines a static scalar subtype. The base range of a scalar type is a static range, unless the type is a descendant of a formal scalar type."),(0,i.kt)("p",null,"{AI95-00263-01} {AI05-0153-3} A static subtype is either a static scalar subtype or a static string subtype. A static scalar subtype is an unconstrained scalar subtype whose type is not a descendant of a formal type, or a constrained scalar subtype formed by imposing a compatible static constraint on a static scalar subtype. A static string subtype is an unconstrained string subtype whose index subtype and component subtype are static, or a constrained string subtype formed by imposing a compatible static constraint on a static string subtype. In any case, the subtype of a generic formal object of mode in out, and the result subtype of a generic formal function, are not static. Also, a subtype is not static if any Dynamic_Predicate specifications apply to it. "),(0,i.kt)("p",null,"Ramification: String subtypes are the only composite subtypes that can be static. "),(0,i.kt)("p",null,"Reason: The part about generic formal objects of mode in out is necessary because the subtype of the formal is not required to have anything to do with the subtype of the actual. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Int10 is Integer range 1..10;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    F : in out Int10;\nprocedure G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure G is\nbegin\n    case F is\n        when 1..10 =&gt null;\n        -- Illegal!\n    end case;\nend G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"X : Integer range 1..20;\nprocedure I is new G(F =&gt X); -- OK.\n\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement")," is illegal, because the subtype of F is not static, so the choices have to cover all values of Integer, not just those in the range 1..10. A similar issue arises for generic formal functions, now that function calls are object names. "),(0,i.kt)("p",null,"The different kinds of static constraint are defined as follows: "),(0,i.kt)("p",null,"A null constraint is always static;"),(0,i.kt)("p",null,"A scalar constraint is static if it has no ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),", or one with a static range;"),(0,i.kt)("p",null,"An index constraint is static if each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," is static, and each index subtype of the corresponding array type is static;"),(0,i.kt)("p",null,"A discriminant constraint is static if each ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of the constraint is static, and the subtype of each discriminant is static. "),(0,i.kt)("p",null,"{AI95-00311-01} In any case, the constraint of the first subtype of a scalar formal type is neither static nor null."),(0,i.kt)("p",null,"A subtype is statically constrained if it is constrained, and its constraint is static. An object is statically constrained if its nominal subtype is statically constrained, or if it is a static string constant. "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"{AI05-0147-1} An expression is statically unevaluated if it is part of:"),(0,i.kt)("p",null,"{AI05-0147-1} the right operand of a static short-circuit control form whose value is determined by its left operand; or"),(0,i.kt)("p",null,"{AI05-0147-1} {AI05-0188-1} a dependent_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression")," whose associated ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition")," is static and equals False; or"),(0,i.kt)("p",null,"{AI05-0147-1} {AI05-0188-1} a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition")," or dependent",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," of an ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.5#S0149"},"if_expression")," where the ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.5#S0150"},"condition")," corresponding to at least one preceding dependent"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression")," is static and equals True; or"),(0,i.kt)("p",null,"Reason: We need this bullet so that only a single dependent_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is evaluated in a static ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression")," if there is more than one ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition")," that evaluates to True. The part about ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition"),"s makes "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"(if N = 0 then Min elsif 10_000/N &gt Min then 10_000/N else Min)\n\n")),(0,i.kt)("p",null,"legal if N and Min are static and N = 0. "),(0,i.kt)("p",null,'Discussion: {AI05-0147-1} {AI05-0188-1} We need the "of the ',(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression"),'" here so there is no confusion for nested ',(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression"),"s; this rule only applies to the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0150"},"condition"),"s and dependent_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s of a single ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression"),'. Similar reasoning applies to the "of a ',(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0151"},"case_expression"),'" of the last bullet. '),(0,i.kt)("p",null,"{AI05-0188-1} {AI05-0269-1} a dependent",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression")," of a ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.5#S0151"},"case_expression")," whose selecting"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is static and whose value is not covered by the corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0073"},"discrete_choice_list"),"; or"),(0,i.kt)("p",null,"{AI05-0158-1} {AI12-0039-1} a choice_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," (or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," that occurs as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0137"},"membership_choice")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0136"},"membership_choice_list"),") of a static membership test that is preceded in the enclosing ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0136"},"membership_choice_list")," by another item whose individual membership test (see 4.5.2) statically yields True. "),(0,i.kt)("p",null,"{AI05-0147-1} A static expression is evaluated at compile time except when it is statically unevaluated. The compile-time evaluation of a static expression is performed exactly, without performing Overflow_Checks. For a static expression that is evaluated: "),(0,i.kt)("p",null,"{AI05-0262-1} The expression is illegal if its evaluation fails a language-defined check other than Overflow_Check. For the purposes of this evaluation, the assertion policy is assumed to be Check."),(0,i.kt)("p",null,"Reason: {AI05-0262-1} Assertion policies can control whether checks are made, but we don't want assertion policies to affect legality. For Ada 2012, subtype predicates are the only checks controlled by the assertion policy that can appear in static expressions. "),(0,i.kt)("p",null,"{AI95-00269-01} If the expression is not part of a larger static expression and the expression is expected to be of a single specific type, then its value shall be within the base range of its expected type. Otherwise, the value may be arbitrarily large or small. "),(0,i.kt)("p",null,'Ramification: {AI95-00269-01} If the expression is expected to be of a universal type, or of "any integer type", there are no limits on the value of the expression. '),(0,i.kt)("p",null,"{AI95-00269-01} If the expression is of type universal_real and its expected type is a decimal fixed point type, then its value shall be a multiple of the small of the decimal type. This restriction does not apply if the expected type is a descendant of a formal scalar type (or a corresponding actual type in an instance). "),(0,i.kt)("p",null,"Ramification: This means that a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal"),' for a decimal type cannot have "extra" significant digits. '),(0,i.kt)("p",null,"Reason: {AI95-00269-01} The small is not known for a generic formal type, so we have to exclude formal types from this check. "),(0,i.kt)("p",null,"{AI95-00269-01} In addition to the places where Legality Rules normally apply (see 12.3), the above restrictions also apply in the private part of an instance of a generic unit."),(0,i.kt)("p",null,'Discussion: Values outside the base range are not permitted when crossing from the "static" domain to the "dynamic" domain. This rule is designed to enhance portability of programs containing static expressions. Note that this rule applies to the exact value, not the value after any rounding or truncation. (See below for the rounding and truncation requirements.)'),(0,i.kt)("p",null,"Short-circuit control forms are a special case: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"N: constant := 0.0;\nX: constant Boolean := (N = 0.0) or else (1.0/N &gt 0.5); -- Static.\n\n")),(0,i.kt)("p",null,"The declaration of X is legal, since the divide-by-zero part of the expression is not evaluated. X is a static constant equal to True."),(0,i.kt)("p",null,'{AI12-0075-1} The preceding "statically unevaluated" rule allows'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"X : constant := (if True then 37 else (1 / 0));\n\n")),(0,i.kt)("p",null,"but does not allow"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function If_Then_Else (Flag : Boolean; X, Y : Integer) return Integer is\n   (if Flag then X else Y) with Static; -- see 6.8\nX : constant := If_Then_Else (True, 37, 1 / 0);\n\n")),(0,i.kt)("p",null,"because evaluation of a function call includes evaluation of all of its actual parameters. "),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"{AI95-00268-01} {AI95-00269-01} For a real static expression that is not part of a larger static expression, and whose expected type is not a descendant of a formal type, the implementation shall round or truncate the value (according to the Machine_Rounds attribute of the expected type) to the nearest machine number of the expected type; if the value is exactly half-way between two machine numbers, the rounding performed is implementation-defined. If the expected type is a descendant of a formal type, or if the static expression appears in the body of an instance of a generic unit and the corresponding expression is nonstatic in the corresponding generic body, then no special rounding or truncating is required - normal accuracy rules apply (see Annex G). "),(0,i.kt)("p",null,"Implementation defined: Rounding of real static expressions which are exactly half-way between two machine numbers."),(0,i.kt)("p",null,"Reason: {AI95-00268-01} Discarding extended precision enhances portability by ensuring that the value of a static constant of a real type is always a machine number of the type. "),(0,i.kt)("p",null,"When the expected type is a descendant of a formal floating point type, extended precision (beyond that of the machine numbers) can be retained when evaluating a static expression, to ease code sharing for generic instantiations. For similar reasons, normal (nondeterministic) rounding or truncating rules apply for descendants of a formal fixed point type."),(0,i.kt)("p",null,"{AI95-00269-01} There is no requirement for exact evaluation or special rounding in an instance body (unless the expression is static in the generic body). This eliminates a potential contract issue where the exact value of a static expression depends on the actual parameters (which could then affect the legality of other code). "),(0,i.kt)("p",null,"Implementation Note: Note that the implementation of static expressions has to keep track of plus and minus zero for a type whose Signed_Zeros attribute is True."),(0,i.kt)("p",null,"{AI95-00100-01} Note that the only machine numbers of a fixed point type are the multiples of the small, so a static conversion to a fixed-point type, or division by an integer, must do truncation to a multiple of small. It is not correct for the implementation to do all static calculations in infinite precision."),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"{AI95-00268-01} For a real static expression that is not part of a larger static expression, and whose expected type is not a descendant of a formal type, the rounding should be the same as the default rounding for the target system. "),(0,i.kt)("p",null,"Implementation Advice: A real static expression with a nonformal type that is not part of a larger static expression should be rounded the same as the target system."),(0,i.kt)("p",null,"NOTE 1   An expression can be static even if it occurs in a context where staticness is not required. "),(0,i.kt)("p",null,"Ramification: For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"X : Float := Float'(1.0E+400) + 1.0 - Float'(1.0E+400);\n\n")),(0,i.kt)("p",null,"The expression is static, which means that the value of X must be exactly 1.0, independent of the accuracy or range of the run-time floating point implementation."),(0,i.kt)("p",null,"The following kinds of expressions are never static: ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0094"},"explicit_dereference"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0096"},"indexed_component"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0097"},"slice"),", null, ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0106"},"aggregate"),", ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.8#S0164"},"allocator"),". "),(0,i.kt)("p",null,"NOTE 2   A static (or run-time) ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.6#S0162"},"type_conversion")," from a real type to an integer type performs rounding. If the operand value is exactly half-way between two integers, the rounding is performed away from zero. "),(0,i.kt)("p",null,"Reason: We specify this for portability. The reason for not choosing round-to-nearest-even, for example, is that this method is easier to undo. "),(0,i.kt)("p",null,"Ramification: The attribute Truncation (see A.5.3) can be used to perform a (static) truncation prior to conversion, to prevent rounding. "),(0,i.kt)("p",null,"Implementation Note: The value of the literal 0E999999999999999999999999999999999999999999999 is zero. The implementation must take care to evaluate such literals properly."),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of static expressions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"1 + 1       -- 2\nabs(-10)*3  -- 30\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Kilo : constant := 1000;\nMega : constant := Kilo*Kilo;   -- 1_000_000\nLong : constant := Float'Digits*2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Half_Pi    : constant := Pi/2;           -- see 3.3.2\nDeg_To_Rad : constant := Half_Pi/90;\nRad_To_Deg : constant := 1.0/Deg_To_Rad; -- equivalent to 1.0/((3.14159_26536/2)/90)\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The rules for static expressions and static subtypes are generalized to allow more kinds of compile-time-known expressions to be used where compile-time-known values are required, as follows: "),(0,i.kt)("p",null,"Membership tests and short-circuit control forms may appear in a static expression."),(0,i.kt)("p",null,"The bounds and length of statically constrained array objects or subtypes are static."),(0,i.kt)("p",null,"The Range attribute of a statically constrained array subtype or object gives a static range."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.6#S0162"},"type_conversion")," is static if the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," denotes a static scalar subtype and the operand is a static expression."),(0,i.kt)("p",null,"All numeric literals are now static, even if the expected type is a formal scalar type. This is useful in ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.4#S0176"},"case_statement"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0071"},"variant_part"),"s, which both now allow a value of a formal scalar type to control the selection, to ease conversion of a package into a generic package. Similarly, named array aggregates are also permitted for array types with an index type that is a formal scalar type. "),(0,i.kt)("p",null,"The rules for the evaluation of static expressions are revised to require exact evaluation at compile time, and force a machine number result when crossing from the static realm to the dynamic realm, to enhance portability and predictability. Exact evaluation is not required for descendants of a formal scalar type, to simplify generic code sharing and to avoid generic contract model problems."),(0,i.kt)("p",null,"Static expressions are legal even if an intermediate in the expression goes outside the base range of the type. Therefore, the following will succeed in Ada 95, whereas it might raise an exception in Ada 83: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Short_Int is range -32_768 .. 32_767;\nI : Short_Int := -32_768;\n\n")),(0,i.kt)("p",null,'This might raise an exception in Ada 83 because "32_768" is out of range, even though "32_768" is not. In Ada 95, this will always succeed.'),(0,i.kt)("p",null,"Certain expressions involving string operations (in particular concatenation and membership tests) are considered static in Ada 95."),(0,i.kt)("p",null,"The reason for this change is to simplify the rule requiring compile-time-known string expressions as the link name in an interfacing pragma, and to simplify the preelaborability rules. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"An Ada 83 program that uses an out-of-range static value is illegal in Ada 95, unless the expression is part of a larger static expression, or the expression is not evaluated due to being on the right-hand side of a short-circuit control form. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'{AI05-0299-1} This subclause (and 4.5.5, "Multiplying Operators") subsumes the RM83 section on Universal Expressions.'),(0,i.kt)("p",null,'The existence of static string expressions necessitated changing the definition of static subtype to include string subtypes. Most occurrences of "static subtype" have been changed to "static scalar subtype", in order to preserve the effect of the Ada 83 rules. This has the added benefit of clarifying the difference between "static subtype" and "statically constrained subtype", which has been a source of confusion. In cases where we allow static string subtypes, we explicitly use phrases like "static string subtype" or "static (scalar or string) subtype", in order to clarify the meaning for those who have gotten used to the Ada 83 terminology.'),(0,i.kt)("p",null,"In Ada 83, an expression was considered nonstatic if it raised an exception. Thus, for example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Bad: constant := 1/0; -- Illegal!\n\n")),(0,i.kt)("p",null,"was illegal because 1/0 was not static. In Ada 95, the above example is still illegal, but for a different reason: 1/0 is static, but there's a separate rule forbidding the exception raising."),(0,i.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,i.kt)("p",null,"{AI95-00268-01} Amendment Correction: Rounding of static real expressions is implementation-defined in Ada 2005, while it was specified as away from zero in (original) Ada 95. This could make subtle differences in programs. However, the original Ada 95 rule required rounding that (probably) differed from the target processor, thus creating anomalies where the value of a static expression was required to be different than the same expression evaluated at run time. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00263-01} {AI95-00268-01} The Ada 95 wording that defined static subtypes unintentionally failed to exclude formal derived types that happen to be scalar (these aren't formal scalar types); and had a parenthetical remark excluding formal string types - but that was neither necessary nor parenthetical (it didn't follow from other wording). This issue also applies to the rounding rules for real static expressions."),(0,i.kt)("p",null,"{AI95-00269-01} Ada 95 didn't clearly define the bounds of a value of a static expression for universal types and for \"any integer/float/fixed type\". We also make it clear that we do not intend exact evaluation of static expressions in an instance body if the expressions aren't static in the generic body."),(0,i.kt)("p",null,"{AI95-00311-01} We clarify that the first subtype of a scalar formal type has a nonstatic, nonnull constraint. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0147-1} {AI05-0188-1} Added wording to define staticness and the lack of evaluation for ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0149"},"if_expression"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0151"},"case_expression"),"s. These are new and defined elsewhere."),(0,i.kt)("p",null,"{AI05-0153-3} Added wording to prevent subtypes that have dynamic predicates (see 3.2.4) from being static."),(0,i.kt)("p",null,"{AI05-0158-1} Revised wording for membership tests to allow for the new possibilities allowed by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0136"},"membership_choice_list"),". "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2012"},"Incompatibilities With Ada 2012"),(0,i.kt)("p",null,"{AI12-0201-1} Added a missing exclusion for concatenations of a string type descended from a formal array type. This could potentially make some expression non-static; but as that could only matter in a context where a static string is required (such as the Link_Name aspect), it is quite unlikely."),(0,i.kt)("p",null,"{AI12-0385-1} Shifting and rotating functions declared in package Interfaces are now static. This could potentially make some expression illegal that is legal if nonstatic (as in Ada 2012). While this can happen especially in conditional code that is not in use, it is quite unlikely given typical uses of shifting or rotating functions. "),(0,i.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0201-1} Expressions involving string relational operators or string type conversions now can be static. Additionally, the length limit on static string constants was removed as being a hazard without much help to implementations. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0064-2} Defined the staticness of the Nonblocking attribute (see 9.5)."),(0,i.kt)("p",null,"{AI12-0075-1} Expression functions can be static if declared correctly; this is documented as an extension in 6.8."),(0,i.kt)("p",null,"{AI12-0249-1} {AI12-0394-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal")," or named number can be non-static if they interpreted using an Integer_Literal or Real_Literal aspect (see 4.2.1)."),(0,i.kt)("p",null,"{AI12-0322-1} Clarified that a target name symbol can statically denote an entity if the associated variable_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," statically denotes an entity. This is necessary so that target names participate in the anti-order-dependence checks of 6.4.1."),(0,i.kt)("p",null,"{AI12-0368-1} {AI12-0373-1} Added wording to define staticness for ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.5#S0156"},"declare_expression"),'s. Also moved "statically names" definition here and used it in array attribute prefix wording.'),(0,i.kt)("p",null,"{AI12-0393-1} Correction: Clarified that constants whose values do not belong to their nominal subtype are not static. This change potentially would be incompatible, but this case is considered pathological and will not be checked by the ACATS. "),(0,i.kt)("h2",{id:"491--statically-matching-constraints-and-subtypes"},"4.9.1  Statically Matching Constraints and Subtypes"),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"{AI95-00311-01} A constraint statically matches another constraint if: "),(0,i.kt)("p",null,"both are null constraints;"),(0,i.kt)("p",null,"Discussion: A null constraint has nothing to do with null exclusions! Unconstrained array subtypes, subtypes with unknown discriminants, and subtypes with no explicit constraint have null constraints (see 3.2). This terminology became confusing when null exclusions were introduced in the 2007 Amendment. "),(0,i.kt)("p",null,"both are static and have equal corresponding bounds or discriminant values;"),(0,i.kt)("p",null,"both are nonstatic and result from the same elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or the same evaluation of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"; or"),(0,i.kt)("p",null,"{AI95-00311-01} both are nonstatic and come from the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-12.5#S0320"},"formal_type_declaration"),". "),(0,i.kt)("p",null,"{AI12-0374-2} {AI12-0427-1} The Global or Global'Class aspects (see 6.1.2) of two entities statically match if both consist of a single ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0209"},"global_aspect_definition"),' where each is the reserved word null, or each is of the form "',(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0211"},"global_mode")," ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0214"},"global_designator"),'" with each ',(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0211"},"global_mode")," being the same sequence of reserved words and each ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0214"},"global_designator")," being the same reserved word, or each being a ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0215"},"global_name")," that statically names the same entity."),(0,i.kt)("p",null,"{AI95-00231-01} {AI95-00254-01} {AI05-0153-3} {AI12-0059-1} {AI12-0374-2} A subtype statically matches another subtype of the same type if they have statically matching constraints, all predicate specifications that apply to them come from the same declarations, Nonblocking aspects have the same value, global aspects statically match, Object_Size (see 13.3) has been specified to have a nonconfirming value for either both or neither, and the nonconfirming values, if any, are the same, and, for access subtypes, either both or neither exclude null. Two anonymous access-to-object subtypes statically match if their designated subtypes statically match, and either both or neither exclude null, and either both or neither are access-to-constant. Two anonymous access-to-subprogram subtypes statically match if their designated profiles are subtype conformant, and either both or neither exclude null. "),(0,i.kt)("p",null,"Ramification: Statically matching constraints and subtypes are the basis for subtype conformance of profiles (see 6.3.1). "),(0,i.kt)("p",null,"Reason: Even though anonymous access types always represent different types, they can statically match. That's important so that they can be used widely. For instance, if this wasn't true, access parameters and access discriminants could never conform, so they couldn't be used in separate specifications. "),(0,i.kt)("p",null,"Ramification: {AI12-0059-1} If one of the subtypes is not yet frozen, an implementation may have to repeat the check when the subtypes are both frozen (as it is impossible to check the Object_Size part before the subtypes are frozen). This recheck can only make a previously statically matching subtype fail to match; it cannot make a match legal. "),(0,i.kt)("p",null,'Discussion: {AI12-0059-1} We exclude the case where both Object_Sizes are confirming so that we don\'t introduce an incompatibility for existing Ada code. But practically the implementation can simply check that the Object_Size values are the same, as we have a rule in 13.1 that the subtype-specific aspects (such as Object_Size) are always the same for statically matching subtypes. We wrote the rules this way to avoid having wording that appeared to require predicting the future ("would statically match if ..."). '),(0,i.kt)("p",null,"Two ranges of the same type statically match if both result from the same evaluation of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),", or if both are static and have equal corresponding bounds. "),(0,i.kt)("p",null,'Ramification: The notion of static matching of ranges is used in 12.5.3, "Formal Array Types"; the index ranges of formal and actual constrained array subtypes have to statically match. '),(0,i.kt)("p",null,"{AI05-0086-1} {AI05-0153-3} A constraint is statically compatible with a scalar subtype if it statically matches the constraint of the subtype, or if both are static and the constraint is compatible with the subtype. A constraint is statically compatible with an access or composite subtype if it statically matches the constraint of the subtype, or if the subtype is unconstrained. "),(0,i.kt)("p",null,"Discussion: Static compatibility is required when constraining a parent subtype with a discriminant from a new ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.7#S0059"},"discriminant_part"),". See 3.7. Static compatibility is also used in matching generic formal derived types."),(0,i.kt)("p",null,"Note that statically compatible with a subtype does not imply compatible with a type. It is OK since the terms are used in different contexts. "),(0,i.kt)("p",null,"{AI05-0153-3} Two statically matching subtypes are statically compatible with each other. In addition, a subtype S1 is statically compatible with a subtype S2 if: "),(0,i.kt)("p",null,"the constraint of S1 is statically compatible with S2, and"),(0,i.kt)("p",null,"{AI05-0086-1} if S2 excludes null, so does S1, and"),(0,i.kt)("p",null,"either: "),(0,i.kt)("p",null,"all predicate specifications that apply to S2 apply also to S1, or"),(0,i.kt)("p",null,"{AI05-0290-1} {AI12-0071-1} both subtypes are static, every value that satisfies the predicates of S1 also satisfies the predicates of S2, and it is not the case that both types each have at least one applicable predicate specification, predicate checks are enabled (see 11.4.2) for S2, and predicate checks are not enabled for S1. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"This subclause is new to Ada 95. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00231-01} {AI95-00254-01} Added static matching rules for null exclusions and anonymous access-to-subprogram types; both of these are new."),(0,i.kt)("p",null,"{AI95-00311-01} We clarify that the constraint of the first subtype of a scalar formal type statically matches itself. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,i.kt)("p",null,"{AI05-0086-1} Correction: Updated the statically compatible rules to take null exclusions into account. This is technically incompatible, as it could cause a legal Ada 2005 program to be rejected; however, such a program violates the intent of the rules (for instance, 3.7(15)) and this probably will simply detect bugs. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005-1"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0153-3} {AI05-0290-1} Modified static matching and static compatibility to take predicate aspects (see 3.2.4) into account. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012-1"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,'{AI12-0071-1} Corrigendum: Updated wording of static compatibility to use the new term "satisfies the predicates" (see 3.2.4).'),(0,i.kt)("p",null,"{AI12-0059-1} Updated wording to take nonconfirming values of Object_Size into account."),(0,i.kt)("p",null,"{AI12-0374-2} Static matching now includes the effects of Global aspects and the Nonblocking aspect."))}h.isMDXComponent=!0}}]);