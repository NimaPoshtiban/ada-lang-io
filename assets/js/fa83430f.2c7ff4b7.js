"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8818],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(6687);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(a),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2452:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(9440),r=(a(6687),a(1716));const o={sidebar_position:7},i="6 Subprograms",s={unversionedId:"arm/AA-6",id:"arm/AA-6",title:"6 Subprograms",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-6.md",sourceDirName:"arm",slug:"/arm/AA-6",permalink:"/docs/arm/AA-6",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"5 Statements",permalink:"/docs/arm/AA-5"},next:{title:"7 Packages",permalink:"/docs/arm/AA-7"}},l={},c=[{value:"6.1  Subprogram Declarations",id:"61--subprogram-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"6.2  Formal Parameter Modes",id:"62--formal-parameter-modes",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"6.3  Subprogram Bodies",id:"63--subprogram-bodies",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"6.3.1  Conformance Rules",id:"631--conformance-rules",level:3},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"6.3.2  Inline Expansion of Subprograms",id:"632--inline-expansion-of-subprograms",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"6.4  Subprogram Calls",id:"64--subprogram-calls",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"6.4.1  Parameter Associations",id:"641--parameter-associations",level:3},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-5",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"6.5  Return Statements",id:"65--return-statements",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"Syntax",id:"syntax-5",level:4},{value:"6.6  Overloading of Operators",id:"66--overloading-of-operators",level:2},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-6",level:4}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"6-subprograms"},"6 Subprograms"),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,r.kt)("p",null,"A subprogram is a program unit or intrinsic operation whose execution is invoked by a subprogram call. There are two forms of subprogram: procedures and functions. A procedure call is a statement; a function call is an expression and returns a value. The definition of a subprogram can be given in two parts: a subprogram declaration defining its interface, and a subprogram_body defining its execution. ","[Operators and enumeration literals are functions.]"," "),(0,r.kt)("p",null,"To be honest: A function call is an expression, but more specifically it is a name. "),(0,r.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[subprogram]",", Def=","[a unit of a program that can be brought into execution in various contexts, with the invocation being a subprogram call that can parameterize the effect of the subprogram through the passing of operands]",", Note1=","[There are two forms of subprograms: functions, which return values, and procedures, which do not.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[function]",", Def=","[a form of subprogram that returns a result and can be called as part of an expression]"," Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[procedure]",", Def=","[a form of subprogram that does not return a result and can only be invoked by a statement]"),(0,r.kt)("p",null,"A callable entity is a subprogram or entry (see 9.5.2). A callable entity is invoked by a call; that is, a subprogram call or entry call. A callable construct is a construct that defines the action of a call upon a callable entity: a subprogram_body, entry_body, or accept_statement. "),(0,r.kt)("p",null,'Ramification: Note that "callable entity" includes predefined operators, enumeration literals, and abstract subprograms. "Call" includes calls of these things. They do not have callable constructs, since they don\'t have completions. '),(0,r.kt)("h2",{id:"61--subprogram-declarations"},"6.1  Subprogram Declarations"),(0,r.kt)("p",null,"[A subprogram_declaration declares a procedure or function.]"," "),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"subprogram_declaration ::= subprogram_specification;"),(0,r.kt)("p",null,"abstract_subprogram_declaration ::= subprogram_specification is abstract;"),(0,r.kt)("p",null,"subprogram_specification ::=\nprocedure defining_program_unit_name parameter_profile\n| function defining_designator parameter_and_result_profile"),(0,r.kt)("p",null,"designator ::= ","[parent_unit_name . ]","identifier | operator_symbol"),(0,r.kt)("p",null,"defining_designator ::= defining_program_unit_name | defining_operator_symbol"),(0,r.kt)("p",null,"defining_program_unit_name ::= ","[parent_unit_name . ]","defining_identifier"),(0,r.kt)("p",null,"[The optional parent_unit_name is only allowed for library units (see 10.1.1).]"," "),(0,r.kt)("p",null,"operator_symbol ::= string_literal"),(0,r.kt)("p",null,"The sequence of characters in an operator_symbol shall correspond to an operator belonging to one of the six classes of operators defined in clause 4.5(spaces are not allowed and the case of letters is not significant)."),(0,r.kt)("p",null,"defining_operator_symbol ::= operator_symbol"),(0,r.kt)("p",null,"parameter_profile ::= ","[formal_part]"),(0,r.kt)("p",null,"parameter_and_result_profile ::= ","[formal_part]"," return subtype_mark"),(0,r.kt)("p",null,"formal_part ::=\n(parameter_specification {; parameter_specification})"),(0,r.kt)("p",null,"parameter_specification ::=\ndefining_identifier_list : mode  subtype_mark ","[:= default_expression]","\n| defining_identifier_list : access_definition ","[:= default_expression]"),(0,r.kt)("p",null,"mode ::= ","[in]"," | in out | out"),(0,r.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,r.kt)("p",null,"A formal parameter is an object ","[directly visible within a subprogram_body]"," that represents the actual parameter passed to the subprogram in a call; it is declared by a parameter_specification. For a formal parameter, the expected type for its default_expression, if any, is that of the formal parameter. "),(0,r.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,r.kt)("p",null,"The parameter mode of a formal parameter conveys the direction of information transfer with the actual parameter: in, in out, or out. Mode in is the default, and is the mode of a parameter defined by an access_definition. The formal parameters of a function, if any, shall have the mode in. "),(0,r.kt)("p",null,"Ramification: Access parameters are permitted. This restriction to in parameters is primarily a methodological restriction, though it also simplifies implementation for some compiler technologies. "),(0,r.kt)("p",null,"A default_expression is only allowed in a parameter_specification for a formal parameter of mode in."),(0,r.kt)("p",null,"A subprogram_declaration or a generic_subprogram_declaration requires a completion: ","[a body, a renaming_declaration (see 8.5), or a pragma Import (see B.1)]",". ","[A completion is not allowed for an abstract_subprogram_declaration.]"," "),(0,r.kt)("p",null,"Ramification: Abstract subprograms are not declared by subprogram_declarations, and so do not require completion. Protected subprograms are declared by subprogram_declarations, and so require completion. Note that an abstract subprogram is a subprogram, and a protected subprogram is a subprogram, but a generic subprogram is not a subprogram. "),(0,r.kt)("p",null,"A name that denotes a formal parameter is not allowed within the formal_part in which it is declared, nor within the formal_part of a corresponding body or accept_statement. "),(0,r.kt)("p",null,"Ramification: By contrast, generic_formal_parameter_declarations are visible to subsequent declarations in the same generic_formal_part. "),(0,r.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,r.kt)("p",null,"The profile of (a view of) a callable entity is either a parameter_profile or parameter_and_result_profile","[; it embodies information about the interface to that entity - for example, the profile includes information about parameters passed to the callable entity. All callable entities have a profile - enumeration literals, other subprograms, and entries. An access-to-subprogram type has a designated profile.]"," Associated with a profile is a calling convention. A subprogram_declaration declares a procedure or a function, as indicated by the initial reserved word, with name and profile as given by its specification."),(0,r.kt)("p",null,"The nominal subtype of a formal parameter is the subtype denoted by the subtype_mark, or defined by the access_definition, in the parameter_specification."),(0,r.kt)("p",null,"An access parameter is a formal in parameter specified by an access_definition. An access parameter is of an anonymous general access-to-variable type (see 3.10). ","[Access parameters  allow dispatching calls to be controlled by access values.]"),(0,r.kt)("p",null,"The subtypes of a profile are: "),(0,r.kt)("p",null,"For any non-access parameters, the nominal subtype of the parameter."),(0,r.kt)("p",null,"For any access parameters, the designated subtype of the parameter type."),(0,r.kt)("p",null,"For any result, the result subtype."),(0,r.kt)("p",null,"[ The types of a profile are the types of those subtypes.]"),(0,r.kt)("p",null,'[A subprogram declared by an abstract_subprogram_declaration is abstract; a subprogram declared by a subprogram_declaration is not. See 3.9.3, "Abstract Types and Subprograms".]'),(0,r.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,r.kt)("p",null,"The elaboration of a subprogram_declaration or an abstract_subprogram_declaration has no effect. "),(0,r.kt)("p",null,"NOTE 1   A parameter_specification with several identifiers is equivalent to a sequence of single parameter_specifications, as explained in 3.3."),(0,r.kt)("p",null,'NOTE 2   Abstract subprograms do not have bodies, and cannot be used in a nondispatching call (see 3.9.3, "Abstract Types and Subprograms").'),(0,r.kt)("p",null,"NOTE 3   The evaluation of default_expressions is caused by certain calls, as described in 6.4.1. They are not evaluated during the elaboration of the subprogram declaration."),(0,r.kt)("p",null,"NOTE 4   Subprograms can be called recursively and can be called concurrently from multiple tasks. "),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Examples of subprogram declarations: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Traverse_Tree;\nprocedure Increment(X : in out Integer);\nprocedure Right_Indent(Margin : out Line_Size);          --  see 3.5.4\nprocedure Switch(From, To : in out Link);                --  see 3.10.1\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"function Random return Probability;                      --  see 3.5.7\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"function Min_Cell(X : Link) return Cell;                 --  see 3.10.1\nfunction Next_Frame(K : Positive) return Frame;          --  see 3.10\nfunction Dot_Product(Left, Right : Vector) return Real;  --  see 3.6\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},'function "*"(Left, Right : Matrix) return Matrix;        --  see 3.6\n\n')),(0,r.kt)("p",null,"Examples of in parameters with default expressions: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Print_Header(Pages  : in Natural;\n            Header : in Line    :=  (1 .. Line'Last =&gt ' ');  --  see 3.6\n            Center : in Boolean := True);\n\n")),(0,r.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,r.kt)("p",null,"The syntax for abstract_subprogram_declaration is added. The syntax for parameter_specification is revised to allow for access parameters (see 3.10)"),(0,r.kt)("p",null,"Program units that are library units may have a parent_unit_name to indicate the parent of a child (see Section 10). "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,'We have incorporated the rules from RM83-6.5, "Function Subprograms" here and in 6.3, "Subprogram Bodies"'),(0,r.kt)("p",null,'We have incorporated the definitions of RM83-6.6, "Parameter and Result Type Profile - Overloading of Subprograms" here.'),(0,r.kt)("p",null,"The syntax rule for defining_operator_symbol is new. It is used for the defining occurrence of an operator_symbol, analogously to defining_identifier. Usage occurrences use the direct_name or selector_name syntactic categories. The syntax rules for defining_designator and defining_program_unit_name are new. "),(0,r.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[precondition]",", Def=","[an assertion that is expected to be True when a given subprogram is called]"," Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[postcondition]",", Def=","[an assertion that is expected to be True when a given subprogram returns normally]"," "),(0,r.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,r.kt)("h2",{id:"62--formal-parameter-modes"},"6.2  Formal Parameter Modes"),(0,r.kt)("p",null,"[A parameter_specification declares a formal parameter of mode in, in out, or out.]"," "),(0,r.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,r.kt)("p",null,"A parameter is passed either by copy or by reference. ","[When a parameter is passed by copy, the formal parameter denotes a separate object from the actual parameter, and any information transfer between the two occurs only before and after executing the subprogram. When a parameter is passed by reference, the formal parameter denotes (a view of) the object denoted by the actual parameter; reads and updates of the formal parameter directly reference the actual parameter object.]"),(0,r.kt)("p",null,"A type is a by-copy type if it is an elementary type, or if it is a descendant of a private type whose full type is a by-copy type. A parameter of a by-copy type is passed by copy."),(0,r.kt)("p",null,"A type is a by-reference type if it is a descendant of one of the following: "),(0,r.kt)("p",null,"a tagged type;"),(0,r.kt)("p",null,"a task or protected type;"),(0,r.kt)("p",null,"a nonprivate type with the reserved word limited in its declaration; "),(0,r.kt)("p",null,"Ramification: A limited private type is by-reference only if it falls under one of the other categories. "),(0,r.kt)("p",null,"a composite type with a subcomponent of a by-reference type;"),(0,r.kt)("p",null,"a private type whose full type is a by-reference type. "),(0,r.kt)("p",null,"A parameter of a by-reference type is passed by reference. Each value of a by-reference type has an associated object. For a parenthesized expression, qualified_expression, or type_conversion, this object is the one associated with the operand."),(0,r.kt)("p",null,"Ramification: By-reference parameter passing makes sense only if there is an object to reference; hence, we define such an object for each case."),(0,r.kt)("p",null,"Since tagged types are by-reference types, this implies that every value of a tagged type has an associated object. This simplifies things, because we can define the tag to be a property of the object, and not of the value of the object, which makes it clearer that object tags never change."),(0,r.kt)("p",null,"We considered simplifying things even more by making every value (and therefore every expression) have an associated object. After all, there is little semantic difference between a constant object and a value. However, this would cause problems for untagged types. In particular, we would have to do a constraint check on every read of a type conversion (or a renaming thereof) in certain cases."),(0,r.kt)("p",null,"We do not want this definition to depend on the view of the type; privateness is essentially ignored for this definition. Otherwise, things would be confusing (does the rule apply at the call site, at the site of the declaration of the subprogram, at the site of the return_statement?), and requiring different calls to use different mechanisms would be an implementation burden."),(0,r.kt)("p",null,'C.6, "Shared Variable Control" says that a composite type with an atomic or volatile subcomponent is a by-reference type, among other things.'),(0,r.kt)("p",null,"Every value of a limited by-reference type is the value of one and only one limited object. The associated object of a value of a limited by-reference type is the object whose value it represents. Two values of a limited by-reference type are the same if and only if they represent the value of the same object."),(0,r.kt)("p",null,'We say "by-reference" above because these statements are not always true for limited private types whose underlying type is nonlimited (unfortunately). '),(0,r.kt)("p",null,"For parameters of other types, it is unspecified whether the parameter is passed by copy or by reference. "),(0,r.kt)("p",null,"Discussion: There is no need to incorporate the discussion of AI83-00178, which requires pass-by-copy for certain kinds of actual parameters, while allowing pass-by-reference for others. This is because we explicitly indicate that a function creates an anonymous constant object for its result, unless the type is a return-by-reference type (see 6.5). We also provide a special dispensation for instances of Unchecked_Conversion to return by reference, even if the result type is not a return-by-reference type (see 13.9). "),(0,r.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,r.kt)("p",null,"If one name denotes a part of a formal parameter, and a second name denotes a part of a distinct formal parameter or an object that is not part of a formal parameter, then the two names are considered distinct access paths. If an object is of a type for which the parameter passing mechanism is not specified, then it is a bounded error to assign to the object via one access path, and then read the value of the object via a distinct access path, unless the first access path denotes a part of a formal parameter that no longer exists at the point of the second access ","[(due to leaving the corresponding callable construct).]"," The possible consequences are that Program_Error is raised, or the newly assigned value is read, or some old value of the object is read. "),(0,r.kt)("p",null,'Discussion: For example, if we call "P(X =',">"," Global_Variable, Y =",">",' Global_Variable)", then within P, the names "X", "Y", and "Global_Variable" are all distinct access paths. If Global_Variable\'s type is neither pass-by-copy nor pass-by-reference, then it is a bounded error to assign to Global_Variable and then read X or Y, since the language does not specify whether the old or the new value would be read. On the other hand, if Global_Variable\'s type is pass-by-copy, then the old value would always be read, and there is no error. Similarly, if Global_Variable\'s type is defined by the language to be pass-by-reference, then the new value would always be read, and again there is no error. '),(0,r.kt)("p",null,"Reason: We are saying assign here, not update, because updating any subcomponent is considered to update the enclosing object."),(0,r.kt)("p",null,'The "still exists" part is so that a read after the subprogram returns is OK.'),(0,r.kt)("p",null,"If the parameter is of a by-copy type, then there is no issue here - the formal is not a view of the actual. If the parameter is of a by-reference type, then the programmer may depend on updates through one access path being visible through some other access path, just as if the parameter were of an access type. "),(0,r.kt)("p",null,'Implementation Note: The implementation can keep a copy in a register of a parameter whose parameter-passing mechanism is not specified. If a different access path is used to update the object (creating a bounded error situation), then the implementation can still use the value of the register, even though the in-memory version of the object has been changed. However, to keep the error properly bounded, if the implementation chooses to read the in-memory version, it has to be consistent -- it cannot then assume that something it has proven about the register is true of the memory location. For example, suppose the formal parameter is L, the value of L(6) is now in a register, and L(6) is used in an indexed_component as in "A(L(6)) := 99;", where A has bounds 1..3. If the implementation can prove that the value for L(6) in the register is in the range 1..3, then it need not perform the constraint check if it uses the register value. However, if the memory value of L(6) has been changed to 4, and the implementation uses that memory value, then it had better not alter memory outside of A.'),(0,r.kt)("p",null,"Note that the rule allows the implementation to pass a parameter by reference and then keep just part of it in a register, or, equivalently, to pass part of the parameter by reference and another part by copy. "),(0,r.kt)("p",null,"Reason: We do not want to go so far as to say that the mere presence of aliasing is wrong. We wish to be able to write the following sorts of things in standard Ada: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Move ( Source  : in  String;\n                 Target  : out String;\n                 Drop    : in  Truncation := Error;\n                 Justify : in  Alignment  := Left;\n                 Pad     : in  Character  := Space);\n-- Copies elements from Source to Target (safely if they overlap)\n\n")),(0,r.kt)("p",null,"This is from the standard string handling package. It would be embarrassing if this couldn't be written in Ada!"),(0,r.kt)("p",null,'The "then" before "read" in the rule implies that the implementation can move a read to an earlier place in the code, but not to a later place after a potentially aliased assignment. Thus, if the subprogram reads one of its parameters into a local variable, and then updates another potentially aliased one, the local copy is safe - it is known to have the old value. For example, the above-mentioned Move subprogram can be implemented by copying Source into a local variable before assigning into Target.'),(0,r.kt)("p",null,"For an assignment_statement assigning one array parameter to another, the implementation has to check which direction to copy at run time, in general, in case the actual parameters are overlapping slices. For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Copy(X : in out String; Y: String) is\nbegin\n    X := Y;\nend Copy;\n\n")),(0,r.kt)("p",null,"It would be wrong for the compiler to assume that X and Y do not overlap (unless, of course, it can prove otherwise). "),(0,r.kt)("p",null,"NOTE 1   A formal parameter of mode in is a constant view (see 3.3); it cannot be updated within the subprogram_body."),(0,r.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,r.kt)("p",null,"The value of an out parameter may be read. An out parameter is treated like a declared variable without an explicit initial expression. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,'Discussion of copy-in for parts of out parameters is now covered in 6.4.1, "Parameter Associations".'),(0,r.kt)("p",null,"The concept of a by-reference type is new to Ada 95."),(0,r.kt)("p",null,"We now cover in a general way in 3.7.2 the rule regarding erroneous execution when a discriminant is changed and one of the parameters depends on the discriminant. "),(0,r.kt)("h2",{id:"63--subprogram-bodies"},"6.3  Subprogram Bodies"),(0,r.kt)("p",null,"[A subprogram_body specifies the execution of a subprogram.]"," "),(0,r.kt)("h4",{id:"syntax-1"},"Syntax"),(0,r.kt)("p",null,"subprogram_body ::=\nsubprogram_specification is\ndeclarative_part\nbegin\nhandled_sequence_of_statements\nend ","[designator]",";"),(0,r.kt)("p",null,"If a designator appears at the end of a subprogram_body, it shall repeat the defining_designator of the subprogram_specification. "),(0,r.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,r.kt)("p",null,"[In contrast to other bodies,]"," a subprogram_body need not be the completion of a previous declaration","[, in which case the body declares the subprogram]",". If the body is a completion, it shall be the completion of a subprogram_declaration or generic_subprogram_declaration. The profile of a subprogram_body that completes a declaration shall conform fully to that of the declaration. "),(0,r.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,r.kt)("p",null,"A subprogram_body is considered a declaration. It can either complete a previous declaration, or itself be the initial declaration of the subprogram. "),(0,r.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,r.kt)("p",null,"The elaboration of a nongeneric subprogram_body has no other effect than to establish that the subprogram can from then on be called without failing the Elaboration_Check. "),(0,r.kt)("p",null,"Ramification: See 12.2 for elaboration of a generic body. Note that protected subprogram_bodies never get elaborated; the elaboration of the containing protected_body allows them to be called without failing the Elaboration_Check. "),(0,r.kt)("p",null,"[The execution of a subprogram_body is invoked by a subprogram call.]"," For this execution the declarative_part is elaborated, and the handled_sequence_of_statements is then executed. "),(0,r.kt)("h4",{id:"examples-1"},"Examples"),(0,r.kt)("p",null,"Example of procedure body: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Push(E : in Element_Type; S : in out Stack) is\nbegin\n   if S.Index = S.Size then\n      raise Stack_Overflow;\n   else\n      S.Index := S.Index + 1;\n      S.Space(S.Index) := E;\n   end if;\nend Push;\n\n")),(0,r.kt)("p",null,"Example of a function body: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"function Dot_Product(Left, Right : Vector) return Real is\n   Sum : Real := 0.0;\nbegin\n   Check(Left'First = Right'First and Left'Last = Right'Last);\n   for J in Left'Range loop\n      Sum := Sum + Left(J)*Right(J);\n   end loop;\n   return Sum;\nend Dot_Product;\n\n")),(0,r.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,r.kt)("p",null,"A renaming_declaration may be used instead of a subprogram_body. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"The syntax rule for subprogram_body now uses the syntactic category handled_sequence_of_statements."),(0,r.kt)("p",null,"The declarative_part of a subprogram_body is now required; that doesn't make any real difference, because a declarative_part can be empty."),(0,r.kt)("p",null,"We have incorporated some rules from RM83-6.5 here."),(0,r.kt)("p",null,"RM83 forgot to restrict the definition of elaboration of a subprogram_body to nongenerics. "),(0,r.kt)("h3",{id:"631--conformance-rules"},"6.3.1  Conformance Rules"),(0,r.kt)("p",null,"[When subprogram profiles are given in more than one place, they are required to conform in one of four ways: type conformance, mode conformance, subtype conformance, or full conformance.]"," "),(0,r.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,r.kt)("p",null,'[As explained in B.1, "Interfacing Pragmas", a convention can be specified for an entity.][For a callable entity or access-to-subprogram type, the convention is called the calling convention.]'," The following conventions are defined by the language: "),(0,r.kt)("p",null,"The default calling convention for any subprogram not listed below is Ada. ","[A pragma Convention, Import, or Export may be used to override the default calling convention (see B.1)]",". "),(0,r.kt)("p",null,"Ramification: See also the rule about renamings-as-body in 8.5.4. "),(0,r.kt)("p",null,'The Intrinsic calling convention represents subprograms that are "built in" to the compiler. The default calling convention is Intrinsic for the following: '),(0,r.kt)("p",null,"an enumeration literal;"),(0,r.kt)("p",null,'a "/=" operator declared implicitly due to the declaration of "=" (see 6.6);'),(0,r.kt)("p",null,"any other implicitly declared subprogram unless it is a dispatching operation of a tagged type;"),(0,r.kt)("p",null,"an inherited subprogram of a generic formal tagged type with unknown discriminants; "),(0,r.kt)("p",null,"an attribute that is a subprogram;"),(0,r.kt)("p",null,"a subprogram declared immediately within a protected_body."),(0,r.kt)("p",null,"[The Access attribute is not allowed for Intrinsic subprograms.]"," "),(0,r.kt)("p",null,"Ramification: The Intrinsic calling convention really represents any number of calling conventions at the machine code level; the compiler might have a different instruction sequence for each intrinsic. That's why the Access attribute is disallowed. We do not wish to require the implementation to generate an out of line body for an intrinsic."),(0,r.kt)("p",null,'Whenever we wish to disallow the Access attribute in order to ease implementation, we make the subprogram Intrinsic. Several language-defined subprograms have "pragma Convention(Intrinsic, ...);". An implementation might actually implement this as "pragma Import(Intrinsic, ...);", if there is really no body, and the implementation of the subprogram is built into the code generator.'),(0,r.kt)("p",null,'Subprograms declared in protected_bodies will generally have a special calling convention so as to pass along the identification of the current instance of the protected type. The convention is not protected since such local subprograms need not contain any "locking" logic since they are not callable via "external" calls; this rule prevents an access value designating such a subprogram from being passed outside the protected unit.'),(0,r.kt)("p",null,'The "implicitly declared subprogram" above refers to predefined operators (other than the "=" of a tagged type) and the inherited subprograms of untagged types. '),(0,r.kt)("p",null,"The default calling convention is protected for a protected subprogram, and for an access-to-subprogram type with the reserved word protected in its definition."),(0,r.kt)("p",null,"The default calling convention is entry for an entry."),(0,r.kt)("p",null,"Of these four conventions, only Ada and Intrinsic are allowed as a convention_identifier in a pragma Convention, Import, or Export. "),(0,r.kt)("p",null,"Discussion: The names of the protected and entry calling conventions cannot be used in the interfacing pragmas. Note that protected and entry are reserved words. "),(0,r.kt)("p",null,"Two profiles are type conformant if they have the same number of parameters, and both have a result if either does, and corresponding parameter and result types are the same, or, for access parameters, corresponding designated types are the same. "),(0,r.kt)("p",null,"Discussion: For access parameters, the designated types have to be the same for type conformance, not the access types, since in general each access parameter has its own anonymous access type, created when the subprogram is called. Of course, corresponding parameters have to be either both access parameters or both not access parameters."),(0,r.kt)("p",null,"Two profiles are mode conformant if they are type-conformant, and corresponding parameters have identical modes, and, for access parameters, the designated subtypes statically match "),(0,r.kt)("p",null,"Two profiles are subtype conformant if they are mode-conformant, corresponding subtypes of the profile statically match, and the associated calling conventions are the same. The profile of a generic formal subprogram is not subtype-conformant with any other profile. "),(0,r.kt)("p",null,"Ramification: "),(0,r.kt)("p",null,"Two profiles are fully conformant if they are subtype-conformant, and corresponding parameters have the same names and have default_expressions that are fully conformant with one another. "),(0,r.kt)("p",null,"Ramification: Full conformance requires subtype conformance, which requires the same calling conventions. However, the calling convention of the declaration and body of a subprogram or entry are always the same by definition. "),(0,r.kt)("p",null,"Two expressions are fully conformant if, ","[after replacing each use of an operator with the equivalent function_call:]"," "),(0,r.kt)("p",null,"each constituent construct of one corresponds to an instance of the same syntactic category in the other, except that an expanded name may correspond to a direct_name (or character_literal) or to a different expanded name in the other; and"),(0,r.kt)("p",null,"each direct_name, character_literal, and selector_name that is not part of the prefix of an expanded name in one denotes the same declaration as the corresponding direct_name, character_literal, or selector_name in the other; and "),(0,r.kt)("p",null,'Ramification: Note that it doesn\'t say "respectively" because a direct_name can correspond to a selector_name, and vice-versa, by the previous bullet. This rule allows the prefix of an expanded name to be removed, or replaced with a different prefix that denotes a renaming of the same entity. However, it does not allow a direct_name or selector_name to be replaced with one denoting a distinct renaming (except for direct_names and selector_names in prefixes of expanded names). Note that calls using operator notation are equivalent to calls using prefix notation.'),(0,r.kt)("p",null,"Given the following declarations: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package A is\n    function F(X : Integer := 1) return Boolean;\nend A;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"with A;\npackage B is\n    package A_View renames A;\n    function F_View(X : Integer := 9999) return Boolean renames F;\nend B;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"with A, B; use A, B;\nprocedure Main is ...\n\n")),(0,r.kt)("p",null,'Within Main, the expressions "F", "A.F", "B.A_View.F", and "A_View.F" are all fully conformant with one another. However, "F" and "F_View" are not fully conformant. If they were, it would be bad news, since the two denoted views have different default_expressions. '),(0,r.kt)("p",null,"each primary that is a literal in one has the same value as the corresponding literal in the other."),(0,r.kt)("p",null,"Ramification: The literals may be written differently. "),(0,r.kt)("p",null,"Ramification: Note that the above definition makes full conformance a transitive relation. "),(0,r.kt)("p",null,"Two known_discriminant_parts are fully conformant if they have the same number of discriminants, and discriminants in the same positions have the same names, statically matching subtypes, and default_expressions that are fully conformant with one another. "),(0,r.kt)("p",null,"Two discrete_subtype_definitions are fully conformant if they are both subtype_indications or are both ranges, the subtype_marks (if any) denote the same subtype, and the corresponding simple_expressions of the ranges (if any) fully conform. "),(0,r.kt)("p",null,"Ramification: In the subtype_indication case, any ranges have to be corresponding; that is, two subtype_indications cannot conform unless both or neither has a range. "),(0,r.kt)("p",null,'Discussion: This definition is used in 9.5.2, "Entries and Accept Statements" for the conformance required between the discrete_subtype_definitions of an entry_declaration for a family of entries and the corresponding entry_index_specification of the entry_body. '),(0,r.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,r.kt)("p",null,"An implementation may declare an operator declared in a language-defined library unit to be intrinsic. "),(0,r.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,r.kt)("p",null,'The rules for full conformance are relaxed - they are now based on the structure of constructs, rather than the sequence of lexical elements. This implies, for example, that "(X, Y: T)" conforms fully with "(X: T; Y: T)", and "(X: T)" conforms fully with "(X: in T)". '),(0,r.kt)("h3",{id:"632--inline-expansion-of-subprograms"},"6.3.2  Inline Expansion of Subprograms"),(0,r.kt)("p",null,"[Subprograms may be expanded in line at the call site.]"," "),(0,r.kt)("h4",{id:"syntax-2"},"Syntax"),(0,r.kt)("p",null,"The form of a pragma Inline, which is a program unit pragma (see 10.1.5), is as follows: "),(0,r.kt)("p",null,"  pragma Inline(name {, name}); "),(0,r.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,r.kt)("p",null,"The pragma shall apply to one or more callable entities or generic subprograms. "),(0,r.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,r.kt)("p",null,"If a pragma Inline applies to a callable entity, this indicates that inline expansion is desired for all calls to that entity. If a pragma Inline applies to a generic subprogram, this indicates that inline expansion is desired for all calls to all instances of that generic subprogram."),(0,r.kt)("p",null,"Ramification: Note that inline expansion is desired no matter what name is used in the call. This allows one to request inlining for only one of several overloaded subprograms as follows: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package IO is\n   procedure Put(X : in Integer);\n   procedure Put(X : in String);\n   procedure Put(X : in Character);\nprivate\n   procedure Character_Put(X : in Character) renames Put;\n   pragma Inline(Character_Put);\nend IO;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"with IO; use IO;\nprocedure Main is\n   I : Integer;\n   C : Character;\nbegin\n   ...\n   Put(C); -- Inline expansion is desired.\n   Put(I); -- Inline expansion is NOT desired.\nend Main;\n\n")),(0,r.kt)("p",null,"Ramification: The meaning of a subprogram can be changed by a pragma Inline only in the presence of failing checks (see 11.6). "),(0,r.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,r.kt)("p",null,"For each call, an implementation is free to follow or to ignore the recommendation expressed by the pragma. "),(0,r.kt)("p",null,"Ramification: Note, in particular, that the recommendation cannot always be followed for a recursive call, and is often infeasible for entries. Note also that the implementation can inline calls even when no such desire was expressed by a pragma, so long as the semantics of the program remains unchanged. "),(0,r.kt)("p",null,"NOTE 1   The name in a pragma Inline can denote more than one entity in the case of overloading. Such a pragma applies to all of the denoted entities. "),(0,r.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,r.kt)("p",null,"A pragma Inline is allowed inside a subprogram_body if there is no corresponding subprogram_declaration. This is for uniformity with other program unit pragmas. "),(0,r.kt)("h2",{id:"64--subprogram-calls"},"6.4  Subprogram Calls"),(0,r.kt)("p",null,"A subprogram call is either a procedure_call_statement or a function_call; ","[it invokes the execution of the subprogram_body. The call specifies the association of the actual parameters, if any, with formal parameters of the subprogram.]"," "),(0,r.kt)("h4",{id:"syntax-3"},"Syntax"),(0,r.kt)("p",null,"procedure_call_statement ::=\nprocedure_name;\n| procedure_prefix actual_parameter_part;"),(0,r.kt)("p",null,"function_call ::=\nfunction_name\n| function_prefix actual_parameter_part"),(0,r.kt)("p",null,"actual_parameter_part ::=\n(parameter_association {, parameter_association})"),(0,r.kt)("p",null,"parameter_association ::=\n","[formal_parameter_selector_name =",">]"," explicit_actual_parameter"),(0,r.kt)("p",null,"explicit_actual_parameter ::= expression | variable_name"),(0,r.kt)("p",null,"A parameter_association is named or positional according to whether or not the formal_parameter_selector_name is specified. Any positional associations shall precede any named associations. Named associations are not allowed if the prefix in a subprogram call is an attribute_reference. "),(0,r.kt)("p",null,"Ramification: This means that the formal parameter names used in describing predefined attributes are to aid presentation of their semantics, but are not intended for use in actual calls. "),(0,r.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,r.kt)("p",null,"The name or prefix given in a procedure_call_statement shall resolve to denote a callable entity that is a procedure, or an entry renamed as (viewed as) a procedure. The name or prefix given in a function_call shall resolve to denote a callable entity that is a function. ","[When there is an actual_parameter_part, the prefix can be an implicit_dereference of an access-to-subprogram value.]"," "),(0,r.kt)("p",null,"Ramification: The function can be an operator, enumeration literal, attribute that is a function, etc. "),(0,r.kt)("p",null,"A subprogram call shall contain at most one association for each formal parameter. Each formal parameter without an association shall have a default_expression (in the profile of the view denoted by the name or prefix). ","[This rule is an overloading rule (see 8.6).]"," "),(0,r.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,r.kt)("p",null,"For the execution of a subprogram call, the name or prefix of the call is evaluated, and each parameter_association is evaluated (see 6.4.1). If a default_expression is used, an implicit parameter_association is assumed for this rule. These evaluations are done in an arbitrary order. The subprogram_body is then executed. Finally, if the subprogram completes normally, then after it is left, any necessary assigning back of formal to actual parameters occurs (see 6.4.1)."),(0,r.kt)("p",null,"Discussion: The implicit association for a default is only for this run-time rule. At compile time, the visibility rules are applied to the default at the place where it occurs, not at the place of a call. "),(0,r.kt)("p",null,'To be honest: If the subprogram is inherited, see 3.4, "Derived Types and Classes".'),(0,r.kt)("p",null,'If the subprogram is protected, see 9.5.1, "Protected Subprograms and Protected Actions".'),(0,r.kt)("p",null,'If the subprogram is really a renaming of an entry, see 9.5.3, "Entry Calls".'),(0,r.kt)("p",null,'Normally, the subprogram_body that is executed by the above rule is the one for the subprogram being called. For an enumeration literal, implicitly declared (but noninherited) subprogram, or an attribute that is a subprogram, an implicit body is assumed. For a dispatching call, 3.9.2, "Dispatching Operations of Tagged Types" defines which subprogram_body is executed. '),(0,r.kt)("p",null,"The exception Program_Error is raised at the point of a function_call if the function completes normally without executing a return_statement. "),(0,r.kt)("p",null,"Discussion: We are committing to raising the exception at the point of call, for uniformity - see AI83-00152. This happens after the function is left, of course."),(0,r.kt)("p",null,"Note that there is no name for suppressing this check, since the check imposes no time overhead and minimal space overhead (since it can usually be statically eliminated as dead code). "),(0,r.kt)("p",null,"A function_call denotes a constant, as defined in 6.5; the nominal subtype of the constant is given by the result subtype of the function. "),(0,r.kt)("h4",{id:"examples-2"},"Examples"),(0,r.kt)("p",null,"Examples of procedure calls: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Traverse_Tree;                                               --  see 6.1\nPrint_Header(128, Title, True);                              --  see 6.1\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Switch(From =&gt X, To =&gt Next);                               --  see 6.1\nPrint_Header(128, Header =&gt Title, Center =&gt True);          --  see 6.1\nPrint_Header(Header =&gt Title, Center =&gt True, Pages =&gt 128); --  see 6.1\n\n")),(0,r.kt)("p",null,"Examples of function calls: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Dot_Product(U, V)   --  see 6.1 and 6.3\nClock               --  see 9.6\nF.all               --  presuming F is of an access-to-subprogram type - see 3.10\n\n")),(0,r.kt)("p",null,"Examples of procedures with default expressions: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Activate(Process : in Process_Name;\n                   After   : in Process_Name := No_Process;\n                   Wait    : in Duration := 0.0;\n                   Prior   : in Boolean := False);\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Pair(Left, Right : in Person_Name := new Person);   --  see 3.10.1\n\n")),(0,r.kt)("p",null,"Examples of their calls: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Activate(X);\nActivate(X, After =&gt Y);\nActivate(X, Wait =&gt 60.0, Prior =&gt True);\nActivate(X, Y, 10.0, False);\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Pair;\nPair(Left =&gt new Person, Right =&gt new Person);\n\n")),(0,r.kt)("p",null,"NOTE 1   If a default_expression is used for two or more parameters in a multiple parameter_specification, the default_expression is evaluated once for each omitted parameter. Hence in the above examples, the two calls of Pair are equivalent. "),(0,r.kt)("h4",{id:"examples-3"},"Examples"),(0,r.kt)("p",null,"Examples of overloaded subprograms: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Put(X : in Integer);\nprocedure Put(X : in String);\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Set(Tint   : in Color);\nprocedure Set(Signal : in Light);\n\n")),(0,r.kt)("p",null,"Examples of their calls: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},'Put(28);\nPut("no possible ambiguity here");\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"Set(Tint   =&gt Red);\nSet(Signal =&gt Red);\nSet(Color'(Red));\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"--  Set(Red) would be ambiguous since Red may\n--  denote a value either of type Color or of type Light\n\n")),(0,r.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,'We have gotten rid of parameters "of the form of a type conversion" (see RM83-6.4.1(3)). The new view semantics of type_conversions allows us to use normal type_conversions instead.'),(0,r.kt)("p",null,"We have moved wording about run-time semantics of parameter associations to 6.4.1."),(0,r.kt)("p",null,"We have moved wording about raising Program_Error for a function that falls off the end to here from RM83-6.5. "),(0,r.kt)("h3",{id:"641--parameter-associations"},"6.4.1  Parameter Associations"),(0,r.kt)("p",null,"[ A parameter association defines the association between an actual parameter and a formal parameter.]"," "),(0,r.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,r.kt)("p",null,'The parameter passing rules for out parameters are designed to ensure that the parts of a type that have implicit initial values (see 3.3.1) don\'t become "de-initialized" by being passed as an out parameter.'),(0,r.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,r.kt)("p",null,"The formal_parameter_selector_name of a parameter_association shall resolve to denote a parameter_specification of the view being called."),(0,r.kt)("p",null,"The actual parameter is either the explicit_actual_parameter given in a parameter_association for a given formal parameter, or the corresponding default_expression if no parameter_association is given for the formal parameter. The expected type for an actual parameter is the type of the corresponding formal parameter. "),(0,r.kt)("p",null,"To be honest: The corresponding default_expression is the one of the corresponding formal parameter in the profile of the view denoted by the name or prefix of the call. "),(0,r.kt)("p",null,"If the mode is in, the actual is interpreted as an expression; otherwise, the actual is interpreted only as a name, if possible. "),(0,r.kt)("p",null,"Ramification: This formally resolves the ambiguity present in the syntax rule for explicit_actual_parameter.  Note that we don't actually require that the actual be a name if the mode is not in; we do that below."),(0,r.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,r.kt)("p",null,"If the mode is in out or out, the actual shall be a name that denotes a variable. "),(0,r.kt)("p",null,'Discussion: We no longer need "or a type_conversion whose argument is the name of a variable", because a type_conversion is now a name, and a type_conversion of a variable is a variable. '),(0,r.kt)("p",null,"Reason: The requirement that the actual be a (variable) name is not an overload resolution rule, since we don't want the difference between expression and name to be used to resolve overloading. For example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Print(X : in Integer; Y : in Boolean := True);\nprocedure Print(Z : in out Integer);\n. . .\nPrint(3); -- Ambiguous!\n  \n\n")),(0,r.kt)("p",null,'The above call to Print is ambiguous even though the call is not compatible with the second Print which requires an actual that is a (variable) name ("3" is an expression, not a name). This requirement is a legality rule, so overload resolution fails before it is considered, meaning that the call is ambiguous. '),(0,r.kt)("p",null,"The type of the actual parameter associated with an access parameter shall be convertible (see 4.6) to its anonymous access type. "),(0,r.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,r.kt)("p",null,"For the evaluation of a parameter_association: "),(0,r.kt)("p",null,"The actual parameter is first evaluated."),(0,r.kt)("p",null,"For an access parameter, the access_definition is elaborated, which creates the anonymous access type."),(0,r.kt)("p",null,"For a parameter ","[(of any mode)]"," that is passed by reference (see 6.2), a view conversion of the actual parameter to the nominal subtype of the formal parameter is evaluated, and the formal parameter denotes that conversion. "),(0,r.kt)("p",null,"Discussion: We are always allowing sliding, even for ","[in]"," out by-reference parameters. "),(0,r.kt)("p",null,"For an in or in out parameter that is passed by copy (see 6.2), the formal parameter object is created, and the value of the actual parameter is converted to the nominal subtype of the formal parameter and assigned to the formal. "),(0,r.kt)("p",null,"Ramification: The conversion mentioned here is a value conversion. "),(0,r.kt)("p",null,"For an out parameter that is passed by copy, the formal parameter object is created, and: "),(0,r.kt)("p",null,"For an access type, the formal parameter is initialized from the value of the actual, without a constraint check;"),(0,r.kt)("p",null,'Reason: This preserves the Language Design Principle that an object of an access type is always initialized with a "reasonable" value. '),(0,r.kt)("p",null,"For a composite type with discriminants or that has implicit initial values for any subcomponents (see 3.3.1), the behavior is as for an in out parameter passed by copy. "),(0,r.kt)("p",null,'Reason: This ensures that no part of an object of such a type can become "de-initialized" by being part of an out parameter. '),(0,r.kt)("p",null,"Ramification: This includes an array type whose component type is an access type, and a record type with a component that has a default_expression, among other things. "),(0,r.kt)("p",null,"For any other type, the formal parameter is uninitialized. If composite, a view conversion of the actual parameter to the nominal subtype of the formal is evaluated ","[(which might raise Constraint_Error)]",", and the actual subtype of the formal is that of the view conversion. If elementary, the actual subtype of the formal is given by its nominal subtype. "),(0,r.kt)("p",null,"Ramification: This case covers scalar types, and composite types whose subcomponent's subtypes do not have any implicit initial values. The view conversion for composite types ensures that if the lengths don't match between an actual and a formal array parameter, the Constraint_Error is raised before the call, rather than after. "),(0,r.kt)("p",null,"A formal parameter of mode in out or out with discriminants is constrained if either its nominal subtype or the actual parameter is constrained."),(0,r.kt)("p",null,"After normal completion and leaving of a subprogram, for each in out or out parameter that is passed by copy, the value of the formal parameter is converted to the subtype of the variable given as the actual parameter and assigned to it. These conversions and assignments occur in an arbitrary order. "),(0,r.kt)("p",null,"Ramification: The conversions mentioned above during parameter passing might raise Constraint_Error - (see 4.6). "),(0,r.kt)("p",null,"Ramification: If any conversion or assignment as part of parameter passing propagates an exception, the exception is raised at the place of the subprogram call; that is, it cannot be handled inside the subprogram_body. "),(0,r.kt)("p",null,"Proof: Since these checks happen before or after executing the subprogram_body, the execution of the subprogram_body does not dynamically enclose them, so it can't handle the exceptions. "),(0,r.kt)("p",null,"Discussion: The variable we're talking about is the one denoted by the variable_name given as the explicit_actual_parameter. If this variable_name is a type_conversion, then the rules in 4.6 for assigning to a view conversion apply. That is, if X is of subtype S1, and the actual is S2(X), the above-mentioned conversion will convert to S2, and the one mentioned in 4.6 will convert to S1. "),(0,r.kt)("h4",{id:"extensions-to-ada-83-5"},"Extensions to Ada 83"),(0,r.kt)("p",null,'In Ada 95, a program can rely on the fact that passing an object as an out parameter does not "de-initialize" any parts of the object whose subtypes have implicit initial values. (This generalizes the RM83 rule that required copy-in for parts that were discriminants or of an access type.) '),(0,r.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"We have eliminated the subclause on Default Parameters, as it is subsumed by earlier clauses and subclauses. "),(0,r.kt)("h2",{id:"65--return-statements"},"6.5  Return Statements"),(0,r.kt)("p",null,"A return_statement is used to complete the execution of the innermost enclosing subprogram_body, entry_body, or accept_statement. "),(0,r.kt)("h4",{id:"syntax-4"},"Syntax"),(0,r.kt)("p",null,"return_statement ::= return ","[expression]",";"),(0,r.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,r.kt)("p",null,"The expression, if any, of a return_statement is called the return expression. The result subtype of a function is the subtype denoted by the subtype_mark after the reserved word return in the profile of the function. The expected type for a return expression is the result type of the corresponding function. "),(0,r.kt)("p",null,"To be honest: The same applies to generic functions. "),(0,r.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,r.kt)("p",null,"A return_statement shall be within a callable construct, and it applies to the innermost one. A return_statement shall not be within a body that is within the construct to which the return_statement applies."),(0,r.kt)("p",null,"A function body shall contain at least one return_statement that applies to the function body, unless the function contains code_statements. A return_statement shall include a return expression if and only if it applies to a function body."),(0,r.kt)("p",null,'Reason: The requirement that a function body has to have at least one return_statement is a "helpful" restriction. There was been some interest in lifting this restriction, or allowing a raise statement to substitute for the return_statement. However, there was enough interest in leaving it as is that we decided not to change it. '),(0,r.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,r.kt)("p",null,"For the execution of a return_statement, the expression (if any) is first evaluated and converted to the result subtype. "),(0,r.kt)("p",null,"Ramification: The conversion might raise Constraint_Error - (see 4.6). "),(0,r.kt)("p",null,"If the result type is class-wide, then the tag of the result is the tag of the value of the expression. "),(0,r.kt)("p",null,"If the result type is a specific tagged type:"),(0,r.kt)("p",null,"Ramification: . "),(0,r.kt)("p",null,"If it is limited, then a check is made that the tag of the value of the return expression identifies the result type. Constraint_Error is raised if this check fails."),(0,r.kt)("p",null,"If it is nonlimited, then the tag of the result is that of the result type. "),(0,r.kt)("p",null,"Ramification: This is true even if the tag of the return expression is different. "),(0,r.kt)("p",null,"Reason: These rules ensure that a function whose result type is a specific tagged type always returns an object whose tag is that of the result type. This is important for dispatching on controlling result, and, if nonlimited, allows the caller to allocate the appropriate amount of space to hold the value being returned (assuming there are no discriminants). "),(0,r.kt)("p",null,"A type is a return-by-reference type if it is a descendant of one of the following: "),(0,r.kt)("p",null,"a tagged limited type;"),(0,r.kt)("p",null,"a task or protected type;"),(0,r.kt)("p",null,"a nonprivate type with the reserved word limited in its declaration;"),(0,r.kt)("p",null,"a composite type with a subcomponent of a return-by-reference type;"),(0,r.kt)("p",null,"a private type whose full type is a return-by-reference type. "),(0,r.kt)("p",null,'Ramification: The above rules are such that there are no "Ada 83" types other than those containing tasks that are return-by-reference. This helps to minimize upward incompatibilities relating to return-by-reference. '),(0,r.kt)("p",null,"If the result type is a return-by-reference type, then a check is made that the return expression is one of the following: "),(0,r.kt)("p",null,"a name that denotes an object view whose accessibility level is not deeper than that of the master that elaborated the function body; or "),(0,r.kt)("p",null,'Discussion: This rule was unnecessarily confusing, and the parenthetical remark "(or a value with an associated object, see 6.2)" was added - and then the entire concept was deleted. '),(0,r.kt)("p",null,"a parenthesized expression or qualified_expression whose operand is one of these kinds of expressions."),(0,r.kt)("p",null,"The exception Program_Error is raised if this check fails. "),(0,r.kt)("p",null,"Discussion: Compare the definition of return-by-reference with that of by-reference."),(0,r.kt)("p",null,"The return-by-reference types are all limited types except those that are limited only because of a limited private type with a nonlimited untagged full type. "),(0,r.kt)("p",null,"Reason: This check can often be performed at compile time. It is defined to be a runtime check to avoid generic contract model problems. In a future version of the standard, we anticipate that function return of a local variable will be illegal for all limited types, eliminating the need for the runtime check except for dereferences of an access parameter. "),(0,r.kt)("p",null,"For a function with a return-by-reference result type the result is returned by reference; that is, the function call denotes a constant view of the object associated with the value of the return expression. For any other function, the result is returned by copy; that is, the converted value is assigned into an anonymous constant created at the point of the return_statement, and the function call denotes that object. "),(0,r.kt)("p",null,'Ramification: The assignment operation does the necessary value adjustment, as described in 7.6, "User-Defined Assignment and Finalization". 7.6.1 describes when the anonymous constant is finalized. '),(0,r.kt)("p",null,"Finally, a transfer of control is performed which completes the execution of the callable construct to which the return_statement applies, and returns to the caller."),(0,r.kt)("h4",{id:"examples-4"},"Examples"),(0,r.kt)("p",null,"Examples of return statements: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"return;                         -- in a procedure body, entry_body, or accept_statement\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"return Key_Value(Last_Index);   -- in a function body\n\n")),(0,r.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,r.kt)("p",null,"In Ada 95, if the result type of a function has a part that is a task, then an attempt to return a local variable will raise Program_Error. In Ada 83, if a function returns a local variable containing a task, execution is erroneous according to AI83-00867. However, there are other situations where functions that return tasks (or that return a variant record only one of whose variants includes a task) are correct in Ada 83 but will raise Program_Error according to the new rules."),(0,r.kt)("p",null,"The rule change was made because there will be more types (protected types, limited controlled types) in Ada 95 for which it will be meaningless to return a local variable, and making all of these erroneous is unacceptable. The current rule was felt to be the simplest that kept upward incompatibilities to situations involving returning tasks, which are quite rare. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"This clause has been moved here from chapter 5, since it has mainly to do with subprograms."),(0,r.kt)("p",null,"A function now creates an anonymous object. This is necessary so that controlled types will work."),(0,r.kt)("p",null,"We have clarified that a return_statement applies to a callable construct, not to a callable entity."),(0,r.kt)("p",null,'There is no need to mention generics in the rules about where a return_statement can appear and what it applies to; the phrase "body of a subprogram or generic subprogram" is syntactic, and refers exactly to "subprogram_body". '),(0,r.kt)("h4",{id:"syntax-5"},"Syntax"),(0,r.kt)("p",null,"Aspect Description for No_Return: "),(0,r.kt)("h2",{id:"66--overloading-of-operators"},"6.6  Overloading of Operators"),(0,r.kt)("p",null,"An operator is a function whose designator is an operator_symbol. ","[Operators, like other functions, may be overloaded.]"," "),(0,r.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,r.kt)("p",null,"Each use of a unary or binary operator is equivalent to a function_call with function_prefix being the corresponding operator_symbol, and with (respectively) one or two positional actual parameters being the operand(s) of the operator (in order). "),(0,r.kt)("p",null,'To be honest: We also use the term operator (in Section 4 and in 6.1) to refer to one of the syntactic categories defined in 4.5, "Operators and Expression Evaluation" whose names end with "_operator:" logical_operator, relational_operator, binary_adding_operator, unary_adding_operator, multiplying_operator, and highest_precedence_operator. '),(0,r.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,r.kt)("p",null,"The subprogram_specification of a unary or binary operator shall have one or two parameters, respectively. A generic function instantiation whose designator is an operator_symbol is only allowed if the specification of the generic function has the corresponding number of parameters."),(0,r.kt)("p",null,"Default_expressions are not allowed for the parameters of an operator (whether the operator is declared with an explicit subprogram_specification or by a generic_instantiation)."),(0,r.kt)("p",null,'An explicit declaration of "/=" shall not have a result type of the predefined type Boolean. '),(0,r.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,r.kt)("p",null,'A declaration of "=" whose result type is Boolean implicitly declares a declaration of "/=" that gives the complementary result. '),(0,r.kt)("p",null,'NOTE 1   The operators "+" and "" are both unary and binary operators, and hence may be overloaded with both one- and two-parameter functions. '),(0,r.kt)("h4",{id:"examples-5"},"Examples"),(0,r.kt)("p",null,"Examples of user-defined operators: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},'function "+" (Left, Right : Matrix) return Matrix;\nfunction "+" (Left, Right : Vector) return Vector;\n\n--  assuming that A, B, and C are of the type Vector\n--  the following two statements are equivalent:\n\nA := B + C;\nA := "+"(B, C);\n\n')),(0,r.kt)("h4",{id:"extensions-to-ada-83-6"},"Extensions to Ada 83"),(0,r.kt)("p",null,'Explicit declarations of "=" are now permitted for any combination of parameter and result types.'),(0,r.kt)("p",null,'Explicit declarations of "/=" are now permitted, so long as the result type is not Boolean.'))}u.isMDXComponent=!0}}]);