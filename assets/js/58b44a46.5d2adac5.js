"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5838],{3294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>A,default:()=>b,frontMatter:()=>k,metadata:()=>p,toc:()=>g});var a=n(1716),l=n(7556),i=n(3183),o=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,h=(e,t)=>{for(var n in t||(t={}))u.call(t,n)&&m(e,n,t[n]);if(d)for(var n of d(t))c.call(t,n)&&m(e,n,t[n]);return e};const k={sidebar_position:69},A="8.5 Renaming Declarations",p={unversionedId:"arm/AA-8/AA-8.5",id:"arm/AA-8/AA-8.5",title:"8.5 Renaming Declarations",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-8/AA-8.5.mdx",sourceDirName:"arm/AA-8",slug:"/arm/AA-8/AA-8.5",permalink:"/docs/arm/AA-8/AA-8.5",draft:!1,tags:[],version:"current",sidebarPosition:69,frontMatter:{sidebar_position:69},sidebar:"tutorialSidebar",previous:{title:"8.4 Use Clauses",permalink:"/docs/arm/AA-8/AA-8.4"},next:{title:"8.6 The Context of Overload Resolution",permalink:"/docs/arm/AA-8/AA-8.6"}},f={},g=[{value:"Syntax",id:"syntax",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"8.5.1  Object Renaming Declarations",id:"851--object-renaming-declarations",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"8.5.2  Exception Renaming Declarations",id:"852--exception-renaming-declarations",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"8.5.3  Package Renaming Declarations",id:"853--package-renaming-declarations",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-2",level:4},{value:"8.5.4  Subprogram Renaming Declarations",id:"854--subprogram-renaming-declarations",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-3",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"8.5.5  Generic Renaming Declarations",id:"855--generic-renaming-declarations",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-4",level:4}],y={toc:g};function b(e){var t,n=e,{components:o}=n,m=((e,t)=>{var n={};for(var a in e)u.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&d)for(var a of d(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=h(h({},y),m),r(t,s({components:o,mdxType:"MDXLayout"}))),(0,a.kt)("h1",h({},{id:"85-renaming-declarations"}),"8.5 Renaming Declarations"),(0,a.kt)("admonition",h({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,a.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"[A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," declares another name for an entity, such as an object, exception, package, subprogram, entry, or generic unit. Alternatively, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," can be the completion of a previous ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),".]"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Glossary entry: "),"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," is a declaration that does not define a new entity, but instead defines a view of an existing entity.")),(0,a.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[C],Term=[renaming], Def=[a declaration that does not define a new entity, but instead defines a new view of an existing entity] "),(0,a.kt)("h4",h({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"renaming_declaration"),(0,a.kt)("a",{id:"S0238"}),(0,a.kt)("code",null," ::= "),"      ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0240"},"exception_renaming_declaration")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),"    | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration"))),(0,a.kt)("h4",h({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)("p",null,"The elaboration of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," evaluates the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that follows the reserved word ",(0,a.kt)("strong",null,"renames")," and thereby determines the view and entity denoted by this name (the ",(0,a.kt)("em",null,"renamed view")," and ",(0,a.kt)("em",null,"renamed entity"),"). [A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," denotes (a new view of) the renamed entity.] "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," Renaming can be used to resolve name conflicts and to act as a shorthand. Renaming with a different ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," does not hide the old ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"; the new ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," and the old ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," can be visible at different places.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI12-0427-1"),"}"," ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   A subtype defined without any additional constraint can be used to achieve the effect of renaming another subtype (including a task or protected subtype) as in ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"subtype Mode is Ada.Text_IO.File_Mode;","\n"),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The second sentence of RM83-8.5(3), "At any point where a renaming declaration is visible, the identifier, or operator symbol of this declaration denotes the renamed entity." is incorrect. It doesn\'t say directly visible. Also, such an ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," might resolve to something else.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The verbiage about renamings being legal "only if exactly one...", which appears in RM83-8.5(4) (for objects) and RM83-8.5(7) (for subprograms) is removed, because it follows from the normal rules about overload resolution. For language lawyers, these facts are obvious; for programmers, they are irrelevant, since failing these tests is highly unlikely. ')),(0,a.kt)("h2",h({},{id:"851--object-renaming-declarations"}),"8.5.1  Object Renaming Declarations"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," [An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration"))," is used to rename an object or value.] "),(0,a.kt)("h4",h({},{id:"syntax-1"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00230-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00423-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0275-1"),"}"," ",(0,a.kt)("code",null,"object_renaming_declaration"),(0,a.kt)("a",{id:"S0239"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," [: [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),"] ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," : ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("h4",h({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00230-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00254-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0275-1"),"}"," The type of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall resolve to the type determined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),", if present. If no ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," is present, the expected type of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is any type."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0275-1"),"}"," In the case where the type is defined by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", the type of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall resolve to an anonymous access type. If the anonymous access type is an access-to-object type, the type of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall have the same designated type as that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),". If the anonymous access type is an access-to-subprogram type, the type of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall have a designated profile that is type conformant with that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),"."),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'A previous version of Ada 9X used the usual "expected type" wording:"The expected type for the ',(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is that determined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),'."We changed it so that this would be illegal: ')),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"X: T;","\n","Y: T'Class renames X; -- Illegal!","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"When the above was legal, it was unclear whether Y was of type T or T'Class. Note that we still allow this: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"Z: T'Class := ...;","\n","W: T renames F(Z);","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"where F is a function with a controlling parameter and result. This is admittedly a bit odd.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Note that the matching rule for generic formal parameters of mode ",(0,a.kt)("strong",null,"in out")," was changed to keep it consistent with the rule for renaming. That makes the rule different for ",(0,a.kt)("strong",null,"in")," vs. ",(0,a.kt)("strong",null,"in out"),".")),(0,a.kt)("h4",h({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," The renamed entity shall be an object or value."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," In the case where the type is defined by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", the type of the renamed entity and the type defined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),": "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," shall both be access-to-object types with statically matching designated subtypes and with both or neither being access-to-constant types; or "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," shall both be access-to-subprogram types with subtype conformant designated profiles. "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00423-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," For an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration"))," with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," that has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),", the subtype of the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall exclude null. In addition, if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration"))," occurs within the body of a generic unit ",(0,a.kt)("em",null,"G")," or within the body of a generic unit declared within the declarative region of generic unit ",(0,a.kt)("em",null,"G"),", then:"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," if the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," statically denotes a generic formal object of mode ",(0,a.kt)("strong",null,"in out")," of ",(0,a.kt)("em",null,"G"),", then the declaration of that object shall have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),";"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," if the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," statically denotes a call of a generic formal function of ",(0,a.kt)("em",null,"G"),", then the declaration of the result of that function shall have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),". "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0005-1"),"}",' These rules prevent "lying". ',(0,a.kt)("strong",null,"Null")," must never be the value of an object with an explicit ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),". The bullets are assume-the-worst rules that prevent trouble in two obscure cases: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"type Acc_I is access Integer;","\n","subtype Acc_NN_I is not null Acc_I;","\n","Obj : Acc_I := null;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"generic","\n","   B : in out Acc_NN_I;","\n","package Gen is","\n","   ...","\n","end Gen;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"package body Gen is","\n","   D : not null Acc_I renames B;","\n","end Gen;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"package Inst is new Gen (B =",">"," Obj);","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," Without the first bullet rule, D would be legal, and contain the value ",(0,a.kt)("strong",null,"null"),", because the rule about lying is satisfied for generic matching (Obj matches B; B does not explicitly state ",(0,a.kt)("strong",null,"not null"),"), Legality Rules are not rechecked in the body of any instance, and the template passes the lying rule as well. The second bullet handles a similar case involving formal functions. The rules are so complex because they have to apply to formals used in bodies of child generics as well as in the bodies of generics. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," In the case where the ",(0,a.kt)("em",null,"object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," with a nominal subtype ",(0,a.kt)("em",null,"S")," and whose ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes an object ",(0,a.kt)("em",null,"Q"),": "),(0,a.kt)("p",null,"if ",(0,a.kt)("em",null,"S")," is an elementary subtype, then: "),(0,a.kt)("p",null,(0,a.kt)("em",null,"Q")," shall be a constant other than a dereference of an access type; or"),(0,a.kt)("p",null,"the nominal subtype of ",(0,a.kt)("em",null,"Q")," shall be statically compatible with ",(0,a.kt)("em",null,"S"),"; or"),(0,a.kt)("p",null,(0,a.kt)("em",null,"S")," shall statically match the base subtype of its type if scalar, or the first subtype of its type if an access type. "),(0,a.kt)("p",null,"if ",(0,a.kt)("em",null,"S")," is a composite subtype, then ",(0,a.kt)("em",null,"Q")," shall be known to be constrained or ",(0,a.kt)("em",null,"S")," shall statically match the first subtype of its type. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"There's no restriction if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is a value. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'This check prevents the renamed object from violating its nominal subtype. As the subtype is only checked when the object is renamed, we make it illegal if the actual object is a variable whose value could be changed afterwards to violate the subtype. This is messy as "known to be constrained" is only defined for composite objects, so we have to handle elementary objects and all values separately. ')),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0017"),"}"," ","{",(0,a.kt)("em",null,"AI95-00184-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00363-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," The renamed entity shall not be a subcomponent that depends on discriminants of an object whose nominal subtype is unconstrained unless the object is known to be constrained. A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," of an array shall not be renamed if this restriction disallows renaming of the array. "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit."),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"This applies to all of the Legality Rules in this subclause. Rechecks are needed for most of the rules (but not the first two). ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This prevents renaming of subcomponents that might disappear, which might leave dangling references. Similar restrictions exist for the Access attribute.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0017"),"}"," ","{",(0,a.kt)("em",null,"AI95-00184-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0008-1"),"}",' The "recheck on instantiation" requirement on generics is necessary to avoid renaming of components which could disappear even when the nominal subtype would prevent the problem:')),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"type T1 (D1 : Boolean) is","\n","   record","\n","      case D1 is","\n","         when False =",">","\n","            C1 : Integer;","\n","         when True =",">","\n","            null;","\n","         end case;","\n","      end record;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"generic","\n","   type F is new T1;","\n","   X : in out F;","\n","package G is","\n","   C1_Ren : Integer renames X.C1;","\n","end G;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"type T2 (D2 : Boolean := False) is new T1 (D1 =",">"," D2);","\n","\n","Y : T2;","\n","\n","package I is new G (T2, Y);","\n","\n","Y := (D1 =",">"," True); -- Oops!  What happened to I.C1_Ren?","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}",' In addition, the "known to be constrained" rules include assume-the-worst rules for generic bodies partially to prevent such problems.')),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Implementation Note: "),"Note that if an implementation chooses to deallocate-then-reallocate on ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0173"},"assignment_statement")),"s assigning to unconstrained definite objects, then it cannot represent renamings and access values as simple addresses, because the above rule does not apply to all components of such an object. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"If it is a generic formal object, then the assume-the-best or assume-the-worst rules are applied as appropriate. ")),(0,a.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00230-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration"))," declares a new view [of the renamed entity] whose properties are identical to those of the renamed view. [Thus, the properties of the renamed entity are not affected by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration")),". In particular, its nominal subtype, whether it is a value or an object, its value if it is an object, and whether or not it is a constant, are unaffected; similarly, the constraints and other properties of its nominal subtype are not affected by renaming (any constraint implied by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration"))," is ignored).] "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"Because the constraints are ignored, it is a good idea to use the nominal subtype of the renamed object when writing an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration")),".")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," If no ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," is given in the renaming, the object may or may not exclude null. This is similar to the way that constraints need not match, and ",(0,a.kt)("strong",null,"constant")," is not specified. The renaming defines a view of the renamed entity, inheriting the original properties. ")),(0,a.kt)("h4",h({},{id:"examples"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of renaming an object:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"declare","\n","   L : Person renames Leftmost_Person; -- see 3.10.1","\n","begin","\n","   L.Age := L.Age + 1;","\n","end;","\n"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," Example of renaming a value:"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"{","AI12-0383-1","}"," Uno renames One;  -- see 3.3.2","\n"),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83-1"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The phrase "subtype ... as defined in a corresponding object declaration, component declaration, or component subtype indication", from RM83-8.5(5), is incorrect in Ada 95; therefore we removed it. It is incorrect in the case of an object with an indefinite unconstrained nominal subtype. ')),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-95"}),"Incompatibilities With Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00363-01"),"}"," Aliased variables are not necessarily constrained in Ada 2005 (see 3.6). Therefore, a subcomponent of an aliased variable may disappear or change shape, and renaming such a subcomponent thus is illegal, while the same operation would have been legal in Ada 95. Note that most allocated objects are still constrained by their initial value (see 4.8), and thus have no change in the legality of renaming for them. For example, using the type T2 of the previous example: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"AT2 : aliased T2;","\n","   C1_Ren : Integer renames AT2.C1; -- Illegal in Ada 2005, legal in Ada 95","\n","   AT2 := (D1 =",">"," True);             -- Raised Constraint_Error in Ada 95,","\n","                                    -- but does not in Ada 2005, so C1_Ren becomes","\n","                                    -- invalid when this is assigned.","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00230-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00254-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00409-01"),"}"," A renaming can have an anonymous access type. In that case, the accessibility of the renaming is that of the original object (accessibility is not lost as it is for assignment to a component or stand-alone object).")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00423-01"),"}"," A renaming can have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"; if so, the renamed object must also exclude null, so that the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," does not lie. On the other hand, if the renaming does not have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),". it excludes null if the renamed object does. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0017"),"}"," ","{",(0,a.kt)("em",null,"AI95-00184-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Fixed to forbid renamings of depends-on-discriminant components if the type ",(0,a.kt)("em",null,"might")," be definite. ")),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2005"}),"Incompatibilities With Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Simplified the description of when a discriminant-dependent component is allowed to be renamed - it's now simply when the object is known to be constrained. This fixes a confusion as to whether a subcomponent of an object that is not certain to be constrained can be renamed. The fix introduces an incompatibility, as the rule did not apply in Ada 95 if the prefix was a constant; but it now applies no matter what kind of object is involved. The incompatibility is not too bad, since most kinds of constants are known to be constrained. ")),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0239"},"object_renaming_declaration")),". This is described in 13.1.1. ")),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," The Legality Rules for renames with null exclusions no longer applies to generic formal objects of mode ",(0,a.kt)("strong",null,"in"),", but does apply to renames of generic formal functions. This means a few unlikely programs are now illegal that were previously allowed by original Ada 2012, while more programs that were previously llegal will be allowed.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0401-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added a rule to ensure that a renaming of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," of a variable is allowed only if the variable will always remain within the nominal subtype of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),". This was not required in Ada 2012. Renamings that are now illegal are at risk of causing erroneous execution if the variable value is changed to a bad value; this is consistent with other rules preventing renamings from changing to violate their known properties. ")),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0275-1"),"}"," The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," in an object renaming is now optional, as the subtype information it provides is not trustworthy anyway (that comes from the renamed object and there is no requirement that it is the same as that of the object).")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0383-1"),"}"," An object renaming can now rename values, such as named numbers. The renamed entity still has to be a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", but an arbitrary ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," can be renamed by qualifying it. ")),(0,a.kt)("h2",h({},{id:"852--exception-renaming-declarations"}),"8.5.2  Exception Renaming Declarations"),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0240"},"exception_renaming_declaration"))," is used to rename an exception.] "),(0,a.kt)("h4",h({},{id:"syntax-2"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("code",null,"exception_renaming_declaration"),(0,a.kt)("a",{id:"S0240"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," : ",(0,a.kt)("strong",null,"exception")," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"exception_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"   [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("h4",h({},{id:"legality-rules-1"}),"Legality Rules"),(0,a.kt)("p",null,"The renamed entity shall be an exception. "),(0,a.kt)("h4",h({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0240"},"exception_renaming_declaration"))," declares a new view [of the renamed exception]. "),(0,a.kt)("h4",h({},{id:"examples-1"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of renaming an exception:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"EOF : exception renames Ada.IO_Exceptions.End_Error; -- see A.13","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0240"},"exception_renaming_declaration")),". This is described in 13.1.1. ")),(0,a.kt)("h2",h({},{id:"853--package-renaming-declarations"}),"8.5.3  Package Renaming Declarations"),(0,a.kt)("p",null,"[A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration"))," is used to rename a package.] "),(0,a.kt)("h4",h({},{id:"syntax-3"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("code",null,"package_renaming_declaration"),(0,a.kt)("a",{id:"S0241"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"package")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"package_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"   [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("h4",h({},{id:"legality-rules-2"}),"Legality Rules"),(0,a.kt)("p",null,"The renamed entity shall be a package."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00217-06"),"}"," ","{",(0,a.kt)("em",null,"AI95-00412-01"),"}"," If the ",(0,a.kt)("em",null,"package_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration"))," denotes a limited view of a package ",(0,a.kt)("em",null,"P"),", then a name that denotes the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration"))," shall occur only within the immediate scope of the renaming or the scope of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause"))," that mentions the package ",(0,a.kt)("em",null,"P")," or, if ",(0,a.kt)("em",null,"P")," is a nested package, the innermost library package enclosing ",(0,a.kt)("em",null,"P"),". "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"The use of a renaming that designates a limited view is restricted to locations where we know whether the view is limited or nonlimited (based on a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause")),"). We don't want to make an implicit limited view, as those are not transitive like a regular view. Implementations should be able to see all limited views needed based on the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0292"},"context_clause")),". ")),(0,a.kt)("h4",h({},{id:"static-semantics-2"}),"Static Semantics"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration"))," declares a new view [of the renamed package]."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00412-01"),"}"," [At places where the declaration of the limited view of the renamed package is visible, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration"))," denotes a limited view of the package (see 10.1.1).] "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),'This rule is found in 8.3, "Visibility". ')),(0,a.kt)("h4",h({},{id:"examples-2"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of renaming a package:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"package TM renames Table_Manager;","\n"),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-95-1"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00217-06"),"}"," ","{",(0,a.kt)("em",null,"AI95-00412-01"),"}"," Uses of renamed limited views of packages can only be used within the scope of a with_clause for the renamed package. ")),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-2"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0241"},"package_renaming_declaration")),". This is described in 13.1.1. ")),(0,a.kt)("h2",h({},{id:"854--subprogram-renaming-declarations"}),"8.5.4  Subprogram Renaming Declarations"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," can serve as the completion of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),"; such a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," is called a ",(0,a.kt)("em",null,"renaming-as-body"),". A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," that is not a completion is called a ",(0,a.kt)("em",null,"renaming-as-declaration"),"[, and is used to rename a subprogram (possibly an enumeration literal) or an entry]. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," A renaming-as-body is a declaration, as defined in Clause 3. ")),(0,a.kt)("h4",h({},{id:"syntax-4"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00218-03"),"}"," ","{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("code",null,"subprogram_renaming_declaration"),(0,a.kt)("a",{id:"S0242"}),(0,a.kt)("code",null," ::= "),"    [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"]    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("h4",h({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The expected profile for the ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is the profile given in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification")),". "),(0,a.kt)("h4",h({},{id:"legality-rules-3"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0239-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0373-1"),"}"," The profile of a renaming-as-declaration shall be mode conformant with that of the renamed callable entity. "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00423-01"),"}"," For a parameter or result subtype of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," that has an explicit ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),":"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," if the ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," statically denotes a generic formal subprogram of a generic unit ",(0,a.kt)("em",null,"G"),", and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," occurs within the body of a generic unit ",(0,a.kt)("em",null,"G")," or within the body of a generic unit declared within the declarative region of the generic unit ",(0,a.kt)("em",null,"G"),", then the corresponding parameter or result subtype of the formal subprogram of ",(0,a.kt)("em",null,"G")," shall have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),";"),(0,a.kt)("p",null,"otherwise, the subtype of the corresponding parameter or result type of the renamed callable entity shall exclude null. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'This rule prevents "lying". ',(0,a.kt)("strong",null,"Null")," must never be the value of a parameter or result with an explicit ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),". The first bullet is an assume-the-worst rule which prevents trouble in generic bodies (including bodies of child units) when the formal subtype excludes null implicitly. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0027"),"}"," ","{",(0,a.kt)("em",null,"8652/0028"),"}"," ","{",(0,a.kt)("em",null,"AI95-00135-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00145-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0239-1"),"}"," The profile of a renaming-as-body shall conform fully to that of the declaration it completes. If the renaming-as-body completes that declaration before the subprogram it declares is frozen, the profile shall be mode conformant with that of the renamed callable entity and the subprogram it declares takes its convention from the renamed subprogram; otherwise, the profile shall be subtype conformant with that of the renamed callable entity and the convention of the renamed subprogram shall not be Intrinsic. A renaming-as-body is illegal if the declaration occurs before the subprogram whose declaration it completes is frozen, and the renaming renames the subprogram itself, through one or more subprogram renaming declarations, none of whose subprograms has been frozen. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'The otherwise part of the second sentence is to allow an implementation of a renaming-as-body as a single jump instruction to the target subprogram. Among other things, this prevents a subprogram from being completed with a renaming of an entry. (In most cases, the target of the jump can be filled in at link time. In some cases, such as a renaming of a name like "A(I).',(0,a.kt)("strong",null,"all"),'", an indirect jump is needed. Note that the name is evaluated at renaming time, not at call time.)')),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0028"),"}"," ","{",(0,a.kt)("em",null,"AI95-00145-01"),"}"," The first part of the second sentence is intended to allow renaming-as-body of predefined operators before the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," is frozen. For some types (such as integer types), the parameter type for operators is the base type, and it would be very strange for   ",(0,a.kt)("strong",null,"function")," Equal (A, B : ",(0,a.kt)("strong",null,"in")," T) ",(0,a.kt)("strong",null,"return")," Boolean;   ",(0,a.kt)("strong",null,"function")," Equal (A, B : ",(0,a.kt)("strong",null,"in")," T) ",(0,a.kt)("strong",null,"return")," Boolean ",(0,a.kt)("strong",null,"renames"),' "=";to be illegal. (Note that predefined operators cannot be renamed this way after the ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," is frozen, as they have convention Intrinsic.)")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The first sentence is the normal rule for completions of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),"s. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", unlike a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),", cannot be completed with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration")),". Nor can a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.1#S0311"},"generic_subprogram_declaration")),".")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The syntax rules prevent a protected subprogram declaration from being completed by a renaming. This is fortunate, because it allows us to avoid worrying about whether the implicit protected object parameter of a protected operation is involved in the conformance rules. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"8652/0027"),"}"," ","{",(0,a.kt)("em",null,"AI95-00135-01"),"}"," Circular renames before freezing is illegal, as the compiler would not be able to determine the convention of the subprogram. Other circular renames are handled below; see Bounded (Run-Time) Errors. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," The ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a renaming shall not denote a subprogram that requires overriding (see 3.9.3). "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," Such a rename cannot be of the inherited subprogram (which requires overriding because it cannot be called), and thus cannot squirrel away a subprogram (see below). That would be confusing, so we make it illegal. The renaming is allowed after the overriding, as then the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," will denote the overriding subprogram, not the inherited one. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," The ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a renaming-as-body shall not denote an abstract subprogram. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," Such a subprogram has no body, so it hardly can replace one in the program. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," If the ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a renaming is a prefixed view, the prefix of that view shall denote an object for which renaming is allowed."),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," The prefix in such a case is essentially renamed and passed to any calls of the renamed subprogram. If the prefix isn't legal to rename, that doesn't make sense (and allowing it might end up passing a nonexistent object to some calls). ")),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a formal parameter of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," is not allowed within the ",(0,a.kt)("em",null,"callable_entity_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This is to prevent things like this: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"function F(X : Integer) return Integer renames Table(X).all;","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"A similar rule in 6.1 forbids things like this: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"function F(X : Integer; Y : Integer := X) return Integer;","\n"),(0,a.kt)("h4",h({},{id:"static-semantics-3"}),"Static Semantics"),(0,a.kt)("p",null,"A renaming-as-declaration declares a new view of the renamed entity. The profile of this new view takes its subtypes, parameter modes, and calling convention from the original profile of the callable entity, while taking the formal parameter ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),"s from the profile given in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),". The new view is a function or procedure, never an entry. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"When renaming an entry as a procedure, the compile-time rules apply as if the new view is a procedure, but the run-time semantics of a call are that of an entry call. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"For example, it is illegal for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0276"},"timed_entry_call"))," to call the new view. But what looks like a procedure call will do things like barrier waiting.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0105"),"}"," ","{",(0,a.kt)("em",null,"AI95-00211-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0095-1"),"}"," All properties of the renamed entity are inherited by the new view unless otherwise stated by this document. In particular, if the renamed entity is abstract, the new view also is abstract. Similarly, if the renamed entity is not a program unit, then neither is the renaming. (Implicitly declared subprograms are not program units, see 10.1). ")),(0,a.kt)("h4",h({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0014"),"}"," ","{",(0,a.kt)("em",null,"AI95-00064-01"),"}"," For a call to a subprogram whose body is given as a renaming-as-body, the execution of the renaming-as-body is equivalent to the execution of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body"))," that simply calls the renamed subprogram with its formal parameters as the actual parameters and, if it is a function, returns the value of the call. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"This implies that the subprogram completed by the renaming-as-body has its own elaboration check. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0123-1"),"}"," For a call on a renaming of a dispatching subprogram that is overridden, if the overriding occurred before the renaming, then the body executed is that of the overriding declaration, even if the overriding declaration is not visible at the place of the renaming; otherwise, the inherited or predefined subprogram is called. A corresponding rule applies to a call on a renaming of a predefined equality operator for an untagged record type. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"Note that whether or not the renaming is itself primitive has nothing to do with the renamed subprogram.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0123-1"),"}"," Note that the above rule is only for tagged types and equality of untagged record types.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Consider the following example: ")),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"package P is","\n","    type T is tagged null record;","\n",'    function Predefined_Equal(X, Y : T) return Boolean renames "=";',"\n","private","\n",'    function "="(X, Y : T) return Boolean; -- Override predefined "=".',"\n","end P;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"with P; use P;","\n","package Q is","\n",'    function User_Defined_Equal(X, Y : T) return Boolean renames P."=";',"\n","end Q;","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"A call on Predefined_Equal will execute the predefined equality operator of T, whereas a call on User_Defined_Equal will execute the body of the overriding declaration in the private part of P.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Thus a renaming allows one to squirrel away a copy of an inherited or predefined subprogram before later overriding it. ")),(0,a.kt)("h4",h({},{id:"bounded-run-time-errors"}),"Bounded (Run-Time) Errors"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0027"),"}"," ","{",(0,a.kt)("em",null,"AI95-00135-01"),"}"," If a subprogram directly or indirectly renames itself, then it is a bounded error to call that subprogram. Possible consequences are that Program_Error or Storage_Error is raised, or that the call results in infinite recursion. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"8652/0027"),"}"," ","{",(0,a.kt)("em",null,"AI95-00135-01"),"}"," This has to be a bounded error, as it is possible for a renaming-as-body appearing in a package body to cause this problem. Thus it is not possible in general to detect this problem at compile time. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   A procedure can only be renamed as a procedure. A function whose ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0200"},"defining_designator"))," is either an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," can be renamed with either an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),"; for renaming as an operator, the subprogram specification given in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," is subject to the rules given in 6.6 for operator declarations. Enumeration literals can be renamed as functions; similarly, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),"s that denote functions (such as references to Succ and Pred) can be renamed as functions. An entry can only be renamed as a procedure; the new ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is only allowed to appear in contexts that allow a procedure ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". An entry of a family can be renamed, but an entry family cannot be renamed as a whole.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   The operators of the root numeric types cannot be renamed because the types in the profile are anonymous, so the corresponding specifications cannot be written; the same holds for certain attributes, such as Pos.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI12-0292-1"),"}"," ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 3   The primitiveness of a renaming-as-declaration is determined by its profile, and by where it occurs, as for any declaration of (a view of) a subprogram; primitiveness is not determined by the renamed view. In order to perform a dispatching call, the subprogram name has to denote a primitive subprogram, not a nonprimitive renaming of a primitive subprogram. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," could more properly be called ",(0,a.kt)("code",null,"renaming_as_subprogram_declaration"),", since you're renaming something as a subprogram, but you're not necessarily renaming a subprogram. But that's too much of a mouthful. Or, alternatively, we could call it a ",(0,a.kt)("code",null,"callable_entity_renaming_declaration"),", but that's even worse. Not only is it a mouthful, it emphasizes the entity being renamed, rather than the new view, which we think is a bad idea. We'll live with the oddity. ")),(0,a.kt)("h4",h({},{id:"examples-3"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of subprogram renaming declarations:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"procedure My_Write(C : in Character) renames Pool(K).Write; --  see 4.1.3","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},'function Real_Plus(Left, Right : Real   ) return Real    renames "+";',"\n",'function Int_Plus (Left, Right : Integer) return Integer renames "+";',"\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"function Rouge return Color renames Red;  --  see 3.5.1","\n","function Rot   return Color renames Red;","\n","function Rosso return Color renames Rouge;","\n"),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"function Next(X : Color) return Color renames Color'Succ; -- see 3.5.1","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of a subprogram renaming declaration with new parameter names:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},'function "*" (X,Y : Vector) return Real renames Dot_Product; -- see 6.1',"\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of a subprogram renaming declaration with a new default expression:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"function Minimum(L : Link := Head) return Cell renames Min_Cell; -- see 6.1","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-95-1"}),"Extensions to Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0028"),"}"," ","{",(0,a.kt)("em",null,"AI95-00145-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Allowed a renaming-as-body to be just mode conformant with the specification if the subprogram is not yet frozen.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00218-03"),"}"," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"Overriding_indicator"))," (see 8.3.1) is optionally added to subprogram renamings. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-95-2"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0014"),"}"," ","{",(0,a.kt)("em",null,"AI95-00064-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Described the semantics of renaming-as-body, so that the location of elaboration checks is clear.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0027"),"}"," ","{",(0,a.kt)("em",null,"AI95-00135-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Clarified that circular renaming-as-body is illegal (if it can be detected in time) or a bounded error.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00228-01"),"}"," ",(0,a.kt)("strong",null,"Amendment Correction:")," Clarified that renaming a shall-be-overridden subprogram is illegal, as well as renaming-as-body an abstract subprogram.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00423-01"),"}"," Added matching rules for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"s. ")),(0,a.kt)("h4",h({},{id:"inconsistencies-with-ada-2005"}),"Inconsistencies With Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0123-1"),"}",' Renaming of user-defined untagged record equality is now defined to call the overridden body so long as the overriding occurred before the renames. This could change the body called in unusual cases; the change is necessary to preserve the principle that the body called for an explicit call to "=" (via a renames in this case) is the same as the one inherited for a derived type and used in generics. Note that any renamings before the overriding will be unchanged. Any differences caused by the change will be rare and most likely will fix a bug. ')),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-3"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),". This is described in 13.1.1. ")),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2012-1"}),"Incompatibilities With Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added a rule to ensure that the prefix of a renaming of a prefixed view continues to exist during the life of a renames. If the prefix is a subcomponent that depends on discriminants, Ada 2005 and 2012 would have allowed the prefix while Ada 2022 would not. Without this change, explicit forms (renaming the object and then using that in calls) would be safer than the renaming; that's inconsistent with other kinds of renaming. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0287-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added wording to ensure that the object subject to a Legality Rule can be determined at compile-time. The alternative being nonsense, we treat this as a wording change. ")),(0,a.kt)("h2",h({},{id:"855--generic-renaming-declarations"}),"8.5.5  Generic Renaming Declarations"),(0,a.kt)("p",null,"[A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration"))," is used to rename a generic unit.] "),(0,a.kt)("h4",h({},{id:"syntax-5"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," ",(0,a.kt)("code",null,"generic_renaming_declaration"),(0,a.kt)("a",{id:"S0243"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("strong",null,"generic package"),"\t",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"generic_package_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];  | ",(0,a.kt)("strong",null,"generic procedure"),"\t",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"generic_procedure_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];  | ",(0,a.kt)("strong",null,"generic function"),"\t",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," ",(0,a.kt)("strong",null,"renames")," ",(0,a.kt)("em",null,"generic_function_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"        [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,a.kt)("h4",h({},{id:"legality-rules-4"}),"Legality Rules"),(0,a.kt)("p",null,"The renamed entity shall be a generic unit of the corresponding kind. "),(0,a.kt)("h4",h({},{id:"static-semantics-4"}),"Static Semantics"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration"))," declares a new view [of the renamed generic unit]. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   ","{",(0,a.kt)("em",null,"AI12-0440-1"),"}"," Although the properties of the new view are the same as those of the renamed view, the place where the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration"))," occurs can affect the legality of subsequent renamings and instantiations that denote the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration")),", in particular if the renamed generic unit is a library unit (see 10.1.1). ")),(0,a.kt)("h4",h({},{id:"examples-4"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Example of renaming a generic unit:")," "),(0,a.kt)(l.Z,{mdxType:"CodeBlock"},"generic package Enum_IO renames Ada.Text_IO.Enumeration_IO;  -- see A.10.10","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Renaming of generic units is new to Ada 95. It is particularly important for renaming child library units that are generic units. For example, it might be used to rename Numerics.Generic_Elementary_Functions as simply Generic_Elementary_Functions, to match the name for the corresponding Ada-83-based package. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83-2"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The information in RM83-8.6, "The Package Standard", has been updated for the child unit feature, and moved to Annex A, except for the definition of "predefined type", which has been moved to 3.2.1. ')),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-4"}),"Extensions to Ada 2005"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration")),". This is described in 13.1.1. ")))}b.isMDXComponent=!0}}]);