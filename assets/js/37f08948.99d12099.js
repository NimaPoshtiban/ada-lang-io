"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7317],{1716:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>c});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(a),c=i,f=u["".concat(l,".").concat(c)]||u[c]||h[c]||r;return a?n.createElement(f,o(o({ref:t},d),{},{components:a})):n.createElement(f,o({ref:t},d))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},377:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:21},o="3.5  Scalar Types",s={unversionedId:"arm/AA-3.5",id:"arm/AA-3.5",title:"3.5  Scalar Types",description:"Scalar types comprise enumeration types, integer types, and real types. Enumeration types and integer types are called discrete types; each value of a discrete type has a position number which is an integer value. Integer types and real types are called numeric types. [All scalar types are ordered, that is, all relational operators are predefined for their values.]",source:"@site/docs/arm/AA-3.5.md",sourceDirName:"arm",slug:"/arm/AA-3.5",permalink:"/docs/arm/AA-3.5",draft:!1,tags:[],version:"current",sidebarPosition:21,frontMatter:{sidebar_position:21},sidebar:"tutorialSidebar",previous:{title:"3.4  Derived Types and Classes",permalink:"/docs/arm/AA-3.4"},next:{title:"3.6  Array Types",permalink:"/docs/arm/AA-3.6"}},l={},p=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"3.5.1  Enumeration Types",id:"351--enumeration-types",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"3.5.2  Character Types",id:"352--character-types",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"3.5.3  Boolean Types",id:"353--boolean-types",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"3.5.4  Integer Types",id:"354--integer-types",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-2",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"3.5.5  Operations of Discrete Types",id:"355--operations-of-discrete-types",level:2},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"3.5.6  Real Types",id:"356--real-types",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"3.5.7  Floating Point Types",id:"357--floating-point-types",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Implementation Requirements",id:"implementation-requirements-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-3",level:4},{value:"Implementation Advice",id:"implementation-advice-2",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"3.5.8  Operations of Floating Point Types",id:"358--operations-of-floating-point-types",level:2},{value:"Static Semantics",id:"static-semantics-9",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-3",level:4},{value:"3.5.9  Fixed Point Types",id:"359--fixed-point-types",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-10",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Implementation Requirements",id:"implementation-requirements-3",level:4},{value:"Implementation Permissions",id:"implementation-permissions-4",level:4},{value:"Examples",id:"examples-6",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-4",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4},{value:"3.5.10  Operations of Fixed Point Types",id:"3510--operations-of-fixed-point-types",level:2},{value:"Static Semantics",id:"static-semantics-11",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-5",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-2",level:4}],d={toc:p};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"35--scalar-types"},"3.5  Scalar Types"),(0,i.kt)("p",null,"Scalar types comprise enumeration types, integer types, and real types. Enumeration types and integer types are called discrete types; each value of a discrete type has a position number which is an integer value. Integer types and real types are called numeric types. ","[All scalar types are ordered, that is, all relational operators are predefined for their values.]"),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"range_constraint",(0,i.kt)("a",{id:"S0036"})," ::=  range ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")),(0,i.kt)("p",null,"range",(0,i.kt)("a",{id:"S0037"})," ::=  ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference"),"\n| ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," .. ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")),(0,i.kt)("p",null,"Discussion: These need to be ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s rather than more general ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s because ranges appear in membership tests and other contexts where ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," .. ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," would be ambiguous. "),(0,i.kt)("p",null,'A range has a lower bound and an upper bound and specifies a subset of the values of some scalar type (the type of the range). A range with lower bound L and upper bound R is described by "L .. R". If R is less than L, then the range is a null range, and specifies an empty set of values. Otherwise, the range specifies the values of the type from the lower bound to the upper bound, inclusive. A value belongs to a range if it is of the type of the range, and is in the subset of values specified by the range. A value satisfies a range constraint if it belongs to the associated range. One range is included in another if all values that belong to the first range also belong to the second. '),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," containing a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),", either directly or as part of some other ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0030"},"scalar_constraint"),", the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," shall resolve to that of the type determined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," of a given type, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," (likewise, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s of the equivalent ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," for a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference"),") are expected to be of the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". "),(0,i.kt)("p",null,"Discussion: In Ada 95, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0029"},"constraint"),"s only appear within ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"s; things that look like constraints that appear in type declarations are called something else like ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),"s."),(0,i.kt)("p",null,'{AI05-0299-1} We say "the expected type is ..." or "the type is expected to be ..." depending on which reads better. They are fundamentally equivalent, and both feed into the type resolution rules of subclause 8.6.'),(0,i.kt)("p",null,"In some cases, it doesn't work to use expected types. For example, in the above rule, we say that the \"type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),' shall resolve to ..." rather than "the expected type for the ',(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),' is ..." We then use "expected type" for the bounds. If we used "expected" at both points, there would be an ambiguity, since one could apply the rules of 8.6 either on determining the type of the range, or on determining the types of the individual bounds. It is clearly important to allow one bound to be of a universal type, and the other of a specific type, so we need to use "expected type" for the bounds. Hence, we used "shall resolve to" for the type of the range as a whole. There are other situations where "expected type" is not quite right, and we use "shall resolve to" instead. '),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The base range of a scalar type is the range of finite values of the type that can be represented in every unconstrained object of the type; it is also the range supported at a minimum for intermediate values during the evaluation of expressions involving predefined operators of the type. "),(0,i.kt)("p",null,"Implementation Note: Note that in some machine architectures intermediates in an expression (particularly if static), and register-resident variables might accommodate a wider range. The base range does not include the values of this wider range that are not assignable without overflow to memory-resident objects."),(0,i.kt)("p",null,"Ramification: The base range of an enumeration type is the range of values of the enumeration type. "),(0,i.kt)("p",null,"Reason: If the representation supports infinities, the base range is nevertheless restricted to include only the representable finite values, so that 'Base'First and 'Base'Last are always guaranteed to be finite."),(0,i.kt)("p",null,'To be honest: By a "value that can be assigned without overflow" we don\'t mean to restrict ourselves to values that can be represented exactly. Values between machine representable values can be assigned, but on subsequent reading, a slightly different value might be retrieved, as (partially) determined by the number of digits of precision of the type. '),(0,i.kt)("p",null,"[A constrained scalar subtype is one to which a range constraint applies.]"," The range of a constrained scalar subtype is the range associated with the range constraint of the subtype. The range of an unconstrained scalar subtype is the base range of its type. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"A range is compatible with a scalar subtype if and only if it is either a null range or each bound of the range belongs to the range of the subtype. A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," is compatible with a scalar subtype if and only if its range is compatible with the subtype. "),(0,i.kt)("p",null,"Ramification: Only ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"s (explicit or implicit) impose conditions on the values of a scalar subtype. The other ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0030"},"scalar_constraint"),"s, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint"),"s impose conditions on the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", but don't impose a condition on the values of the subtype being defined. Therefore, a scalar subtype is not called constrained if all that applies to it is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),". Decimal subtypes are subtle, because a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," without a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," nevertheless includes an implicit ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),". "),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," consists of the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". The evaluation of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," determines a lower bound and an upper bound. If ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s are given to specify bounds, the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," evaluates these ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s in an arbitrary order, and converts them to the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference")," is given, the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," consists of the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference"),"."),(0,i.kt)("p",null,"Attributes"),(0,i.kt)("p",null,"For every scalar subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'FirstS'First denotes the lower bound of the range of S. The value of this attribute is of the type of S. "),(0,i.kt)("p",null,"Ramification: Evaluating S'First never raises Constraint_Error."),(0,i.kt)("p",null,"S'LastS'Last denotes the upper bound of the range of S. The value of this attribute is of the type of S. "),(0,i.kt)("p",null,"Ramification: Evaluating S'Last never raises Constraint_Error."),(0,i.kt)("p",null,"S'RangeS'Range is equivalent to the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," S'First .. S'Last."),(0,i.kt)("p",null,"S'BaseS'Base denotes an unconstrained subtype of the type of S. This unconstrained subtype is called the base subtype of the type. "),(0,i.kt)("p",null,"S'MinS'Min denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Min(Left, Right : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the lesser of the values of the two parameters. "),(0,i.kt)("p",null,"Discussion: The formal parameter names are italicized because they cannot be used in calls - see 6.4. Such a specification cannot be written by the user because an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," is not permitted as the designator of a user-defined function, nor can its formal parameters be anonymous. "),(0,i.kt)("p",null,"S'MaxS'Max denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Max(Left, Right : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the greater of the values of the two parameters."),(0,i.kt)("p",null,"S'SuccS'Succ denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Succ(Arg : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"For an enumeration type, the function returns the value whose position number is one more than that of the value of Arg; Constraint_Error is raised if there is no such value of the type. For an integer type, the function returns the result of adding one to the value of Arg. For a fixed point type, the function returns the result of adding small to the value of Arg. For a floating point type, the function returns the machine number (as defined in 3.5.7) immediately above the value of Arg; Constraint_Error is raised if there is no such machine number. "),(0,i.kt)("p",null,"Ramification: S'Succ for a modular integer subtype wraps around if the value of Arg is S'Base'Last. S'Succ for a signed integer subtype might raise Constraint_Error if the value of Arg is S'Base'Last, or it might return the out-of-base-range value S'Base'Last+1, as is permitted for all predefined numeric operations. "),(0,i.kt)("p",null,"S'PredS'Pred denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Pred(Arg : S'Base)\n  return S'Base\n\n")),(0,i.kt)("p",null,"For an enumeration type, the function returns the value whose position number is one less than that of the value of Arg; Constraint_Error is raised if there is no such value of the type. For an integer type, the function returns the result of subtracting one from the value of Arg. For a fixed point type, the function returns the result of subtracting small from the value of Arg. For a floating point type, the function returns the machine number (as defined in 3.5.7) immediately below the value of Arg; Constraint_Error is raised if there is no such machine number. "),(0,i.kt)("p",null,"Ramification: S'Pred for a modular integer subtype wraps around if the value of Arg is S'Base'First. S'Pred for a signed integer subtype might raise Constraint_Error if the value of Arg is S'Base'First, or it might return the out-of-base-range value S'Base'First1, as is permitted for all predefined numeric operations. "),(0,i.kt)("p",null,'Paragraphs 28 through 37 were moved to 4.10, "Image Attributes". '),(0,i.kt)("p",null,"S'Wide_Wide_Width{AI95-00285-01} {AI12-0020-1} S'Wide_Wide_Width denotes the maximum length of a Wide_Wide_String returned by S'Wide_Wide_Image over all values of the subtype S, assuming a default implementation of S'Put_Image. It denotes zero for a subtype that has a null range. Its type is universal_integer."),(0,i.kt)("p",null,"S'Wide_Width{AI12-0020-1} S'Wide_Width denotes the maximum length of a Wide_String returned by S'Wide_Image over all values of the subtype S, assuming a default implementation of S'Put_Image. It denotes zero for a subtype that has a null range. Its type is universal_integer."),(0,i.kt)("p",null,"S'Width{AI12-0020-1} S'Width denotes the maximum length of a String returned by S'Image over all values of the subtype S, assuming a default implementation of S'Put_Image. It denotes zero for a subtype that has a null range. Its type is universal_integer."),(0,i.kt)("p",null,"S'Wide_Wide_Value{AI95-00285-01} S'Wide_Wide_Value denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Wide_Wide_Value(Arg : Wide_Wide_String)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value given an image of the value as a Wide_Wide_String, ignoring any leading or trailing spaces."),(0,i.kt)("p",null,"{AI05-0264-1} For the evaluation of a call on S'Wide_Wide_Value for an enumeration subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Wide_Wide_Image for a nongraphic character of the type), the result is the corresponding enumeration value; otherwise, Constraint_Error is raised. "),(0,i.kt)("p",null,"Discussion: It's not crystal clear that Range_Check is appropriate here, but it doesn't seem worthwhile to invent a whole new check name just for this weird case, so we decided to lump it in with Range_Check. "),(0,i.kt)("p",null,'To be honest: {8652/0096} {AI95-00053-01} A sequence of characters corresponds to the result of S\'Wide_Wide_Image if it is the same ignoring case. Thus, the case of an image of a nongraphic character does not matter. For example, Character\'Wide_Wide_Value("nul") does not raise Constraint_Error, even though Character\'Wide_Wide_Image returns "NUL" for the nul character. '),(0,i.kt)("p",null,"{AI05-0264-1} For the evaluation of a call on S'Wide_Wide_Value for an integer subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an integer literal, with an optional leading sign character (plus or minus for a signed type; only plus for a modular type), and the corresponding numeric value belongs to the base range of the type of S, then that value is the result; otherwise, Constraint_Error is raised."),(0,i.kt)("p",null,"Discussion: We considered allowing 'Value to return a representable but out-of-range value without a Constraint_Error. However, we currently require (see 4.9) in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-5.2#S0173"},"assignment_statement"),' like "X := ',"<","numeric_literal",">","\" that the value of the numeric-literal be in X's base range (at compile time), so it seems unfriendly and confusing to have a different range allowed for 'Value. Furthermore, for modular types, without the requirement for being in the base range, 'Value would have to handle arbitrarily long literals (since overflow never occurs for modular types). "),(0,i.kt)("p",null,"For the evaluation of a call on S'Wide_Wide_Value for a real subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of one of the following: "),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0006"},"numeric_literal")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0008"},"numeral"),".[",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0009"},"exponent"),"]"),(0,i.kt)("p",null,".",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0008"},"numeral"),"[",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0009"},"exponent"),"]"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0012"},"base"),"#",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0013"},"based_numeral"),".#[",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0009"},"exponent"),"]"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0012"},"base"),"#.",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0013"},"based_numeral"),"#[",(0,i.kt)("a",{parentName:"p",href:"./AA-2.4#S0009"},"exponent"),"] "),(0,i.kt)("p",null,"{AI05-0264-1} with an optional leading sign character (plus or minus), and if the corresponding numeric value belongs to the base range of the type of S, then that value is the result; otherwise, Constraint_Error is raised. The sign of a zero value is preserved (positive if none has been specified) if S'Signed_Zeros is True."),(0,i.kt)("p",null,"S'Wide_ValueS'Wide_Value denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Wide_Value(Arg : Wide_String)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value given an image of the value as a Wide_String, ignoring any leading or trailing spaces."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0264-1} {AI12-0020-1} For the evaluation of a call on S'Wide_Value for an enumeration subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Wide_Image for a value of the type, assuming a default implementation of S'Put_Image), the result is the corresponding enumeration value; otherwise, Constraint_Error is raised. For a numeric subtype S, the evaluation of a call on S'Wide_Value with Arg of type Wide_String is equivalent to a call on S'Wide_Wide_Value for a corresponding Arg of type Wide_Wide_String. "),(0,i.kt)("p",null,"This paragraph was deleted."),(0,i.kt)("p",null,"This paragraph was deleted.{8652/0096} {AI95-00053-01} "),(0,i.kt)("p",null,"Reason: S'Wide_Value is subtly different from S'Wide_Wide_Value for enumeration subtypes since S'Wide_Image might produce a different sequence of characters than S'Wide_Wide_Image if the enumeration literal uses characters outside of the predefined type Wide_Character. That is why we don't just define S'Wide_Value in terms of S'Wide_Wide_Value for enumeration subtypes. S'Wide_Value and S'Wide_Wide_Value for numeric subtypes yield the same result given the same sequence of characters. "),(0,i.kt)("p",null,"Paragraphs 44 through 51 were moved to Wide_Wide_Value. "),(0,i.kt)("p",null,"S'ValueS'Value denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Value(Arg : String)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value given an image of the value as a String, ignoring any leading or trailing spaces."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0264-1} {AI12-0020-1} For the evaluation of a call on S'Value for an enumeration subtype S, if the sequence of characters of the parameter (ignoring leading and trailing spaces) has the syntax of an enumeration literal and if it corresponds to a literal of the type of S (or corresponds to the result of S'Image for a value of the type, assuming a default implementation of S'Put_Image), the result is the corresponding enumeration value; otherwise, Constraint_Error is raised. For a numeric subtype S, the evaluation of a call on S'Value with Arg of type String is equivalent to a call on S'Wide_Wide_Value for a corresponding Arg of type Wide_Wide_String. "),(0,i.kt)("p",null,"Reason: {AI95-00285-01} S'Value is subtly different from S'Wide_Wide_Value for enumeration subtypes; see the discussion under S'Wide_Value. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI95-00285-01} An implementation may extend the Wide_Wide_Value, ","[Wide_Value, Value, Wide_Wide_Image, Wide_Image, and Image]"," attributes of a floating point type to support special values such as infinities and NaNs."),(0,i.kt)("p",null,"Proof: {AI95-00285-01} The permission is really only necessary for Wide_Wide_Value, because Value and Wide_Value are defined in terms of Wide_Wide_Value, and because the behavior of Wide_Wide_Image, Wide_Image, and Image is already unspecified for things like infinities and NaNs. "),(0,i.kt)("p",null,"Reason: This is to allow implementations to define full support for IEEE arithmetic. See also the similar permission for Get in A.10.9. "),(0,i.kt)("p",null,'{AI05-0182-1} {AI05-0262-1} {AI05-0269-1} An implementation may extend the Wide_Wide_Value, Wide_Value, and Value attributes of a character type to accept strings of the form "Hex_hhhhhhhh" (ignoring case) for any character (not just the ones for which Wide_Wide_Image would produce that form - see 3.5.2), as well as three-character strings of the form "\'X\'", where X is any character, including nongraphic characters. '),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"{AI05-0228-1} For a scalar type, the following language-defined representation aspect may be specified with an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," (see 13.1.1): "),(0,i.kt)("p",null,"Default_ValueThis aspect shall be specified by a static expression, and that expression shall be explicit, even if the aspect has a boolean type. Default_Value shall be specified only on a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),". "),(0,i.kt)("p",null,"Reason: The part about requiring an explicit expression is to disallow omitting the value for this aspect, which would otherwise be allowed by the rules of 13.1.1."),(0,i.kt)("p",null,"This is a representation aspect in order to disallow specifying it on a derived type that has inherited primitive subprograms; that is necessary as the sizes of out parameters could be different whether or not a Default_Value is specified (see 6.4.1). "),(0,i.kt)("p",null,"Aspect Description for Default_Value: Default value for a scalar subtype."),(0,i.kt)("p",null,"{AI05-0228-1} {AI12-0427-1} If a derived type inherits a boolean Default_Value aspect, the aspect may be specified to have any value for the derived type. If a derived type T does not inherit a Default_Value aspect, it shall not specify such an aspect if it inherits a primitive subprogram that has a parameter of type T of mode out. "),(0,i.kt)("p",null,"Reason: This overrides the 13.1.1 rule that says that a boolean aspect with a value True cannot be changed."),(0,i.kt)("p",null,"{AI12-0427-1} The second sentence is to avoid violating the rules specified in 6.4.1 about view conversions of out parameters with a specified Default_Value aspect. "),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI05-0228-1} The expected type for the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," specified for the Default_Value aspect is the type defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," on which it appears. "),(0,i.kt)("p",null,"NOTE 1   The evaluation of S'First or S'Last never raises an exception. If a scalar subtype S has a nonnull range, S'First and S'Last belong to this range. These values can, for example, always be assigned to a variable of subtype S. "),(0,i.kt)("p",null,'Discussion: This paragraph addresses an issue that came up with Ada 83, where for fixed point types, the end points of the range specified in the type definition were not necessarily within the base range of the type. However, it was later clarified (and we reconfirm it in 3.5.9, "Fixed Point Types") that the First and Last attributes reflect the true bounds chosen for the type, not the bounds specified in the type definition (which might be outside the ultimately chosen base range). '),(0,i.kt)("p",null,"NOTE 2   {AI12-0442-1} For a subtype of a scalar type, the result delivered by the attributes Succ, Pred, and Value can be outside to the subtype; similarly, the actual parameters of the attributes Succ, Pred, and Image can also be outside the subtype."),(0,i.kt)("p",null,"NOTE 3   {AI95-00285-01} {AI12-0020-1} For any value V (including any nongraphic character) of an enumeration subtype S without a specified Put_Image (see 4.10), S'Value(S'Image(V)) equals V, as do S'Wide_Value(S'Wide_Image(V)) and S'Wide_Wide_Value(S'Wide_Wide_Image(V)). None of these expressions ever raise Constraint_Error. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of ranges: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"-10 .. 10\nX .. X + 1\n0.0 .. 2.0*Pi\nRed .. Green     -- see 3.5.1\n1 .. 0           -- a null range\nTable'Range      -- a range attribute reference (see 3.6)\n\n")),(0,i.kt)("p",null,"Examples of range constraints: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"range -999.0 .. +999.0\nrange S'First+1 .. S'Last-1\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"S'Base is no longer defined for nonscalar types. One conceivable existing use of S'Base for nonscalar types is S'Base'Size where S is a generic formal private type. However, that is not generally useful because the actual subtype corresponding to S might be a constrained array or discriminated type, which would mean that S'Base'Size might very well overflow (for example, S'Base'Size where S is a constrained subtype of String will generally be 8 * (Integer'Last + 1)). For derived discriminated types that are packed, S'Base'Size might not even be well defined if the first subtype is constrained, thereby allowing some amount of normally required \"dope\" to have been squeezed out in the packing. Hence our conclusion is that S'Base'Size is not generally useful in a generic, and does not justify keeping the attribute Base for nonscalar types just so it can be used as a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix"),"."),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The attribute S'Base for a scalar subtype is now permitted anywhere a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," is permitted. S'Base'First .. S'Base'Last is the base range of the type. Using an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),", one cannot specify any subtype-specific attributes for the subtype denoted by S'Base (the base subtype)."),(0,i.kt)("p",null,"The attribute S'Range is now allowed for scalar subtypes."),(0,i.kt)("p",null,"The attributes S'Min and S'Max are now defined, and made available for all scalar types."),(0,i.kt)("p",null,"The attributes S'Succ, S'Pred, S'Image, S'Value, and S'Width are now defined for real types as well as discrete types."),(0,i.kt)("p",null,"Wide_String versions of S'Image and S'Value are defined. These are called S'Wide_Image and S'Wide_Value to avoid introducing ambiguities involving uses of these attributes with string literals. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We now use the syntactic category ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0102"},"range_attribute_reference")," since it is now syntactically distinguished from other attribute references."),(0,i.kt)("p",null,"The definition of S'Base has been moved here from 3.3.3 since it now applies only to scalar types."),(0,i.kt)("p",null,"More explicit rules are provided for nongraphic characters. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} The attributes Wide_Wide_Image, Wide_Wide_Value, and Wide_Wide_Width are new. Note that Wide_Image and Wide_Value are now defined in terms of Wide_Wide_Image and Wide_Wide_Value, but the image of types other than characters have not changed. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} The Wide_Image and Wide_Value attributes are now defined in terms of Wide_Wide_Image and Wide_Wide_Value, but the images of numeric types have not changed. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-2005"},"Inconsistencies With Ada 2005"),(0,i.kt)("p",null,"{AI05-0181-1} Correction: Soft hyphen (code point 173) is nongraphic in ISO/IEC 10646:2011 (and also in the 2003 version of that standard). Thus, we have given it the language-defined name soft_hyphen. This changes the result of Character'Image (and all of the related types and Image attributes) for this character, and changes the behavior of Character'Value (and all of the related types and Value attributes) for this character, and (in unusual circumstances), changes the result for Character'Width (and all of the related types and Width attributes). The vast majority of programs won't see any difference, as they are already prepared to handle nongraphic characters."),(0,i.kt)("p",null,'{AI05-0182-1} Correction: Added an Implementation Permissions to let Wide_Wide_Value, Wide_Value, and Value accept strings in the form of literals containing nongraphic characters and "Hex_hhhhhhhh" for Latin-1 and graphic characters. These were required to raise Constraint_Error in Ada 2005. Since these attributes aren\'t very useful, implementations were inconsistent as to whether these were accepted, and since code that would care why the attribute failed seems unlikely, this should not be a problem in practice. '),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0228-1} The new aspect Default_Value allows defining implicit initial values (see 3.3.1) for scalar types. "),(0,i.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0124-1} Corrigendum: An object can be now used as the prefix of the Image attribute (as well as Wide_Image and Wide_Wide_Image), a convenience feature already present in some implementations."),(0,i.kt)("p",null,"{AI12-0020-1} All of the Image-family attributes have been moved to 4.10. "),(0,i.kt)("h2",{id:"351--enumeration-types"},"3.5.1  Enumeration Types"),(0,i.kt)("p",null,"[ An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition")," defines an enumeration type.] "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"enumeration_type_definition",(0,i.kt)("a",{id:"S0038"})," ::=\n(",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0039"},"enumeration_literal_specification")," {, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0039"},"enumeration_literal_specification"),"})"),(0,i.kt)("p",null,"enumeration_literal_specification",(0,i.kt)("a",{id:"S0039"})," ::=  ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")),(0,i.kt)("p",null,"defining_character_literal",(0,i.kt)("a",{id:"S0040"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"{AI05-0227-1} {AI05-0299-1} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),"s in upper case [and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal"),"s] listed in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition")," shall be distinct. "),(0,i.kt)("p",null,"Proof: {AI05-0227-1} For character literals, this is a ramification of the normal disallowance of homographs explicitly declared immediately in the same declarative region. "),(0,i.kt)("p",null,"Reason: {AI05-0227-1} To ease implementation of the attribute Wide_Wide_Value, we require that all enumeration literals have distinct images. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"{AI05-0006-1} Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0039"},"enumeration_literal_specification")," is the explicit declaration of the corresponding enumeration literal: it declares a parameterless function, whose defining name is the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal"),", and whose result subtype is the base subtype of the enumeration type. "),(0,i.kt)("p",null,"Reason: This rule defines the profile of the enumeration literal, which is used in the various types of conformance. "),(0,i.kt)("p",null,"Ramification: The parameterless function associated with an enumeration literal is fully defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition"),"; a body is not permitted for it, and it never fails the Elaboration_Check when called. "),(0,i.kt)("p",null,"Discussion: {AI05-0006-1} The result subtype is primarily a concern when an enumeration literal is used as the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of a case statement, due to the full coverage requirement based on the nominal subtype. "),(0,i.kt)("p",null,"Each enumeration literal corresponds to a distinct value of the enumeration type, and to a distinct position number. The position number of the value of the first listed enumeration literal is zero; the position number of the value of each subsequent enumeration literal is one more than that of its predecessor in the list."),(0,i.kt)("p",null,"[The predefined order relations between values of the enumeration type follow the order of corresponding position numbers.]"),(0,i.kt)("p",null,"[ If the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")," is specified in more than one ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition"),", the corresponding enumeration literals are said to be overloaded. At any place where an overloaded enumeration literal occurs in the text of a program, the type of the enumeration literal has to be determinable from the context (see 8.6).] "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0038"},"enumeration_type_definition")," creates the enumeration type and its first subtype, which is constrained to the base range of the type. "),(0,i.kt)("p",null,"Ramification: The first subtype of a discrete type is always constrained, except in the case of a derived type whose parent subtype is Whatever'Base. "),(0,i.kt)("p",null,"When called, the parameterless function associated with an enumeration literal returns the corresponding value of the enumeration type. "),(0,i.kt)("p",null,"NOTE 1   If an enumeration literal occurs in a context that does not otherwise suffice to determine the type of the literal, then qualification by the name of the enumeration type is one way to resolve the ambiguity (see 4.7). "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Examples of enumeration types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0386-1} type Day        is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\ntype Month_Name is (January, February, March, April, May, June, July,\n                    August, September, October, November, December);\ntype Suit       is (Clubs, Diamonds, Hearts, Spades);\ntype Gender     is (M, F);\ntype Level      is (Low, Medium, Urgent);\ntype Color      is (White, Red, Yellow, Green, Blue, Brown, Black);\ntype Light      is (Red, Amber, Green); -- Red and Green are overloaded\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Hexa       is ('A', 'B', 'C', 'D', 'E', 'F');\ntype Mixed      is ('A', 'B', '*', B, None, '?', '%');\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Weekday is Day   range Mon .. Fri;\nsubtype Major   is Suit  range Hearts .. Spades;\nsubtype Rainbow is Color range Red .. Blue;  --  the Color Red, not the Light\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0040"},"defining_character_literal")," is new. It is used for the defining occurrence of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", analogously to ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),". Usage occurrences use the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0091"},"name")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," syntactic categories."),(0,i.kt)("p",null,"We emphasize the fact that an enumeration literal denotes a function, which is called to produce a value. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,i.kt)("p",null,"{AI05-0227-1} Correction: Required that all enumeration literals in a type have distinct images; this might not be the case since upper case conversion can map distinct characters to the same upper case character. This can only happen for identifiers using Unicode characters first allowed by Ada 2005; moreover, the original definition of Ada 2005 was confused and appeared to require inconsistent results from the Image attribute, so implementations that allowed problematic cases are rare; the problematic cases are very rare; so it is expected that this change would only affect test programs. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0006-1} Correction: Defined the result subtype of an enumeration literal to close a minor language hole. "),(0,i.kt)("h2",{id:"352--character-types"},"3.5.2  Character Types"),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"An enumeration type is said to be a character type if at least one of its enumeration literals is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),"."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0181-1} {AI05-0262-1} {AI05-0266-1} {AI12-0263-1} The predefined type Character is a character type whose values correspond to the 256 code points of Row 00 (also known as Latin-1) of the ISO/IEC 10646:2017 Basic Multilingual Plane (BMP). Each of the graphic characters of Row 00 of the BMP has a corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),' in Character. Each of the nongraphic characters of Row 00 has a corresponding language-defined name, which is not usable as an enumeration literal, but which is usable with the attributes Image, Wide_Image, Wide_Wide_Image, Value, Wide_Value, and Wide_Wide_Value; these names are given in the definition of type Character in A.1, "The Package Standard", but are set in italics. '),(0,i.kt)("p",null,"Discussion: {AI05-0262-1} {AI12-0263-1} Code point is defined in ISO/IEC 10646:2017. "),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0262-1} {AI12-0263-1} The predefined type Wide_Character is a character type whose values correspond to the 65536 code points of the ISO/IEC 10646:2017 Basic Multilingual Plane (BMP). Each of the graphic characters of the BMP has a corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," in Wide_Character. The first 256 values of Wide_Character have the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," or language-defined name as defined for Character. Each of the graphic_characters has a corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),"."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0262-1} {AI12-0263-1} The predefined type Wide_Wide_Character is a character type whose values correspond to the 2147483648 code points of the ISO/IEC 10646:2017 character set. Each of the graphic_characters has a corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," in Wide_Wide_Character. The first 65536 values of Wide_Wide_Character have the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," or language-defined name as defined for Wide_Character."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0262-1} The characters whose code point is larger than 16#FF# and which are not graphic",(0,i.kt)("em",{parentName:"p"},'characters have language-defined names which are formed by appending to the string "Hex'),'" the representation of their code point in hexadecimal as eight extended digits. As with other language-defined names, these names are usable only with the attributes (Wide',(0,i.kt)("em",{parentName:"p"},")Wide_Image and (Wide"),")Wide_Value; they are not usable as enumeration literals."),(0,i.kt)("p",null,'Reason: {AI95-00285-01} The language-defined names are not usable as enumeration literals to avoid "polluting" the name space. Since Wide_Character and Wide_Wide_Character are defined in Standard, if the language-defined names were usable as enumeration literals, they would hide other nonoverloadable declarations with the same names in use-d packages.'),(0,i.kt)("p",null,"Original Paragraphs 4 and 5 were deleted. "),(0,i.kt)("p",null,"NOTE 1   The language-defined library package Characters.Latin_1 (see A.3.3) includes the declaration of constants denoting control characters, lower case characters, and special characters of the predefined type Character. "),(0,i.kt)("p",null,"To be honest: The package ASCII does the same, but only for the first 128 characters of Character. Hence, it is an obsolescent package, and we no longer mention it here. "),(0,i.kt)("p",null,"NOTE 2   {AI05-0299-1} A conventional character set such as EBCDIC can be declared as a character type; the internal codes of the characters can be specified by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.4#S0350"},"enumeration_representation_clause")," as explained in subclause 13.4. "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Example of a character type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"The declaration of Wide_Character in package Standard hides use-visible declarations with the same defining identifier. In the unlikely event that an Ada 83 program had depended on such a use-visible declaration, and the program remains legal after the substitution of Standard.Wide_Character, the meaning of the program will be different. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"The presence of Wide_Character in package Standard means that an expression such as "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"'a' = 'b'\n\n")),(0,i.kt)("p",null,"is ambiguous in Ada 95, whereas in Ada 83 both literals could be resolved to be of type Character."),(0,i.kt)("p",null,"The change in visibility rules (see 4.2) for character literals means that additional qualification might be necessary to resolve expressions involving overloaded subprograms and character literals. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The type Character has been extended to have 256 positions, and the type Wide_Character has been added. Note that this change was already approved by the ARG for Ada 83 conforming compilers."),(0,i.kt)("p",null,"The rules for referencing character literals are changed (see 4.2), so that the declaration of the character type need not be directly visible to use its literals, similar to null and string literals. Context is used to resolve their type. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} Ada 95 defined most characters in Wide_Character to be graphic characters, while Ada 2005 uses the categorizations from ISO-10646:2003. It also provides language-defined names for all nongraphic characters. That means that in Ada 2005, Wide_Character'Wide_Value will raise Constraint_Error for a string representing a ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal")," of a nongraphic character, while Ada 95 would have accepted it. Similarly, the result of Wide_Character'Wide_Image will change for such nongraphic characters."),(0,i.kt)("p",null,"{AI95-00395-01} {AI05-0005-1} {AI05-0262-1} The language-defined names FFFE and FFFF were replaced by a consistent set of language-defined names for all nongraphic characters with code points greater than 16#FF#. That means that in Ada 2005, Wide_Character'Wide_Value(\"FFFE\") will raise Constraint_Error while Ada 95 would have accepted it. Similarly, the result of Wide_Character'Wide_Image will change for the position numbers 16#FFFE# and 16#FFFF#. It is very unlikely that this will matter in practice, as these names do not represent usable characters."),(0,i.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} Because of the previously mentioned changes to the Wide_Character'Wide_Image of various character values, the value of attribute Wide_Width will change for some subtypes of Wide_Character. However, the new language-defined names were chosen so that the value of Wide_Character'Wide_Width itself does not change."),(0,i.kt)("p",null,"{AI95-00285-01} The declaration of Wide_Wide_Character in package Standard hides use-visible declarations with the same defining identifier. In the (very) unlikely event that an Ada 95 program had depended on such a use-visible declaration, and the program remains legal after the substitution of Standard.Wide_Wide_Character, the meaning of the program will be different. "),(0,i.kt)("h4",{id:"extensions-to-ada-95-1"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} The type Wide_Wide_Character is new. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} Characters are now defined in terms of the entire ISO/IEC 10646:2003 character set."),(0,i.kt)("p",null,"{AI95-00285-01} {AI05-0248-1} We dropped the Implementation Advice for nonstandard interpretation of character sets; an implementation can do what it wants in a nonstandard mode, so there isn't much point to any advice. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005-1"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0181-1} Correction: Removed the position numbers of nongraphic characters from the text, as it is wrong and thus misleading."),(0,i.kt)("p",null,'{AI05-0262-1} Changed "code position" to "code point" consistently throughout the standard, as ISO/IEC 10646:2011 prefers "code point" and we are referring to the definition in that Standard. This change also reduces confusion between "code point" and "position number"; while these have the same values for the predefined character types, there is no required relationship for other character types. '),(0,i.kt)("h2",{id:"353--boolean-types"},"3.5.3  Boolean Types"),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"There is a predefined enumeration type named Boolean, ","[declared in the visible part of package Standard]",". It has the two enumeration literals False and True ordered with the relation False ","<"," True. Any descendant of the predefined type Boolean is called a boolean type. "),(0,i.kt)("p",null,'Implementation Note: An implementation is not required to support enumeration representation clauses on boolean types that impose an unacceptable implementation burden. See 13.4, "Enumeration Representation Clauses". However, it is generally straightforward to support representations where False is zero and True is 2**n  1 for some n. '),(0,i.kt)("h2",{id:"354--integer-types"},"3.5.4  Integer Types"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition")," defines an integer type; it defines either a signed integer type, or a modular integer type. The base range of a signed integer type includes at least the values of the specified range. A modular type is an integer type with all arithmetic modulo a specified positive modulus; such a type corresponds to an unsigned type with wrap-around semantics. "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"integer_type_definition",(0,i.kt)("a",{id:"S0041"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition")),(0,i.kt)("p",null,"signed",(0,i.kt)("em",{parentName:"p"},"integer_type_definition",(0,i.kt)("a",{id:"S0042"})," ::= range static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," .. static_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")),(0,i.kt)("p",null,"Discussion: We don't call this a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),", because it is rather different - not only is it required to be static, but the associated overload resolution rules are different than for normal range constraints. A similar comment applies to ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),". This used to be integer_range_specification but when we added support for modular types, it seemed overkill to have three levels of syntax rules, and just calling these signed_integer_range_specification and modular_range_specification loses the fact that they are defining different classes of types, which is important for the generic type matching rules. "),(0,i.kt)("p",null,"modular",(0,i.kt)("em",{parentName:"p"},"type_definition",(0,i.kt)("a",{id:"S0043"})," ::= mod static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")),(0,i.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI12-0444-1} Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition")," is expected to be of any integer type; they can be of different integer types. The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition")," is likewise expected to be of any integer type. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition")," shall be static, and their values shall be in the range System.Min_Int .. System.Max_Int."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition")," shall be static, and its value (the modulus) shall be positive, and shall be no greater than System.Max_Binary_Modulus if a power of 2, or no greater than System.Max_Nonbinary_Modulus if not. "),(0,i.kt)("p",null,"Reason: For a 2's-complement machine, supporting nonbinary moduli greater than System.Max_Int can be quite difficult, whereas essentially any binary moduli are straightforward to support, up to 2*System.Max_Int+2, so this justifies having two separate limits. "),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"The set of values for a signed integer type is the (infinite) set of mathematical integers","[, though only values of the base range of the type are fully supported for run-time operations]",". The set of values for a modular integer type are the values from 0 to one less than the modulus, inclusive."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition")," defines an integer type whose base range includes at least the values of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s and is symmetric about zero, excepting possibly an extra negative value. A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition")," also defines a constrained first subtype of the type, with a range whose bounds are given by the values of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s, converted to the type being defined. "),(0,i.kt)("p",null,"Implementation Note: {AI95-00114-01} The base range of a signed integer type might be much larger than is necessary to satisfy the above requirements. "),(0,i.kt)("p",null,"To be honest: The conversion mentioned above is not an implicit subtype conversion (which is something that happens at overload resolution, see 4.6), although it happens implicitly. Therefore, the freezing rules are not invoked on the type (which is important so that representation items can be given for the type). "),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition")," defines a modular type whose base range is from zero to one less than the given modulus. A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0043"},"modular_type_definition")," also defines a constrained first subtype of the type with a range that is the same as the base range of the type."),(0,i.kt)("p",null,"There is a predefined signed integer subtype named Integer","[, declared in the visible part of package Standard]",". It is constrained to the base range of its type. "),(0,i.kt)("p",null,"Reason: Integer is a constrained subtype, rather than an unconstrained subtype. This means that on assignment to an object of subtype Integer, a range check is required. On the other hand, an object of subtype Integer'Base is unconstrained, and no range check (only overflow check) is required on assignment. For example, if the object is held in an extended-length register, its value might be outside of Integer'First .. Integer'Last. All parameter and result subtypes of the predefined integer operators are of such unconstrained subtypes, allowing extended-length registers to be used as operands or for the result. In an earlier version of Ada 95, Integer was unconstrained. However, the fact that certain Constraint_Errors might be omitted or appear elsewhere was felt to be an undesirable upward inconsistency in this case. Note that for Float, the opposite conclusion was reached, partly because of the high cost of performing range checks when not actually necessary. Objects of subtype Float are unconstrained, and no range checks, only overflow checks, are performed for them. "),(0,i.kt)("p",null,"Integer has two predefined subtypes, ","[declared in the visible part of package Standard:]"," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Natural  is Integer range 0 .. Integer'Last;\nsubtype Positive is Integer range 1 .. Integer'Last;\n\n")),(0,i.kt)("p",null,"A type defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition")," is implicitly derived from root_integer, an anonymous predefined (specific) integer type, whose base range is System.Min_Int .. System.Max_Int. However, the base range of the new type is not inherited from root_integer, but is instead determined by the range or modulus specified by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition"),". ","[Integer literals are all of the type universal_integer, the universal type (see 3.4.1) for the class rooted at root_integer, allowing their use with the operations of any integer type.]"," "),(0,i.kt)("p",null,"Discussion: This implicit derivation is not considered exactly equivalent to explicit derivation via a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition"),". In particular, integer types defined via a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition")," inherit their base range from their parent type. A type defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition")," does not necessarily inherit its base range from root_integer. It is not specified whether the implicit derivation from root_integer is direct or indirect, not that it really matters. All we want is for all integer types to be descendants of root_integer."),(0,i.kt)("p",null,"{8652/0099} {AI95-00152-01} Note that this derivation does not imply any inheritance of subprograms. Subprograms are inherited only for types derived by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition")," (see 3.4), or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.3#S0233"},"private_extension_declaration")," (see 7.3, 7.3.1, and 12.5.1). "),(0,i.kt)("p",null,"Implementation Note: It is the intent that even nonstandard integer types (see below) will be descendants of root_integer, even though they might have a base range that exceeds that of root_integer. This causes no problem for static calculations, which are performed without range restrictions (see 4.9). However for run-time calculations, it is possible that Constraint_Error might be raised when using an operator of root_integer on the result of 'Val applied to a value of a nonstandard integer type. "),(0,i.kt)("p",null,"The position number of an integer value is equal to the value."),(0,i.kt)("p",null,"{AI95-00340-01} For every modular subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'Mod{AI95-00340-01} S'Mod denotes a function with the following specification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Mod (Arg : universal_integer)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns Arg mod S'Modulus, as a value of the type of S."),(0,i.kt)("p",null,"S'ModulusS'Modulus yields the modulus of the type of S, as a value of the type universal_integer. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition")," creates the integer type and its first subtype."),(0,i.kt)("p",null,"For a modular type, if the result of the execution of a predefined operator (see 4.5) is outside the base range of the type, the result is reduced modulo the modulus of the type to a value that is within the base range of the type."),(0,i.kt)("p",null,"For a signed integer type, the exception Constraint_Error is raised by the execution of an operation that cannot deliver the correct result because it is outside the base range of the type. ",'[ For any integer type, Constraint_Error is raised by the operators "/", "rem", and "mod" if the right operand is zero.]'),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation, the range of Integer shall include the range 2",(0,i.kt)("strong",{parentName:"p"},"15+1 .. +2"),"151."),(0,i.kt)("p",null,"If Long_Integer is predefined for an implementation, then its range shall include the range 2",(0,i.kt)("strong",{parentName:"p"},"31+1 .. +2"),"311."),(0,i.kt)("p",null,"System.Max_Binary_Modulus shall be at least 2**16. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI12-0444-1} For the execution of a predefined operation of a signed integer type, it is optional to raise Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced. "),(0,i.kt)("p",null,"Discussion: Constraint_Error is never raised for operations on modular types, except for divide-by-zero (and rem/mod-by-zero). "),(0,i.kt)("p",null,"An implementation may provide additional predefined signed integer types","[, declared in the visible part of Standard]",", whose first subtypes have names of the form Short_Integer, Long_Integer, Short_Short_Integer, Long_Long_Integer, etc. Different predefined integer types are allowed to have the same base range. However, the range of Integer should be no wider than that of Long_Integer. Similarly, the range of Short_Integer (if provided) should be no wider than Integer. Corresponding recommendations apply to any other predefined integer types. An implementation may support base ranges for which there is no corresponding named integer type. The range of each first subtype should be the base range of its type. "),(0,i.kt)("p",null,"{AI12-0444-1} Implementation defined: The predefined integer types declared in Standard."),(0,i.kt)("p",null,"{AI12-0444-1} An implementation may provide nonstandard integer types, descendants of root_integer that are declared outside of the specification of package Standard, which may have different characteristics than a type defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0041"},"integer_type_definition"),'. For example, a nonstandard integer type can have an asymmetric base range or it can be disallowed as an array or loop index (a very long integer). Any type descended from a nonstandard integer type is also nonstandard. An implementation may place arbitrary restrictions on the use of such types; it is implementation defined whether operators that are predefined for "any integer type" are defined for a particular nonstandard integer type. [In any case, such types are not permitted as ',(0,i.kt)("a",{parentName:"p",href:"./AA-12.3#S0318"},"explicit_generic_actual_parameter"),"s for formal scalar types - see 12.5.2.] "),(0,i.kt)("p",null,"Implementation defined: Any nonstandard integer types and the operators defined for them."),(0,i.kt)("p",null,"For a one's complement machine, the high bound of the base range of a modular type whose modulus is one less than a power of 2 may be equal to the modulus, rather than one less than the modulus. It is implementation defined for which powers of 2, if any, this permission is exercised."),(0,i.kt)("p",null,"{8652/0003} {AI95-00095-01} For a one's complement machine, implementations may support nonbinary modulus values greater than System.Max_Nonbinary_Modulus. It is implementation defined which specific values greater than System.Max_Nonbinary_Modulus, if any, are supported. "),(0,i.kt)("p",null,"Reason: On a one's complement machine, the natural full word type would have a modulus of 2**Word_Size1. However, we would want to allow the all-ones bit pattern (which represents negative zero as a number) in logical operations. These permissions are intended to allow that and the natural modulus value without burdening implementations with supporting expensive modulus values. "),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"An implementation should support Long_Integer in addition to Integer if the target machine supports 32-bit (or longer) arithmetic. No other named integer subtypes are recommended for package Standard. Instead, appropriate named integer subtypes should be provided in the library package Interfaces (see B.2). "),(0,i.kt)("p",null,"Implementation Advice: Long_Integer should be declared in Standard if the target supports 32-bit arithmetic. No other named integer subtypes should be declared in Standard."),(0,i.kt)("p",null,"Implementation Note: To promote portability, implementations should explicitly declare the integer (sub)types Integer and Long_Integer in Standard, and leave other predefined integer types anonymous. For implementations that already support Byte_Integer, etc., upward compatibility argues for keeping such declarations in Standard during the transition period, but perhaps generating a warning on use. A separate package Interfaces in the predefined environment is available for pre-declaring types such as Integer_8, Integer_16, etc. See B.2. In any case, if the user declares a subtype (first or not) whose range fits in, for example, a byte, the implementation can store variables of the subtype in a single byte, even if the base range of the type is wider. "),(0,i.kt)("p",null,"An implementation for a two's complement machine should support modular types with a binary modulus up to System.Max_Int*2+2. An implementation should support a nonbinary modulus up to Integer'Last. "),(0,i.kt)("p",null,"Implementation Advice: For a two's complement target, modular types with a binary modulus up to System.Max_Int*2+2 should be supported. A nonbinary modulus up to Integer'Last should be supported."),(0,i.kt)("p",null,'Reason: Modular types provide bit-wise "and", "or", "xor", and "not" operations. It is important for systems programming that these be available for all integer types of the target hardware. '),(0,i.kt)("p",null,"Ramification: Note that on a one's complement machine, the largest supported modular type would normally have a nonbinary modulus. On a two's complement machine, the largest supported modular type would normally have a binary modulus. "),(0,i.kt)("p",null,"Implementation Note: Supporting a nonbinary modulus greater than Integer'Last can impose an undesirable implementation burden on some machines. "),(0,i.kt)("p",null,'NOTE 1   Integer literals are of the anonymous predefined integer type universal_integer. Other integer types have no literals. However, the overload resolution rules (see 8.6, "The Context of Overload Resolution") allow expressions of the type universal_integer whenever an integer type is expected.'),(0,i.kt)("p",null,"NOTE 2   The same arithmetic operators are predefined for all signed integer types defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0042"},"signed_integer_type_definition"),' (see 4.5, "Operators and Expression Evaluation"). For modular types, these same operators are predefined, plus bit-wise logical operators (and, or, xor, and not). In addition, for the unsigned types declared in the language-defined package Interfaces (see B.2), functions are defined that provide bit-wise shifting and rotating.'),(0,i.kt)("p",null,"NOTE 3   Modular types match a ",(0,i.kt)("a",{parentName:"p",href:"./AA-12.1#S0314"},"generic_formal_parameter_declaration"),' of the form "type T is mod ',"<",">",'"; signed integer types match "type T is range ',"<",">",'" (see 12.5.2). '),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Examples of integer types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Page_Num  is range 1 .. 2_000;\ntype Line_Size is range 1 .. Max_Line_Size;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Small_Int   is Integer   range -10 .. 10;\nsubtype Column_Ptr  is Line_Size range 1 .. 10;\nsubtype Buffer_Size is Integer   range 0 .. Max;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Byte        is mod 256; -- an unsigned byte\ntype Hash_Index  is mod 97;  -- modulus is prime\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"An implementation is allowed to support any number of distinct base ranges for integer types, even if fewer integer types are explicitly declared in Standard."),(0,i.kt)("p",null,"Modular (unsigned, wrap-around) types are new. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Ada 83\'s integer types are now called "signed" integer types, to contrast them with "modular" integer types.'),(0,i.kt)("p",null,"Standard.Integer, Standard.Long_Integer, etc., denote constrained subtypes of predefined integer types, consistent with the Ada 95 model that only subtypes have names."),(0,i.kt)("p",null,"We now impose minimum requirements on the base range of Integer and Long_Integer."),(0,i.kt)("p",null,"We no longer explain integer type definition in terms of an equivalence to a normal type derivation, except to say that all integer types are by definition implicitly derived from root_integer. This is for various reasons."),(0,i.kt)("p",null,"First of all, the equivalence with a type derivation and a subtype declaration was not perfect, and was the source of various AIs (for example, is the conversion of the bounds static? Is a numeric type a derived type with respect to other rules of the language?)"),(0,i.kt)("p",null,"Secondly, we don't want to require that every integer size supported shall have a corresponding named type in Standard. Adding named types to Standard creates nonportabilities."),(0,i.kt)("p",null,'Thirdly, we don\'t want the set of types that match a formal derived type "type T is new Integer;" to depend on the particular underlying integer representation chosen to implement a given user-defined integer type. Hence, we would have needed anonymous integer types as parent types for the implicit derivation anyway. We have simply chosen to identify only one anonymous integer type - root_integer, and stated that every integer type is derived from it.'),(0,i.kt)("p",null,'Finally, the "fiction" that there were distinct preexisting predefined types for every supported representation breaks down for fixed point with arbitrary smalls, and was never exploited for enumeration types, array types, etc. Hence, there seems little benefit to pushing an explicit equivalence between integer type definition and normal type derivation. '),(0,i.kt)("h4",{id:"extensions-to-ada-95-2"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00340-01} The Mod attribute is new. It eases mixing of signed and unsigned values in an expression, which can be difficult as there may be no type which can contain all of the values of both of the types involved. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-2"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0003} {AI95-00095-01} Corrigendum: Added additional permissions for modular types on one's complement machines. "),(0,i.kt)("h2",{id:"355--operations-of-discrete-types"},"3.5.5  Operations of Discrete Types"),(0,i.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,i.kt)("p",null,"For every discrete subtype S, the following attributes are defined: "),(0,i.kt)("p",null,"S'PosS'Pos denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Pos(Arg : S'Base)\n  return universal_integer\n\n")),(0,i.kt)("p",null,"This function returns the position number of the value of Arg, as a value of type universal_integer."),(0,i.kt)("p",null,"S'ValS'Val denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Val(Arg : universal_integer)\n  return S'Base\n\n")),(0,i.kt)("p",null,"This function returns a value of the type of S whose position number equals the value of Arg. For the evaluation of a call on S'Val, if there is no value in the base range of its type with the given position number, Constraint_Error is raised. "),(0,i.kt)("p",null,"Ramification: By the overload resolution rules, a formal parameter of type universal_integer allows an actual parameter of any integer type."),(0,i.kt)("p",null,"Reason: We considered allowing S'Val for a signed integer subtype S to return an out-of-range value, but since checks were required for enumeration and modular types anyway, the allowance didn't seem worth the complexity of the rule."),(0,i.kt)("p",null,"{AI05-0297-1} {AI12-0071-1} For every static discrete subtype S for which there exists at least one value belonging to S that satisfies the predicates of S, the following attributes are defined:"),(0,i.kt)("p",null,"S'First_Valid{AI05-0297-1} {AI12-0071-1} S'First_Valid denotes the smallest value that belongs to S and satisfies the predicates of S. The value of this attribute is of the type of S."),(0,i.kt)("p",null,"S'Last_Valid{AI05-0297-1} {AI12-0071-1} S'Last_Valid denotes the largest value that belongs to S and satisfies the predicates of S. The value of this attribute is of the type of S. "),(0,i.kt)("p",null,"{AI05-0297-1} [First_Valid and Last_Valid ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),"s are always static expressions. Any explicit predicate of S can only have been specified by a Static_Predicate aspect.]"),(0,i.kt)("p",null,"Proof: An ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," is static if the prefix is a static subtype (see 4.9), (true by definition) and any arguments are static (there are none). Similarly, a dynamic predicate always makes a subtype nonstatic. QED. "),(0,i.kt)("p",null,"Reason: We require there to be at least one value so that these are always values of the subtype. (This sidesteps the question of what to return for a subtype with no values.) "),(0,i.kt)("p",null,"Discussion: These attributes are intended primarily for use in the case where the Static_Predicate aspect of S has been specified; First and Last are equivalent if these are allowed and there is no predicate. "),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"For the evaluation of a call on S'Pos for an enumeration subtype, if the value of the operand does not correspond to the internal code for any enumeration literal of its type ","[(perhaps due to an uninitialized variable)]",", then the implementation should raise Program_Error. This is particularly important for enumeration types with noncontiguous internal codes specified by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.4#S0350"},"enumeration_representation_clause"),". "),(0,i.kt)("p",null,"Implementation Advice: Program_Error should be raised for the evaluation of S'Pos for an enumeration type, if the value of the operand does not correspond to the internal code for any enumeration literal of the type."),(0,i.kt)("p",null,"Reason: We say Program_Error here, rather than Constraint_Error, because the main reason for such values is uninitialized variables, and the normal way to indicate such a use (if detected) is to raise Program_Error. (Other reasons would involve the misuse of low-level features such as Unchecked_Conversion.) "),(0,i.kt)("p",null,"NOTE 1   Indexing and loop iteration use values of discrete types."),(0,i.kt)("p",null,"NOTE 2   {AI05-0299-1} The predefined operations of a discrete type include the assignment operation, qualification, the membership tests, and the relational operators; for a boolean type they include the short-circuit control forms and the logical operators; for an integer type they include type conversion to and from other numeric types, as well as the binary and unary adding operators  and +, the multiplying operators, the unary operator abs, and the exponentiation operator. The assignment operation is described in 5.2. The other predefined operations are described in Clause 4."),(0,i.kt)("p",null,"NOTE 3   As for all types, objects of a discrete type have Size and Address attributes (see 13.3)."),(0,i.kt)("p",null,"NOTE 4   {AI12-0442-1} For a subtype of a discrete type, the result delivered by the attribute Val can be outside the subtype; similarly, the actual parameter of the attribute Pos can also be outside the subtype. The following relations are satisfied (in the absence of an exception) by these attributes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   S'Val(S'Pos(X)) = X\n   S'Pos(S'Val(N)) = N\n\n")),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Examples of attributes of discrete subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  For the types and subtypes declared in subclause 3.5.1 the following hold: \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Color'First   = White,   Color'Last   = Black\n--  Rainbow'First = Red,     Rainbow'Last = Blue\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown\n--  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4\n--  Color'Val(0)     = Rainbow'Val(0)     = White\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The attributes S'Succ, S'Pred, S'Width, S'Image, and S'Value have been generalized to apply to real types as well (see 3.5, \"Scalar Types\"). "),(0,i.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0297-1} The attributes S'First_Valid and S'Last_Valid are new. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0071-1} Corrigendum: Updated wording of the attributes S'First_Valid and S'Last_Valid to use the new term \"satisfies the predicates\" (see 3.2.4). "),(0,i.kt)("h2",{id:"356--real-types"},"3.5.6  Real Types"),(0,i.kt)("p",null,"Real types provide approximations to the real numbers, with relative bounds on errors for floating point types, and with absolute bounds for fixed point types. "),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"real_type_definition",(0,i.kt)("a",{id:"S0044"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition")),(0,i.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,i.kt)("p",null,"A type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0044"},"real_type_definition")," is implicitly derived from root_real, an anonymous predefined (specific) real type. ","[Hence, all real types, whether floating point or fixed point, are in the derivation class rooted at root_real.]"," "),(0,i.kt)("p",null,"Ramification: It is not specified whether the derivation from root_real is direct or indirect, not that it really matters. All we want is for all real types to be descendants of root_real."),(0,i.kt)("p",null,"{8652/0099} {AI95-00152-01} Note that this derivation does not imply any inheritance of subprograms. Subprograms are inherited only for types derived by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition")," (see 3.4), or a ",(0,i.kt)("a",{parentName:"p",href:"./AA-7.3#S0233"},"private_extension_declaration")," (see 7.3, 7.3.1, and 12.5.1)."),(0,i.kt)("p",null,"[ Real literals are all of the type universal_real, the universal type (see 3.4.1) for the class rooted at root_real, allowing their use with the operations of any real type. Certain multiplying operators have a result type of universal_fixed (see 4.5.5), the universal type for the class of fixed point types, allowing the result of the multiplication or division to be used where any specific fixed point type is expected.]"," "),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0044"},"real_type_definition")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," or the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition"),". "),(0,i.kt)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,i.kt)("p",null,"An implementation shall perform the run-time evaluation of a use of a predefined operator of root_real with an accuracy at least as great as that of any floating point type definable by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition"),". "),(0,i.kt)("p",null,"Ramification: Static calculations using the operators of root_real are exact, as for all static calculations. See 4.9. "),(0,i.kt)("p",null,"Implementation Note: The Digits attribute of the type used to represent root_real at run time is at least as great as that of any other floating point type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition"),", and its safe range includes that of any such floating point type with the same Digits attribute. On some machines, there might be real types with less accuracy but a wider range, and hence run-time calculations with root_real might not be able to accommodate all values that can be represented at run time in such floating point or fixed point types. "),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI95-00114-01} {AI12-0426-1} {AI12-0444-1} ","[For the execution of a predefined operation of a real type, it is optional to raise Constraint_Error if the result is outside the base range of the type, so long as the correct result is produced, or the Machine_Overflows attribute of the type is False (see G.2.1).]"),(0,i.kt)("p",null,"{AI12-0426-1} {AI12-0444-1} An implementation may provide nonstandard real types, descendants of root_real that are declared outside of the specification of package Standard, which may have different characteristics than a type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0044"},"real_type_definition"),'. For example, a nonstandard real type can have an asymmetric or unsigned base range, or its predefined operations can wrap around or "saturate" rather than overflow (modular or saturating arithmetic), or it can have a different accuracy model than is standard (see G.2.1). Any type descended from a nonstandard real type is also nonstandard. An implementation may place arbitrary restrictions on the use of such types; it is implementation defined whether operators that are predefined for "any real type" are defined for a particular nonstandard real type. [In any case, such types are not permitted as ',(0,i.kt)("a",{parentName:"p",href:"./AA-12.3#S0318"},"explicit_generic_actual_parameter"),"s for formal scalar types - see 12.5.2.] "),(0,i.kt)("p",null,"Implementation defined: Any nonstandard real types and the operators defined for them."),(0,i.kt)("p",null,"NOTE 1   As stated, real literals are of the anonymous predefined real type universal_real. Other real types have no literals. However, the overload resolution rules (see 8.6) allow expressions of the type universal_real whenever a real type is expected."),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0044"},"real_type_definition")," is modified to use the new syntactic categories ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition"),", instead of floating_point_constraint and fixed_point_constraint, because the semantics of a type definition are significantly different than the semantics of a constraint."),(0,i.kt)("p",null,"All discussion of model numbers, safe ranges, and machine numbers is moved to 3.5.7, 3.5.8, and G.2. Values of a fixed point type are now described as being multiples of the small of the fixed point type, and we have no need for model numbers, safe ranges, etc. for fixed point types."),(0,i.kt)("h2",{id:"357--floating-point-types"},"3.5.7  Floating Point Types"),(0,i.kt)("p",null,"For floating point types, the error bound is specified as a relative precision by giving the required minimum number of significant decimal digits. "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"floating",(0,i.kt)("em",{parentName:"p"},"point_definition",(0,i.kt)("a",{id:"S0045"})," ::=\ndigits static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," [",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),"]"),(0,i.kt)("p",null,"real",(0,i.kt)("em",{parentName:"p"},"range_specification",(0,i.kt)("a",{id:"S0046"})," ::=\nrange static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," .. static_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")),(0,i.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,i.kt)("p",null,"The requested decimal precision, which is the minimum number of significant decimal digits required for the floating point type, is specified by the value of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," given after the reserved word digits. This ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is expected to be of any integer type."),(0,i.kt)("p",null,"{AI12-0444-1} Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is expected to be of any real type","[; the types can be different]",". "),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"The requested decimal precision shall be specified by a static ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," whose value is positive and no greater than System.Max_Base_Digits. Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," shall also be static. If the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is omitted, the requested decimal precision shall be no greater than System.Max_Digits. "),(0,i.kt)("p",null,"Reason: We have added Max_Base_Digits to package System. It corresponds to the requested decimal precision of root_real. System.Max_Digits corresponds to the maximum value for Digits that may be specified in the absence of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),", for upward compatibility. These might not be the same if root_real has a base range that does not include \ufffd 10.0*",(0,i.kt)("em",{parentName:"p"},"(4"),"Max_Base_Digits). "),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," is illegal if the implementation does not support a floating point type that satisfies the requested decimal precision and range. "),(0,i.kt)("p",null,"Implementation defined: What combinations of requested decimal precision and range are supported for floating point types."),(0,i.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,i.kt)("p",null,"The set of values for a floating point type is the (infinite) set of rational numbers. The machine numbers of a floating point type are the values of the type that can be represented exactly in every unconstrained variable of the type. The base range (see 3.5) of a floating point type is symmetric around zero, except that it can include some extra negative values in some implementations."),(0,i.kt)("p",null,"Implementation Note: For example, if a 2's complement representation is used for the mantissa rather than a sign-mantissa or 1's complement representation, then there is usually one extra negative machine number."),(0,i.kt)("p",null,"To be honest: If the Signed_Zeros attribute is True, then minus zero could in a sense be considered a value of the type. However, for most purposes, minus zero behaves the same as plus zero."),(0,i.kt)("p",null,"The base decimal precision of a floating point type is the number of decimal digits of precision representable in objects of the type. The safe range of a floating point type is that part of its base range for which the accuracy corresponding to the base decimal precision is preserved by all predefined operations. "),(0,i.kt)("p",null,"Implementation Note: In most cases, the safe range and base range are the same. However, for some hardware, values near the boundaries of the base range might result in excessive inaccuracies or spurious overflows when used with certain predefined operations. For such hardware, the safe range would omit such values."),(0,i.kt)("p",null,"{AI12-0439-1} A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," defines a floating point type whose base decimal precision is no less than the requested decimal precision. If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is given, the safe range of the floating point type (and hence, also its base range) includes at least the values of the simple expressions given in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),". If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is not given, the safe (and base) range of the type includes at least the values of the range 10.0",(0,i.kt)("strong",{parentName:"p"},"(4*D) .. +10.0"),"(4*D) where D is the requested decimal precision. ","[The safe range can include other values as well. The attributes Safe_First and Safe_Last give the actual bounds of the safe range.]"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," also defines a first subtype of the type. If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is given, then the subtype is constrained to a range whose bounds are given by a conversion of the values of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," to the type being defined. Otherwise, the subtype is unconstrained."),(0,i.kt)("p",null,"To be honest: The conversion mentioned above is not an implicit subtype conversion (which is something that happens at overload resolution, see 4.6), although it happens implicitly. Therefore, the freezing rules are not invoked on the type (which is important so that representation items can be given for the type). "),(0,i.kt)("p",null,"There is a predefined, unconstrained, floating point subtype named Float","[, declared in the visible part of package Standard]",". "),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"[The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," creates the floating point type and its first subtype.] "),(0,i.kt)("h4",{id:"implementation-requirements-2"},"Implementation Requirements"),(0,i.kt)("p",null,"In an implementation that supports floating point types with 6 or more digits of precision, the requested decimal precision for Float shall be at least 6."),(0,i.kt)("p",null,"If Long_Float is predefined for an implementation, then its requested decimal precision shall be at least 11. "),(0,i.kt)("h4",{id:"implementation-permissions-3"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI12-0444-1} An implementation is allowed to provide additional predefined floating point types","[, declared in the visible part of Standard]",", whose (unconstrained) first subtypes have names of the form Short_Float, Long_Float, Short_Short_Float, Long_Long_Float, etc. Different predefined floating point types are allowed to have the same base decimal precision. However, the precision of Float should be no greater than that of Long_Float. Similarly, the precision of Short_Float (if provided) should be no greater than Float. Corresponding recommendations apply to any other predefined floating point types. An implementation may support base decimal precisions for which there is no corresponding named floating point type. "),(0,i.kt)("p",null,"Implementation defined: The predefined floating point types declared in Standard."),(0,i.kt)("h4",{id:"implementation-advice-2"},"Implementation Advice"),(0,i.kt)("p",null,"An implementation should support Long_Float in addition to Float if the target machine supports 11 or more digits of precision. No other named floating point subtypes are recommended for package Standard. Instead, appropriate named floating point subtypes should be provided in the library package Interfaces (see B.2). "),(0,i.kt)("p",null,"Implementation Advice: Long_Float should be declared in Standard if the target supports 11 or more digits of precision. No other named float subtypes should be declared in Standard."),(0,i.kt)("p",null,"Implementation Note: To promote portability, implementations should explicitly declare the floating point (sub)types Float and Long_Float in Standard, and leave other predefined float types anonymous. For implementations that already support Short_Float, etc., upward compatibility argues for keeping such declarations in Standard during the transition period, but perhaps generating a warning on use. A separate package Interfaces in the predefined environment is available for pre-declaring types such as Float_32, IEEE_Float_64, etc. See B.2. "),(0,i.kt)("p",null,"NOTE 1   If a floating point subtype is unconstrained, then assignments to variables of the subtype involve only Overflow_Checks, never Range_Checks. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"Examples of floating point types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Coefficient is digits 10 range -1.0 .. 1.0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Real is digits 8;\ntype Mass is digits 7 range 0.0 .. 1.0E35;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"subtype Probability is Real range 0.0 .. 1.0;   --   a subtype with a smaller range\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-1"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"No Range_Checks, only Overflow_Checks, are performed on variables (or parameters) of an unconstrained floating point subtype. This is upward compatible for programs that do not raise Constraint_Error. For those that do raise Constraint_Error, it is possible that the exception will be raised at a later point, or not at all, if extended range floating point registers are used to hold the value of the variable (or parameter). "),(0,i.kt)("p",null,"Reason: This change was felt to be justified by the possibility of improved performance on machines with extended-range floating point registers. An implementation need not take advantage of this relaxation in the range checking; it can hide completely the use of extended range registers if desired, presumably at some run-time expense. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rules for floating_point_constraint and floating_accuracy_definition are removed. The syntax rules for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0045"},"floating_point_definition")," and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," are new."),(0,i.kt)("p",null,"A syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),' is given in 3.5.9, "Fixed Point Types". In J.3 we indicate that a ',(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," may be applied to a floating point ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," as well (to be compatible with Ada 83's floating_point_constraint)."),(0,i.kt)("p",null,"Discussion of model numbers is postponed to 3.5.8 and G.2. The concept of safe numbers has been replaced by the concept of the safe range of values. The bounds of the safe range are given by T'Safe_First .. T'Safe_Last, rather than -T'Safe_Large .. T'Safe_Large, since on some machines the safe range is not perfectly symmetric. The concept of machine numbers is new, and is relevant to the definition of Succ and Pred for floating point numbers. "),(0,i.kt)("h2",{id:"358--operations-of-floating-point-types"},"3.5.8  Operations of Floating Point Types"),(0,i.kt)("h4",{id:"static-semantics-9"},"Static Semantics"),(0,i.kt)("p",null,"The following attribute is defined for every floating point subtype S:"),(0,i.kt)("p",null,"S'Digits{8652/0004} {AI95-00203-01} S'Digits denotes the requested decimal precision for the subtype S. The value of this attribute is of the type universal_integer. The requested decimal precision of the base subtype of a floating point type T is defined to be the largest value of d for which\nceiling(d * log(10) / log(T'Machine_Radix)) + g ","<","= T'Model_Mantissa\nwhere g is 0 if Machine_Radix is a positive power of 10 and 1 otherwise. "),(0,i.kt)("p",null,"NOTE 1   The predefined operations of a floating point type include the assignment operation, qualification, the membership tests, and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators  and +, certain multiplying operators, the unary operator abs, and the exponentiation operator."),(0,i.kt)("p",null,"NOTE 2   As for all types, objects of a floating point type have Size and Address attributes (see 13.3). Other attributes of floating point types are defined in A.5.3. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-3"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0004} {AI95-00203-01} Corrigendum: Corrected the formula for Digits when the Machine_Radix is 10. "),(0,i.kt)("h2",{id:"359--fixed-point-types"},"3.5.9  Fixed Point Types"),(0,i.kt)("p",null,"A fixed point type is either an ordinary fixed point type, or a decimal fixed point type. The error bound of a fixed point type is specified as an absolute value, called the delta of the fixed point type. "),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("p",null,"fixed_point_definition",(0,i.kt)("a",{id:"S0047"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition")),(0,i.kt)("p",null,"ordinary",(0,i.kt)("em",{parentName:"p"},"fixed_point_definition",(0,i.kt)("a",{id:"S0048"})," ::=\ndelta static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"  ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")),(0,i.kt)("p",null,"decimal",(0,i.kt)("em",{parentName:"p"},"fixed_point_definition",(0,i.kt)("a",{id:"S0049"})," ::=\ndelta static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," digits static_",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," [",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),"]"),(0,i.kt)("p",null,"{AI12-0152-1} digits",(0,i.kt)("em",{parentName:"p"},"constraint",(0,i.kt)("a",{id:"S0050"})," ::=\ndigits static"),(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," [",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"]"),(0,i.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition"),", the delta of the type is specified by the value of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," given after the reserved word delta; this ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is expected to be of any real type. For a type defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition")," (a decimal fixed point type), the number of significant decimal digits for its first subtype (the digits of the first subtype) is specified by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," given after the reserved word digits; this ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," is expected to be of any integer type."),(0,i.kt)("p",null,"{AI12-0159-1} The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," is expected to be of any integer type. "),(0,i.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,i.kt)("p",null,"In a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),", the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression"),"s given after the reserved words delta and digits shall be static; their values shall be positive."),(0,i.kt)("p",null,"{AI95-00100-01} The set of values of a fixed point type comprise the integral multiples of a number called the small of the type. The machine numbers of a fixed point type are the values of the type that can be represented exactly in every unconstrained variable of the type. For a type defined by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition")," (an ordinary fixed point type), the small may be specified by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," (see 13.3); if so specified, it shall be no greater than the delta of the type. If not specified, the small of an ordinary fixed point type is an implementation-defined power of two less than or equal to the delta. "),(0,i.kt)("p",null,"Implementation defined: The small of an ordinary fixed point type."),(0,i.kt)("p",null,"For a decimal fixed point type, the small equals the delta; the delta shall be a power of 10. If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification")," is given, both bounds of the range shall be in the range (10",(0,i.kt)("strong",{parentName:"p"},"digits1)*delta .. +(10"),"digits1)*delta."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition")," is illegal if the implementation does not support a fixed point type with the given small and specified range or digits. "),(0,i.kt)("p",null,"Implementation defined: What combinations of small, range, and digits are supported for fixed point types."),(0,i.kt)("p",null,"For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),", the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," shall denote a decimal fixed point subtype. "),(0,i.kt)("p",null,"To be honest: Or, as an obsolescent feature, a floating point subtype is permitted - see J.3. "),(0,i.kt)("h4",{id:"static-semantics-10"},"Static Semantics"),(0,i.kt)("p",null,"The base range (see 3.5) of a fixed point type is symmetric around zero, except possibly for an extra negative value in some implementations."),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition")," defines an ordinary fixed point type whose base range includes at least all multiples of small that are between the bounds specified in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),". The base range of the type does not necessarily include the specified bounds themselves. An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0048"},"ordinary_fixed_point_definition")," also defines a constrained first subtype of the type, with each bound of its range given by the closer to zero of: "),(0,i.kt)("p",null,"the value of the conversion to the fixed point type of the corresponding ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0046"},"real_range_specification"),"; "),(0,i.kt)("p",null,"To be honest: The conversion mentioned above is not an implicit subtype conversion (which is something that happens at overload resolution, see 4.6), although it happens implicitly. Therefore, the freezing rules are not invoked on the type (which is important so that representation items can be given for the type). "),(0,i.kt)("p",null,"the corresponding bound of the base range. "),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition")," defines a decimal fixed point type whose base range includes at least the range (10",(0,i.kt)("strong",{parentName:"p"},"digits1)*delta .. +(10"),"digits1)",(0,i.kt)("em",{parentName:"p"},"delta. A ",(0,i.kt)("a",{parentName:"em",href:"./AA-3.5#S0049"},"decimal_fixed_point_definition")," also defines a constrained first subtype of the type. If a ",(0,i.kt)("a",{parentName:"em",href:"./AA-3.5#S0046"},"real_range_specification")," is given, the bounds of the first subtype are given by a conversion of the values of the ",(0,i.kt)("a",{parentName:"em",href:"./AA-4.4#S0132"},"expression"),"s of the ",(0,i.kt)("a",{parentName:"em",href:"./AA-3.5#S0046"},"real_range_specification"),". Otherwise, the range of the first subtype is (10**digits1)"),"delta .. +(10*",(0,i.kt)("em",{parentName:"p"},"digits1)"),"delta."),(0,i.kt)("p",null,"To be honest: The conversion mentioned above is not an implicit subtype conversion (which is something that happens at overload resolution, see 4.6), although it happens implicitly. Therefore, the freezing rules are not invoked on the type (which is important so that representation items can be given for the type). "),(0,i.kt)("h4",{id:"dynamic-semantics-5"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition")," creates the fixed point type and its first subtype."),(0,i.kt)("p",null,"{AI12-0152-1} For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," on a decimal fixed point subtype with a given delta, if it does not have a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),", then it specifies an implicit range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta, where D is the value of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),". A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," is compatible with a decimal fixed point subtype if the value of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," is no greater than the digits of the subtype, and if it specifies (explicitly or implicitly) a range that is compatible with the subtype. "),(0,i.kt)("p",null,"Discussion: Except for the requirement that the digits specified be no greater than the digits of the subtype being constrained, a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," is essentially equivalent to a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),"."),(0,i.kt)("p",null,"Consider the following example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type D is delta 0.01 digits 7 range -0.00 .. 9999.99;\n\n")),(0,i.kt)("p",null,"The compatibility rule implies that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),' "digits 6" specifies an implicit range of "9999.99 .. 9999.99". Thus, "digits 6" is not compatible with the constraint of D, but "digits 6 range 0.00 .. 9999.99" is compatible.'),(0,i.kt)("p",null,"{AI95-00114-01} A value of a scalar type belongs to a constrained subtype of the type if it belongs to the range of the subtype. Attributes like Digits and Delta have no effect on this fundamental rule. So the obsolescent forms of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint"),'s that are called "accuracy constraints" in RM83 don\'t really represent constraints on the values of the subtype, but rather primarily affect compatibility of the "constraint" with the subtype being "constrained". In this sense, they might better be called "subtype assertions" rather than "constraints".'),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," on a decimal fixed point subtype is a combination of an assertion about the digits of the subtype being further constrained, and a constraint on the range of the subtype being defined, either explicit or implicit. "),(0,i.kt)("p",null,"{AI12-0152-1} The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint"),", if any. If a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0036"},"range_constraint")," is given, a check is made that the bounds of the range are both in the range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta, where D is the value of the (static) ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression")," given after the reserved word digits. If this check fails, Constraint_Error is raised. "),(0,i.kt)("h4",{id:"implementation-requirements-3"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall support at least 24 bits of precision (including the sign bit) for fixed point types. "),(0,i.kt)("p",null,"Reason: This is sufficient to represent Standard.Duration with a small no more than 50 milliseconds. "),(0,i.kt)("h4",{id:"implementation-permissions-4"},"Implementation Permissions"),(0,i.kt)("p",null,"Implementations are permitted to support only smalls that are a power of two. In particular, all decimal fixed point type declarations can be disallowed. Note however that conformance with the Information Systems Annex requires support for decimal smalls, and decimal fixed point type declarations with digits up to at least 18. "),(0,i.kt)("p",null,'Implementation Note: The accuracy requirements for multiplication, division, and conversion (see G.2.1, "Model of Floating Point Arithmetic") are such that support for arbitrary smalls should be practical without undue implementation effort. Therefore, implementations should support fixed point types with arbitrary values for small (within reason). One reasonable limitation would be to limit support to fixed point types that can be converted to the most precise floating point type without loss of precision (so that Fixed_IO is implementable in terms of Float_IO). '),(0,i.kt)("p",null,"NOTE   {AI12-0442-1} The specified bounds themselves can be outside the base range of an ordinary fixed point type so that the range specification can be given in a natural way, such as: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Fraction is delta 2.0**(-15) range -1.0 .. 1.0;\n  \n\n")),(0,i.kt)("p",null,"{AI12-0442-1} With 2's complement hardware, such a type would typically have a signed 16-bit representation, using 1 bit for the sign and 15 bits for fraction, resulting in a base range of 1.0 .. 1.02.0**(15). "),(0,i.kt)("h4",{id:"examples-6"},"Examples"),(0,i.kt)("p",null,"Examples of fixed point types and subtypes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Volt is delta 0.125 range 0.0 .. 255.0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"  -- A pure fraction which requires all the available\n  -- space in a word can be declared as the type Fraction:\ntype Fraction is delta System.Fine_Delta range -1.0 .. 1.0;\n  -- Fraction'Last = 1.0  System.Fine_Delta\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Money is delta 0.01 digits 15;  -- decimal fixed point\nsubtype Salary is Money digits 10;\n  -- Money'Last = 10.0**13  0.01, Salary'Last = 10.0**8  0.01\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83-2"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"In Ada 95, S'Small always equals S'Base'Small, so if an implementation chooses a small for a fixed point type smaller than required by the delta, the value of S'Small in Ada 95 might not be the same as it was in Ada 83. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,i.kt)("p",null,"{AI05-0005-1} Decimal fixed point types are new, though their capabilities are essentially similar to that available in Ada 83 with a fixed point type whose small equals its delta and both are a power of 10. However, in the Information Systems Annex, additional requirements are placed on the support of decimal fixed point types (e.g. a minimum of 18 digits of precision). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The syntax rules for fixed_point_constraint and fixed_accuracy_definition are removed. The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0047"},"fixed_point_definition")," is new. A syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint")," is included in the Obsolescent features (to be compatible with Ada 83's fixed_point_constraint). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-4"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{AI95-00100-01} Added wording to define the machine numbers of fixed point types; this is needed by the static evaluation rules. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2012"},"Incompatibilities With Ada 2012"),(0,i.kt)("p",null,"{AI12-0152-1} Corrigendum: Changed the syntax so that the value following digits in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint")," is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),". This is compatible with one very unlikely exception: if the digits expression is a static expression of a modular type using an unparenthesized logical operator (like and or or). Parenthesizing the expression will make it legal in that case. The change is necessary to eliminate syntax ambguities in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition"),"s. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012-1"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0159-1} Corrigendum:Added wording to define the expected type for a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),". This was missing since Ada 95, but as it is obvious and unchanged from Ada 83, we don't consider it an incompatibility. "),(0,i.kt)("h2",{id:"3510--operations-of-fixed-point-types"},"3.5.10  Operations of Fixed Point Types"),(0,i.kt)("h4",{id:"static-semantics-11"},"Static Semantics"),(0,i.kt)("p",null,"The following attributes are defined for every fixed point subtype S: "),(0,i.kt)("p",null,"S'Small{8652/0005} {AI95-00054-01} {AI12-0367-1} S'Small denotes the small of the type of S. The value of this attribute is of the type universal_real. Small may be specified for nonderived ordinary fixed point types via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," (see 13.3); the expression of such a clause shall be static and positive."),(0,i.kt)("p",null,"Aspect Description for Small: Scale factor for a fixed point type."),(0,i.kt)("p",null,"S'DeltaS'Delta denotes the delta of the fixed point subtype S. The value of this attribute is of the type universal_real. "),(0,i.kt)("p",null,"Reason: The delta is associated with the subtype as opposed to the type, because of the possibility of an (obsolescent) ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint"),"."),(0,i.kt)("p",null,"S'ForeS'Fore yields the minimum number of characters needed before the decimal point for the decimal representation of any value of the subtype S, assuming that the representation does not include an exponent, but includes a one-character prefix that is either a minus sign or a space. (This minimum number does not include superfluous zeros or underlines, and is at least 2.) The value of this attribute is of the type universal_integer."),(0,i.kt)("p",null,"S'AftS'Aft yields the number of decimal digits needed after the decimal point to accommodate the delta of the subtype S, unless the delta of the subtype S is greater than 0.1, in which case the attribute yields the value one. ","[(S'Aft is the smallest positive integer N for which (10*",(0,i.kt)("em",{parentName:"p"},"N)"),"S'Delta is greater than or equal to one.)]"," The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"The following additional attributes are defined for every decimal fixed point subtype S: "),(0,i.kt)("p",null,"S'DigitsS'Digits denotes the digits of the decimal fixed point subtype S, which corresponds to the number of decimal digits that are representable in objects of the subtype. The value of this attribute is of the type universal_integer. Its value is determined as follows: "),(0,i.kt)("p",null,"For a first subtype or a subtype defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," with a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),", the digits is the value of the expression given after the reserved word digits;"),(0,i.kt)("p",null,"{AI12-0426-1} For a subtype defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," without a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0050"},"digits_constraint"),", the digits of the subtype is the same as that of the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"; "),(0,i.kt)("p",null,"Implementation Note: Although a decimal subtype can be both range-constrained and digits-constrained, the digits constraint is intended to control the Size attribute of the subtype. For decimal types, Size can be important because input/output of decimal types is so common. "),(0,i.kt)("p",null,"The digits of a base subtype is the largest integer D such that the range (10",(0,i.kt)("strong",{parentName:"p"},"D1)*delta .. +(10"),"D1)*delta is included in the base range of the type."),(0,i.kt)("p",null,"S'ScaleS'Scale denotes the scale of the subtype S, defined as the value N such that S'Delta = 10.0**(N). ","[The scale indicates the position of the point relative to the rightmost significant digits of values of subtype S.]"," The value of this attribute is of the type universal_integer. "),(0,i.kt)("p",null,"Ramification: S'Scale is negative if S'Delta is greater than one. By contrast, S'Aft is always positive. "),(0,i.kt)("p",null,"S'RoundS'Round denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"function S'Round(X : universal_real)\n  return S'Base\n\n")),(0,i.kt)("p",null,"The function returns the value obtained by rounding X (away from 0, if X is midway between two values of the type of S). "),(0,i.kt)("p",null,"NOTE 1   All subtypes of a fixed point type will have the same value for the Delta attribute, in the absence of ",(0,i.kt)("a",{parentName:"p",href:"./AA-J.3#S0367"},"delta_constraint"),"s (see J.3)."),(0,i.kt)("p",null,"NOTE 2   S'Scale is not always the same as S'Aft for a decimal subtype; for example, if S'Delta = 1.0 then S'Aft is 1 while S'Scale is 0."),(0,i.kt)("p",null,"NOTE 3   The predefined operations of a fixed point type include the assignment operation, qualification, the membership tests, and explicit conversion to and from other numeric types. They also include the relational operators and the following predefined arithmetic operators: the binary and unary adding operators  and +, multiplying operators, and the unary operator abs."),(0,i.kt)("p",null,"NOTE 4   As for all types, objects of a fixed point type have Size and Address attributes (see 13.3). Other attributes of fixed point types are defined in A.5.4. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-5"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0005} {AI95-00054-01} Corrigendum: Clarified that small may be specified only for ordinary fixed point types. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012-2"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0367-1} Correction: Clarified that small may be specified only with positive values."))}h.isMDXComponent=!0}}]);