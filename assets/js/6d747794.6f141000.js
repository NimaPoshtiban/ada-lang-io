"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4358],{70662:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>p,default:()=>m,frontMatter:()=>f,metadata:()=>h,toc:()=>g});var o=n(91716),s=Object.defineProperty,a=Object.defineProperties,i=Object.getOwnPropertyDescriptors,r=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&d(e,n,t[n]);if(r)for(var n of r(t))c.call(t,n)&&d(e,n,t[n]);return e};const f={title:"9.1 Object-Oriented Design"},p=void 0,h={unversionedId:"style-guide/s9/01",id:"style-guide/s9/01",title:"9.1 Object-Oriented Design",description:"You will find it easier to take advantage of many of the concepts in",source:"@site/docs/style-guide/s9/01.mdx",sourceDirName:"style-guide/s9",slug:"/style-guide/s9/01",permalink:"/docs/style-guide/s9/01",draft:!1,tags:[],version:"current",frontMatter:{title:"9.1 Object-Oriented Design"},sidebar:"styleGuideSidebar",previous:{title:"9. Object-Oriented Features",permalink:"/docs/style-guide/s9/"},next:{title:"9.2 Tagged Type Hierarchies",permalink:"/docs/style-guide/s9/02"}},b={},g=[],y={toc:g};function m(e){var t,n=e,{components:s}=n,d=((e,t)=>{var n={};for(var o in e)l.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&r)for(var o of r(e))t.indexOf(o)<0&&c.call(e,o)&&(n[o]=e[o]);return n})(n,["components"]);return(0,o.kt)("wrapper",(t=u(u({},y),d),a(t,i({components:s,mdxType:"MDXLayout"}))),(0,o.kt)("p",null,"You will find it easier to take advantage of many of the concepts in\nthis chapter if you have done an object-oriented design. The results of\nan object-oriented design would include a set of meaningful abstractions\nand hierarchy of classes. The abstractions need to include the\ndefinition of the design objects, including structure and state, the\noperations on the objects, and the intended encapsulation for each\nobject. The details on designing these abstractions and the hierarchy of\nclasses are beyond the scope of this book. A number of good sources\nexist for this detail, including Rumbaugh et al. (1991), Jacobson et al.\n(1992), Software Productivity Consortium (1993), and Booch (1994)."),(0,o.kt)("p",null,'An important part of the design process is deciding on the overall\norganization of the system. Looking at a single type, a single package,\nor even a single class of types by itself is probably the wrong place to\nstart. The appropriate level to start is more at the level of\n"subsystem" or "framework." You should use child packages (Guidelines\n4.1.1 and 4.2.2) to group sets of abstractions into subsystems\nrepresenting reusable frameworks. You should distinguish the "abstract"\nreusable core of the framework from the particular "instantiation" of\nthe framework. Presuming the framework is constructed properly, the\nabstract core and its instantiation can be separated into distinct\nsubsystems within the package hierarchy because the internals of an\nabstract reusable framework probably do not need to be visible to a\nparticular instantiation of the framework.'))}m.isMDXComponent=!0}}]);