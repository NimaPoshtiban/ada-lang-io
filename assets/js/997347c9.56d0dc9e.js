"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6417],{4492:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>f,contentTitle:()=>h,default:()=>b,frontMatter:()=>m,metadata:()=>p,toc:()=>g});var a=t(1716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,u=(e,n,t)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,c=(e,n)=>{for(var t in n||(n={}))l.call(n,t)&&u(e,t,n[t]);if(s)for(var t of s(n))d.call(n,t)&&u(e,t,n[t]);return e};const m={title:"Readability",sidebar_position:3},h=void 0,p={unversionedId:"style-guide/Readability",id:"style-guide/Readability",title:"Readability",description:"This chapter recommends ways of using Ada features to make reading and",source:"@site/docs/style-guide/Readability.mdx",sourceDirName:"style-guide",slug:"/style-guide/Readability",permalink:"/docs/style-guide/Readability",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Readability",sidebar_position:3},sidebar:"styleGuideSidebar",previous:{title:"Source Code Presentation",permalink:"/docs/style-guide/Source_Code_Presentation"},next:{title:"Program Structure",permalink:"/docs/style-guide/Program_Structure"}},f={},g=[{value:"Spelling",id:"spelling",level:2},{value:"Use of Underscores",id:"use-of-underscores",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Numbers",id:"numbers",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"instantiation",id:"instantiation",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Capitalization",id:"capitalization",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"instantiation",id:"instantiation-1",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"automation notes",id:"automation-notes",level:4},{value:"Abbreviations",id:"abbreviations",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Names",id:"names",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"notes",id:"notes-1",level:4},{value:"Subtype Names",id:"subtype-names",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4},{value:"Object Names",id:"object-names",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-3",level:4},{value:"Naming of Tagged Types and Associated Packages",id:"naming-of-tagged-types-and-associated-packages",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"instantiation",id:"instantiation-2",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"notes",id:"notes-4",level:4},{value:"Program Unit Names",id:"program-unit-names",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"notes",id:"notes-5",level:4},{value:"Constants and Named Numbers",id:"constants-and-named-numbers",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"notes",id:"notes-6",level:4},{value:"Exceptions",id:"exceptions",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"Constructors",id:"constructors",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"instantiation",id:"instantiation-3",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Comments",id:"comments",level:2},{value:"General Comments",id:"general-comments",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"automation notes",id:"automation-notes-1",level:4},{value:"File Headers",id:"file-headers",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"instantiation",id:"instantiation-4",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"notes",id:"notes-7",level:4},{value:"Program Unit Specification Headers",id:"program-unit-specification-headers",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"instantiation",id:"instantiation-5",level:4},{value:"example",id:"example-13",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"notes",id:"notes-8",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Program Unit Body Headers",id:"program-unit-body-headers",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"instantiation",id:"instantiation-6",level:4},{value:"example",id:"example-14",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"notes",id:"notes-9",level:4},{value:"Data Comments",id:"data-comments",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-15",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"Statement Comments",id:"statement-comments",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"example",id:"example-16",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"notes",id:"notes-10",level:4},{value:"Marker Comments",id:"marker-comments",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"example",id:"example-17",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"notes",id:"notes-11",level:4},{value:"Using Types",id:"using-types",level:2},{value:"Declaring Types",id:"declaring-types",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"example",id:"example-18",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"notes",id:"notes-12",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Enumeration Types",id:"enumeration-types",level:3},{value:"guideline",id:"guideline-20",level:4},{value:"example",id:"example-19",level:4},{value:"rationale",id:"rationale-20",level:4},{value:"Summary",id:"summary",level:2},{value:"spelling",id:"spelling-1",level:3},{value:"naming conventions",id:"naming-conventions-1",level:3},{value:"comments",id:"comments-1",level:3},{value:"using types",id:"using-types-1",level:3}],k={toc:g};function b(e){var n,t=e,{components:i}=t,u=((e,n)=>{var t={};for(var a in e)l.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(null!=e&&s)for(var a of s(e))n.indexOf(a)<0&&d.call(e,a)&&(t[a]=e[a]);return t})(t,["components"]);return(0,a.kt)("wrapper",(n=c(c({},k),u),o(n,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"This chapter recommends ways of using Ada features to make reading and\nunderstanding code easier. There are many myths about comments and\nreadability. The responsibility for true readability rests more with\nnaming and code structure than with comments. Having as many comment\nlines as code lines does not imply readability; it more likely indicates\nthe writer does not understand what is important to communicate."),(0,a.kt)("h2",c({},{id:"spelling"}),"Spelling"),(0,a.kt)("p",null,"Spelling conventions in source code include rules for capitalization and\nuse of underscores, numbers, and abbreviations. If you follow these\nconventions consistently, the resulting code is clearer and more\nreadable."),(0,a.kt)("h3",c({},{id:"use-of-underscores"}),"Use of Underscores"),(0,a.kt)("h4",c({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use underscores to separate words in a compound name.")),(0,a.kt)("h4",c({},{id:"example"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-none"}),"Miles_Per_Hour\nEntry_Value\n")),(0,a.kt)("h4",c({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"When an identifier consists of more than one word, it is much easier to\nread if the words are separated by underscores. Indeed, there is\nprecedent in English in which compound words are separated by a hyphen\nor a space. In addition to promoting readability of the code, if\nunderscores are used in names, a code formatter has more control over\naltering capitalization. See Guideline 3.1.3."),(0,a.kt)("h3",c({},{id:"numbers"}),"Numbers"),(0,a.kt)("h4",c({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Represent numbers in a consistent fashion."),(0,a.kt)("li",{parentName:"ul"},"Represent literals in a radix appropriate to the problem."),(0,a.kt)("li",{parentName:"ul"},"Use underscores to separate digits the same way commas or periods\n(or spaces for nondecimal bases) would be used in normal text."),(0,a.kt)("li",{parentName:"ul"},"When using scientific notation, make the E consistently either\nuppercase or lowercase."),(0,a.kt)("li",{parentName:"ul"},"In an alternate base, represent the alphabetic characters in either\nall uppercase or all lowercase.")),(0,a.kt)("h4",c({},{id:"instantiation"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Decimal and octal numbers are grouped by threes beginning on the\nleft side of the radix point and by fives beginning on the right\nside of the radix point."),(0,a.kt)("li",{parentName:"ul"},"The E is always capitalized in scientific notation."),(0,a.kt)("li",{parentName:"ul"},"Use uppercase for the alphabetic characters representing digits in\nbases above 10."),(0,a.kt)("li",{parentName:"ul"},"Hexadecimal numbers are grouped by fours beginning on either side of\nthe radix point.")),(0,a.kt)("h4",c({},{id:"example-1"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Maximum_Samples     is range          1 ..  1_000_000;\ntype Legal_Hex_Address   is range   16#0000# ..   16#FFFF#;\ntype Legal_Octal_Address is range 8#000_000# .. 8#777_777#;\n\nAvogadro_Number : constant := 6.02216_9E+23;\n")),(0,a.kt)("p",null,"To represent the number 1/3 as a constant, use:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"One_Third : constant := 1.0 / 3.0;\n")),(0,a.kt)("p",null,"Avoid this use:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"One_Third_As_Decimal_Approximation : constant := 0.33333_33333_3333;\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"One_Third_Base_3 : constant := 3#0.1#;\n")),(0,a.kt)("h4",c({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Consistent use of uppercase or lowercase aids scanning for numbers.\nUnderscores serve to group portions of numbers into familiar patterns.\nConsistency with common use in everyday contexts is a large part of\nreadability."),(0,a.kt)("h4",c({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"If a rational fraction is represented in a base in which it has a\nterminating rather than a repeating representation, as 3","#","0.1","#"," does in\nthe example above, it may have increased accuracy upon conversion to the\nmachine base. (This is wrong for named numbers as in this example - they\nmust be calculated exactly.)"),(0,a.kt)("h3",c({},{id:"capitalization"}),"Capitalization"),(0,a.kt)("h4",c({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make reserved words and other elements of the program visually\ndistinct from each other.")),(0,a.kt)("h4",c({},{id:"instantiation-1"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use lowercase for all reserved words (when used as reserved words)."),(0,a.kt)("li",{parentName:"ul"},"Use mixed case for all other identifiers, a capital letter beginning\nevery word separated by underscores."),(0,a.kt)("li",{parentName:"ul"},"Use uppercase for abbreviations and acronyms (see automation notes).")),(0,a.kt)("h4",c({},{id:"example-2"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"...\n\ntype Second_Of_Day      is range 0 .. 86_400;\ntype Noon_Relative_Time is (Before_Noon, After_Noon, High_Noon);\n\nsubtype Morning   is Second_Of_Day range 0 .. 86_400 / 2 - 1;\nsubtype Afternoon is Second_Of_Day range Morning'Last + 2 .. 86_400;\n\n...\n\nCurrent_Time := Second_Of_Day(Calendar.Seconds(Calendar.Clock));\nif Current_Time in Morning then\n   Time_Of_Day := Before_Noon;\nelsif Current_Time in Afternoon then\n   Time_Of_Day := After_Noon;\nelse\n   Time_Of_Day := High_Noon;\nend if;\n\ncase Time_Of_Day is\n   when Before_Noon =>   Get_Ready_For_Lunch;\n   when High_Noon   =>   Eat_Lunch;\n   when After_Noon  =>   Get_To_Work;\nend case;\n\n...\n")),(0,a.kt)("h4",c({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Visually distinguishing reserved words allows you to focus on program\nstructure alone, if desired, and also aids scanning for particular\nidentifiers."),(0,a.kt)("p",null,"The instantiation chosen here is meant to be more readable for the\nexperienced Ada programmer, who does not need reserved words to leap off\nthe page. Beginners to any language often find that reserved words\nshould be emphasized to help them find the control structures more\neasily. Because of this, instructors in the classroom and books\nintroducing the Ada language may want to consider an alternative\ninstantiation. The Ada Reference Manual (1995) chose bold lowercase for\nall reserved words."),(0,a.kt)("h4",c({},{id:"automation-notes"}),"automation notes"),(0,a.kt)("p",null,"Ada names are not case sensitive. Therefore, the names ",(0,a.kt)("inlineCode",{parentName:"p"},"max_limit"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"MAX_LIMIT"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"Max_Limit")," denote the same object or entity. A good\ncode formatter should be able to automatically convert from one style to\nanother as long as the words are delimited by underscores."),(0,a.kt)("p",null,"As recommended in Guideline 3.1.4, abbreviations should be project-wide.\nAn automated tool should allow a project to specify those abbreviations\nand format them accordingly."),(0,a.kt)("h3",c({},{id:"abbreviations"}),"Abbreviations"),(0,a.kt)("h4",c({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not use an abbreviation of a long word as an identifier where a\nshorter synonym exists."),(0,a.kt)("li",{parentName:"ul"},"Use a consistent abbreviation strategy."),(0,a.kt)("li",{parentName:"ul"},"Do not use ambiguous abbreviations."),(0,a.kt)("li",{parentName:"ul"},"To justify its use, an abbreviation must save many characters over\nthe full word."),(0,a.kt)("li",{parentName:"ul"},"Use abbreviations that are well-accepted in the application domain."),(0,a.kt)("li",{parentName:"ul"},"Maintain a list of accepted abbreviations, and use only\nabbreviations on that list.")),(0,a.kt)("h4",c({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Time_Of_Receipt\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Recd_Time or R_Time\n")),(0,a.kt)("p",null,"But in an application that commonly deals with message formats that meet\nmilitary standards, ",(0,a.kt)("inlineCode",{parentName:"p"},"DOD_STD_MSG_FMT")," is an acceptable abbreviation for:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Department_Of_Defense_Standard_Message_Format.\n")),(0,a.kt)("h4",c({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"Many abbreviations are ambiguous or unintelligible unless taken in\ncontext. As an example, Temp could indicate either temporary or\ntemperature. For this reason, you should choose abbreviations carefully\nwhen you use them. The rationale in Guideline 8.1.2 provides a more\nthorough discussion of how context should influence the use of\nabbreviations."),(0,a.kt)("p",null,"Because very long variable names can obscure the structure of the\nprogram, especially in deeply nested (indented) control structures, it\nis a good idea to try to keep identifiers short and meaningful. Use\nshort unabbreviated names whenever possible. If there is no short word\nthat will serve as an identifier, then a well-known unambiguous\nabbreviation is the next best choice, especially if it comes from a list\nof standard abbreviations used throughout the project."),(0,a.kt)("p",null,"You can establish an abbreviated format for a fully qualified name using\nthe renames clause. This capability is useful when a very long, fully\nqualified name would otherwise occur many times in a localized section\nof code (see Guideline 5.7.2)."),(0,a.kt)("p",null,"A list of accepted abbreviations for a project provides a standard\ncontext for using each abbreviation."),(0,a.kt)("h2",c({},{id:"naming-conventions"}),"Naming Conventions"),(0,a.kt)("p",null,"Choose names that clarify the object's or entity's intended use. Ada\nallows identifiers to be any length as long as the identifier fits on a\nline with all characters being significant (including underscores).\nIdentifiers are the names used for variables, constants, program units,\nand other entities within a program."),(0,a.kt)("h3",c({},{id:"names"}),"Names"),(0,a.kt)("h4",c({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Choose names that are as self-documenting as possible."),(0,a.kt)("li",{parentName:"ul"},"Use a short synonym instead of an abbreviation (see Guideline\n3.1.4)."),(0,a.kt)("li",{parentName:"ul"},"Use names given by the application, but do not use obscure jargon."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the same name to declare different kinds of identifiers.")),(0,a.kt)("h4",c({},{id:"example-4"}),"example"),(0,a.kt)("p",null,"In a tree-walker, using the name ",(0,a.kt)("inlineCode",{parentName:"p"},"Left")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"Left_Branch")," is\nsufficient to convey the full meaning given the context. However, use\n",(0,a.kt)("inlineCode",{parentName:"p"},"Time_Of_Day")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"TOD"),"."),(0,a.kt)("p",null,"Mathematical formulas are often given using single-letter names for\nvariables. Continue this convention for mathematical equations where\nthey would recall the formula, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   A*(X**2) + B*X + C.\n")),(0,a.kt)("p",null,"With the use of child packages, a poor choice of package, subunit, and\nidentifier names can lead to a visibility clash with subunits. See the\nRationale (1995, \xa78.1) for a sample of the resulting, rather obscure\ncode."),(0,a.kt)("h4",c({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"A program that follows these guidelines can be more easily comprehended.\nSelf-documenting names require fewer explanatory comments. Empirical\nstudies have shown that you can further improve comprehension if your\nvariable names are not excessively long (Schneiderman 1986, 7). The\ncontext and application can help greatly. The unit of measure for\nnumeric entities can be a source of subtype names."),(0,a.kt)("p",null,"You should try not to use the same name as an identifier for different\ndeclarations, such as an object and a child package. Overusing an\nidentifier in seemingly different name spaces can, in fact, lead to\nvisibility clashes if the enclosing program units are intended to work\ntogether."),(0,a.kt)("h4",c({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"See Guideline 8.1.2 for a discussion on how to use the application\ndomain as a guideline for selecting abbreviations."),(0,a.kt)("h3",c({},{id:"subtype-names"}),"Subtype Names"),(0,a.kt)("h4",c({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use singular, general nouns as subtype identifiers."),(0,a.kt)("li",{parentName:"ul"},"Choose identifiers that describe one of the subtype's values."),(0,a.kt)("li",{parentName:"ul"},"Consider using suffixes for subtype identifiers that define visible\naccess types, visible subranges, or visible array types."),(0,a.kt)("li",{parentName:"ul"},"For private types, do not use identifier constructions (e.g.,\nsuffixes) that are unique to subtype identifiers."),(0,a.kt)("li",{parentName:"ul"},"Do not use the subtype names from predefined packages.")),(0,a.kt)("h4",c({},{id:"example-5"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Day is\n   (Monday,    Tuesday,   Wednesday, Thursday,  Friday,\n    Saturday,  Sunday);\n\ntype Day_Of_Month    is range      0 ..    31;\ntype Month_Number    is range      1 ..    12;\ntype Historical_Year is range -6_000 .. 2_500;\n\ntype Date is\n   record\n      Day   : Day_Of_Month;\n      Month : Month_Number;\n      Year  : Historical_Year;\n   end record;\n")),(0,a.kt)("p",null,"In particular, ",(0,a.kt)("inlineCode",{parentName:"p"},"Day")," should be used in preference to ",(0,a.kt)("inlineCode",{parentName:"p"},"Days")," or\n",(0,a.kt)("inlineCode",{parentName:"p"},"Day_Type"),"."),(0,a.kt)("p",null,"The identifier ",(0,a.kt)("inlineCode",{parentName:"p"},"Historical_Year")," might appear to be specific, but it is\nactually general, with the adjective ",(0,a.kt)("inlineCode",{parentName:"p"},"historical")," describing the range\nconstraint:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nprocedure Disk_Driver is\n\n   -- In this procedure, a number of important disk parameters are\n   -- linked.\n   Number_Of_Sectors  : constant :=     4;\n   Number_Of_Tracks   : constant :=   200;\n   Number_Of_Surfaces : constant :=    18;\n   Sector_Capacity    : constant := 4_096;\n\n   Track_Capacity   : constant := Number_Of_Sectors  * Sector_Capacity;\n   Surface_Capacity : constant := Number_Of_Tracks   * Track_Capacity;\n   Disk_Capacity    : constant := Number_Of_Surfaces * Surface_Capacity;\n\n   type Sector_Range  is range 1 .. Number_Of_Sectors;\n   type Track_Range   is range 1 .. Number_Of_Tracks;\n   type Surface_Range is range 1 .. Number_Of_Surfaces;\n\n   type Track_Map   is array (Sector_Range)  of ...;\n   type Surface_Map is array (Track_Range)   of Track_Map;\n   type Disk_Map    is array (Surface_Range) of Surface_Map;\n\nbegin  -- Disk_Driver\n   ...\nend Disk_Driver;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The suffixes ",(0,a.kt)("inlineCode",{parentName:"p"},"_Capacity"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"_Range"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"_Map")," help define the purpose\nof the above subtypes and avoid the search for synonyms for the sector,\ntrack, and surface abstractions. Without the suffixes, you would need\nthree different names per abstraction, one to describe each of the\nconcepts succinctly named in the suffix. This recommendation only\napplies to certain visible subtypes. Private types, for example, should\nbe given a good name that reflects the abstraction being represented."),(0,a.kt)("h4",c({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"When this style and the suggested style for object identifiers are used,\nprogram code more closely resembles English (see Guideline 3.2.3).\nFurthermore, this style is consistent with the names of the language's\npredefined identifiers. They are not named ",(0,a.kt)("inlineCode",{parentName:"p"},"Integers"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Booleans"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"Integer_Type"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"Boolean_Type"),"."),(0,a.kt)("p",null,"However, using the name of a subtype from the predefined packages is\nsure to confuse a programmer when that subtype appears somewhere without\na package qualification."),(0,a.kt)("h4",c({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,'This style guide tries to be consistent with the Ada Reference Manual\n(1995) in use of the terms "type" and "subtype" name. In general, a\n"type" refers to the abstract concept, as in a type declaration, while\nthe "subtype" refers to the name given to that abstract concept in an\nactual declaration. Thus, what was called a type name in Ada 83 (Ada\nReference Manual 1983) is now called a subtype name.'),(0,a.kt)("h3",c({},{id:"object-names"}),"Object Names"),(0,a.kt)("h4",c({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use predicate clauses or adjectives for Boolean objects."),(0,a.kt)("li",{parentName:"ul"},"Use singular, specific nouns as object identifiers."),(0,a.kt)("li",{parentName:"ul"},"Choose identifiers that describe the object's value during\nexecution."),(0,a.kt)("li",{parentName:"ul"},"Use singular, general nouns as identifiers for record components.")),(0,a.kt)("h4",c({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"Non-Boolean objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Today           : Day;\nYesterday       : Day;\nRetirement_Date : Date;\n")),(0,a.kt)("p",null,"Boolean objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"User_Is_Available : Boolean;        -- predicate clause\nList_Is_Empty     : Boolean;        -- predicate clause\nEmpty             : Boolean;        -- adjective\nBright            : Boolean;        -- adjective\n")),(0,a.kt)("h4",c({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"Using specific nouns for objects establishes a context for understanding\nthe object's value, which is one of the general values described by the\nsubtype's name (see Guideline 3.2.2). Object declarations become very\nEnglish-like with this style. For example, the first declaration above\nis read as \"Today is a Day.\""),(0,a.kt)("p",null,'General nouns, rather than specific, are used for record components\nbecause a record object\'s name will supply the context for understanding\nthe component. Thus, the following component is understood as "the year\nof retirement":'),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Retirement_Date.Year\n")),(0,a.kt)("p",null,"Following conventions that relate object types and parts of speech makes\ncode read more like text. For example, because of the names chosen, the\nfollowing code segment needs no comments:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"if List_Is_Empty then\n   Number_Of_Elements := 0;\nelse\n   Number_Of_Elements := Length_Of_List;\nend if;\n")),(0,a.kt)("h4",c({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"If it is difficult to find a specific noun that describes an object's\nvalue during the entire execution of a program, the object is probably\nserving multiple purposes. Multiple objects should be used in such a\ncase."),(0,a.kt)("h3",c({},{id:"naming-of-tagged-types-and-associated-packages"}),"Naming of Tagged Types and Associated Packages"),(0,a.kt)("h4",c({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use a consistent naming convention for tagged types and associated\npackages.")),(0,a.kt)("h4",c({},{id:"instantiation-2"}),"instantiation"),(0,a.kt)("p",null,'Naming conventions spark "religious wars"; therefore, two different\ninstantiations are presented. The first instantiation integrates the use\nof object-oriented features. Except for two special cases, it applies\nthe same naming conventions to declarations, independent of whether they\nuse an object-oriented feature:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Name tagged types no differently than subtype names (see Guideline\n3.2.2)."),(0,a.kt)("li",{parentName:"ul"},"Use the prefix ",(0,a.kt)("inlineCode",{parentName:"li"},"Abstract_")," for packages that export an abstraction\nfor which you intend to provide multiple implementations (see\nGuideline 9.2.4)."),(0,a.kt)("li",{parentName:"ul"},"Use the suffix ",(0,a.kt)("inlineCode",{parentName:"li"},"_Mixin"),' for packages that provide units of\nfunctionality that can be "mixed in" to core abstractions.')),(0,a.kt)("p",null,"The second instantiation highlights the use of object-oriented features\nthrough special names or suffixes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Name class packages after the object they represent, without a\nsuffix (Rosen 1995)."),(0,a.kt)("li",{parentName:"ul"},"Name mixin packages after the facet they represent, appending the\nsuffix ","_","Facet (Rosen 1995)."),(0,a.kt)("li",{parentName:"ul"},"Name the main tagged type ",(0,a.kt)("inlineCode",{parentName:"li"},"Instance")," (Rosen 1995)."),(0,a.kt)("li",{parentName:"ul"},"Follow the declaration of the specific type with a subtype named\n",(0,a.kt)("inlineCode",{parentName:"li"},"Class")," for the corresponding class-wide type (Rosen 1995).")),(0,a.kt)("h4",c({},{id:"example-7"}),"example"),(0,a.kt)("p",null,"The following two-part example from the Rationale (1995, \xa7\xa74.4.4 and\n4.6.2) applies the naming conventions of the first instantiation."),(0,a.kt)("p",null,"For the first part of this example, assume the type ",(0,a.kt)("inlineCode",{parentName:"p"},"Set_Element")," was\ndeclared elsewhere:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"package Abstract_Sets is\n\n   type Set is abstract tagged private;\n\n   -- empty set\n   function Empty return Set is abstract;\n\n   -- build set with 1 element\n   function Unit (Element: Set_Element) return Set is abstract;\n\n   -- union of two sets\n   function Union (Left, Right: Set) return Set is abstract;\n\n   -- intersection of two sets\n   function Intersection (Left, Right: Set) return Set is abstract;\n\n   -- remove an element from a set\n   procedure Take (From    : in out Set;\n                   Element :    out set_Element) is abstract;\n\n   Element_Too_Large : exception;\nprivate\n   type Set is abstract tagged null record;\nend Abstract_Sets;\n\nwith Abstract_Sets;\npackage Bit_Vector_Sets is   -- one implementation of set abstraction\n\n   type Bit_Set is new Abstract_Sets.Set with private;\n   ...\nprivate\n   Bit_Set_Size : constant := 64;\n   type Bit_Vector is ...\n   type Bit_Set is new Abstract_Sets.Set with\n      record\n         Data : Bit_Vector;\n      end record;\nend Bit_Vector_Sets;\n\nwith Abstract_Sets;\npackage Sparse_Sets  -- alternate implementation of set abstraction\n\n   type Sparse_Set is new Abstract_Sets.Set with private;\n   ...\nprivate\n   ...\nend Bit_Vector_Sets;\n")),(0,a.kt)("p",null,"The second part of this example applies the naming convention to mixin\npackages that support a windowing system:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"-- assume you have type Basic_Window is tagged limited private;\n\ngeneric\n   type Some_Window is abstract new Basic_Window with private;\npackage Label_Mixin is\n   type Window_With_Label is abstract new Some_Window with private;\n   ...\nprivate\n   ...\nend Label_Mixin;\n\ngeneric\n   type Some_Window is abstract new Basic_Window with private;\npackage Border_Mixin is\n   type Window_With_Label is abstract new Some_Window with private;\n   ...\nprivate\n   ...\nend Border_Mixin;\n")),(0,a.kt)("p",null,"The following example applies the naming conventions of the second\ninstantiation, as discussed in Rosen (1995):"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"package Shape is\n   subtype Side_Count is range 0 .. 100;\n   type Instance (Sides: Side_Count) is tagged private;\n   subtype Class is Instance'Class;\n   . . .\n   -- operations on Shape.Instance\nprivate\n   . . .\nend Shape;\n\nwith Shape; use Shape;\npackage Line is\n   type Instance is new Shape.Instance with private;\n   subtype Class is Instance'Class;\n   . . .\n   -- Overridden or new operations\nprivate\n   . . .\nend Line;\n\nwith Shape; use Shape;\ngeneric\n   type Origin is new Shape.Instance;\npackage With_Color_Facet is\n   type Instance is new Origin with private;\n   subtype Class is Instance'Class;\n   -- operations for colored shapes\nprivate\n   . . .\nend With_Color_Facet;\n\nwith Line; use Line;\nwith With_Color_Facet;\npackage Colored_Line is new With_Color_Facet (Line.Instance);\n")),(0,a.kt)("p",null,"Sample declarations might look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Red_Line : Colored_Line.Instance;\n\nprocedure Draw (What : Shape.Instance);\n")),(0,a.kt)("p",null,"The above scheme works whether you use full names or a ",(0,a.kt)("inlineCode",{parentName:"p"},"use")," clause. As\nlong as you use the same name for all the specific types (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"type Instance"),") and class-wide types, the unqualified names will always hide\none another. Thus, the compiler will insist you use full name\nqualification to resolve the ambiguity introduced by the use clause\n(Rosen 1995)."),(0,a.kt)("h4",c({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"You want to use a naming scheme that is consistent and readable and\nconveys the intent of the abstraction. Ideally, the naming scheme should\nbe uniform in how it handles the different ways in which tagged types\nare used to create classes. If the naming convention is too rigid,\nhowever, you will write code fragments that appear stilted from a\nreadability point of view. By using a similar naming convention for type\nextension through derivation and through generic mixin (see also\nGuideline 9.5.1), you achieve readable declarations of objects and\nprocedures."),(0,a.kt)("h4",c({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"A naming convention for classes draws a hard line between\nobject-oriented abstractions and other kinds of abstractions. Given that\nengineers have been defining abstract data types in Ada 83 (Ada\nReference Manual 1983) for over 10 years, you may not want to change the\nnaming convention just for the sake of using type extension with a type.\nYou must consider how important it is to call out uses of inheritance in\nthe overall use of abstractions in your program. If you prefer to\nemphasize abstraction, in general, over the mechanism used to implement\nthe abstraction (i.e., inheritance, type-extension, and polymorphism),\nyou may not want to impose such a stringent naming convention. You do\nnot hamper quality by favoring a smoother transition in naming\nconventions from abstractions developed without inheritance to those\ndeveloped with inheritance."),(0,a.kt)("p",null,"If you choose a naming convention that highlights the use of\nobject-oriented features and later decide to change the declaration to\none that does not use an object-oriented feature, the change may be\nexpensive. You must naturally change all occurrences of the names and\nmust be careful not to introduce errors as you update the names. If you\nchoose a naming convention that prohibits the use of suffixes or\nprefixes to characterize the declaration, you lose the opportunity to\nconvey the intended usage of the declared item."),(0,a.kt)("h3",c({},{id:"program-unit-names"}),"Program Unit Names"),(0,a.kt)("h4",c({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use action verbs for procedures and entries."),(0,a.kt)("li",{parentName:"ul"},"Use predicate clauses for Boolean functions."),(0,a.kt)("li",{parentName:"ul"},"Use nouns for non-Boolean functions."),(0,a.kt)("li",{parentName:"ul"},"Give packages names that imply a higher level of organization than\nsubprograms. Generally, these are noun phrases that describe the\nabstraction provided."),(0,a.kt)("li",{parentName:"ul"},"Give tasks names that imply an active entity."),(0,a.kt)("li",{parentName:"ul"},"Use nouns descriptive of the data being protected for protected\nunits."),(0,a.kt)("li",{parentName:"ul"},"Consider naming generic subprograms as if they were nongeneric\nsubprograms."),(0,a.kt)("li",{parentName:"ul"},"Consider naming generic packages as if they were nongeneric\npackages."),(0,a.kt)("li",{parentName:"ul"},"Make the generic names more general than the instantiated names.")),(0,a.kt)("h4",c({},{id:"example-8"}),"example"),(0,a.kt)("p",null,"The following are sample names for elements that compose an Ada program:"),(0,a.kt)("p",null,"Sample procedure names:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"procedure Get_Next_Token          -- get is a transitive verb\nprocedure Create                  -- create is a transitive verb\n")),(0,a.kt)("p",null,"Sample function names for Boolean-valued functions:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"function Is_Last_Item             -- predicate clause\nfunction Is_Empty                 -- predicate clause\n")),(0,a.kt)("p",null,"Sample function names for non-Boolean-valued functions:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"function Successor                -- common noun\nfunction Length                   -- attribute\nfunction Top                      -- component\n")),(0,a.kt)("p",null,"Sample package names:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"package Terminals is               -- common noun\npackage Text_Routines is           -- common noun\n")),(0,a.kt)("p",null,"Sample protected objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"protected Current_Location is      -- data being protected\nprotected type Guardian is         -- noun implying protection\n")),(0,a.kt)("p",null,"Sample task names:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"task Terminal_Resource_Manager is  -- common noun that shows action\n")),(0,a.kt)("p",null,"The following sample piece of code shows the clarity that results from\nusing the parts-of-speech naming conventions:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Get_Next_Token(Current_Token);\n\ncase Current_Token is\n   when Identifier =>         Process_Identifier;\n   when Numeric    =>         Process_Numeric;\nend case;  -- Current_Token\n\nif Is_Empty(Current_List) then\n   Number_Of_Elements := 0;\nelse\n   Number_Of_Elements := Length(Current_List);\nend if;\n")),(0,a.kt)("p",null,"When packages and their subprograms are named together, the resulting\ncode is very descriptive:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"if Stack.Is_Empty(Current_List) then\n   Current_Token := Stack.Top(Current_List);\nend if;\n")),(0,a.kt)("h4",c({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"Using these naming conventions creates understandable code that reads\nmuch like natural language. When verbs are used for actions, such as\nsubprograms, and nouns are used for objects, such as the data that the\nsubprogram manipulates, code is easier to read and understand. This\nmodels a medium of communication already familiar to a reader. Where the\npieces of a program model a real-life situation, using these conventions\nreduces the number of translation steps involved in reading and\nunderstanding the program. In a sense, your choice of names reflects the\nlevel of abstraction from computer hardware toward application\nrequirements."),(0,a.kt)("p",null,"See also Guideline 3.2.4 for the use of special-purpose suffixes in\npackages associated with tagged types."),(0,a.kt)("h4",c({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"There are some conflicting conventions in current use for task entries.\nSome programmers and designers advocate naming task entries with the\nsame conventions used for subprograms to blur the fact that a task is\ninvolved. Their reasoning is that if the task is reimplemented as a\npackage, or vice versa, the names need not change. Others prefer to make\nthe fact of a task entry as explicit as possible to ensure that the\nexistence of a task with its presumed overhead is recognizable.\nProject-specific priorities may be useful in choosing between these\nconventions."),(0,a.kt)("h3",c({},{id:"constants-and-named-numbers"}),"Constants and Named Numbers"),(0,a.kt)("h4",c({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use symbolic values instead of literals where the symbolic value\nimproves readability."),(0,a.kt)("li",{parentName:"ul"},"Use symbolic values instead of literals if the value occurs at more\nthan one place and might need to be changed."),(0,a.kt)("li",{parentName:"ul"},"Use the predefined constants Ada.Numerics.Pi and Ada.Numerics.e for\nthe mathematical constants Pi and e."),(0,a.kt)("li",{parentName:"ul"},"Use constants instead of variables for constant values."),(0,a.kt)("li",{parentName:"ul"},"Use a constant when the value is specific to a type or when the\nvalue must be static."),(0,a.kt)("li",{parentName:"ul"},"Use named numbers instead of constants, whenever possible."),(0,a.kt)("li",{parentName:"ul"},"Use named numbers to replace numeric literals whose type or context\nis truly universal."),(0,a.kt)("li",{parentName:"ul"},"Use constants for objects whose values cannot change after\nelaboration (United Technologies 1987)."),(0,a.kt)("li",{parentName:"ul"},"Show relationships between symbolic values by defining them with\nstatic expressions."),(0,a.kt)("li",{parentName:"ul"},"Use linearly independent sets of literals."),(0,a.kt)("li",{parentName:"ul"},"Use attributes like 'First and 'Last instead of literals, wherever\npossible.")),(0,a.kt)("h4",c({},{id:"example-9"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"3.14159_26535_89793                                 -- literal\nMax_Entries : constant Integer       := 400;        -- constant\nAvogadros_Number  : constant := 6.022137 * 10**23;  -- named number\nAvogadros_Number / 2                                -- static expression\nAvogadros_Number                                    -- symbolic value\n")),(0,a.kt)("p",null,"Declaring ",(0,a.kt)("inlineCode",{parentName:"p"},"Pi")," as a named number (assuming a ",(0,a.kt)("inlineCode",{parentName:"p"},"with")," clause for the\npredefined package ",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Numerics")," in the Ada Reference Manual ","[","1995,\n\xa7A.5","]"," allows it to be referenced symbolically in the assignment\nstatement below:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Area :=       Pi * Radius**2;       -- if radius is known.\n")),(0,a.kt)("p",null,"instead of:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Area := 3.14159 * Radius**2;        -- Needs explanatory comment\n")),(0,a.kt)("p",null,"Also, ",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Characters.Latin_1.Bel")," is more expressive than\n",(0,a.kt)("inlineCode",{parentName:"p"},"Character'Val(8#007#)"),"."),(0,a.kt)("p",null,"Clarity of constant and named number declarations can be improved by\nusing other constant and named numbers. For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Bytes_Per_Page   : constant := 512;\nPages_Per_Buffer : constant := 10;\nBuffer_Size      : constant := Pages_Per_Buffer * Bytes_Per_Page;\n")),(0,a.kt)("p",null,"is more self-explanatory and easier to maintain than:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Buffer_Size : constant := 5_120;   -- ten pages\n")),(0,a.kt)("p",null,"The following literals should be constants:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'if New_Character  = \'$\' then  -- "constant" that may change\n...\nif Current_Column = 7 then    -- "constant" that may change\n')),(0,a.kt)("h4",c({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"Using identifiers instead of literals makes the purpose of expressions\nclear, reducing the need for comments. Constant declarations consisting\nof expressions of numeric literals are safer because they do not need to\nbe computed by hand. They are also more enlightening than a single\nnumeric literal because there is more opportunity for embedding\nexplanatory names. Clarity of constant declarations can be improved\nfurther by using other related constants in static expressions defining\nnew constants. This is not less efficient because static expressions of\nnamed numbers are computed at compile time."),(0,a.kt)("p",null,"A constant has a type. A named number can only be a universal type:\nuniversal_integer or universal_real. Strong typing is enforced for\nconstants but not for named numbers or literals. Named numbers allow\ncompilers to generate more efficient code than for constants and to\nperform more complete error checking at compile time. If the literal\ncontains a large number of digits (as Pi in the example above), the use\nof an identifier reduces keystroke errors. If keystroke errors occur,\nthey are easier to locate either by inspection or at compile time."),(0,a.kt)("p",null,"Independence of literals means that the few literals that are used do\nnot depend on one another and that any relationship between constant or\nnamed values is shown in the static expressions. Linear independence of\nliteral values gives the property that if one literal value changes, all\nof the named numbers of values dependent on that literal are\nautomatically changed."),(0,a.kt)("p",null,"See Guideline 4.1.4 for additional guidelines on choosing a\nparameterless function versus a constant."),(0,a.kt)("h4",c({},{id:"notes-6"}),"notes"),(0,a.kt)("p",null,"There are situations where a literal is a better choice than a name. For\nthis to be the case, the following conditions have to be fulfilled:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The literal has to be self-explanatory in the respective context,\nsuch that replacing the literal by a symbolic value would not\nimprove the readability."),(0,a.kt)("li",{parentName:"ul"},"The value is either unchangeable or only occurs at one single place\nin the code, such that replacing the literal by a symbolic value\nwould not improve the maintainability.")),(0,a.kt)("p",null,"For example, the literals in the following well known relationship are\nboth self-explanatory and unchangeable:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Fahrenheit := 32.0 + (9.0 * Celsius) / 5.0;\n")),(0,a.kt)("p",null,"As a second example, dividing by the literal 2 is self-explanatory in a\nbinary search algorithm context. And, since the value is also\nunchangeably related with the algorithm, it also does not matter if the\nliteral occurs at more than one place in the code (for example due to\nloop unrolling). Therefore, the use of a symbolic value like the\nfollowing would neither improve readability nor maintainability:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Binary_Search_Divisor : constant := 2;\n")),(0,a.kt)("h3",c({},{id:"exceptions"}),"Exceptions"),(0,a.kt)("h4",c({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use a name that indicates the kind of problem the exception\nrepresents.")),(0,a.kt)("h4",c({},{id:"example-10"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Invalid_Name: exception;\nStack_Overflow: exception;\n")),(0,a.kt)("h4",c({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,"Naming exceptions according to the kind of problem they are detecting\nenhances the readability of the code. You should name your exceptions as\nprecisely as you can so that the maintainer of the code understands why\nthe exception might be raised. A well-named exception should be\nmeaningful to the clients of the package declaring the exception."),(0,a.kt)("h3",c({},{id:"constructors"}),"Constructors"),(0,a.kt)("h4",c({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Include a prefix like ",(0,a.kt)("inlineCode",{parentName:"li"},"New"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"Make"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"Create")," in naming\nconstructors (in this sense, operations to create and/or initialize\nan object)."),(0,a.kt)("li",{parentName:"ul"},"Use names indicative of their content for child packages containing\nconstructors.")),(0,a.kt)("h4",c({},{id:"instantiation-3"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Name a child package containing constructors\n",(0,a.kt)("inlineCode",{parentName:"li"},"\\<whatever\\>.Constructor"),".")),(0,a.kt)("h4",c({},{id:"example-11"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"function Make_Square (Center : Cartesian_Coordinates;\n                      Side   : Positive)\n  return Square;\n")),(0,a.kt)("h4",c({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,"Including a word like ",(0,a.kt)("inlineCode",{parentName:"p"},"New"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Make"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"Create")," in a constructor name\nmakes its purpose clear. You may want to restrict the use of the prefix\nNew to constructors that return an access value because the prefix\nsuggests the internal use of an allocator."),(0,a.kt)("p",null,"Putting all constructors in a child package, even when they return\naccess values, is a useful organizational principle."),(0,a.kt)("p",null,"For information regarding the use of Ada constructors, refer to\nGuideline 9.3.3."),(0,a.kt)("h2",c({},{id:"comments"}),"Comments"),(0,a.kt)("p",null,"Comments in source text are a controversial issue. There are arguments\nboth for and against the view that comments enhance readability. In\npractice, the biggest problem with comments is that people often fail to\nupdate them when the associated source text is changed, thereby making\nthe commentary misleading. Commentary should be reserved for expressing\nneeded information that cannot be expressed in code and highlighting\ncases where there are overriding reasons to violate one of the\nguidelines. If possible, source text should use self-explanatory names\nfor objects and program units, and it should use simple, understandable\nprogram structures so that little additional commentary is needed. The\nextra effort in selecting (and entering) appropriate names and the extra\nthought needed to design clean and understandable program structures are\nfully justified."),(0,a.kt)("p",null,'Use comments to state the intent of the code. Comments that provide an\noverview of the code help the maintenance programmer see the forest for\nthe trees. The code itself is the detailed "how" and should not be\nparaphrased in the comments.'),(0,a.kt)("p",null,"Comments should be minimized. They should provide needed information\nthat cannot be expressed in the Ada language, emphasize the structure of\ncode, and draw attention to deliberate and necessary violations of the\nguidelines. Comments are present either to draw attention to the real\nissue being exemplified or to compensate for incompleteness in the\nsample program."),(0,a.kt)("p",null,"Maintenance programmers need to know the causal interaction of\nnoncontiguous pieces of code to get a global, more or less complete\nsense of the program. They typically acquire this kind of information\nfrom mental simulation of parts of the code. Comments should be\nsufficient enough to support this process (Soloway et al. 1986)."),(0,a.kt)("p",null,"This section presents general guidelines about how to write good\ncomments. It then defines several different classes of comments with\nguidelines for the use of each. The classes are file headers, program\nunit specification headers, program unit body headers, data comments,\nstatement comments, and marker comments."),(0,a.kt)("h3",c({},{id:"general-comments"}),"General Comments"),(0,a.kt)("h4",c({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make the code as clear as possible to reduce the need for comments."),(0,a.kt)("li",{parentName:"ul"},"Never repeat information in a comment that is readily available in\nthe code."),(0,a.kt)("li",{parentName:"ul"},"Where a comment is required, make it concise and complete."),(0,a.kt)("li",{parentName:"ul"},"Use proper grammar and spelling in comments."),(0,a.kt)("li",{parentName:"ul"},"Make comments visually distinct from the code."),(0,a.kt)("li",{parentName:"ul"},"Structure comments in header so that information can be\nautomatically extracted by a tool.")),(0,a.kt)("h4",c({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"The structure and function of well-written code is clear without\ncomments. Obscured or badly structured code is hard to understand,\nmaintain, or reuse regardless of comments. Bad code should be improved,\nnot explained. Reading the code itself is the only way to be absolutely\npositive about what the code does; therefore, the code should be made as\nreadable as possible."),(0,a.kt)("p",null,"Using comments to duplicate information in the code is a bad idea for\nseveral reasons. First, it is unnecessary work that decreases\nproductivity. Second, it is very difficult to correctly maintain the\nduplication as the code is modified. When changes are made to existing\ncode, it is compiled and tested to make sure that it is once again\ncorrect. However, there is no automatic mechanism to make sure that the\ncomments are correctly updated to reflect the changes. Very often, the\nduplicate information in a comment becomes obsolete at the first code\nchange and remains so through the life of the software. Third, when\ncomments about an entire system are written from the limited point of\nview of the author of a single subsystem, the comments are often\nincorrect from the start."),(0,a.kt)("p",null,"Comments are necessary to reveal information difficult or impossible to\nobtain from the code. Subsequent chapters of this book contain examples\nof such comments. Completely and concisely present the required\ninformation."),(0,a.kt)("p",null,"The purpose of comments is to help readers understand the code.\nMisspelled, ungrammatical, ambiguous, or incomplete comments defeat this\npurpose. If a comment is worth adding, it is worth adding correctly in\norder to increase its usefulness."),(0,a.kt)("p",null,"Making comments visually distinct from the code by indenting them,\ngrouping them together into headers, or highlighting them with dashed\nlines is useful because it makes the code easier to read. Subsequent\nchapters of this book elaborate on this point."),(0,a.kt)("h4",c({},{id:"automation-notes-1"}),"automation notes"),(0,a.kt)("p",null,"The guideline about storing redundant information in comments applies\nonly to manually generated comments. There are tools that automatically\nmaintain information about the code (e.g., calling units, called units,\ncross-reference information, revision histories, etc.), storing it in\ncomments in the same file as the code. Other tools read comments but do\nnot update them, using the information from the comments to\nautomatically generate detailed design documents and other reports."),(0,a.kt)("p",null,"The use of such tools is encouraged and may require that you structure\nyour header comments so they can be automatically extracted and/or\nupdated. Beware that tools that modify the comments in a file are only\nuseful if they are executed frequently enough. Automatically generated\nobsolete information is even more dangerous than manually generated\nobsolete information because it is more trusted by the reader."),(0,a.kt)("p",null,"Revision histories are maintained much more accurately and completely by\nconfiguration management tools. With no tool support, it is very common\nfor an engineer to make a change and forget to update the revision\nhistory. If your configuration management tool is capable of maintaining\nrevision histories as comments in the source file, then take advantage\nof that capability, regardless of any compromise you might have to make\nabout the format or location of the revision history. It is better to\nhave a complete revision history appended to the end of the file than to\nhave a partial one formatted nicely and embedded in the file header."),(0,a.kt)("h3",c({},{id:"file-headers"}),"File Headers"),(0,a.kt)("h4",c({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put a file header on each source file."),(0,a.kt)("li",{parentName:"ul"},"Place ownership, responsibility, and history information for the\nfile in the file header.")),(0,a.kt)("h4",c({},{id:"instantiation-4"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put a copyright notice in the file header."),(0,a.kt)("li",{parentName:"ul"},"Put the author's name and department in the file header."),(0,a.kt)("li",{parentName:"ul"},"Put a revision history in the file header, including a summary of\neach change, the date, and the name of the person making the change.")),(0,a.kt)("h4",c({},{id:"example-12"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\n--      Copyright (c) 1991, Software Productivity Consortium, Inc.\n--      All rights reserved.\n--\n-- Author: J. Smith\n-- Department:System Software Department\n--\n-- Revision History:\n--   7/9/91 J. Smith\n--     - Added function Size_Of to support queries of node sizes.\n--     - Fixed bug in Set_Size which caused overlap of large nodes.\n--   7/1/91 M. Jones\n--     - Optimized clipping algorithm for speed.\n--   6/25/91 J. Smith\n--     - Original version.\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"Ownership information should be present in each file if you want to be\nsure to protect your rights to the software. Furthermore, for high\nvisibility, it should be the first thing in the file."),(0,a.kt)("p",null,"Responsibility and revision history information should be present in\neach file for the sake of future maintainers; this is the header\ninformation most trusted by maintainers because it accumulates. It does\nnot evolve. There is no need to ever go back and modify the author's\nname or the revision history of a file. As the code evolves, the\nrevision history should be updated to reflect each change. At worst, it\nwill be incomplete; it should rarely be wrong. Also, the number and\nfrequency of changes and the number of different people who made the\nchanges over the history of a unit can be good indicators of the\nintegrity of the implementation with respect to the design."),(0,a.kt)("p",null,"Information about how to find the original author should be included in\nthe file header, in addition to the author's name, to make it easier for\nmaintainers to find the author in case questions arise. However,\ndetailed information like phone numbers, mail stops, office numbers, and\ncomputer account user names are too volatile to be very useful. It is\nbetter to record the department for which the author was working when\nthe code was written. This information is still useful if the author\nmoves offices, changes departments, or even leaves the company because\nthe department is likely to retain responsibility for the original\nversion of the code."),(0,a.kt)("h4",c({},{id:"notes-7"}),"notes"),(0,a.kt)("p",null,"With modern configuration management systems, explicitly capturing\nversion history as header comments may be superfluous. The configuration\nmanagement tool maintains a more reliable and consistent (from a content\npoint of view) change history. Some systems can re-create earlier\nversions of a unit."),(0,a.kt)("h3",c({},{id:"program-unit-specification-headers"}),"Program Unit Specification Headers"),(0,a.kt)("h4",c({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put a header on the specification of each program unit."),(0,a.kt)("li",{parentName:"ul"},"Place information required by the user of the program unit in the\nspecification header."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the specification\nheader that is present in the specification."),(0,a.kt)("li",{parentName:"ul"},"Explain what the unit does, not how or why it does it."),(0,a.kt)("li",{parentName:"ul"},"Describe the complete interface to the program unit, including any\nexceptions it can raise and any global effects it can have."),(0,a.kt)("li",{parentName:"ul"},"Do not include information about how the unit fits into the\nenclosing software system."),(0,a.kt)("li",{parentName:"ul"},"Describe the performance (time and space) characteristics of the\nunit.")),(0,a.kt)("h4",c({},{id:"instantiation-5"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put the name of the program unit in the header."),(0,a.kt)("li",{parentName:"ul"},"Briefly explain the purpose of the program unit."),(0,a.kt)("li",{parentName:"ul"},"For packages, describe the effects of the visible subprograms on\neach other and how they should be used together."),(0,a.kt)("li",{parentName:"ul"},"List all exceptions that can be raised by the unit."),(0,a.kt)("li",{parentName:"ul"},"List all global effects of the unit."),(0,a.kt)("li",{parentName:"ul"},"List preconditions and postconditions of the unit."),(0,a.kt)("li",{parentName:"ul"},"List hidden tasks activated by the unit."),(0,a.kt)("li",{parentName:"ul"},"Do not list the names of parameters of a subprogram."),(0,a.kt)("li",{parentName:"ul"},"Do not list the names of package subprograms just to list them."),(0,a.kt)("li",{parentName:"ul"},"Do not list the names of all other units used by the unit."),(0,a.kt)("li",{parentName:"ul"},"Do not list the names of all other units that use the unit.")),(0,a.kt)("h4",c({},{id:"example-13"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"     ------------------------------------------------------------------------\n     -- AUTOLAYOUT\n     --\n     -- Purpose:\n     --   This package computes positional information for nodes and arcs\n     --   of a directed graph.  It encapsulates a layout algorithm which is\n     --   designed to minimize the number of crossing arcs and to emphasize\n     --   the primary direction of arc flow through the graph.\n     --\n     -- Effects:\n     --   - The expected usage is:\n     --     1. Call Define for each node and arc to define the graph.\n     --     2. Call Layout to assign positions to all nodes and arcs.\n     --     3. Call Position_Of for each node and arc to determine the\n     --        assigned coordinate positions.\n     --   - Layout can be called multiple times, and recomputes the\n     --     positions of all currently defined nodes and arcs each time.\n     --   - Once a node or arc has been defined, it remains defined until\n     --     Clear is called to delete all nodes and arcs.\n     --\n     -- Performance:\n     --   This package has been optimized for time, in preference to space.\n     --   Layout times are on the order of N*log(N) where N is the number\n     --   of nodes, but memory space is used inefficiently.\n     ------------------------------------------------------------------------\n\n     package Autolayout is\n\n        ...\n\n        ---------------------------------------------------------------------\n        -- Define\n        --\n        -- Purpose:\n        --   This procedure defines one node of the current graph.\n        -- Exceptions:\n        --   Node_Already_Defined\n        ---------------------------------------------------------------------\n        procedure Define\n              (New_Node : in     Node);\n\n        ---------------------------------------------------------------------\n        -- Layout\n        --\n        -- Purpose:\n        --   This procedure assigns coordinate positions to all defined\n        --   nodes and arcs.\n        -- Exceptions:\n        --   None.\n        ---------------------------------------------------------------------\n        procedure Layout;\n\n        ---------------------------------------------------------------------\n        -- Position_Of\n        --\n        -- Purpose:\n        --   This function returns the coordinate position of the\n        --   specified node.  The default position (0,0) is returned if no\n        --   position has been assigned yet.\n        -- Exceptions:\n        --   Node_Not_Defined\n        ---------------------------------------------------------------------\n        function Position_Of (Current : in     Node)\n              return Position;\n\n        ...\n\n     end Autolayout;\n")),(0,a.kt)("h4",c({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"The purpose of a header comment on the specification of a program unit\nis to help the user understand how to use the program unit. From reading\nthe program unit specification and header, a user should know everything\nnecessary to use the unit. It should not be necessary to read the body\nof the program unit. Therefore, there should be a header comment on each\nprogram unit specification, and each header should contain all usage\ninformation not expressed in the specification itself. Such information\nincludes the units' effects on each other and on shared resources,\nexceptions raised, and time/space characteristics. None of this\ninformation can be determined from the Ada specification of the program\nunit."),(0,a.kt)("p",null,"When you duplicate information in the header that can be readily\nobtained from the specification, the information tends to become\nincorrect during maintenance. For example, do not make a point of\nlisting all parameter names, modes, or subtypes when describing a\nprocedure. This information is already available from the procedure\nspecification. Similarly, do not list all subprograms of a package in\nthe header unless this is necessary to make some important statement\nabout the subprograms."),(0,a.kt)("p",null,"Do not include information in the header that the user of the program\nunit does not need. In particular, do not include information about how\na program unit performs its function or why a particular algorithm was\nused. This information should be hidden in the body of the program unit\nto preserve the abstraction defined by the unit. If the user knows such\ndetails and makes decisions based on that information, the code may\nsuffer when that information is later changed."),(0,a.kt)("p",null,'When describing the purpose of the unit, avoid referring to other parts\nof the enclosing software system. It is better to say "this unit does\u2026"\nthan to say "this unit is called by Xyz to do\u2026." The unit should be\nwritten in such a way that it does not know or care which unit is\ncalling it. This makes the unit much more general purpose and reusable.\nIn addition, information about other units is likely to become obsolete\nand incorrect during maintenance.'),(0,a.kt)("p",null,"Include information about the performance (time and space)\ncharacteristics of the unit. Much of this information is not present in\nthe Ada specification, but it is required by the user. To integrate the\nunit into a system, the user needs to understand the resource usage\n(CPU, memory, etc.) of the unit. It is especially important to note that\nwhen a subprogram call causes activation of a task hidden in a package\nbody, the task may continue to consume resources after the subroutine\nends."),(0,a.kt)("h4",c({},{id:"notes-8"}),"notes"),(0,a.kt)("p",null,"Some projects have deferred most of the commentary to the end rather\nthan at the beginning of the program unit. Their rationale is that\nprogram units are written once and read many times and that long header\ncomments make the start of the specification difficult to find."),(0,a.kt)("h4",c({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"Where a group of program units are closely related or simple to\nunderstand, it is acceptable to use a single header for the entire group\nof program units. For example, it makes sense to use a single header to\ndescribe the behavior of Max and Min functions; Sin, Cos, and Tan\nfunctions; or a group of functions to query related attributes of an\nobject encapsulated in a package. This is especially true when each\nfunction in the set is capable of raising the same exceptions."),(0,a.kt)("h3",c({},{id:"program-unit-body-headers"}),"Program Unit Body Headers"),(0,a.kt)("h4",c({},{id:"guideline-15"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Place information required by the maintainer of the program unit in\nthe body of the header"),(0,a.kt)("li",{parentName:"ul"},"Explain how and why the unit performs its function, not what the\nunit does."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the header that is\nreadily apparent from reading the code."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the body header that\nis available in the specification header.")),(0,a.kt)("h4",c({},{id:"instantiation-6"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Put the name of the program unit in the header."),(0,a.kt)("li",{parentName:"ul"},"Record portability issues in the header."),(0,a.kt)("li",{parentName:"ul"},"Summarize complex algorithms in the header."),(0,a.kt)("li",{parentName:"ul"},"Record reasons for significant or controversial implementation\ndecisions."),(0,a.kt)("li",{parentName:"ul"},"Record discarded implementation alternatives, along with the reason\nfor discarding them."),(0,a.kt)("li",{parentName:"ul"},"Record anticipated changes in the header, especially if some work\nhas already been done to the code to make the changes easy to\naccomplish.")),(0,a.kt)("h4",c({},{id:"example-14"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\n-- Autolayout\n--\n-- Implementation Notes:\n--   - This package uses a heuristic algorithm to minimize the number\n--     of arc crossings.  It does not always achieve the true minimum\n--     number which could theoretically be reached.  However it does a\n--     nearly perfect job in relatively little time.  For details about\n--     the algorithm, see ...\n--\n-- Portability Issues:\n--   - The native math package Math_Lib is used for computations of\n--     coordinate positions.\n--   - 32-bit integers are required.\n--   - No operating system specific routines are called.\n--\n-- Anticipated Changes:\n--   - Coordinate_Type below could be changed from integer to float\n--     with little effort.  Care has been taken to not depend on the\n--     specific characteristics of integer arithmetic.\n------------------------------------------------------------------------\npackage body Autolayout is\n\n   ...\n\n   ---------------------------------------------------------------------\n   -- Define\n   --\n   -- Implementation Notes:\n   --   - This routine stores a node in the general purpose Graph data\n   --     structure, not the Fast_Graph structure because ...\n   ---------------------------------------------------------------------\n   procedure Define\n         (New_Node : in     Node) is\n   begin\n      ...\n   end Define;\n\n   ---------------------------------------------------------------------\n   -- Layout\n   --\n   -- Implementation Notes:\n   --   - This routine copies the Graph data structure (optimized for\n   --     fast random access) into the Fast_Graph data structure\n   --     (optimized for fast sequential iteration), then performs the\n   --     layout, and copies the data back to the Graph structure.  This\n   --     technique was introduced as an optimization when the algorithm\n   --     was found to be too slow, and it produced an order of\n   --     magnitude improvement.\n   ---------------------------------------------------------------------\n   procedure Layout is\n   begin\n      ...\n   end Layout;\n\n   ---------------------------------------------------------------------\n   -- Position_Of\n   ---------------------------------------------------------------------\n   function Position_Of (Current : in     Node)\n         return Position is\n   begin\n      ...\n   end Position_Of;\n\n   ...\n\nend Autolayout;\n")),(0,a.kt)("h4",c({},{id:"rationale-15"}),"rationale"),(0,a.kt)("p",null,"The purpose of a header comment on the body of a program unit is to help\nthe maintainer of the program unit to understand the implementation of\nthe unit, including tradeoffs among different techniques. Be sure to\ndocument all decisions made during implementation to prevent the\nmaintainer from making the same mistakes you made. One of the most\nvaluable comments to a maintainer is a clear description of why a change\nbeing considered will not work."),(0,a.kt)("p",null,"The header is also a good place to record portability concerns. The\nmaintainer may have to port the software to a different environment and\nwill benefit from a list of nonportable features. Furthermore, the act\nof collecting and recording portability issues focuses attention on\nthese issues and may result in more portable code from the start."),(0,a.kt)("p",null,"Summarize complex algorithms in the header if the code is difficult to\nread or understand without such a summary, but do not merely paraphrase\nthe code. Such duplication is unnecessary and hard to maintain.\nSimilarly, do not repeat the information from the header of the program\nunit specification."),(0,a.kt)("h4",c({},{id:"notes-9"}),"notes"),(0,a.kt)("p",null,"It is often the case that a program unit is self-explanatory so that it\ndoes not require a body header to explain how it is implemented or why.\nIn such a case, omit the header entirely, as in the case with\nPosition_Of above. Be sure, however, that the header you omit truly\ncontains no information. For example, consider the difference between\nthe two header sections:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"-- Implementation Notes:  None.\n")),(0,a.kt)("p",null,"and:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"-- NonPortable Features:  None.\n")),(0,a.kt)("p",null,'The first is a message from the author to the maintainer saying "I can\'t\nthink of anything else to tell you," while the second may mean "I\nguarantee that this unit is entirely portable."'),(0,a.kt)("h3",c({},{id:"data-comments"}),"Data Comments"),(0,a.kt)("h4",c({},{id:"guideline-16"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Comment on all data types, objects, and exceptions unless their\nnames are self-explanatory."),(0,a.kt)("li",{parentName:"ul"},"Include information on the semantic structure of complex,\npointer-based data structures."),(0,a.kt)("li",{parentName:"ul"},"Include information about relationships that are maintained between\ndata objects."),(0,a.kt)("li",{parentName:"ul"},"Omit comments that merely repeat the information in the name."),(0,a.kt)("li",{parentName:"ul"},"Include information on redispatching for tagged types in cases where\nyou intend the specializations (i.e., derived types) to override\nthese redispatching operations.")),(0,a.kt)("h4",c({},{id:"example-15"}),"example"),(0,a.kt)("p",null,"Objects can be grouped by purpose and commented as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"...\n\n---------------------------------------------------------------------\n-- Current position of the cursor in the currently selected text\n-- buffer, and the most recent position explicitly marked by the\n-- user.\n-- Note:  It is necessary to maintain both current and desired\n--        column positions because the cursor cannot always be\n--        displayed in the desired position when moving between\n--        lines of different lengths.\n---------------------------------------------------------------------\nDesired_Column : Column_Counter;\nCurrent_Column : Column_Counter;\nCurrent_Row    : Row_Counter;\nMarked_Column  : Column_Counter;\nMarked_Row     : Row_Counter;\n")),(0,a.kt)("p",null,"The conditions under which an exception is raised should be commented:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"---------------------------------------------------------------------\n-- Exceptions\n---------------------------------------------------------------------\nNode_Already_Defined : exception;   -- Raised when an attempt is made\n                                    --|   to define a node with an\n                                    --|   identifier which already\n                                    --|   defines a node.\nNode_Not_Defined     : exception;   -- Raised when a reference is\n                                    --|   made to a node which has\n                                    --|   not been defined.\n")),(0,a.kt)("p",null,"Here is a more complex example, involving multiple record and access\ntypes that are used to form a complex data structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'---------------------------------------------------------------------\n-- These data structures are used to store the graph during the\n-- layout process. The overall organization is a sorted list of\n-- "ranks," each containing a sorted list of nodes, each containing\n-- a list of incoming arcs and a list of outgoing arcs.\n-- The lists are doubly linked to support forward and backward\n-- passes for sorting. Arc lists do not need to be doubly linked\n-- because order of arcs is irrelevant.\n--\n-- The nodes and arcs are doubly linked to each other to support\n-- efficient lookup of all arcs to/from a node, as well as efficient\n-- lookup of the source/target node of an arc.\n---------------------------------------------------------------------\n\ntype Arc;\ntype Arc_Pointer is access Arc;\n\ntype Node;\ntype Node_Pointer is access Node;\n\ntype Node is\n   record\n      Id       : Node_Pointer;-- Unique node ID supplied by the user.\n      Arc_In   : Arc_Pointer;\n      Arc_Out  : Arc_Pointer;\n      Next     : Node_Pointer;\n      Previous : Node_Pointer;\n   end record;\n\ntype Arc is\n   record\n      ID     : Arc_ID;        -- Unique arc ID supplied by the user.\n      Source : Node_Pointer;\n      Target : Node_Pointer;\n      Next   : Arc_Pointer;\n   end record;\n\ntype Rank;\ntype Rank_Pointer is access Rank;\n\ntype Rank is\n   record\n      Number     : Level_ID;  -- Computed ordinal number of the rank.\n      First_Node : Node_Pointer;\n      Last_Node  : Node_Pointer;\n      Next       : Rank_Pointer;\n      Previous   : Rank_Pointer;\n   end record;\n\nFirst_Rank : Rank_Pointer;\nLast_Rank  : Rank_Pointer;\n')),(0,a.kt)("h4",c({},{id:"rationale-16"}),"rationale"),(0,a.kt)("p",null,"It is very useful to add comments explaining the purpose, structure, and\nsemantics of the data structures. Many maintainers look at the data\nstructures first when trying to understand the implementation of a unit.\nUnderstanding the data that can be stored, along with the relationships\nbetween the different data items and the flow of data through the unit,\nis an important first step in understanding the details of the unit."),(0,a.kt)("p",null,"In the first example above, the names Current_Column and Current_Row\nare relatively self-explanatory. The name Desired_Column is also well\nchosen, but it leaves the reader wondering what the relationship is\nbetween the current column and the desired column. The comment explains\nthe reason for having both."),(0,a.kt)("p",null,'Another advantage of commenting on the data declarations is that the\nsingle set of comments on a declaration can replace multiple sets of\ncomments that might otherwise be needed at various places in the code\nwhere the data is manipulated. In the first example above, the comment\nbriefly expands on the meaning of "current" and "marked." It states that\nthe "current" position is the location of the cursor, the "current"\nposition is in the current buffer, and the "marked" position was marked\nby the user. This comment, along with the mnemonic names of the\nvariables, greatly reduces the need for comments at individual\nstatements throughout the code.'),(0,a.kt)("p",null,"It is important to document the full meaning of exceptions and under\nwhat conditions they can be raised, as shown in the second example\nabove, especially when the exceptions are declared in a package\nspecification. The reader has no other way to find out the exact meaning\nof the exception (without reading the code in the package body)."),(0,a.kt)("p",null,'Grouping all the exceptions together, as shown in the second example,\ncan provide the reader with the effect of a "glossary" of special\nconditions. This is useful when many different subprograms in the\npackage can raise the same exceptions. For a package in which each\nexception can be raised by only one subprogram, it may be better to\ngroup related subprograms and exceptions together.'),(0,a.kt)("p",null,"When commenting exceptions, it is better to describe the exception's\nmeaning in general terms than to list all the subprograms that can cause\nthe exception to be raised; such a list is harder to maintain. When a\nnew routine is added, it is likely that these lists will not be updated.\nAlso, this information is already present in the comments describing the\nsubprograms, where all exceptions that can be raised by the subprogram\nshould be listed. Lists of exceptions by subprogram are more useful and\neasier to maintain than lists of subprograms by exception."),(0,a.kt)("p",null,"In the third example, the names of the record fields are short and\nmnemonic, but they are not completely self-explanatory. This is often\nthe case with complex data structures involving access types. There is\nno way to choose the record and field names so that they completely\nexplain the overall organization of the records and pointers into a\nnested set of sorted lists. The comments shown are useful in this case.\nWithout them, the reader would not know which lists are sorted, which\nlists are doubly linked, or why. The comments express the intent of the\nauthor with respect to this complex data structure. The maintainer still\nhas to read the code if he wants to be sure that the double links are\nall properly maintained. Keeping this in mind when reading the code\nmakes it much easier for the maintainer to find a bug where one pointer\nis updated and the opposite one is not."),(0,a.kt)("p",null,"See Guideline 9.3.1 for the rationale for documenting the use of\nredispatching operations. (Redispatching means converting an argument of\none primitive operation to a class-wide type and making a dispatching\ncall to another primitive operation.) The rationale in Guideline 9.3.1\ndiscusses whether such documentation should be in the specification or\nthe body."),(0,a.kt)("h3",c({},{id:"statement-comments"}),"Statement Comments"),(0,a.kt)("h4",c({},{id:"guideline-17"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize comments embedded among statements."),(0,a.kt)("li",{parentName:"ul"},"Use comments only to explain parts of the code that are not obvious."),(0,a.kt)("li",{parentName:"ul"},"Comment intentional omissions from the code."),(0,a.kt)("li",{parentName:"ul"},"Do not use comments to paraphrase the code."),(0,a.kt)("li",{parentName:"ul"},"Do not use comments to explain remote pieces of code, such as\nsubprograms called by the current unit."),(0,a.kt)("li",{parentName:"ul"},"Where comments are necessary, make them visually distinct from the\ncode.")),(0,a.kt)("h4",c({},{id:"example-16"}),"example"),(0,a.kt)("p",null,"The following is an example of very poorly commented code:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"...\n\n-- Loop through all the strings in the array Strings, converting\n-- them to integers by calling Convert_To_Integer on each one,\n-- accumulating the sum of all the values in Sum, and counting them\n-- in Count.  Then divide Sum by Count to get the average and store\n-- it in Average. Also, record the maximum number in the global\n-- variable Max_Number.\n\nfor I in Strings'Range loop\n   -- Convert each string to an integer value by looping through\n   -- the characters which are digits, until a nondigit is found,\n   -- taking the ordinal value of each, subtracting the ordinal value\n   -- of '0', and multiplying by 10 if another digit follows.  Store\n   -- the result in Number.\n   Number := Convert_To_Integer(Strings(I));\n   -- Accumulate the sum of the numbers in Total.\n   Sum := Sum + Number;\n   -- Count the numbers.\n   Count := Count + 1;\n\n   -- Decide whether this number is more than the current maximum.\n   if Number > Max_Number then\n      -- Update the global variable Max_Number.\n      Max_Number := Number;\n   end if;\n\nend loop;\n-- Compute the average.\nAverage := Sum / Count;\n")),(0,a.kt)("p",null,"The following is improved by not repeating things in the comments that\nare obvious from the code, not describing the details of what goes in\ninside of ",(0,a.kt)("inlineCode",{parentName:"p"},"Convert_To_Integer"),", deleting an erroneous comment (the one\non the statement that accumulates the sum), and making the few remaining\ncomments more visually distinct from the code."),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Sum_Integers_Converted_From_Strings:\n   for I in Strings'Range loop\n      Number := Convert_To_Integer(Strings(I));\n      Sum := Sum + Number;\n      Count := Count + 1;\n\n      -- The global Max_Number is computed here for efficiency.\n      if Number > Max_Number then\n         Max_Number := Number;\n      end if;\n\n   end loop Sum_Integers_Converted_From_Strings;\n\nAverage := Sum / Count;\n")),(0,a.kt)("h4",c({},{id:"rationale-17"}),"rationale"),(0,a.kt)("p",null,"The improvements shown in the example are not improvements merely by\nreducing the total number of comments; they are improvements by reducing\nthe number of useless comments."),(0,a.kt)("p",null,"Comments that paraphrase or explain obvious aspects of the code have no\nvalue. They are a waste of effort for the author to write and the\nmaintainer to update. Therefore, they often end up becoming incorrect.\nSuch comments also clutter the code, hiding the few important comments."),(0,a.kt)("p",null,"Comments describing what goes on inside another unit violate the\nprinciple of information hiding. The details about Convert_To_Integer\n(deleted above) are irrelevant to the calling unit, and they are better\nleft hidden in case the algorithm ever changes. Examples explaining what\ngoes on elsewhere in the code are very difficult to maintain and almost\nalways become incorrect at the first code modification."),(0,a.kt)("p",null,"The advantage of making comments visually distinct from the code is that\nit makes the code easier to scan, and the few important comments stand\nout better. Highlighting unusual or special code features indicates that\nthey are intentional. This assists maintainers by focusing attention on\ncode sections that are likely to cause problems during maintenance or\nwhen porting the program to another implementation."),(0,a.kt)("p",null,'Comments should be used to document code that is nonportable,\nimplementation-dependent, environment-dependent, or tricky in any way.\nThey notify the reader that something unusual was put there for a\nreason. A beneficial comment would be one explaining a work around for a\ncompiler bug. If you use a lower level (not "ideal" in the software\nengineering sense) solution, comment on it. Information included in the\ncomments should state why you used that particular construct. Also\ninclude documentation on the failed attempts, for example, using a\nhigher level structure. This kind of comment is useful to maintainers\nfor historical purposes. You show the reader that a significant amount\nof thought went into the choice of a construct.'),(0,a.kt)("p",null,'Finally, comments should be used to explain what is not present in the\ncode as well as what is present. If you make a conscious decision to not\nperform some action, like deallocating a data structure with which you\nappear to be finished, be sure to add a comment explaining why not.\nOtherwise, a maintainer may notice the apparent omission and "correct"\nit later, thus introducing an error.'),(0,a.kt)("p",null,"See also Guideline 9.3.1 for a discussion of what kind of documentation\nyou should provide regarding tagged types and redispatching."),(0,a.kt)("h4",c({},{id:"notes-10"}),"notes"),(0,a.kt)("p",null,"Further improvements can be made on the above example by declaring the\nvariables Count and Sum in a local block so that their scope is limited\nand their initializations occur near their usage, e.g., by naming the\nblock Compute_Average or by moving the code into a function called\nAverage_Of. The computation of Max_Number can also be separated from\nthe computation of Average. However, those changes are the subject of\nother guidelines; this example is only intended to illustrate the proper\nuse of comments."),(0,a.kt)("h3",c({},{id:"marker-comments"}),"Marker Comments"),(0,a.kt)("h4",c({},{id:"guideline-18"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use pagination markers to mark program unit boundaries (see\nGuideline 2.1.7)."),(0,a.kt)("li",{parentName:"ul"},"Repeat the unit name in a comment to mark the ",(0,a.kt)("inlineCode",{parentName:"li"},"begin")," of a package\nbody, subprogram body, task body, or block if the ",(0,a.kt)("inlineCode",{parentName:"li"},"begin")," is\npreceded by declarations."),(0,a.kt)("li",{parentName:"ul"},"For long or heavily nested ",(0,a.kt)("inlineCode",{parentName:"li"},"if")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statements, mark the end\nof the statement with a comment summarizing the condition governing\nthe statement."),(0,a.kt)("li",{parentName:"ul"},"For long or heavily nested ",(0,a.kt)("inlineCode",{parentName:"li"},"if")," statements, mark the ",(0,a.kt)("inlineCode",{parentName:"li"},"else")," part\nwith a comment summarizing the conditions governing this portion of\nthe statement.")),(0,a.kt)("h4",c({},{id:"example-17"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"if    A_Found then\n   ...\nelsif B_Found then\n   ...\n\nelse  -- A and B were both not found\n   ...\n\n   if Count = Max then\n      ...\n\n   end if;\n\n   ...\nend if;  -- A_Found\n\n------------------------------------------------------------------------\npackage body Abstract_Strings is\n   ...\n\n   ---------------------------------------------------------------------\n   procedure Concatenate (...) is\n   begin\n      ...\n   end Concatenate;\n   ---------------------------------------------------------------------\n\n   ...\nbegin  -- Abstract_Strings\n   ...\nend Abstract_Strings;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-18"}),"rationale"),(0,a.kt)("p",null,"Marker comments emphasize the structure of code and make it easier to\nscan. They can be lines that separate sections of code or descriptive\ntags for a construct. They help the reader resolve questions about the\ncurrent position in the code. This is more important for large units\nthan for small ones. A short marker comment fits on the same line as the\nreserved word with which it is associated. Thus, it adds information\nwithout clutter."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"elsif"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"else"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"end if")," of an ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement are often\nseparated by long sequences of statements, sometimes involving other\n",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statements. As shown in the first example, marker comments\nemphasize the association of the keywords of the same statement over a\ngreat visual distance. Marker comments are not necessary with the block\nstatement and loop statement because the syntax of these statements\nallows them to be named with the name repeated at the end. Using these\nnames is better than using marker comments because the compiler verifies\nthat the names at the beginning and end match."),(0,a.kt)("p",null,"The sequence of statements of a package body is often very far from the\nfirst line of the package. Many subprogram bodies, each containing many\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin")," lines, may occur first. As shown in the second example, the\nmarker comment emphasizes the association of the begin with the package."),(0,a.kt)("h4",c({},{id:"notes-11"}),"notes"),(0,a.kt)("p",null,"Repeating names and noting conditional expressions clutters the code if\noverdone. It is visual distance, especially page breaks, that makes\nmarker comments beneficial."),(0,a.kt)("h2",c({},{id:"using-types"}),"Using Types"),(0,a.kt)("p",null,"Strong typing promotes reliability in software. The type definition of\nan object defines all legal values and operations and allows the\ncompiler to check for and identify potential errors during compilation.\nIn addition, the rules of type allow the compiler to generate code to\ncheck for violations of type constraints at execution time. Using these\nAda compiler's features facilitates earlier and more complete error\ndetection than that which is available with less strongly typed\nlanguages."),(0,a.kt)("h3",c({},{id:"declaring-types"}),"Declaring Types"),(0,a.kt)("h4",c({},{id:"guideline-19"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Limit the range of scalar types as much as possible."),(0,a.kt)("li",{parentName:"ul"},"Seek information about possible values from the application."),(0,a.kt)("li",{parentName:"ul"},"Do not reuse any of the subtype names in package Standard."),(0,a.kt)("li",{parentName:"ul"},"Use subtype declarations to improve program readability (Booch\n1987)."),(0,a.kt)("li",{parentName:"ul"},"Use derived types and subtypes in concert (see Guideline 5.3.1).")),(0,a.kt)("h4",c({},{id:"example-18"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"subtype Card_Image is String (1 .. 80);\nInput_Line : Card_Image := (others => ' ');\n-- restricted integer type:\ntype    Day_Of_Leap_Year     is                  range 1 .. 366;\nsubtype Day_Of_Non_Leap_Year is Day_Of_Leap_Year range 1 .. 365;\n")),(0,a.kt)("p",null,'By the following declaration, the programmer means, "I haven\'t the\nfoggiest idea how many," but the actual base range will show up buried\nin the code or as a system parameter:'),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Employee_Count : Integer;\n")),(0,a.kt)("h4",c({},{id:"rationale-19"}),"rationale"),(0,a.kt)("p",null,"Eliminating meaningless values from the legal range improves the\ncompiler's ability to detect errors when an object is set to an invalid\nvalue. This also improves program readability. In addition, it forces\nyou to carefully think about each use of objects declared to be of the\nsubtype."),(0,a.kt)("p",null,"Different implementations provide different sets of values for most of\nthe predefined types. A reader cannot determine the intended range from\nthe predefined names. This situation is aggravated when the predefined\nnames are overloaded."),(0,a.kt)("p",null,"The names of an object and its subtype can clarify their intended use\nand document low-level design decisions. The example above documents a\ndesign decision to restrict the software to devices whose physical\nparameters are derived from the characteristics of punch cards. This\ninformation is easy to find for any later changes, thus enhancing\nprogram maintainability."),(0,a.kt)("p",null,"You can rename a type by declaring a subtype without a constraint (Ada\nReference Manual 1995, \xa78.5). You cannot overload a subtype name;\noverloading only applies to callable entities. Enumeration literals are\ntreated as parameterless functions and so are included in this rule."),(0,a.kt)("p",null,"Types can have highly constrained sets of values without eliminating\nuseful values. Usage as described in Guideline 5.3.1 eliminates many\nflag variables and type conversions within executable statements. This\nrenders the program more readable while allowing the compiler to enforce\nstrong typing constraints."),(0,a.kt)("h4",c({},{id:"notes-12"}),"notes"),(0,a.kt)("p",null,"Subtype declarations do not define new types, only constraints for\nexisting types."),(0,a.kt)("p",null,"Any deviation from this guideline detracts from the advantages of the\nstrong typing facilities of the Ada language."),(0,a.kt)("h4",c({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("p",null,"There are cases where you do not have a particular dependence on any\nrange of numeric values. Such situations occur, for example, with array\nindices (e.g., a list whose size is not fixed by any particular\nsemantics). See Guideline 7.2.1 for a discussion of appropriate uses of\npredefined types."),(0,a.kt)("h3",c({},{id:"enumeration-types"}),"Enumeration Types"),(0,a.kt)("h4",c({},{id:"guideline-20"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use enumeration types instead of numeric codes."),(0,a.kt)("li",{parentName:"ul"},"Only if absolutely necessary, use representation clauses to match\nrequirements of external devices.")),(0,a.kt)("h4",c({},{id:"example-19"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Color is (Blue, Red, Green, Yellow);\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Blue   : constant := 1;\nRed    : constant := 2;\nGreen  : constant := 3;\nYellow : constant := 4;\n")),(0,a.kt)("p",null,"and add the following if necessary:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"for Color use (Blue   => 1,\n               Red    => 2,\n               Green  => 3,\n               Yellow => 4);\n")),(0,a.kt)("h4",c({},{id:"rationale-20"}),"rationale"),(0,a.kt)("p",null,"Enumerations are more robust than numeric codes; they leave less\npotential for errors resulting from incorrect interpretation and from\nadditions to and deletions from the set of values during maintenance.\nNumeric codes are holdovers from languages that have no user-defined\ntypes."),(0,a.kt)("p",null,"In addition, Ada provides a number of attributes ('Pos, 'Val, 'Succ,\n'Pred, 'Image, and 'Value) for enumeration types that, when used, are\nmore reliable than user-written operations on encodings."),(0,a.kt)("p",null,'A numeric code may at first seem appropriate to match external values.\nInstead, these situations call for a representation clause on the\nenumeration type. The representation clause documents the "encoding." If\nthe program is properly structured to isolate and encapsulate hardware\ndependencies (see Guideline 7.1.5), the numeric code ends up in an\ninterface package where it can be easily found and replaced if the\nrequirements change.'),(0,a.kt)("p",null,"In general, avoid using representation clauses for enumeration types.\nWhen there is no obvious ordering of the enumeration literals, an\nenumeration representation can create portability problems if the\nenumeration type must be reordered to accommodate a change in\nrepresentation order on the new platform."),(0,a.kt)("h2",c({},{id:"summary"}),"Summary"),(0,a.kt)("h3",c({},{id:"spelling-1"}),"spelling"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use underscores to separate words in a compound name."),(0,a.kt)("li",{parentName:"ul"},"Represent numbers in a consistent fashion."),(0,a.kt)("li",{parentName:"ul"},"Represent literals in a radix appropriate to the problem."),(0,a.kt)("li",{parentName:"ul"},"Use underscores to separate digits the same way commas or periods\n(or spaces for nondecimal bases) would be used in normal text."),(0,a.kt)("li",{parentName:"ul"},"When using scientific notation, make the E consistently either\nuppercase or lowercase."),(0,a.kt)("li",{parentName:"ul"},"In an alternate base, represent the alphabetic characters in either\nall uppercase or all lowercase."),(0,a.kt)("li",{parentName:"ul"},"Make reserved words and other elements of the program visually\ndistinct from each other."),(0,a.kt)("li",{parentName:"ul"},"Do not use an abbreviation of a long word as an identifier where a\nshorter synonym exists."),(0,a.kt)("li",{parentName:"ul"},"Use a consistent abbreviation strategy."),(0,a.kt)("li",{parentName:"ul"},"Do not use ambiguous abbreviations."),(0,a.kt)("li",{parentName:"ul"},"To justify its use, an abbreviation must save many characters over\nthe full word."),(0,a.kt)("li",{parentName:"ul"},"Use abbreviations that are well-accepted in the application domain."),(0,a.kt)("li",{parentName:"ul"},"Maintain a list of accepted abbreviations, and use only\nabbreviations on that list.")),(0,a.kt)("h3",c({},{id:"naming-conventions-1"}),"naming conventions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Choose names that are as self-documenting as possible."),(0,a.kt)("li",{parentName:"ul"},"Use a short synonym instead of an abbreviation."),(0,a.kt)("li",{parentName:"ul"},"Use names given by the application, but do not use obscure jargon."),(0,a.kt)("li",{parentName:"ul"},"Avoid using the same name to declare different kinds of identifiers."),(0,a.kt)("li",{parentName:"ul"},"Use singular, general nouns as subtype identifiers."),(0,a.kt)("li",{parentName:"ul"},"Choose identifiers that describe one of the subtype's values."),(0,a.kt)("li",{parentName:"ul"},"Consider using suffixes for subtype identifiers that define visible\naccess types, visible subranges, or visible array types."),(0,a.kt)("li",{parentName:"ul"},"For private types, do not use identifier constructions (e.g.,\nsuffixes) that are unique to subtype identifiers."),(0,a.kt)("li",{parentName:"ul"},"Do not use the subtype names from predefined packages."),(0,a.kt)("li",{parentName:"ul"},"Use predicate clauses or adjectives for Boolean objects."),(0,a.kt)("li",{parentName:"ul"},"Use singular, specific nouns as object identifiers."),(0,a.kt)("li",{parentName:"ul"},"Choose identifiers that describe the object's value during\nexecution."),(0,a.kt)("li",{parentName:"ul"},"Use singular, general nouns as identifiers for record components."),(0,a.kt)("li",{parentName:"ul"},"Use a consistent naming convention for tagged types and associated\npackages."),(0,a.kt)("li",{parentName:"ul"},"Use action verbs for procedures and entries."),(0,a.kt)("li",{parentName:"ul"},"Use predicate clauses for Boolean functions."),(0,a.kt)("li",{parentName:"ul"},"Use nouns for non-Boolean functions."),(0,a.kt)("li",{parentName:"ul"},"Give packages names that imply a higher level of organization than\nsubprograms. Generally, these are noun phrases that describe the\nabstraction provided."),(0,a.kt)("li",{parentName:"ul"},"Give tasks names that imply an active entity."),(0,a.kt)("li",{parentName:"ul"},"Use nouns descriptive of the data being protected for protected\nunits."),(0,a.kt)("li",{parentName:"ul"},"Consider naming generic subprograms as if they were nongeneric\nsubprograms."),(0,a.kt)("li",{parentName:"ul"},"Consider naming generic packages as if they were nongeneric\npackages."),(0,a.kt)("li",{parentName:"ul"},"Make the generic names more general than the instantiated names."),(0,a.kt)("li",{parentName:"ul"},"Use symbolic values instead of literals, wherever possible."),(0,a.kt)("li",{parentName:"ul"},"Use the predefined constants Ada.Numerics.Pi and Ada.Numerics.e for\nthe mathematical constants Pi and e."),(0,a.kt)("li",{parentName:"ul"},"Use constants instead of variables for constant values."),(0,a.kt)("li",{parentName:"ul"},"Use a constant when the value is specific to a type or when the\nvalue must be static."),(0,a.kt)("li",{parentName:"ul"},"Use named numbers instead of constants, whenever possible."),(0,a.kt)("li",{parentName:"ul"},"Use named numbers to replace numeric literals whose type or context\nis truly universal."),(0,a.kt)("li",{parentName:"ul"},"Use constants for objects whose values cannot change after\nelaboration. (United Technologies 1987)."),(0,a.kt)("li",{parentName:"ul"},"Show relationships between symbolic values by defining them with\nstatic expressions."),(0,a.kt)("li",{parentName:"ul"},"Use linearly independent sets of literals."),(0,a.kt)("li",{parentName:"ul"},"Use attributes like 'First and 'Last instead of literals, wherever\npossible."),(0,a.kt)("li",{parentName:"ul"},"Use a name that indicates the kind of problem the exception\nrepresents."),(0,a.kt)("li",{parentName:"ul"},"Include a prefix like New, Make, or Create in naming constructors\n(in this sense, operations to create and/or initialize an object)."),(0,a.kt)("li",{parentName:"ul"},"Use names indicative of their content for child packages containing\nconstructors.")),(0,a.kt)("h3",c({},{id:"comments-1"}),"comments"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Make the code as clear as possible to reduce the need for comments."),(0,a.kt)("li",{parentName:"ul"},"Never repeat information in a comment that is readily available in\nthe code."),(0,a.kt)("li",{parentName:"ul"},"Where a comment is required, make it concise and complete."),(0,a.kt)("li",{parentName:"ul"},"Use proper grammar and spelling in comments."),(0,a.kt)("li",{parentName:"ul"},"Make comments visually distinct from the code."),(0,a.kt)("li",{parentName:"ul"},"Structure comments in headers so that information can be\nautomatically extracted by a tool."),(0,a.kt)("li",{parentName:"ul"},"Put a file header on each source file."),(0,a.kt)("li",{parentName:"ul"},"Place ownership, responsibility, and history information for the\nfile in the file header."),(0,a.kt)("li",{parentName:"ul"},"Put a header on the specification of each program unit."),(0,a.kt)("li",{parentName:"ul"},"Place information required by the user of the program unit in the\nspecification header."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the specification\nheader that is present in the specification."),(0,a.kt)("li",{parentName:"ul"},"Explain what the unit does, not how or why it does it."),(0,a.kt)("li",{parentName:"ul"},"Describe the complete interface to the program unit, including any\nexceptions it can raise and any global effects it can have."),(0,a.kt)("li",{parentName:"ul"},"Do not include information about how the unit fits into the\nenclosing software system."),(0,a.kt)("li",{parentName:"ul"},"Describe the performance (time and space) characteristics of the\nunit."),(0,a.kt)("li",{parentName:"ul"},"Place information required by the maintainer of the program unit in\nthe body header."),(0,a.kt)("li",{parentName:"ul"},"Explain how and why the unit performs its function, not what the\nunit does."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the header that is\nreadily apparent from reading the code."),(0,a.kt)("li",{parentName:"ul"},"Do not repeat information (except unit name) in the body header that\nis available in the specification header."),(0,a.kt)("li",{parentName:"ul"},"Comment on all data types, objects, and exceptions unless their\nnames are self-explanatory."),(0,a.kt)("li",{parentName:"ul"},"Include information on the semantic structure of complex,\npointer-based data structures."),(0,a.kt)("li",{parentName:"ul"},"Include information about relationships that are maintained between\ndata objects."),(0,a.kt)("li",{parentName:"ul"},"Omit comments that merely repeat the information in the name."),(0,a.kt)("li",{parentName:"ul"},"Include information on redispatching for tagged types in cases where\nyou intend the specializations (i.e., derived types) to override\nthese redispatching operations."),(0,a.kt)("li",{parentName:"ul"},"Minimize comments embedded among statements."),(0,a.kt)("li",{parentName:"ul"},"Use comments only to explain parts of the code that are not obvious."),(0,a.kt)("li",{parentName:"ul"},"Comment intentional omissions from the code."),(0,a.kt)("li",{parentName:"ul"},"Do not use comments to paraphrase the code."),(0,a.kt)("li",{parentName:"ul"},"Do not use comments to explain remote pieces of code, such as\nsubprograms called by the current unit."),(0,a.kt)("li",{parentName:"ul"},"Where comments are necessary, make them visually distinct from the\ncode."),(0,a.kt)("li",{parentName:"ul"},"Use pagination markers to mark program unit boundaries."),(0,a.kt)("li",{parentName:"ul"},"Repeat the unit name in a comment to mark the begin of a package\nbody, subprogram body, task body, or block if the begin is preceded\nby declarations."),(0,a.kt)("li",{parentName:"ul"},"For long or heavily nested if and case statements, mark the end of\nthe statement with a comment summarizing the condition governing the\nstatement."),(0,a.kt)("li",{parentName:"ul"},"For long or heavily nested if statements, mark the else part with a\ncomment summarizing the conditions governing this portion of the\nstatement.")),(0,a.kt)("h3",c({},{id:"using-types-1"}),"using types"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Limit the range of scalar types as much as possible."),(0,a.kt)("li",{parentName:"ul"},"Seek information about possible values from the application."),(0,a.kt)("li",{parentName:"ul"},"Do not reuse any of the subtype names in package Standard."),(0,a.kt)("li",{parentName:"ul"},"Use subtype declarations to improve program readability (Booch\n1987)."),(0,a.kt)("li",{parentName:"ul"},"Use derived types and subtypes in concert."),(0,a.kt)("li",{parentName:"ul"},"Use enumeration types instead of numeric codes."),(0,a.kt)("li",{parentName:"ul"},"Only if absolutely necessary, use representation clauses to match\nrequirements of external devices.\n:::note")),(0,a.kt)("p",null,'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",c({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",c({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work."),(0,a.kt)("p",null,":::"))}b.isMDXComponent=!0}}]);