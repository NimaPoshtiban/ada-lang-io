"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8709],{4711:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>f,contentTitle:()=>m,default:()=>b,frontMatter:()=>h,metadata:()=>g,toc:()=>k});var n=a(1716),r=a(3183),i=Object.defineProperty,o=Object.defineProperties,s=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,a)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,p=(e,t)=>{for(var a in t||(t={}))d.call(t,a)&&u(e,a,t[a]);if(l)for(var a of l(t))c.call(t,a)&&u(e,a,t[a]);return e};const h={sidebar_position:1},m="Table of Contents",g={unversionedId:"arm/AA-TOC",id:"arm/AA-TOC",title:"Table of Contents",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-TOC.mdx",sourceDirName:"arm",slug:"/arm/AA-TOC",permalink:"/docs/arm/AA-TOC",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Reference Manual",permalink:"/docs/category/reference-manual"},next:{title:"1 General",permalink:"/docs/arm/AA-1/"}},f={},k=[],y={toc:k};function b(e){var t,a=e,{components:i}=a,u=((e,t)=>{var a={};for(var n in e)d.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&l)for(var n of l(e))t.indexOf(n)<0&&c.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=p(p({},y),u),o(t,s({components:i,mdxType:"MDXLayout"}))),(0,n.kt)("h1",p({},{id:"table-of-contents"}),"Table of Contents"),(0,n.kt)("admonition",p({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",p({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"Foreword"),(0,n.kt)("p",null,"Introduction"),(0,n.kt)("p",null,"1. General    1.1 Scope        1.1.1 Extent    1.2 Normative References        1.2.1 Bibliography    1.3 Terms and Definitions        1.3.1 Types, Objects, and their Properties        1.3.2 Subprograms and their Properties        1.3.3 Other Syntactic Constructs        1.3.4 Runtime Actions        1.3.5 Exceptional Situations"),(0,n.kt)("p",null,"2. Lexical Elements    2.1 Character Set    2.2 Lexical Elements, Separators, and Delimiters    2.3 Identifiers    2.4 Numeric Literals        2.4.1 Decimal Literals        2.4.2 Based Literals    2.5 Character Literals    2.6 String Literals    2.7 Comments    2.8 Pragmas    2.9 Reserved Words"),(0,n.kt)("p",null,"3. Declarations and Types    3.1 Declarations    3.2 Types and Subtypes        3.2.1 Type Declarations        3.2.2 Subtype Declarations        3.2.3 Classification of Operations        3.2.4 Subtype Predicates    3.3 Objects and Named Numbers        3.3.1 Object Declarations        3.3.2 Number Declarations    3.4 Derived Types and Classes        3.4.1 Derivation Classes    3.5 Scalar Types        3.5.1 Enumeration Types        3.5.2 Character Types        3.5.3 Boolean Types        3.5.4 Integer Types        3.5.5 Operations of Discrete Types        3.5.6 Real Types        3.5.7 Floating Point Types        3.5.8 Operations of Floating Point Types        3.5.9 Fixed Point Types        3.5.10 Operations of Fixed Point Types    3.6 Array Types        3.6.1 Index Constraints and Discrete Ranges        3.6.2 Operations of Array Types        3.6.3 String Types    3.7 Discriminants        3.7.1 Discriminant Constraints        3.7.2 Operations of Discriminated Types    3.8 Record Types        3.8.1 Variant Parts and Discrete Choices    3.9 Tagged Types and Type Extensions        3.9.1 Type Extensions        3.9.2 Dispatching Operations of Tagged Types        3.9.3 Abstract Types and Subprograms        3.9.4 Interface Types    3.10 Access Types        3.10.1 Incomplete Type Declarations        3.10.2 Operations of Access Types    3.11 Declarative Parts        3.11.1 Completions of Declarations"),(0,n.kt)("p",null,"4. Names and Expressions    4.1 Names        4.1.1 Indexed Components        4.1.2 Slices        4.1.3 Selected Components        4.1.4 Attributes        4.1.5 User-Defined References        4.1.6 User-Defined Indexing    4.2 Literals        4.2.1 User-Defined Literals    4.3 Aggregates        4.3.1 Record Aggregates        4.3.2 Extension Aggregates        4.3.3 Array Aggregates        4.3.4 Delta Aggregates        4.3.5 Container Aggregates    4.4 Expressions    4.5 Operators and Expression Evaluation        4.5.1 Logical Operators and Short-circuit Control Forms        4.5.2 Relational Operators and Membership Tests        4.5.3 Binary Adding Operators        4.5.4 Unary Adding Operators        4.5.5 Multiplying Operators        4.5.6 Highest Precedence Operators        4.5.7 Conditional Expressions        4.5.8 Quantified Expressions        4.5.9 Declare Expressions        4.5.10 Reduction Expressions    4.6 Type Conversions    4.7 Qualified Expressions    4.8 Allocators    4.9 Static Expressions and Static Subtypes        4.9.1 Statically Matching Constraints and Subtypes    4.10 Image Attributes"),(0,n.kt)("p",null,"5. Statements    5.1 Simple and Compound Statements - Sequences of Statements    5.2 Assignment Statements        5.2.1 Target Name Symbols    5.3 If Statements    5.4 Case Statements    5.5 Loop Statements        5.5.1 User-Defined Iterator Types        5.5.2 Generalized Loop Iteration        5.5.3 Procedural Iterators    5.6 Block Statements        5.6.1 Parallel Block Statements    5.7 Exit Statements    5.8 Goto Statements"),(0,n.kt)("p",null,"6. Subprograms    6.1 Subprogram Declarations        6.1.1 Preconditions and Postconditions        6.1.2 The Global and Global'Class Aspects    6.2 Formal Parameter Modes    6.3 Subprogram Bodies        6.3.1 Conformance Rules        6.3.2 Inline Expansion of Subprograms    6.4 Subprogram Calls        6.4.1 Parameter Associations    6.5 Return Statements        6.5.1 Nonreturning Subprograms    6.6 Overloading of Operators    6.7 Null Procedures    6.8 Expression Functions"),(0,n.kt)("p",null,"7. Packages    7.1 Package Specifications and Declarations    7.2 Package Bodies    7.3 Private Types and Private Extensions        7.3.1 Private Operations        7.3.2 Type Invariants        7.3.3 Default Initial Conditions        7.3.4 Stable Properties of a Type    7.4 Deferred Constants    7.5 Limited Types    7.6 Assignment and Finalization        7.6.1 Completion and Finalization"),(0,n.kt)("p",null,"8. Visibility Rules    8.1 Declarative Region    8.2 Scope of Declarations    8.3 Visibility        8.3.1 Overriding Indicators    8.4 Use Clauses    8.5 Renaming Declarations        8.5.1 Object Renaming Declarations        8.5.2 Exception Renaming Declarations        8.5.3 Package Renaming Declarations        8.5.4 Subprogram Renaming Declarations        8.5.5 Generic Renaming Declarations    8.6 The Context of Overload Resolution"),(0,n.kt)("p",null,"9. Tasks and Synchronization    9.1 Task Units and Task Objects    9.2 Task Execution - Task Activation    9.3 Task Dependence - Termination of Tasks    9.4 Protected Units and Protected Objects    9.5 Intertask Communication        9.5.1 Protected Subprograms and Protected Actions        9.5.2 Entries and Accept Statements        9.5.3 Entry Calls        9.5.4 Requeue Statements    9.6 Delay Statements, Duration, and Time        9.6.1 Formatting, Time Zones, and other operations for Time    9.7 Select Statements        9.7.1 Selective Accept        9.7.2 Timed Entry Calls        9.7.3 Conditional Entry Calls        9.7.4 Asynchronous Transfer of Control    9.8 Abort of a Task - Abort of a Sequence of Statements    9.9 Task and Entry Attributes    9.10 Shared Variables        9.10.1 Conflict Check Policies    9.11 Example of Tasking and Synchronization"),(0,n.kt)("p",null,"10. Program Structure and Compilation Issues    10.1 Separate Compilation        10.1.1 Compilation Units - Library Units        10.1.2 Context Clauses - With Clauses        10.1.3 Subunits of Compilation Units        10.1.4 The Compilation Process        10.1.5 Pragmas and Program Units        10.1.6 Environment-Level Visibility Rules    10.2 Program Execution        10.2.1 Elaboration Control"),(0,n.kt)("p",null,"11. Exceptions    11.1 Exception Declarations    11.2 Exception Handlers    11.3 Raise Statements and Raise Expressions    11.4 Exception Handling        11.4.1 The Package Exceptions        11.4.2 Pragmas Assert and Assertion_Policy        11.4.3 Example of Exception Handling    11.5 Suppressing Checks    11.6 Exceptions and Optimization"),(0,n.kt)("p",null,"12. Generic Units    12.1 Generic Declarations    12.2 Generic Bodies    12.3 Generic Instantiation    12.4 Formal Objects    12.5 Formal Types        12.5.1 Formal Private and Derived Types        12.5.2 Formal Scalar Types        12.5.3 Formal Array Types        12.5.4 Formal Access Types        12.5.5 Formal Interface Types    12.6 Formal Subprograms    12.7 Formal Packages    12.8 Example of a Generic Package"),(0,n.kt)("p",null,"13. Representation Issues    13.1 Operational and Representation Aspects        13.1.1 Aspect Specifications    13.2 Packed Types    13.3 Operational and Representation Attributes    13.4 Enumeration Representation Clauses    13.5 Record Layout        13.5.1 Record Representation Clauses        13.5.2 Storage Place Attributes        13.5.3 Bit Ordering    13.6 Change of Representation    13.7 The Package System        13.7.1 The Package System.Storage_Elements        13.7.2 The Package System.Address_To_Access_Conversions    13.8 Machine Code Insertions    13.9 Unchecked Type Conversions        13.9.1 Data Validity        13.9.2 The Valid Attribute    13.10 Unchecked Access Value Creation    13.11 Storage Management        13.11.1 Storage Allocation Attributes        13.11.2 Unchecked Storage Deallocation        13.11.3 Default Storage Pools        13.11.4 Storage Subpools        13.11.5 Subpool Reclamation        13.11.6 Storage Subpool Example    13.12 Pragma Restrictions and Pragma Profile        13.12.1 Language-Defined Restrictions and Profiles    13.13 Streams        13.13.1 The Streams Subsystem        13.13.2 Stream-Oriented Attributes    13.14 Freezing Rules"),(0,n.kt)("p",null,"The Standard Libraries"),(0,n.kt)("p",null,"A. Predefined Language Environment    A.1 The Package Standard    A.2 The Package Ada    A.3 Character Handling        A.3.1 The Packages Characters, Wide_Characters, and Wide_Wide_Characters        A.3.2 The Package Characters.Handling        A.3.3 The Package Characters.Latin_1        A.3.4 The Package Characters.Conversions        A.3.5 The Package Wide_Characters.Handling        A.3.6 The Package Wide_Wide_Characters.Handling    A.4 String Handling        A.4.1 The Package Strings        A.4.2 The Package Strings.Maps        A.4.3 Fixed-Length String Handling        A.4.4 Bounded-Length String Handling        A.4.5 Unbounded-Length String Handling        A.4.6 String-Handling Sets and Mappings        A.4.7 Wide_String Handling        A.4.8 Wide_Wide_String Handling        A.4.9 String Hashing        A.4.10 String Comparison        A.4.11 String Encoding        A.4.12 Universal Text Buffers    A.5 The Numerics Packages        A.5.1 Elementary Functions        A.5.2 Random Number Generation        A.5.3 Attributes of Floating Point Types        A.5.4 Attributes of Fixed Point Types        A.5.5 Big Numbers        A.5.6 Big Integers        A.5.7 Big Reals    A.6 Input-Output    A.7 External Files and File Objects    A.8 Sequential and Direct Files        A.8.1 The Generic Package Sequential_IO        A.8.2 File Management        A.8.3 Sequential Input-Output Operations        A.8.4 The Generic Package Direct_IO        A.8.5 Direct Input-Output Operations    A.9 The Generic Package Storage_IO    A.10 Text Input-Output        A.10.1 The Package Text_IO        A.10.2 Text File Management        A.10.3 Default Input, Output, and Error Files        A.10.4 Specification of Line and Page Lengths        A.10.5 Operations on Columns, Lines, and Pages        A.10.6 Get and Put Procedures        A.10.7 Input-Output of Characters and Strings        A.10.8 Input-Output for Integer Types        A.10.9 Input-Output for Real Types        A.10.10 Input-Output for Enumeration Types        A.10.11 Input-Output for Bounded Strings        A.10.12 Input-Output for Unbounded Strings    A.11 Wide Text Input-Output and Wide Wide Text Input-Output    A.12 Stream Input-Output        A.12.1 The Package Streams.Stream_IO        A.12.2 The Package Text_IO.Text_Streams        A.12.3 The Package Wide_Text_IO.Text_Streams        A.12.4 The Package Wide_Wide_Text_IO.Text_Streams    A.13 Exceptions in Input-Output    A.14 File Sharing    A.15 The Package Command_Line        A.15.1 The Packages Wide_Command_Line and Wide_Wide_Command_Line    A.16 The Package Directories        A.16.1 The Package Directories.Hierarchical_File_Names        A.16.2 The Packages Wide_Directories and Wide_Wide_Directories    A.17 The Package Environment_Variables        A.17.1 The Packages Wide_Environment_Variables and Wide_Wide_Environment_Variables    A.18 Containers        A.18.1 The Package Containers        A.18.2 The Generic Package Containers.Vectors        A.18.3 The Generic Package Containers.Doubly_Linked_Lists        A.18.4 Maps        A.18.5 The Generic Package Containers.Hashed_Maps        A.18.6 The Generic Package Containers.Ordered_Maps        A.18.7 Sets        A.18.8 The Generic Package Containers.Hashed_Sets        A.18.9 The Generic Package Containers.Ordered_Sets        A.18.10 The Generic Package Containers.Multiway_Trees        A.18.11 The Generic Package Containers.Indefinite_Vectors        A.18.12 The Generic Package Containers.Indefinite_Doubly_Linked_Lists        A.18.13 The Generic Package Containers.Indefinite_Hashed_Maps        A.18.14 The Generic Package Containers.Indefinite_Ordered_Maps        A.18.15 The Generic Package Containers.Indefinite_Hashed_Sets        A.18.16 The Generic Package Containers.Indefinite_Ordered_Sets        A.18.17 The Generic Package Containers.Indefinite_Multiway_Trees        A.18.18 The Generic Package Containers.Indefinite_Holders        A.18.19 The Generic Package Containers.Bounded_Vectors        A.18.20 The Generic Package Containers.Bounded_Doubly_Linked_Lists        A.18.21 The Generic Package Containers.Bounded_Hashed_Maps        A.18.22 The Generic Package Containers.Bounded_Ordered_Maps        A.18.23 The Generic Package Containers.Bounded_Hashed_Sets        A.18.24 The Generic Package Containers.Bounded_Ordered_Sets        A.18.25 The Generic Package Containers.Bounded_Multiway_Trees        A.18.26 Array Sorting        A.18.27 The Generic Package Containers.Synchronized_Queue_Interfaces        A.18.28 The Generic Package Containers.Unbounded_Synchronized_Queues        A.18.29 The Generic Package Containers.Bounded_Synchronized_Queues        A.18.30 The Generic Package Containers.Unbounded_Priority_Queues        A.18.31 The Generic Package Containers.Bounded_Priority_Queues        A.18.32 The Generic Package Containers.Bounded_Indefinite_Holders        A.18.33 Example of Container Use    A.19 The Package Locales"),(0,n.kt)("p",null,"B. Interface to Other Languages    B.1 Interfacing Aspects    B.2 The Package Interfaces    B.3 Interfacing with C and C++        B.3.1 The Package Interfaces.C.Strings        B.3.2 The Generic Package Interfaces.C.Pointers        B.3.3 Unchecked Union Types    B.4 Interfacing with COBOL    B.5 Interfacing with Fortran"),(0,n.kt)("p",null,"C. Systems Programming    C.1 Access to Machine Operations    C.2 Required Representation Support    C.3 Interrupt Support        C.3.1 Protected Procedure Handlers        C.3.2 The Package Interrupts    C.4 Preelaboration Requirements    C.5 Aspect Discard_Names    C.6 Shared Variable Control        C.6.1 The Package System.Atomic_Operations        C.6.2 The Package System.Atomic_Operations.Exchange        C.6.3 The Package System.Atomic_Operations.Test_and_Set        C.6.4 The Package System.Atomic_Operations.Integer_Arithmetic        C.6.5 The Package System.Atomic_Operations.Modular_Arithmetic    C.7 Task Information        C.7.1 The Package Task_Identification        C.7.2 The Package Task_Attributes        C.7.3 The Package Task_Termination"),(0,n.kt)("p",null,"D. Real-Time Systems    D.1 Task Priorities    D.2 Priority Scheduling        D.2.1 The Task Dispatching Model        D.2.2 Task Dispatching Pragmas        D.2.3 Preemptive Dispatching        D.2.4 Non-Preemptive Dispatching        D.2.5 Round Robin Dispatching        D.2.6 Earliest Deadline First Dispatching    D.3 Priority Ceiling Locking    D.4 Entry Queuing Policies        D.4.1 Admission Policies    D.5 Dynamic Priorities        D.5.1 Dynamic Priorities for Tasks        D.5.2 Dynamic Priorities for Protected Objects    D.6 Preemptive Abort    D.7 Tasking Restrictions    D.8 Monotonic Time    D.9 Delay Accuracy    D.10 Synchronous Task Control        D.10.1 Synchronous Barriers    D.11 Asynchronous Task Control    D.12 Other Optimizations and Determinism Rules    D.13 The Ravenscar and Jorvik Profiles    D.14 Execution Time        D.14.1 Execution Time Timers        D.14.2 Group Execution Time Budgets        D.14.3 Execution Time of Interrupt Handlers    D.15 Timing Events    D.16 Multiprocessor Implementation        D.16.1 Multiprocessor Dispatching Domains"),(0,n.kt)("p",null,"E. Distributed Systems    E.1 Partitions    E.2 Categorization of Library Units        E.2.1 Shared Passive Library Units        E.2.2 Remote Types Library Units        E.2.3 Remote Call Interface Library Units    E.3 Consistency of a Distributed System    E.4 Remote Subprogram Calls        E.4.1 Asynchronous Remote Calls        E.4.2 Example of Use of a Remote Access-to-Class-Wide Type    E.5 Partition Communication Subsystem"),(0,n.kt)("p",null,"F. Information Systems    F.1 Machine_Radix Attribute Definition Clause    F.2 The Package Decimal    F.3 Edited Output for Decimal Types        F.3.1 Picture String Formation        F.3.2 Edited Output Generation        F.3.3 The Package Text_IO.Editing        F.3.4 The Package Wide_Text_IO.Editing        F.3.5 The Package Wide_Wide_Text_IO.Editing"),(0,n.kt)("p",null,"G. Numerics    G.1 Complex Arithmetic        G.1.1 Complex Types        G.1.2 Complex Elementary Functions        G.1.3 Complex Input-Output        G.1.4 The Package Wide_Text_IO.Complex_IO        G.1.5 The Package Wide_Wide_Text_IO.Complex_IO    G.2 Numeric Performance Requirements        G.2.1 Model of Floating Point Arithmetic        G.2.2 Model-Oriented Attributes of Floating Point Types        G.2.3 Model of Fixed Point Arithmetic        G.2.4 Accuracy Requirements for the Elementary Functions        G.2.5 Performance Requirements for Random Number Generation        G.2.6 Accuracy Requirements for Complex Arithmetic    G.3 Vector and Matrix Manipulation        G.3.1 Real Vectors and Matrices        G.3.2 Complex Vectors and Matrices"),(0,n.kt)("p",null,"H. High Integrity Systems    H.1 Pragma Normalize_Scalars    H.2 Documentation of Implementation Decisions    H.3 Reviewable Object Code        H.3.1 Pragma Reviewable        H.3.2 Pragma Inspection_Point    H.4 High Integrity Restrictions        H.4.1 Aspect No_Controlled_Parts    H.5 Pragma Detect_Blocking    H.6 Pragma Partition_Elaboration_Policy    H.7 Extensions to Global and Global'Class Aspects        H.7.1 The Use_Formal and Dispatching Aspects"),(0,n.kt)("p",null,"J. Obsolescent Features    J.1 Renamings of Library Units    J.2 Allowed Replacements of Characters    J.3 Reduced Accuracy Subtypes    J.4 The Constrained Attribute    J.5 ASCII    J.6 Numeric_Error    J.7 At Clauses        J.7.1 Interrupt Entries    J.8 Mod Clauses    J.9 The Storage_Size Attribute    J.10 Specific Suppression of Checks    J.11 The Class Attribute of Untagged Incomplete Types    J.12 Pragma Interface    J.13 Dependence Restriction Identifiers    J.14 Character and Wide_Character Conversion Functions    J.15 Aspect-related Pragmas        J.15.1 Pragma Inline        J.15.2 Pragma No_Return        J.15.3 Pragma Pack        J.15.4 Pragma Storage_Size        J.15.5 Interfacing Pragmas        J.15.6 Pragma Unchecked_Union        J.15.7 Pragmas Interrupt_Handler and Attach_Handler        J.15.8 Shared Variable Pragmas        J.15.9 Pragma CPU        J.15.10 Pragma Dispatching_Domain        J.15.11 Pragmas Priority and Interrupt_Priority        J.15.12 Pragma Relative_Deadline        J.15.13 Pragma Asynchronous        J.15.14 Elaboration Control Pragmas        J.15.15 Distribution Pragmas"),(0,n.kt)("p",null,"K. Language-Defined Aspects and Attributes    K.1 Language-Defined Aspects    K.2 Language-Defined Attributes"),(0,n.kt)("p",null,"L. Language-Defined Pragmas"),(0,n.kt)("p",null,"M. Summary of Documentation Requirements    M.1 Specific Documentation Requirements    M.2 Implementation-Defined Characteristics    M.3 Implementation Advice"),(0,n.kt)("p",null,"N. Glossary"),(0,n.kt)("p",null,"P. Syntax Summary    P.1 Syntax Rules    P.2 Syntax Cross Reference"),(0,n.kt)("p",null,"Q. Language-Defined Entities    Q.1 Language-Defined Packages    Q.2 Language-Defined Types and Subtypes    Q.3 Language-Defined Subprograms    Q.4 Language-Defined Exceptions    Q.5 Language-Defined Objects"),(0,n.kt)("p",null,"Index"),(0,n.kt)("p",null,"This document is the Annotated Ada Reference Manual. The International Standard for the programming language Ada is ISO/IEC 8652:2012(E). The International Standard is derived from the Ada Reference Manual, with various non-normative changes. In particular, the International Standard omits the annotations and paragraph numbers, eliminates the Acknowledgements, and modifies various front matter such as the Title page and the Foreword. "),(0,n.kt)("p",null,"The Ada Working Group ISO/IEC JTC 1/SC 22/WG 9 is tasked by ISO with the work item to interpret and maintain the International Standard and to produce Technical Corrigenda, as appropriate. The technical work on the International Standard is performed by the Ada Rapporteur Group (ARG) of WG 9."),(0,n.kt)("p",null,"AXE Consultants produces the Ada Reference Manual in consultation with the ARG, along with drafts of other documents as needed. ISO/IEC documents often list the individual changes that need to be made to the text of a Standard, rather than simply updating the document. As such, an International Standard is often found in several parts, while the Ada Reference Manual is always a single document."),(0,n.kt)("p",null,"In June 2015, WG 9 approved and forwarded Technical Corrigendum 1 to SC 22 for ISO approval, which was granted in December 2015. Technical Corrigendum 1 was published in February 2016."),(0,n.kt)("p",null,"In June 2016, WG 9 approved a tentative schedule for the preparation of an Amendment or Revision to the International Standard, with a delivery no earlier than 2018. In July 2019, WG 9 approved an additional review and prototyping period for this revision, extending the delivery to no earlier than late 2020. The draft standard was delivered to WG 9 in July 2021, with publication expected in the summer of 2022. "),(0,n.kt)("p",null,"This version of the Ada Reference Manual shows the current state of Ada 2022. As Ada 2022 is still under development, features are still subject to change."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Significant changes in this edition are:"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Improved support for parallel execution is provided via the introduction of parallel loops, parallel blocks, parallel container iteration, and parallel reduction."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," More precise specification of subprogram interfaces is supported via the new aspects Global, Global'Class, and Nonblocking. The Global aspects, in particular, help to determine whether two constructs can safely execute in parallel."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Pre and Post aspects can now be specified for access-to-subprogram types and for generic formal subprograms; a postcondition for the default initialization of a type can be specified using the new Default_Initial_Condition aspect."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}",' The behavior of many predefined container operations is now more precisely specified by using pre- and postcondition specifications instead of English descriptions; a restricted ("stable") view for most containers is introduced to support more efficient iteration.'),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," More flexible uses of static expressions are supported via the introduction of static expression functions along with fewer restrictions on static strings."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," The Image attribute is supported for nonscalar types, and a user-specifiable attribute Put_Image is provided, which determines the value of the Image attribute for a user-defined type."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," The use of numeric and string literals is generalized to allow their use with other categories of types, via the new aspects Integer_Literal, Real_Literal, and String_Literal."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Array and record aggregates are made more flexible: index parameters are allowed in an array aggregate to define the components as a function of their array index; discriminants can be defined more flexibly within an aggregate for a variant record type."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," New types of aggregates are provided: delta aggregates to allow the construction of a new object by incremental updates to an existing object; container aggregates to allow construction of an object of a container type by directly specifying its elements."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," A shorthand is provided, using the token '@', to refer to the target of an assignment statement in the expression defining its new value."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Declare expressions are provided that permit the definition and use of local constants or renamings, to allow a large expression to be simplified by defining common parts as named entities."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Support for lightweight iteration is added via the introduction of procedural iterators."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Support for the map-reduce programming strategy is added via the introduction of reduction expressions."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," For constructs that use iterators of any sort, a filter can be specified that restricts the elements produced by the iteration to those that satisfy the condition of the filter."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Predefined packages supporting arbitrary-precision integer and real arithmetic are provided."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," The Jorvik profile is introduced to support hard real-time applications that want to go beyond the restrictions of the Ravenscar profile."),(0,n.kt)("p",null,"This is the Annotated Ada Reference Manual. "),(0,n.kt)(r.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"This document is the Annotated Ada Reference Manual (AARM). It contains the entire text of the Ada 2022 standard (ISO/IEC 8652:2022), plus various annotations. It is intended primarily for compiler writers, validation test writers, and other language lawyers. The annotations include detailed rationale for individual rules and explanations of some of the more arcane interactions among the rules. ")),(0,n.kt)("p",null,"Other available Ada documents include: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0245-1"),"}"," Ada 2022 Overview. This gives an introduction to the changes and new features in Ada 2022. Programmers should read this overview before reading Reference Manual in depth."),(0,n.kt)("p",null,(0,n.kt)("em",null,"This paragraph was deleted.")),(0,n.kt)("p",null,"The Ada Reference Manual (RM). This directly corresponds to the International Standard - ISO/IEC 8652:2022."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Design Goals"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," Ada was originally designed with three overriding concerns: program reliability and maintenance, programming as a human activity, and efficiency. The 1995 revision to the language was designed to provide greater flexibility and extensibility, additional control over storage management and synchronization, and standardized packages oriented toward supporting important application areas, while at the same time retaining the original emphasis on reliability, maintainability, and efficiency. Subsequent editions, including this fourth edition, have provided further flexibility and added more standardized packages within the framework provided by the 1995 revision."),(0,n.kt)("p",null,"The need for languages that promote reliability and simplify maintenance is well established. Hence emphasis was placed on program readability over ease of writing. For example, the rules of the language require that program variables be explicitly declared and that their type be specified. Since the type of a variable is invariant, compilers can ensure that operations on variables are compatible with the properties intended for objects of the type. Furthermore, error-prone notations have been avoided, and the syntax of the language avoids the use of encoded forms in favor of more English-like constructs. Finally, the language offers support for separate compilation of program units in a way that facilitates program development and maintenance, and which provides the same degree of checking between units as within a unit."),(0,n.kt)("p",null,"Concern for the human programmer was also stressed during the design. Above all, an attempt was made to keep to a relatively small number of underlying concepts integrated in a consistent and systematic way while continuing to avoid the pitfalls of excessive involution. The design especially aims to provide language constructs that correspond intuitively to the normal expectations of users."),(0,n.kt)("p",null,"Like many other human activities, the development of programs is becoming ever more decentralized and distributed. Consequently, the ability to assemble a program from independently produced software components continues to be a central idea in the design. The concepts of packages, of private types, and of generic units are directly related to this idea, which has ramifications in many other aspects of the language. An allied concern is the maintenance of programs to match changing requirements; type extension and the hierarchical library enable a program to be modified while minimizing disturbance to existing tested and trusted components."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," No language can avoid the problem of efficiency. Languages that require over-elaborate compilers, or that lead to the inefficient use of storage or execution time, force these inefficiencies on all machines and on all programs. Every construct of the language was examined in the light of present implementation techniques. Any proposed construct whose implementation was unclear or that required excessive machine resources was rejected. Parallel constructs were introduced to simplify making safe and efficient use of modern multicore architectures."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Language Summary"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0438-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," An Ada program is composed of one or more program units. Program units can be subprograms (which define executable algorithms), packages (which define collections of entities), task units (which define concurrent computations), protected units (which define operations for the coordinated sharing of data between tasks), or generic units (which define parameterized forms of packages and subprograms). Each program unit normally consists of two parts: a specification, containing the information that is visible to other units, and a body, containing the implementation details, which are not  visible to other units. Most program units can be compiled separately."),(0,n.kt)("p",null,"This distinction of the specification and body, and the ability to compile units separately, allows a program to be designed, written, and tested as a set of largely independent software components."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0438-1"),"}"," An Ada program will normally make use of a library of program units of general utility. The language provides means whereby individual organizations can construct their own libraries. All libraries are structured in a hierarchical manner; this enables the logical decomposition of a subsystem into individual components. The text of a separately compiled program unit has to name the library units it requires."),(0,n.kt)("p",null,(0,n.kt)("em",null,"Program Units")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," A subprogram is the basic unit for expressing an algorithm. There are two kinds of subprograms: procedures and functions. A procedure is the means of invoking a series of actions. For example, it can read data, update variables, or produce some output. It can have parameters, to provide a controlled means of passing information between the procedure and the point of call. A function is the means of invoking the computation of a value. It is similar to a procedure, but in addition will return a result."),(0,n.kt)("p",null,"A package is the basic unit for defining a collection of logically related entities. For example, a package can be used to define a set of type declarations and associated operations. Portions of a package can be hidden from the user, thus allowing access only to the logical properties expressed by the package specification."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Subprogram and package units can be compiled separately and arranged in hierarchies of parent and child units giving fine control over visibility of the logical properties and their detailed implementation."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," A task unit is the basic unit for defining a task whose sequence of actions can be executed concurrently with those of other tasks. Such tasks can be implemented on multicomputers, multiprocessors, or with interleaved execution on a single processor. A task unit can define either a single executing task or a task type permitting the creation of any number of similar tasks."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0438-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," A protected unit is the basic unit for defining protected operations for the coordinated use of data shared between tasks. Simple mutual exclusion is provided automatically, and more elaborate sharing protocols can be defined. A protected operation can either be a subprogram or an entry. A protected entry specifies a Boolean expression (an entry barrier) that has to be True before the body of the entry is executed. A protected unit can define a single protected object or a protected type permitting the creation of several similar objects."),(0,n.kt)("p",null,(0,n.kt)("em",null,"Declarations and Statements")),(0,n.kt)("p",null,"The body of a program unit generally contains two parts: a declarative part, which defines the logical entities to be used in the program unit, and a sequence of statements, which defines the execution of the program unit."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," The declarative part associates names with declared entities. For example, a name can denote a type, a constant, a variable, or an exception. A declarative part also introduces the names and parameters of other nested subprograms, packages, task units, protected units, and generic units to be used in the program unit."),(0,n.kt)("p",null,"The sequence of statements describes a sequence of actions that are to be performed. The statements are executed in succession (unless a transfer of control causes execution to continue from another place)."),(0,n.kt)("p",null,"An assignment statement changes the value of a variable. A procedure call invokes execution of a procedure after associating any actual parameters provided at the call with the corresponding formal parameters."),(0,n.kt)("p",null,"Case statements and if statements allow the selection of an enclosed sequence of statements based on the value of an expression or on the value of a condition."),(0,n.kt)("p",null,"The loop statement provides the basic iterative mechanism in the language. A loop statement specifies that a sequence of statements is to be executed repeatedly as directed by an iteration scheme, or until an exit statement is encountered."),(0,n.kt)("p",null,"A block statement comprises a sequence of statements preceded by the declaration of local entities used by the statements."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," Certain statements are associated with concurrent execution. A delay statement delays the execution of a task for a specified duration or until a specified time. An entry call statement is written as a procedure call statement; it requests an operation on a task or on a protected object, blocking the caller until the operation can be performed. A called task can accept an entry call by executing a corresponding accept statement, which specifies the actions then to be performed as part of the rendezvous with the calling task. An entry call on a protected object is processed when the corresponding entry barrier evaluates to true, whereupon the body of the entry is executed. The requeue statement permits the provision of a service as a number of related activities with preference control. One form of the select statement allows a selective wait for one of several alternative rendezvous. Other forms of the select statement allow conditional or timed entry calls and the asynchronous transfer of control in response to some triggering event. Various parallel constructs, including parallel loops and parallel blocks, support the initiation of multiple logical threads of control designed to execute in parallel when multiple processors are available."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Execution of a program unit can encounter error situations in which normal program execution cannot continue. For example, an arithmetic computation can exceed the maximum allowed value of a number, or an attempt can be made to access an array component by using an incorrect index value. To deal with such error situations, the statements of a program unit can be textually followed by exception handlers that specify the actions to be taken when the error situation arises. Exceptions can be raised explicitly by a raise statement."),(0,n.kt)("p",null,(0,n.kt)("em",null,"Data Types")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," Every object in the language has a type, which characterizes a set of values and a set of applicable operations. The main categories of types are elementary types (comprising enumeration, numeric, and access types) and composite types (including array and record types)."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," An enumeration type defines an ordered set of distinct enumeration literals, for example a list of states or an alphabet of characters. The enumeration types Boolean, Character, Wide_Character, and Wide_Wide_Character are predefined."),(0,n.kt)("p",null,"Numeric types provide a means of performing exact or approximate numerical computations. Exact computations use integer types, which denote sets of consecutive integers. Approximate computations use either fixed point types, with absolute bounds on the error, or floating point types, with relative bounds on the error. The numeric types Integer, Float, and Duration are predefined."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," Composite types allow definitions of structured objects with related components. The composite types in the language include arrays and records. An array is an object with indexed components of the same type. A record is an object with named components of possibly different types. Task and protected types are also forms of composite types. The array types String, Wide_String, and Wide_Wide_String are predefined."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Record, task, and protected types can have special components called discriminants which parameterize the type. Variant record structures that depend on the values of discriminants can be defined within a record type."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Access types allow the construction of linked data structures. A value of an access type represents a reference to an object declared as aliased or to an object created by the evaluation of an allocator. Several variables of an access type can designate the same object, and components of one object can designate the same or other objects. Both the elements in such linked data structures and their relation to other elements can be altered during program execution. Access types also permit references to subprograms to be stored, passed as parameters, and ultimately dereferenced as part of an indirect call."),(0,n.kt)("p",null,"Private types permit restricted views of a type. A private type can be defined in a package so that only the logically necessary properties are made visible to the users of the type. The full structural details that are externally irrelevant are then only available within the package and any child units."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0438-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," From any type a new type can be defined by derivation. A type, together with its derivatives (both direct and indirect) form a derivation class. Class-wide operations can be defined that accept as a parameter an operand of any type in a derivation class. For record and private types, the derivatives can be extensions of the parent type. Types that support these object-oriented capabilities of class-wide operations and type extension have to be tagged, so that the specific type of an operand within a derivation class can be identified at run time. When an operation of a tagged type is applied to an operand whose specific type is not known until run time, implicit dispatching is performed based on the tag of the operand."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Interface types provide abstract models from which other interfaces and types can be composed and derived. This provides a reliable form of multiple inheritance. Interface types can also be implemented by task types and protected types thereby enabling concurrent programming and inheritance to be merged."),(0,n.kt)("p",null,"The concept of a type is further refined by the concept of a subtype, whereby a user can constrain the set of allowed values of a type. Subtypes can be used to define subranges of scalar types, arrays with a limited set of index values, and records and private types with particular discriminant values."),(0,n.kt)("p",null,(0,n.kt)("em",null,"Other Facilities")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0438-1"),"}"," Aspect clauses can be used to specify the mapping between types and features of an underlying machine. For example, the user can specify that objects of a given type are to be represented with a given number of bits, or that the components of a record are to be represented using a given storage layout. Other features allow the controlled use of low level, nonportable, or implementation-dependent aspects, including the direct insertion of machine code."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0313-1"),"}"," Aspect clauses can also be used to specify more abstract properties of program entities, such as the pre- and postconditions of a subprogram, or the invariant for a private type. Additional aspects are specifiable to allow user-defined types to use constructs of the language, such as literals, aggregates, or indexing, normally reserved for particular language-defined categories of types, such as numeric types, record types, or array types."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," The predefined environment of the language provides for input-output and other capabilities by means of standard library packages. Input-output is supported for values of user-defined as well as of predefined types. Standard means of representing values in display form are also provided."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," The predefined standard library packages provide facilities such as string manipulation, containers of various kinds (vectors, lists, maps, etc.), mathematical functions, random number generation, and access to the execution environment."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00387-01"),"}"," The specialized annexes define further predefined library packages and facilities with emphasis on areas such as real-time scheduling, interrupt handling, distributed systems, numerical computation, and high-integrity systems."),(0,n.kt)("p",null,"Finally, the language provides a powerful means of parameterization of program units, called generic program units. The generic parameters can be types and subprograms (as well as objects and packages) and so allow general algorithms and data structures to be defined that are applicable to all types of a given class. "),(0,n.kt)("p",null,"Version=[5],Language Changes"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Paragraphs 44 through 57 have been replaced and moved to the Foreword.")," "),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Instructions for Comment Submission"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0441-1"),"}"," Informal comments on this Reference Manual can be sent via e-mail to ",(0,n.kt)("strong",null,"ada-comment@ada-auth.org"),". If appropriate, the Project Editor will initiate the defect correction procedure."),(0,n.kt)("p",null,"Comments should use the following format: "),(0,n.kt)("p",null,"\t",(0,n.kt)("strong",null,"!topic")," ",(0,n.kt)("em",null,"Title summarizing comment"),"\t",(0,n.kt)("strong",null,"!reference")," Ada 2022 RM",(0,n.kt)("em",null,"ss.ss(pp)"),"\t",(0,n.kt)("strong",null,"!from")," ",(0,n.kt)("em",null,"Author Name yy-mm-dd"),"\t",(0,n.kt)("strong",null,"!keywords")," ",(0,n.kt)("em",null,"keywords related to topic"),"\t",(0,n.kt)("strong",null,"!discussion"),"\t",(0,n.kt)("em",null,"text of discussion")),(0,n.kt)("p",null,"where ",(0,n.kt)("em",null,"ss.ss")," is the clause or subclause number, ",(0,n.kt)("em",null,"pp")," is the paragraph number where applicable, and ",(0,n.kt)("em",null,"yy-mm-dd")," is the date the comment was sent. The date is optional, as is the ",(0,n.kt)("strong",null,"!keywords")," line."),(0,n.kt)("p",null,'Please use a descriptive "Subject" in your e-mail message, and limit each message to a single comment.'),(0,n.kt)("p",null,"When correcting typographical errors or making minor wording suggestions, please put the correction directly as the topic of the comment; use square brackets [ ] to indicate text to be omitted and curly braces ","{"," ","}"," to indicate text to be added, and provide enough context to make the nature of the suggestion self-evident or put additional information in the body of the comment, for example: "),(0,n.kt)("p",null,"\t",(0,n.kt)("strong",null,"!topic")," [c]","{","C","}","haracter\t",(0,n.kt)("strong",null,"!topic")," it[']s meaning is not defined"),(0,n.kt)("p",null,"Formal requests for interpretations and for reporting defects in the International Standard may be made in accordance with the ISO/IEC JTC 1 Directives and the ISO/IEC JTC 1/SC 22 policy for interpretations. National Bodies may submit a Defect Report to ISO/IEC JTC 1/SC 22 for resolution under the JTC 1 procedures. A response will be provided and, if appropriate, a Technical Corrigendum will be issued in accordance with the procedures."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Ada 83 edition"))),(0,n.kt)("p",null,"Ada is the result of a collective effort to design a common language for programming large scale and real-time systems."),(0,n.kt)("p",null,"The common high order language program began in 1974. The requirements of the United States Department of Defense were formalized in a series of documents which were extensively reviewed by the Services, industrial organizations, universities, and foreign military departments. The Ada language was designed in accordance with the final (1978) form of these requirements, embodied in the Steelman specification."),(0,n.kt)("p",null,"The Ada design team was led by Jean D. Ichbiah and has included Bernd Krieg-Brueckner, Brian A. Wichmann, Henry F. Ledgard, Jean-Claude Heliard, Jean-Loup Gailly, Jean-Raymond Abrial, John G.P. Barnes, Mike Woodger, Olivier Roubine, Paul N. Hilfinger, and Robert Firth."),(0,n.kt)("p",null,"At various stages of the project, several people closely associated with the design team made major contributions. They include J.B. Goodenough, R.F. Brender, M.W. Davis, G. Ferran, K. Lester, L. MacLaren, E. Morel, I.R. Nassi, I.C. Pyle, S.A. Schuman, and S.C. Vestal."),(0,n.kt)("p",null,"Two parallel efforts that were started in the second phase of this design had a deep influence on the language. One was the development of a formal definition using denotational semantics, with the participation of V. Donzeau-Gouge, G. Kahn, and B. Lang. The other was the design of a test translator with the participation of K. Ripken, P. Boullier, P. Cadiou, J. Holden, J.F. Hueras, R.G. Lange, and D.T. Cornhill. The entire effort benefitted from the dedicated assistance of Lyn Churchill and Marion Myers, and the effective technical support of B. Gravem, W.L. Heimerdinger, and P. Cleve. H.G. Schmitz served as program manager."),(0,n.kt)("p",null,"Over the five years spent on this project, several intense week-long design reviews were conducted, with the participation of P. Belmont, B. Brosgol, P. Cohen, R. Dewar, A. Evans, G. Fisher, H. Harte, A.L. Hisgen, P. Knueven, M. Kronental, N. Lomuto, E. Ploedereder, G. Seegmueller, V. Stenning, D. Taffs, and also F. Belz, R. Converse, K. Correll, A.N. Habermann, J. Sammet, S. Squires, J. Teller, P. Wegner, and P.R. Wetherall."),(0,n.kt)("p",null,"Several persons had a constructive influence with their comments, criticisms and suggestions. They include P. Brinch Hansen, G. Goos, C.A.R. Hoare, Mark Rain, W.A. Wulf, and also E. Boebert, P. Bonnard, H. Clausen, M. Cox, G. Dismukes, R. Eachus, T. Froggatt, H. Ganzinger, C. Hewitt, S. Kamin, R. Kotler, O. Lecarme, J.A.N. Lee, J.L. Mansion, F. Minel, T. Phinney, J. Roehrich, V. Schneider, A. Singer, D. Slosberg, I.C. Wand, the reviewers of Ada-Europe, AdaTech, Afcet, those of the LMSC review team, and those of the Ada Tokyo Study Group."),(0,n.kt)("p",null,"These reviews and comments, the numerous evaluation reports received at the end of the first and second phase, the nine hundred language issue reports and test and evaluation reports received from fifteen different countries during the third phase of the project, the thousands of comments received during the ANSI Canvass, and the on-going work of the IFIP Working Group 2.4 on system implementation languages and that of the Purdue Europe LTPL-E committee, all had a substantial influence on the final definition of Ada."),(0,n.kt)("p",null,"The Military Departments and Agencies have provided a broad base of support including funding, extensive reviews, and countless individual contributions by the members of the High Order Language Working Group and other interested personnel. In particular, William A. Whitaker provided leadership for the program during the formative stages. David A. Fisher was responsible for the successful development and refinement of the language requirement documents that led to the Steelman specification."),(0,n.kt)("p",null,"The Ada 83 language definition was developed by Cii Honeywell Bull and later Alsys, and by Honeywell Systems and Research Center, under contract to the United States Department of Defense. William E. Carlson and later Larry E. Druffel served as the technical representatives of the United States Government and effectively coordinated the efforts of all participants in the Ada program."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Ada 95 edition"))),(0,n.kt)("p",null,"This Reference Manual was prepared by the Ada 9X Mapping/Revision Team based at Intermetrics, Inc., which has included: W. Carlson, Program Manager; T. Taft, Technical Director; J. Barnes (consultant); B. Brosgol (consultant); R. Duff (Oak Tree Software); M. Edwards; C. Garrity; R. Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W. White; M. Woodger."),(0,n.kt)("p",null,"The following consultants to the Ada 9X Project contributed to the Specialized Needs Annexes: T. Baker (Real-Time/Systems Programming - SEI, FSU); K. Dritz (Numerics - Argonne National Laboratory); A. Gargaro (Distributed Systems - Computer Sciences); J. Goodenough (Real-Time/Systems Programming - SEI); J. McHugh (Secure Systems - consultant); B. Wichmann (Safety-Critical Systems - NPL: UK)."),(0,n.kt)("p",null,"This work was regularly reviewed by the Ada 9X Distinguished Reviewers and the members of the Ada 9X Rapporteur Group (XRG): E. Ploedereder, Chairman of DRs and XRG (University of Stuttgart: Germany); B. Bardin (Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol (consultant); R. Brukardt (RR Software); N. Cohen (IBM); R. Dewar (NYU); G. Dismukes (TeleSoft); A. Evans (consultant); A. Gargaro (Computer Sciences); M. Gerhardt (ESL); J. Goodenough (SEI); S. Heilbrunner (University of Salzburg: Austria); P. Hilfinger (UC/Berkeley); B. K\ufffdllberg (CelsiusTech: Sweden); M. Kamrad II (Unisys); J. van Katwijk (Delft University of Technology: The Netherlands); V. Kaufman (Russia); P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester (Portsmouth Polytechnic: UK); L. M\ufffdnsson (TELIA Research: Sweden); S. Michell (Multiprocessor Toolsmiths: Canada); M. Mills (US Air Force); D. Pogge (US Navy); K. Power (Boeing); O. Roubine (Verdix: France); A. Strohmeier (Swiss Fed Inst of Technology: Switzerland); W. Taylor (consultant: UK); J. Tokar (Tartan); E. Vasilescu (Grumman); J. Vladik (Prospeks s.r.o.: Czech Republic); S. Van Vlierberghe (OFFIS: Belgium). "),(0,n.kt)("p",null,"Other valuable feedback influencing the revision process was provided by the Ada 9X Language Precision Team (Odyssey Research Associates), the Ada 9X User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X Implementation Analysis Team (New York University) and the Ada community-at-large."),(0,n.kt)("p",null,"Special thanks go to R. Mathis, Convenor of ISO/IEC JTC 1/SC 22 Working Group 9. "),(0,n.kt)("p",null,"The Ada 9X Project was sponsored by the Ada Joint Program Office. Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland AFB, NM) was the project manager."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Corrigendum version"))),(0,n.kt)("p",null,"The editor [R. Brukardt (USA)] would like to thank the many people whose hard work and assistance has made this update possible."),(0,n.kt)("p",null,"Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose work on creating and editing the wording corrections was critical to the entire process. Especially valuable contributions came from the chairman of the ARG, E. Ploedereder (Germany), who kept the process moving; J. Barnes (UK) and K. Ishihata (Japan), whose extremely detailed reviews kept the editor on his toes; G. Dismukes (USA), M. Kamrad (USA), P. Leroy (France), S. Michell (Canada), T. Taft (USA), J. Tokar (USA), and other members too numerous to mention."),(0,n.kt)("p",null,"Special thanks go to R. Duff (USA) for his explanations of the previous system of formatting of these documents during the tedious conversion to more modern formats. Special thanks also go to the convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Moore (USA), without whose help and support the Corrigendum and this consolidated reference manual would not have been possible."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Amendment 1 version"))),(0,n.kt)("p",null,"The editor [R. Brukardt (USA)] would like to thank the many people whose hard work and assistance has made this update possible."),(0,n.kt)("p",null,"Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose work on creating and editing the wording corrections was critical to the entire process. Especially valuable contributions came from the chairman of the ARG, P. Leroy (France), who kept the process on schedule; J. Barnes (UK) whose careful reviews found many typographical errors; T. Taft (USA), who always seemed to have a suggestion when we were stuck, and who also was usually able to provide the valuable service of explaining why things were as they are; S. Baird (USA), who found many obscure problems with the proposals; and A. Burns (UK), who pushed many of the real-time proposals to completion. Other ARG members who contributed were: R. Dewar (USA), G. Dismukes (USA), R. Duff (USA), K. Ishihata (Japan), S. Michell (Canada), E. Ploedereder (Germany), J.P. Rosen (France), E. Schonberg (USA), J. Tokar (USA), and T. Vardanega (Italy)."),(0,n.kt)("p",null,"Special thanks go to Ada-Europe and the Ada Resource Association, without whose help and support the Amendment and this consolidated reference manual would not have been possible. M. Heaney (USA) requires special thanks for his tireless work on the containers packages. Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Moore (USA), who guided the document through the standardization process."),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Ada 2012 edition"))),(0,n.kt)("p",null,"The editor [R. Brukardt (USA)] would like to thank the many people whose hard work and assistance has made this revision possible."),(0,n.kt)("p",null,"Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose work on creating and editing the wording changes was critical to the entire process. Especially valuable contributions came from the chairman of the ARG, E. Schonberg (USA), who guided the work; T. Taft (USA), whose insights broke many logjams, both in design and wording; J. Barnes (UK) whose careful reviews uncovered many editorial errors; S. Baird (USA), who repeatedly found obscure interactions with the proposals that the rest of us missed. Other ARG members who substantially contributed were: A. Burns (UK), J. Cousins (UK), R. Dewar (USA), G. Dismukes (USA), R. Duff (USA), P. Leroy (France), B. Moore (Canada), E. Ploedereder (Germany), J.P. Rosen (France), B. Thomas (USA), and T. Vardanega (Italy)."),(0,n.kt)("p",null,"Special thanks go to Ada-Europe and the Ada Resource Association, without whose help and support this third edition of the Ada Standard would not have been possible. A special mention has to go to A. Beneschan (USA) for his efforts in eliminating sloppiness in our wording. M. Heaney (USA) also deserves a mention for his efforts to improve the containers packages. Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Tokar (USA), who guided the document through the standardization process. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Ada 2012 Corrigendum 1 version"))),(0,n.kt)("p",null,"The editor [R. Brukardt (USA)] would like to thank the many people whose hard work and assistance has made this update possible."),(0,n.kt)("p",null,"Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose work on creating and editing the wording changes was critical to the entire process. Especially valuable contributions came from the chairman of the ARG, J. Cousins (UK), who guided the work; T. Taft (USA), who seems to have the ability to cut any Gordian knot we encounter in wording; J. Barnes (UK) who continues to be able to find editorial errors invisible to most; S. Baird (USA), who so frequently finds obscure interactions that we now have named such things for him. Other ARG members who substantially contributed were: A. Burns (UK), R. Dewar (USA), G. Dismukes (USA), R. Duff (USA), B. Moore (Canada), E. Ploedereder (Germany), J.P. Rosen (France), E. Schonberg (USA), and T. Vardanega (Italy)."),(0,n.kt)("p",null,"Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Tokar (USA), who guided the document through the standardization process. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Acknowledgements for the Ada 2022 version"))),(0,n.kt)("p",null,"The editor [R. Brukardt] would like to thank the many people whose hard work and assistance has made this revision possible."),(0,n.kt)("p",null,"Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada Rapporteur Group, whose work in all steps of the process, from determining problems to address, reviewing feature designs, and creating and editing wording changes, was critical to the entire process. Especially valuable contributions came from the chairman of the ARG through June 2018, J. Cousins, who guided the work and ensured we followed defined procedures; his replacement as chairman, S. Baird, who ably powered through obstacles to complete the work while continuing to find obscure interactions; T. Taft, who often solved difficult problems that had stumped others; B. Moore, whose frequent suggestions for parallel constructs greatly improved the result. Other ARG members who substantially contributed were: R. Amiard, J. Barnes, A. Burns, A. Charlet, G. Dismukes, C. Dross, R. Duff, E. Ploedereder, J.P. Rosen, F. Schanda, E. Schonberg, J. Squirek, T. Vardanega, and R. Wai. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,(0,n.kt)("code",null,"Using this version of the Ada Reference Manual"))),(0,n.kt)("p",null,"This document has been revised with the corrections specified in Technical Corrigendum 1 for Ada 2012 (which corresponds to ISO/IEC 8652:2012/COR.1:2016) and other changes specifically for Ada 2022. In addition, more annotations have been added and a variety of editorial errors have been corrected. "),(0,n.kt)("p",null,"Changes to the original 1995 version of the Annotated Ada Reference Manual (AARM) can be identified by the version number following the paragraph number. Paragraphs with a version number of /1 were changed by Technical Corrigendum 1 for Ada 95 or were editorial corrections at that time, while paragraphs with a version number of /2 were changed by Amendment 1 or were more recent editorial corrections, and paragraphs with a version number of /3 were changed by the 2012 edition of the AARM or were still more recent editorial corrections. Paragraphs with a version number of /4 are changed by Technical Corrigendum 1 for Ada 2012 or were editorial corrections at that time. Paragraphs with a version number of /5 are changes or editorial corrections for Ada 2022. Paragraphs not so marked are unchanged since the original 1995 edition of the Annotated Ada Reference Manual, and have the same paragraph numbers as in that edition. Inserted text is indicated by underlining, and deleted text is indicated by strikethroughs. Some versions also use color to indicate the version of the change. Where paragraphs are inserted, the paragraph numbers are of the form pp.nn, where pp is the number of the preceding paragraph, and nn is an insertion number. For instance, the first paragraph inserted after paragraph 8 is numbered 8.1, the second paragraph inserted is numbered 8.2, and so on. Deleted paragraphs are indicated by text such as ",(0,n.kt)("em",null,"This paragraph was deleted.")," Deleted paragraphs include empty paragraphs that were numbered in the 1995 edition of the Ada Reference Manual. Similar markings and numbering are used for changes to annotations. "),(0,n.kt)(r.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"The paragraph number is considered part of the paragraph; when a paragraph is moved to a different paragraph number, it is marked as changed even if the contents have not changed. ")))}b.isMDXComponent=!0}}]);