"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8382],{7715:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>f,contentTitle:()=>A,default:()=>_,frontMatter:()=>m,metadata:()=>p,toc:()=>b});var n=l(1716),a=l(7556),r=l(2787),o=Object.defineProperty,i=Object.defineProperties,s=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,k=(e,t,l)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[t]=l,h=(e,t)=>{for(var l in t||(t={}))c.call(t,l)&&k(e,l,t[l]);if(u)for(var l of u(t))d.call(t,l)&&k(e,l,t[l]);return e};const m={sidebar_position:44},A="5.5 Loop Statements",p={unversionedId:"arm/AA-5/AA-5.5",id:"arm/AA-5/AA-5.5",title:"5.5 Loop Statements",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-5/AA-5.5.mdx",sourceDirName:"arm/AA-5",slug:"/arm/AA-5/AA-5.5",permalink:"/docs/arm/AA-5/AA-5.5",draft:!1,tags:[],version:"current",sidebarPosition:44,frontMatter:{sidebar_position:44},sidebar:"referenceManualSidebar",previous:{title:"5.4 Case Statements",permalink:"/docs/arm/AA-5/AA-5.4"},next:{title:"5.6 Block Statements",permalink:"/docs/arm/AA-5/AA-5.6"}},f={},b=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"5.5.1  User-Defined Iterator Types",id:"551--user-defined-iterator-types",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4},{value:"5.5.2  Generalized Loop Iteration",id:"552--generalized-loop-iteration",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4},{value:"5.5.3  Procedural Iterators",id:"553--procedural-iterators",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-3",level:4}],y={toc:b};function _(e){var t,l=e,{components:o}=l,k=((e,t)=>{var l={};for(var n in e)c.call(e,n)&&t.indexOf(n)<0&&(l[n]=e[n]);if(null!=e&&u)for(var n of u(e))t.indexOf(n)<0&&d.call(e,n)&&(l[n]=e[n]);return l})(l,["components"]);return(0,n.kt)("wrapper",(t=h(h({},y),k),i(t,s({components:o,mdxType:"MDXLayout"}))),(0,n.kt)("h1",h({},{id:"55-loop-statements"}),"5.5 Loop Statements"),(0,n.kt)("admonition",h({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,n.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ",(0,n.kt)("br",null),"[A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," includes a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," that is to be executed repeatedly, zero or more times with the iterations running sequentially or concurrently with one another.] ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"syntax"}),"Syntax"),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},(0,n.kt)("code",null,"loop_statement"),(0,n.kt)("a",{id:"S0178"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"   [",(0,n.kt)("em",null,"loop_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0172"},"statement_identifier")),":]",(0,n.kt)("br",null),"      [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme")),"] ",(0,n.kt)("strong",null,"loop"),(0,n.kt)("br",null),"         ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),(0,n.kt)("br",null),"       ",(0,n.kt)("strong",null,"end")," ",(0,n.kt)("strong",null,"loop")," [",(0,n.kt)("em",null,"loop_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"];",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0355-2"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iteration_scheme"),(0,n.kt)("a",{id:"S0179"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("strong",null,"while")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),(0,n.kt)("br",null),"   | ",(0,n.kt)("strong",null,"for")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),(0,n.kt)("br",null),"   | ",(0,n.kt)("strong",null,"for")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),(0,n.kt)("br",null),"   | [",(0,n.kt)("strong",null,"parallel")," [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]]",(0,n.kt)("br",null),"     ",(0,n.kt)("strong",null,"for")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator")),(0,n.kt)("br",null),"   | ",(0,n.kt)("strong",null,"parallel")," [(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),")] [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]",(0,n.kt)("br",null),"     ",(0,n.kt)("strong",null,"for")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),(0,n.kt)("br",null),"   | ",(0,n.kt)("strong",null,"parallel")," [(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),")] [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]",(0,n.kt)("br",null),"     ",(0,n.kt)("strong",null,"for")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"chunk_specification"),(0,n.kt)("a",{id:"S0180"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     ",(0,n.kt)("em",null,"integer_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression")),(0,n.kt)("br",null),"   | ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," ",(0,n.kt)("strong",null,"in")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"loop_parameter_specification"),(0,n.kt)("a",{id:"S0181"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"   ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," ",(0,n.kt)("strong",null,"in")," [",(0,n.kt)("strong",null,"reverse"),"] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),(0,n.kt)("br",null),"     [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),"]",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_filter"),(0,n.kt)("a",{id:"S0182"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("strong",null,"when")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),(0,n.kt)("br",null)),(0,n.kt)("p",null,"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," has a ",(0,n.kt)("em",null,"loop_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0172"},"statement_identifier")),", then the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," shall be repeated after the ",(0,n.kt)("strong",null,"end loop"),"; otherwise, there shall not be an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," after the ",(0,n.kt)("strong",null,"end loop"),".",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," that begins with the reserved word ",(0,n.kt)("strong",null,"parallel")," shall not have the reserved word ",(0,n.kt)("strong",null,"reverse")," in its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ",(0,n.kt)("br",null),"In a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," that is an ",(0,n.kt)("em",null,"integer_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression")),", the ",(0,n.kt)("em",null,"integer_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression"))," is expected to be of any integer type. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0061-1"),"}"," ",(0,n.kt)("br",null),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," declares a ",(0,n.kt)("em",null,"loop parameter"),", which is an object whose subtype (and nominal subtype) is that defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ",(0,n.kt)("br",null),"In a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," that has a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," declares a ",(0,n.kt)("em",null,"chunk parameter")," object whose subtype (and nominal subtype) is that defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0327-1"),"}"," ",(0,n.kt)("br",null),"The ",(0,n.kt)("em",null,"filter")," of an ",(0,n.kt)("em",null,"iterator construct"),"  (a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator")),") is defined to be ",(0,n.kt)("em",null,"satisfied")," when there is no ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter"))," for the iterator construct, or when the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter"))," evaluates to True for a given iteration of the iterator construct.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"glossary-entry",title:"Glossary entry: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An iterator filter is a construct that is used to restrict the elements produced by an iteration to those for which a boolean condition evaluates to True.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0327-1"),"}"," ",(0,n.kt)("br",null),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with an iterator construct is said to be ",(0,n.kt)("em",null,"conditionally executed"),", then the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0167"},"statement")),"s are executed only when the filter of the iterator construct is satisfied.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0327-1"),"}"," ",(0,n.kt)("br",null),"The loop iterators ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," can also be used in contexts other than ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),"s (for example, see 4.3.5 and 4.5.8). In such a context, the iterator ",(0,n.kt)("em",null,"conditionally produces")," values in the order specified for the associated construct below or in 5.5.2. The values produced are the values given to the loop parameter when the filter of the iterator construct is satisfied for that value. [No value is produced when the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter"))," evaluates to False.]",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ",(0,n.kt)("br",null),"For the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is executed zero or more times, until the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete when a transfer of control occurs that transfers control out of the loop, or, in the case of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme")),", as specified below.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"For the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with a ",(0,n.kt)("strong",null,"while")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme")),", the condition is evaluated before each execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),"; if the value of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," is True, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is executed; if False, the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null),"If the reserved word ",(0,n.kt)("strong",null,"parallel")," is present in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," (a ",(0,n.kt)("em",null,"parallel loop"),"), the iterations are partitioned into one or more ",(0,n.kt)("em",null,"chunks"),", each with its own separate logical thread of control (see clause 9). If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," is present in a parallel loop, it is elaborated first, and the result of the elaboration determines the maximum number of chunks used for the parallel loop. If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," is an ",(0,n.kt)("em",null,"integer_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression")),", the elaboration evaluates the expression, and the value of the expression determines the maximum number of chunks. If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," is present, the elaboration elaborates the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),", which defines the subtype of the chunk parameter, and the number of values in this subtype determines the maximum number of chunks. After elaborating the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),", a check is made that the determined maximum number of chunks is greater than zero. If this check fails, Program_Error is raised. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0071-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0355-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0416-1"),"}"," ",(0,n.kt)("br",null),"For the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," that has an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," including a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),", after elaborating the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),", if any, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," is elaborated. This elaborates the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),", which defines the subtype of the loop parameter. If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," defines a subtype with a null range, the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete. Otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is conditionally executed once for each value of the discrete subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," that satisfies the predicates of the subtype (or until the loop is left as a consequence of a transfer of control). Prior to each such iteration, the corresponding value of the discrete subtype is assigned to the loop parameter associated with the given iteration. If the loop is a parallel loop, each chunk has its own logical thread of control with its own copy of the loop parameter; otherwise (a ",(0,n.kt)("em",null,"sequential loop"),"), a single logical thread of control performs the loop, and there is a single copy of the loop parameter. Each logical thread of control handles a distinct subrange of the values of the subtype of the loop parameter such that all values are covered with no overlaps. Within each logical thread of control, the values are assigned to the loop parameter in increasing order unless the reserved word ",(0,n.kt)("strong",null,"reverse")," is present, in which case the values are assigned in decreasing order. In the absence of a transfer of control, the associated parallel construct of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," is complete when all of its logical threads of control are complete. ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null),"This wording does not describe when the loop parameter object(s) are created. That creation has no side-effects (other than possibly raising Storage_Error, but anything can do that), so we simplified the wording by leaving it out. Each object has to be created before any iteration that depends on it starts, but we do not (for instance) require that the objects are all created at once at the start of the loop, nor that the objects are created after the elaboration of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("em",null,"This paragraph was deleted."),"{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ",(0,n.kt)("br",null),"The predicate (if any) necessarily has to be a static predicate as a dynamic predicate is explicitly disallowed - see 3.2.4. ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ",(0,n.kt)("br",null),"If there is a predicate, the loop still visits the values in the order of the underlying base type; the order of the values in the predicate is irrelevant. This is the case so that the following loops have the same sequence of calls and parameters on procedure Call for any subtype S: ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"for I in S loop","\n","   Call (I);","\n","end loop;","\n","for I in S'Base loop","\n","   if I in S then","\n","      Call (I);","\n","   end if;","\n","end loop;","\n"),(0,n.kt)(r.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0416-1"),"}"," ",(0,n.kt)("br",null),"The rules for completing a parallel construct when there is a transfer of control are given in 5.1. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," is present, then the logical thread of control associated with a given chunk has its own copy of the chunk parameter initialized with a distinct value from the discrete subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". The values of the chunk parameters are assigned such that they increase with increasing values of the ranges covered by the corresponding loop parameters.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ",(0,n.kt)("br",null),"Whether or not a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," is present in a parallel loop, the total number of iterations of the loop represents an upper bound on the number of logical threads of control devoted to the loop.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"[For details about the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," including an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", see 5.5.2. For details relating to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator")),", see 5.5.3.]",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 1   ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),"A loop parameter declared by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," is a constant; it cannot be updated within the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of the loop (see 3.3).",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 2   ","{",(0,n.kt)("em",null,"AI12-0442-1"),"}"," ",(0,n.kt)("br",null),"No separate ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," is expected for a loop parameter, since the loop parameter is automatically declared by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),". The scope of a loop parameter extends from the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," to the end of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),", and the visibility rules are such that a loop parameter is only visible within the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of the loop. ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An implementation could give a warning if a variable is hidden by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),". ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 3   The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," of a for loop is elaborated just once. Use of the reserved word ",(0,n.kt)("strong",null,"reverse")," does not alter the discrete subtype defined, so that the following ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme")),"s are not equivalent; the first has a null range. ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"for J in reverse 1 .. 0","\n","for J in 0 .. 1","\n"),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification"))," has a static discrete range, the subtype of the loop parameter is static. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a loop statement without an iteration scheme:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"loop","\n","   Get(Current_Character);","\n","   exit when Current_Character = '*';","\n","end loop;","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a loop statement with a ",(0,n.kt)("strong",null,"while")," iteration scheme:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"while Bid(N).Price ","<"," Cut_Off.Price loop","\n","   Record_Bid(Bid(N).Price);","\n","   N := N + 1;","\n","end loop;","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a loop statement with a ",(0,n.kt)("strong",null,"for")," iteration scheme:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"for J in Buffer'Range loop     --  works even with a null range","\n","   if Buffer(J) /= Space then","\n","      Put(Buffer(J));","\n","   end if;","\n","end loop;","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a loop statement with a name:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"Summation:","\n","   while Next /= Head loop       -- see 3.10.1","\n","      Sum  := Sum + Next.Value;","\n","      Next := Next.Succ;","\n","   end loop Summation;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0312-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"Example of a simple parallel loop:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"-- see 3.6","\n","parallel","\n","for I in Grid'Range(1) loop","\n","   Grid(I, 1) := (for all J in Grid'Range(2) =",">"," Grid(I,J) = True);","\n","end loop;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0312-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"Example of a parallel loop with a chunk specification:")," ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"declare","\n","   subtype Chunk_Number is Natural range 1 .. 8;","\n","Partial_Sum,","\n","   Partial_Max : array (Chunk_Number) of Natural := (others =",">"," 0);","\n","   Partial_Min : array (Chunk_Number) of Natural :=","\n","                       (others =",">"," Natural'Last);","\n","begin","\n","   parallel (Chunk in Chunk_Number)","\n","   for I in Grid'Range(1) loop","\n","      declare","\n","         True_Count : constant Natural :=","\n","           [for J in Grid'Range(2) =",">","\n",'              (if Grid (I, J) then 1 else 0)]\'Reduce("+",0);',"\n","      begin","\n","         Partial_Sum (Chunk) := @ + True_Count;","\n","         Partial_Min (Chunk) := Natural'Min(@, True_Count);","\n","         Partial_Max (Chunk) := Natural'Max(@, True_Count);","\n","      end;","\n","   end loop;","\n","--  ","{","AI12-0386-1","}","\n","    Put_Line","\n",'     ("Total=" & Partial_Sum\'Reduce("+", 0)\'Image &',"\n","      \", Min=\" & Partial_Min'Reduce(Natural'Min, Natural'Last)'Image &","\n","      \", Max=\" & Partial_Max'Reduce(Natural'Max, 0)'Image);","\n","end;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0312-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"For an example of an")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),(0,n.kt)("em",null,", see 4.5.8.")," ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'The constant-ness of loop parameters is specified in 3.3, "Objects and Named Numbers". ',(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," ",(0,n.kt)("br",null),"Generalized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),"s are allowed in ",(0,n.kt)("strong",null,"for")," loops; these are documented as an extension in the appropriate subclause. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0119-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0251-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null),"Parallel loops are new.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter"))," is now allowed on ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0181"},"loop_parameter_specification")),"s. This is mainly for consistency with aggregate and reduction iterators, where it eliminates the need for temporary objects. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0071-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:"),' Updated wording of loop execution to use the new term "satisfies the predicates" (see 3.2.4).',(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0061-1"),"}"," ",(0,n.kt)("br",null),"Added text so that the nominal subtype of a loop parameter is clearly defined. ",(0,n.kt)("br",null)),(0,n.kt)("h2",h({},{id:"551--user-defined-iterator-types"}),"5.5.1  User-Defined Iterator Types"),(0,n.kt)("h4",h({},{id:"static-semantics-1"}),"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"The following language-defined generic library package exists: ",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI12-0241-1","}","\n"," generic","\n","   type Cursor;","\n","   with function Has_Element (Position : Cursor) return Boolean;","\n","package Ada.Iterator_Interfaces","\n","   with Pure, Nonblocking =",">"," False is","\n","type Forward_Iterator is limited interface;","\n","   function First (Object : Forward_Iterator) return Cursor is abstract;","\n","   function Next (Object : Forward_Iterator; Position : Cursor)","\n","      return Cursor is abstract;","\n","type Reversible_Iterator is limited interface and Forward_Iterator;","\n","   function Last (Object : Reversible_Iterator) return Cursor is abstract;","\n","   function Previous (Object : Reversible_Iterator; Position : Cursor)","\n","      return Cursor is abstract;","\n","--  ","{","AI12-0266-1","}","\n","    type Parallel_Iterator is limited interface and Forward_Iterator;","\n","--  ","{","AI12-0266-1","}","\n","    subtype Chunk_Index is Positive;","\n","--  ","{","AI12-0266-1","}","\n","    function Is_Split (Object : Parallel_Iterator)","\n","      return Boolean is abstract;","\n","--  ","{","AI12-0266-1","}","\n","    procedure Split_Into_Chunks (Object     : in out Parallel_Iterator;","\n","                                Max_Chunks : in     Chunk_Index) is abstract","\n","      with Pre'Class   =",">"," not Object.Is_Split or else raise Program_Error,","\n","           Post'Class  =",">"," Object.Is_Split and then","\n","                          Object.Chunk_Count ","<","= Max_Chunks;","\n","--  ","{","AI12-0266-1","}","\n","    function Chunk_Count (Object : Parallel_Iterator)","\n","      return Chunk_Index is abstract","\n","      with Pre'Class   =",">"," Object.Is_Split or else raise Program_Error;","\n","--  ","{","AI12-0266-1","}","\n","    function First (Object : Parallel_Iterator;","\n","                   Chunk  : Chunk_Index) return Cursor is abstract","\n","      with Pre'Class   =",">"," (Object.Is_Split and then","\n","                              Chunk ","<","= Object.Chunk_Count)","\n","                           or else raise Program_Error;","\n","--  ","{","AI12-0266-1","}","\n","    function Next (Object   : Parallel_Iterator;","\n","                  Position : Cursor;","\n","                  Chunk    : Chunk_Index) return Cursor is abstract","\n","      with Pre'Class   =",">"," (Object.Is_Split and then","\n","                              Chunk ","<","= Object.Chunk_Count)","\n","                           or else raise Program_Error;","\n","--  ","{","AI12-0266-1","}","\n","    type Parallel_Reversible_Iterator is limited interface","\n","      and Parallel_Iterator and Reversible_Iterator;","\n","end Ada.Iterator_Interfaces;","\n"),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0241-1"),"}"," ",(0,n.kt)("br",null),"This package must allow blocking (Nonblocking =",">"," False) for compatibility. The purpose of this package is to provide a template for overriding user-defined routines; and such routines can only allow blocking if the root type does so. Users can still declare their overridding routines nonblocking if they wish. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("em",null,"iterator type")," is a type descended from the Forward_Iterator interface from some instance of Ada.Iterator_Interfaces. A ",(0,n.kt)("em",null,"reversible iterator type")," is a type descended from the Reversible_Iterator interface from some instance of Ada.Iterator_Interfaces. A ",(0,n.kt)("em",null,"parallel iterator type")," is a type descended from the Parallel_Iterator interface from some instance of Ada.Iterator_Interfaces. A type descended from the Parallel_Reversible_Iterator interface from some instance of Ada.Iterator_Interfaces is both a parallel iterator type and a reversible iterator type. An ",(0,n.kt)("em",null,"iterator object")," is an object of an iterator type. A ",(0,n.kt)("em",null,"reversible iterator object")," is an object of a reversible iterator type. A ",(0,n.kt)("em",null,"parallel iterator object")," is an object of a parallel iterator type. The formal subtype Cursor from the associated instance of Ada.Iterator_Interfaces is the ",(0,n.kt)("em",null,"iteration cursor subtype")," for the iterator type.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ",(0,n.kt)("br",null),"The following type-related operational aspects may be specified for an indexable container type ",(0,n.kt)("em",null,"T")," (see 4.1.6):",(0,n.kt)("br",null)),(0,n.kt)("dt",null,(0,n.kt)("br",null),"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0428-1"),"}"," ",(0,n.kt)("br",null),"Default_Iterator"),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"This aspect is specified by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes exactly one function declared immediately within the same declaration list in which ",(0,n.kt)("em",null,"T"),", or the declaration completed by ",(0,n.kt)("em",null,"T"),", is declared, whose first parameter is of type ",(0,n.kt)("em",null,"T")," or ",(0,n.kt)("em",null,"T"),"'Class or an access parameter whose designated type is type ",(0,n.kt)("em",null,"T")," or ",(0,n.kt)("em",null,"T"),"'Class, whose other parameters, if any, have default expressions, and whose result type is an iterator type. This function is the ",(0,n.kt)("em",null,"default iterator function")," for ",(0,n.kt)("em",null,"T"),". Its result subtype is the ",(0,n.kt)("em",null,"default iterator subtype")," for ",(0,n.kt)("em",null,"T"),". The iteration cursor subtype for the default iterator subtype is the ",(0,n.kt)("em",null,"default cursor subtype")," for ",(0,n.kt)("em",null,"T"),". This aspect is inherited by descendants of type ",(0,n.kt)("em",null,"T")," (including ",(0,n.kt)("em",null,"T"),"'Class).",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"Aspect Description for "),(0,n.kt)("strong",null,"Default_Iterator: "),"Default iterator to be used in ",(0,n.kt)("strong",null,"for")," loops.",(0,n.kt)("br",null)),(0,n.kt)("dt",null,(0,n.kt)("br",null),"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null),"Iterator_Element"),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"This aspect is specified by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a subtype. This is the ",(0,n.kt)("em",null,"default element subtype")," for ",(0,n.kt)("em",null,"T"),". This aspect is inherited by descendants of type ",(0,n.kt)("em",null,"T")," (including ",(0,n.kt)("em",null,"T"),"'Class).",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"Aspect Description for "),(0,n.kt)("strong",null,"Iterator_Element: "),"Element type to be used for user-defined iterators.",(0,n.kt)("br",null)),(0,n.kt)("dt",null,(0,n.kt)("br",null),"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null),"Iterator_View"),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"This aspect is specified by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a type ",(0,n.kt)("em",null,"T2")," with the following properties:",(0,n.kt)("br",null))),(0,n.kt)("ul",null,(0,n.kt)("li",null,(0,n.kt)("em",null,"T2")," is declared in the same compilation unit as ",(0,n.kt)("em",null,"T"),";",(0,n.kt)("br",null)),(0,n.kt)("li",null,(0,n.kt)("em",null,"T2")," is an iterable container type;",(0,n.kt)("br",null)),(0,n.kt)("li",null,(0,n.kt)("em",null,"T2")," has a single discriminant which is an access discriminant designating ",(0,n.kt)("em",null,"T"),"; and",(0,n.kt)("br",null)),(0,n.kt)("li",null,"The default iterator subtypes for ",(0,n.kt)("em",null,"T")," and ",(0,n.kt)("em",null,"T2")," statically match. ",(0,n.kt)("br",null))),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"This aspect is never inherited[, even by ",(0,n.kt)("em",null,"T"),"'Class].",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"Iterator_View allows specifying an alternative type to be automatically used by container element iterators; see 5.5.2. This allows setting state for an iteration only once rather than for each individual reference. ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"Since Iterator_View is not inherited, it does not apply to ",(0,n.kt)("em",null,"T"),"'Class. Otherwise, the type of the iterator object would not be known at compile-time (since it necessarily has to be different for each descendant). ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"Aspect Description for "),(0,n.kt)("strong",null,"Iterator_View: "),"An alternative type to used for container element iterators.",(0,n.kt)("br",null)),(0,n.kt)("p",null,(0,n.kt)("em",null,"This paragraph was deleted."),"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("em",null,"iterable container type")," is an indexable container type with specified Default_Iterator and Iterator_Element aspects. A ",(0,n.kt)("em",null,"reversible iterable container type")," is an iterable container type with the default iterator type being a reversible iterator type. A ",(0,n.kt)("em",null,"parallel iterable container type")," is an iterable container type with the default iterator type being a parallel iterator type. An ",(0,n.kt)("em",null,"iterable container object")," is an object of an iterable container type. A ",(0,n.kt)("em",null,"reversible iterable container object")," is an object of a reversible iterable container type. A ",(0,n.kt)("em",null,"parallel iterable container object")," is an object of a parallel iterable container type.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"glossary-entry",title:"Glossary entry: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An iterable container type is one that has user-defined behavior for iteration, via the Default_Iterator and Iterator_Element aspects.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0138-1"),"}"," ",(0,n.kt)("br",null),"The Default_Iterator and Iterator_Element aspects are nonoverridable (see 13.1.1). ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This ensures that all descendants of an iterable container type have aspects with the same properties. This prevents generic contract problems with formal derived types. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"legality-rules"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ",(0,n.kt)("br",null),"The Constant_Indexing aspect (if any) of an iterable container type ",(0,n.kt)("em",null,"T")," shall denote exactly one function with the following properties:",(0,n.kt)("br",null)),(0,n.kt)("ul",null,(0,n.kt)("li",null,"the result type of the function is covered by the default element type of ",(0,n.kt)("em",null,"T")," or is a reference type (see 4.1.5) with an access discriminant designating a type covered by the default element type of ",(0,n.kt)("em",null,"T"),";",(0,n.kt)("br",null)),(0,n.kt)("li",null,"the type of the second parameter of the function covers the default cursor type for ",(0,n.kt)("em",null,"T"),";",(0,n.kt)("br",null)),(0,n.kt)("li",null,"if there are more than two parameters, the additional parameters all have default expressions.",(0,n.kt)("br",null))),(0,n.kt)("p",null,"This function (if any) is the ",(0,n.kt)("em",null,"default constant indexing function")," for ",(0,n.kt)("em",null,"T"),".",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This does not mean that Constant_Indexing has to designate only one subprogram, only that there is only one routine that meets all of these properties. There can be other routines designated by Constant_Indexing, but they cannot have the profile described above. For instance, map containers have a version of Constant_Indexing that takes a key instead of a cursor; this is allowed. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ",(0,n.kt)("br",null),"The Variable_Indexing aspect (if any) of an iterable container type ",(0,n.kt)("em",null,"T")," shall denote exactly one function with the following properties:",(0,n.kt)("br",null)),(0,n.kt)("ul",null,(0,n.kt)("li",null,"the result type of the function is a reference type (see 4.1.5) with an access discriminant designating a type covered by the default element type of ",(0,n.kt)("em",null,"T"),";",(0,n.kt)("br",null)),(0,n.kt)("li",null,"the type of the second parameter of the function covers the default cursor type for ",(0,n.kt)("em",null,"T"),";",(0,n.kt)("br",null)),(0,n.kt)("li",null,"if there are more than two parameters, the additional parameters all have default expressions.",(0,n.kt)("br",null))),(0,n.kt)("p",null,"This function (if any) is the ",(0,n.kt)("em",null,"default variable indexing function")," for ",(0,n.kt)("em",null,"T"),".",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"erroneous-execution"}),"Erroneous Execution"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0354-1"),"}"," ",(0,n.kt)("br",null),"A call on the First or Next operation on a given Parallel_Iterator object with a given Chunk value, which does not propagate an exception, should return a Cursor value that either yields False when passed to Has_Element, or that identifies an element distinct from any Cursor value returned by a call on a First or Next operation on the same Parallel_Iterator object with a different Chunk value. If the First or Next operations with a Chunk parameter behave in any other manner, execution is erroneous. ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This describes the expectations from a user-written parallel iterator. If the expectations are not met, execution is erroneous so that implementations do not need to go to heroic efforts to avoid problems caused by bad iterators. This is similar to the handling of storage pools, see 13.11. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"User-defined iterator types are new in Ada 2012. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0138-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:")," Defined Default_Iterator and Iterator_Element to be nonoveridable, which makes redefinitions and hiding of these aspects illegal. It's possible that some program could violate one of these new restrictions, but in most cases this can easily be worked around by using overriding rather than redefinition.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"Various new types and subprograms are newly added to Ada.Iterator_Interfaces. Therefore, a use clause conflict is possible; see the introduction of Annex A for more on this topic. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2012-1"}),"Extensions to Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null),"Aspect Iterator_View is new; it allows container element iterators to set the tampering state once rather than for each use of the element.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0354-1"),"}"," ",(0,n.kt)("br",null),"Parallel iterator interfaces are new; they allow user-defined parallel loops to be defined. ",(0,n.kt)("br",null)),(0,n.kt)("h2",h({},{id:"552--generalized-loop-iteration"}),"5.5.2  Generalized Loop Iteration"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"Generalized forms of loop iteration are provided by an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"syntax-1"}),"Syntax"),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_specification"),(0,n.kt)("a",{id:"S0183"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"    ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," [: ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication")),"] ",(0,n.kt)("strong",null,"in")," [",(0,n.kt)("strong",null,"reverse"),"] ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),(0,n.kt)("br",null),"      [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),"]",(0,n.kt)("br",null),"  | ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," [: ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication")),"] ",(0,n.kt)("strong",null,"of")," [",(0,n.kt)("strong",null,"reverse"),"] ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),(0,n.kt)("br",null),"      [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),"]",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"loop_parameter_subtype_indication"),(0,n.kt)("a",{id:"S0184"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," | ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"If an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is for a parallel construct, the reserved word ",(0,n.kt)("strong",null,"reverse")," shall not appear in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ",(0,n.kt)("br",null),"For the first form of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", called a ",(0,n.kt)("em",null,"generalized iterator"),", the expected type for the ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is any iterator type. For the second form of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", the expected type for the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is any array or iterable container type. If the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes an array object, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is called an ",(0,n.kt)("em",null,"array component iterator"),"; otherwise it is called a ",(0,n.kt)("em",null,"container element iterator"),". ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"glossary-entry",title:"Glossary entry: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An iterator is a construct that is used to loop over the elements of an array or container. Iterators may be user defined, and may perform arbitrary computations to access elements from a container.",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"legality-rules-1"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"If the reserved word ",(0,n.kt)("strong",null,"reverse")," appears, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is a ",(0,n.kt)("em",null,"reverse iterator"),". If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is for a parallel construct, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is a ",(0,n.kt)("em",null,"parallel iterator"),". Otherwise, it is a ",(0,n.kt)("em",null,"forward iterator"),". Forward and reverse iterators are collectively called ",(0,n.kt)("em",null,"sequential")," iterators. In a reverse generalized iterator, the ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall be of a reversible iterator type. In a parallel generalized iterator, the ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall be of a parallel iterator type. In a reverse container element iterator, the default iterator type for the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall be a reversible iterator type. In a parallel container element iterator, the default iterator type for the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall be of a parallel iterator type.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0151-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0183-1"),"}"," ",(0,n.kt)("br",null),"The subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication")),", if any, of a generalized iterator shall statically match the iteration cursor subtype. The subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication")),", if any, of an array component iterator shall statically match the component subtype of the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". The subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication")),", if any, of a container element iterator shall statically match the default element subtype for the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),".",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"In a container element iterator whose ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," has type ",(0,n.kt)("em",null,"T"),", if the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes a constant or the Variable_Indexing aspect is not specified for ",(0,n.kt)("em",null,"T"),", then the Constant_Indexing aspect shall be specified for ",(0,n.kt)("em",null,"T"),".",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0047-1"),"}"," ",(0,n.kt)("br",null),"The ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," shall not denote a subcomponent that depends on discriminants of an object whose nominal subtype is unconstrained, unless the object is known to be constrained.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This is the same rule that applies to renames; it serves the same purpose of preventing the object from disappearing while the iterator is still using it. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0120-1"),"}"," ",(0,n.kt)("br",null),"A container element iterator is illegal if the call of the default iterator function that creates the loop iterator (see below) is illegal.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This can happen if the parameter to the default iterator function is ",(0,n.kt)("strong",null,"in out")," and the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a constant. The wording applies to any reason that the call would be illegal, as it's possible that one of the default parameters would be illegal, or that some accessibility check would fail. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0120-1"),"}"," ",(0,n.kt)("br",null),"A generalized iterator is illegal if the iteration cursor subtype of the ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a limited type at the point of the generalized iterator. A container element iterator is illegal if the default cursor subtype of the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a limited type at the point of the container element iterator.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),'If the cursor type is limited, the assignment to the loop parameter for a generalized iterator would be illegal. The same is true for a container element iterator. We have to say "at the point of the iterator" as the limitedness of a type can change due to visibility. ',(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"static-semantics-2"}),"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0269-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," declares a ",(0,n.kt)("em",null,"loop parameter"),". In a generalized iterator, an array component iterator, or a container element iterator, if a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication"))," is present, it determines the nominal subtype of the loop parameter. In a generalized iterator, if a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication"))," is not present, the nominal subtype of the loop parameter is the iteration cursor subtype. In an array component iterator, if a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication"))," is not present, the nominal subtype of the loop parameter is the component subtype of the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". In a container element iterator, if a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication"))," is not present, the nominal subtype of the loop parameter is the default element subtype for the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),".",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ",(0,n.kt)("br",null),"In a generalized iterator, the loop parameter is a constant. In an array component iterator, the loop parameter is a constant if the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes a constant; otherwise it denotes a variable. In a container element iterator, the loop parameter is a constant if the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes a constant, or if the Variable_Indexing aspect is not specified for the type of the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"; otherwise it is a variable.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0093-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ",(0,n.kt)("br",null),"The loop parameter of a generalized iterator has the same accessibility as the loop statement. This means that the loop parameter object is finalized when the loop statement is left. (It also may be finalized as part of assigning a new value to the loop parameter.) For array component iterators, the loop parameter directly denotes an element of the array and has the accessibility of the associated array. For container element iterators, the loop parameter denotes the result of the indexing function call (in the case of a constant indexing) or a generalized reference thereof (in the case of a variable indexing). Roughly speaking, the loop parameter has the accessibility level of a single iteration of the loop. More precisely, the function result (or the generalized reference thereof) is considered to be renamed in the declarative part of a notional block statement which immediately encloses the loop's ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),"; the accessibility of the loop parameter is that of the block statement. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"For the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification"))," is first elaborated. This elaboration elaborates the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication")),", if any.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"For a sequential generalized iterator, the loop parameter is created, the ",(0,n.kt)("em",null,"iterator_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is evaluated, and the denoted iterator object becomes the ",(0,n.kt)("em",null,"loop iterator"),". In a forward generalized iterator, the operation First of the iterator type is called on the loop iterator, to produce the initial value for the loop parameter. If the result of calling Has_Element on the initial value is False, then the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete. Otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is conditionally executed and then the Next operation of the iterator type is called with the loop iterator and the current value of the loop parameter to produce the next value to be assigned to the loop parameter. This repeats until the result of calling Has_Element on the loop parameter is False, or the loop is left as a consequence of a transfer of control. For a reverse generalized iterator, the operations Last and Previous are called rather than First and Next.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0093-1"),"}"," ",(0,n.kt)("br",null),"The loop parameter of a generalized iterator is a variable of which the user only has a constant view. It follows the normal rules for a variable of its nominal subtype. In particular, if the nominal subtype is indefinite, the variable is constrained by its initial value. Similarly, if the nominal subtype is class-wide, the variable (like all variables) has the tag of the initial value. Constraint_Error may be raised by a subsequent iteration if Next or Previous return an object with a different tag or constraint. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"For a parallel generalized iterator, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),", if any, of the associated parallel construct, is first elaborated, to determine the maximum number of chunks (see 5.5), and then the operation Split_Into_Chunks of the iterator type is called, with the determined maximum passed as the Max_Chunks parameter, specifying the upper bound for the number of loop parameter objects (and the number of logical threads of control) to be associated with the iterator. In the absence of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),", the maximum number of chunks is determined in an implementation-defined manner.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"The maximum number of chunks for a parallel generalized iterator without a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification")),".",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"The Max_Chunks parameter of the Split_Into_Chunks procedure is an upper bound for the number of chunks to be associated with a loop. A container implementation may opt for a lower value for the number of chunks if a more optimal split can be determined. For instance, a tree-based container might create the split based on the number of branches at the top levels of the tree. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0418-1"),"}"," ",(0,n.kt)("br",null),"Upon return from Split_Into_Chunks, the actual number of chunks for the loop is determined by calling the Chunk_Count operation of the iterator, at which point one logical thread of control is initiated for each chunk, with an associated chunk index in the range from one to the actual number of chunks.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0418-1"),"}"," ",(0,n.kt)("br",null),"Within each logical thread of control, a loop parameter is created. If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," is present in the associated parallel construct, then a chunk parameter is created and initialized with a value from the discrete subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),", so that the order of the chosen chunk parameter values correspond to the order of the chunk indices associated with the logical threads of control. The operation First of the iterator type that has a Chunk parameter is called on the loop iterator, with Chunk initialized from the corresponding chunk index, to produce the initial value for the loop parameter. If the result of calling Has_Element on this initial value is False, then the execution of the logical thread of control is complete. Otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is conditionally executed, and then the Next operation of the iterator type that has a Chunk parameter is called with the loop iterator, the current value of the loop parameter, and the corresponding chunk index, to produce the next value to be assigned to the loop parameter. This repeats until the result of calling Has_Element on the loop parameter is False, or the associated parallel construct is left as a consequence of a transfer of control.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0418-1"),"}"," ",(0,n.kt)("br",null),"In the absence of a transfer of control, the associated parallel construct of a parallel generalized iterator is complete when all of its logical threads of control are complete.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"For an array component iterator, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," of the associated parallel construct, if any, is first elaborated to determine the maximum number of chunks (see 5.5), and then the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is evaluated and the denoted array object becomes the ",(0,n.kt)("em",null,"array for the loop"),". If the array for the loop is a null array, then the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete. Otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is conditionally executed with the loop parameter denoting each component of the array for the loop, using a ",(0,n.kt)("em",null,"canonical")," order of components, which is last dimension varying fastest (unless the array has convention Fortran, in which case it is first dimension varying fastest). For a forward array component iterator, the iteration starts with the component whose index values are each the first in their index range, and continues in the canonical order. For a reverse array component iterator, the iteration starts with the component whose index values are each the last in their index range, and continues in the reverse of the canonical order. For a parallel array component iterator, the iteration is broken up into contiguous chunks of the canonical order, such that all components are covered with no overlaps; each chunk has its own logical thread of control with its own loop parameter and iteration within each chunk is in the canonical order. The number of chunks is implementation defined, but is limited in the presence of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," to the determined maximum. The loop iteration proceeds until the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," has been conditionally executed for each component of the array for the loop, or until the loop is left as a consequence of a transfer of control.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"The number of chunks for an array component iterator.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," is present in the associated parallel construct, then the logical thread of control associated with a given chunk has a chunk parameter initialized with a distinct value from the discrete subtype defined by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". The values of the chunk parameters are assigned such that they increase in the canonical order of the starting array components for the chunks.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"For a container element iterator, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0180"},"chunk_specification"))," of the associated parallel construct, if any, is first elaborated to determine the maximum number of chunks (see 5.5), and then the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is evaluated. If the container type has Iterator_View specified, an object of the Iterator_View type is created with the discriminant referencing the iterable container object denoted by the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". This is the ",(0,n.kt)("em",null,"iterable container object for the loop"),". Otherwise, the iterable container object denoted by the ",(0,n.kt)("em",null,"iterable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," becomes the iterable container object for the loop. The default iterator function for the type of the iterable container object for the loop is called on the iterable container object and the result is the ",(0,n.kt)("em",null,"loop iterator"),". For a sequential container element iterator, an object of the default cursor subtype is created (the ",(0,n.kt)("em",null,"loop cursor"),"). For a parallel container element iterator, each chunk of iterations will have its own loop cursor, again of the default cursor subtype.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null),"If Iterator_View is specified, we add an extra object and use that object for this iteration. This allows these iterators to automatically use the stable view (defined in each of the language-defined containers) to do the iteration. That eliminates the need to set and clear the tampering with elements indication each time Reference is called; that eliminates substantial overhead as finalization is typically used to implement the tampering reset. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,n.kt)("em",null,"AI05-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"A container element iterator then proceeds as described above for a generalized iterator, except that each reference to a loop parameter is replaced by a reference to the corresponding loop cursor. For a container element iterator, the loop parameter for each iteration instead denotes an indexing (see 4.1.6) into the iterable container object for the loop, with the only parameter to the indexing being the value of the loop cursor for the given iteration. If the loop parameter is a constant (see above), then the indexing uses the default constant indexing function for the type of the iterable container object for the loop; otherwise it uses the default variable indexing function.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0120-1"),"}"," ",(0,n.kt)("br",null),"Any exception propagated by the execution of a generalized iterator or container element iterator is propagated by the immediately enclosing loop statement.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This text covers exceptions raised by called functions that make up the execution of the iterator as well as exceptions raised by the assignment to the loop parameter or cursor. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"examples-1"}),"Examples"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"Example of a parallel generalized loop over an array:"),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI05-0269-1","}","\n"," --  ","{","AI12-0266-1","}","\n"," --  ","{","AI12-0429-1","}","\n"," parallel","\n","for Element of Board loop  -- See 3.6.1.","\n","   Element := Element * 2.0; -- Double each element of Board, a two-dimensional array.","\n","end loop;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0268-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"For examples of use of generalized iterators, see A.18.33 and the corresponding container packages in A.18.2 and A.18.3."),(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI05-0139-2"),"}"," ",(0,n.kt)("br",null),"Generalized forms of loop iteration are new. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"incompatibilities-with-ada-2012-1"}),"Incompatibilities With Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0047-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:")," Added a rule to ensure that the object being iterated cannot be a component that could disappear before the loop completes. This could be incompatible by making a loop that was legal (and worked correctly, so long as the enclosing object is not modified during the loop) from the original Ada 2012 illegal in corrected Ada 2012. Such loops should be pretty rare, especially as these iterator forms are new to Ada 2012.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0120-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:")," Added rules to reject loops if the call to the default iterator function for a container element iterator is illegal, or if the cursor type of an iterator is limited. These are formally incompatible with original Ada 2012, but as it's unlikely that any Ada 2012 compiler ever allowed the illegal usages in an expansion of a loop (it's much more likely that they would have just caused an internal error in the compiler), this should have no effect in practice.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0151-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:")," Added a requirement that the given subtype statically match the subtype of the element or component for a component element iterator or array component iterator. Original Ada 2012 text allowed any type that covered the subtype of the element or component, but that led to questions of what the meaning was if they are different. In this case, the element is essentially a renaming of the container element, and it doesn't make sense for the constraints to be different. Ignoring explicitly defined constraints in renames is a mistake that we don't want to continue, thus we require static matching. This means that some programs might be illegal, but those programs were misleading at best, and potentially would raise unexpected exceptions because the element values might have been invalid or abnormal with respect to the declared constraint. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2012-2"}),"Extensions to Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0156-1"),"}"," ",(0,n.kt)("br",null),"For consistency, we now allow a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," on a generalized iterator, and anonymous access types on all forms of iterator. We introduced a new syntax non-terminal, ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0184"},"loop_parameter_subtype_indication"))," to simplfy the wording.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter"))," is now allowed on ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0183"},"iterator_specification")),"s. This is mainly for consistency with aggregate and reduction iterators, where it eliminates the need for temporary objects. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2012-1"}),"Wording Changes from Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0120-1"),"}"," ",(0,n.kt)("strong",null,(0,n.kt)("br",null),"Corrigendum:")," Added wording to specify that a loop propagates any exceptions propagated by the execution of an iterator. Since that's what naturally would happen from a macro-style expansion of the parts of an iterator, and no other interpretation makes sense given the way the rest of Ada works, we consider it so unlikely that any Ada 2012 implementation ever did anything else that we don't document this as a possible inconsistency.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0111-1"),"}"," ",(0,n.kt)("br",null),"Added wording to include the use of the iterator view in a container element iterator.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0266-1"),"}"," ",(0,n.kt)("br",null),"Added wording to describe the execution of parallel iterators. ",(0,n.kt)("br",null)),(0,n.kt)("h2",h({},{id:"553--procedural-iterators"}),"5.5.3  Procedural Iterators"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," invokes a user-defined procedure, passing in the body of the enclosing ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," as a parameter of an anonymous access-to-procedure type, to allow the loop body to be executed repeatedly as part of the invocation of the user-defined procedure. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"syntax-2"}),"Syntax"),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"procedural_iterator"),(0,n.kt)("a",{id:"S0185"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0186"},"iterator_parameter_specification"))," ",(0,n.kt)("strong",null,"of")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call")),(0,n.kt)("br",null),"       [",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),"]",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0308-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_parameter_specification"),(0,n.kt)("a",{id:"S0186"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),(0,n.kt)("br",null),"   | (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"}",")",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_procedure_call"),(0,n.kt)("a",{id:"S0187"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     ",(0,n.kt)("em",null,"procedure_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),(0,n.kt)("br",null),"   | ",(0,n.kt)("em",null,"procedure_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0188"},"iterator_actual_parameter_part")),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_actual_parameter_part"),(0,n.kt)("a",{id:"S0188"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0189"},"iterator_parameter_association"))," ","{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0189"},"iterator_parameter_association")),"}",")",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"iterator_parameter_association"),(0,n.kt)("a",{id:"S0189"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"     ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association")),(0,n.kt)("br",null),"   | ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box")),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),(0,n.kt)("code",null,"parameter_association_with_box"),(0,n.kt)("a",{id:"S0190"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("br",null),"   [ ",(0,n.kt)("em",null,"formal_parameter_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," =",">"," ] ","<",">",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),"At most one ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0189"},"iterator_parameter_association"))," within an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0188"},"iterator_actual_parameter_part"))," shall be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"name-resolution-rules-2"}),"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," given in an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," shall resolve to denote a callable entity ",(0,n.kt)("em",null,"C")," (the ",(0,n.kt)("em",null,"iterating procedure"),") that is a procedure, or an entry renamed as (viewed as) a procedure. [When there is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0188"},"iterator_actual_parameter_part")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," can be an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," of an access-to-subprogram value.]",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," without a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box"))," is equivalent to one with an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0188"},"iterator_actual_parameter_part"))," with an additional ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box"))," at the end, with the ",(0,n.kt)("em",null,"formal_parameter_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," identifying the last formal parameter of the callable entity denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),".",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0320-1"),"}"," ",(0,n.kt)("br",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," shall contain at most one ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0189"},"iterator_parameter_association"))," for each formal parameter of the callable entity ",(0,n.kt)("em",null,"C"),". Each formal parameter without an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0189"},"iterator_parameter_association"))," shall have a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," (in the profile of the view of ",(0,n.kt)("em",null,"C")," denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),").",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ",(0,n.kt)("br",null),"The formal parameter of the callable entity ",(0,n.kt)("em",null,"C")," associated with the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box"))," shall be of an anonymous access-to-procedure type ",(0,n.kt)("em",null,"A"),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"legality-rules-2"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0308-1"),"}"," ",(0,n.kt)("br",null),"The anonymous access-to-procedure type ",(0,n.kt)("em",null,"A")," shall have at least one formal parameter in its parameter profile. If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0186"},"iterator_parameter_specification"))," is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),", then this ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," shall be mode conformant with that of ",(0,n.kt)("em",null,"A"),". If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0186"},"iterator_parameter_specification"))," is a list of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"s, the number of formal parameters of ",(0,n.kt)("em",null,"A")," shall be the same as the length of this list.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0292-1"),"}"," ",(0,n.kt)("br",null),"[If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," given in an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," denotes an abstract subprogram, the subprogram shall be a dispatching subprogram.]",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"proof",title:"Proof: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0320-1"),"}"," ",(0,n.kt)("br",null),"This is stated normatively in 3.9.3. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"static-semantics-3"}),"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0308-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," that has a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," is equivalent to a local declaration of a procedure P followed by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0217"},"procedure_call_statement"))," that is formed from the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," by replacing the ","<",">"," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0190"},"parameter_association_with_box"))," with P'Access. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," of the locally declared procedure P is formed from the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," of the anonymous access-to-procedure type ",(0,n.kt)("em",null,"A"),", by replacing the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," of each formal parameter of this ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," with the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," of the corresponding formal parameter or element of the list of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),"s given in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0186"},"iterator_parameter_specification")),". The body of ",(0,n.kt)("em",null,"P")," consists of the conditionally executed ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),". The procedure P is called the ",(0,n.kt)("em",null,"loop body procedure"),".",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0250-1"),"}"," ",(0,n.kt)("br",null),"For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," with an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")),", the body of the routine would be something like:",(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"procedure P ... is","\n","begin","\n","   if ",(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0182"},"iterator_filter")," then","\n","      ",(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"),"\n","   end if;","\n","end P;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0344-1"),"}"," ",(0,n.kt)("br",null),"In a procedural iterator, the Parallel_Calls aspect (see 9.10.1) of the loop body procedure is True if the reserved word ",(0,n.kt)("strong",null,"parallel")," occurs in the corresponding loop statement, and False otherwise.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0344-1"),"}"," ",(0,n.kt)("br",null),"The following aspects may be specified for a callable entity ",(0,n.kt)("em",null,"S")," that has exactly one formal parameter of an anonymous access-to-subprogram type:",(0,n.kt)("br",null)),(0,n.kt)("dt",null,(0,n.kt)("br",null),"Allows_Exit"),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"The Allows_Exit aspect is of type Boolean. The specified value shall be static. The Allows_Exit aspect of an inherited primitive subprogram is True if Allows_Exit is True either for the corresponding subprogram of the progenitor type or for any other inherited subprogram that it overrides. If not specified or inherited as True, the Allows_Exit aspect of a callable entity is False. For an entry, only a confirming specification of False is permitted for the Allows_Exit aspect.",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An entry does not allow exit, because implementing a transfer of control out of a task or protected entry creates unnecessarily complex dynamic semantics. ",(0,n.kt)("br",null)),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"Specifying the Allows_Exit aspect to be True for a subprogram indicates that the subprogram ",(0,n.kt)("em",null,"allows exit"),", meaning that it is prepared to be completed by arbitrary transfers of control from the loop body procedure[, including propagation of exceptions. A subprogram for which Allows_Exit is True should use finalization as appropriate rather than exception handling to recover resources and make any necessary final updates to data structures].",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"Aspect Description for "),(0,n.kt)("strong",null,"Allows_Exit: "),"An indication of whether a subprogram will operate correctly for arbitrary transfers of control.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"A subprogram that does not need cleanup satisfies the requirements, and thus can specify Allows_Exit as True. If a subprogram ",(0,n.kt)("em",null,"S")," allows exit, it cannot expect to get control other than via finalization if the loop body procedure initiates a transfer of control as part of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator")),". In particular, exception handlers in ",(0,n.kt)("em",null,"S"),", even ",(0,n.kt)("strong",null,"when others")," handlers, will not be executed when a transfer of control occurs. The mechanism that the implementation uses to implement such transfers of control needs to avoid triggering exception handlers. ",(0,n.kt)("br",null)),(0,n.kt)("dt",null,(0,n.kt)("br",null),"Parallel_Iterator"),(0,n.kt)("dl",null,(0,n.kt)("dd",null,"The Parallel_Iterator aspect is of type Boolean. The specified value shall be static. The Parallel_Iterator aspect of an inherited primitive subprogram is True if Parallel_Iterator is True either for the corresponding subprogram of the progenitor type or for any other inherited subprogram that it overrides. If not specified or inherited as True, the Parallel_Iterator aspect of a callable entity is False.",(0,n.kt)("br",null)),(0,n.kt)("dd",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0442-1"),"}"," ",(0,n.kt)("br",null),"Specifying the Parallel_Iterator aspect to be True for a callable entity indicates that the entity is allowed to invoke the loop body procedure from multiple distinct logical threads of control. The Parallel_Iterator aspect for a subprogram shall be statically False if the subprogram allows exit.",(0,n.kt)("br",null))),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,n.kt)("strong",null,"Aspect Description for "),(0,n.kt)("strong",null,"Parallel_Iterator: "),"An indication of whether a subprogram may use multiple threads of control to invoke a loop body procedure.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"Permitting exit from a parallel procedural iterator introduces additional semantic and implementation complexity. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"legality-rules-3"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"If a callable entity overrides an inherited dispatching subprogram that allows exit, the overriding callable entity also shall allow exit. If a callable entity overrides an inherited dispatching subprogram that has a True Parallel_Iterator aspect, the overriding callable entity also shall have a True Parallel_Iterator aspect.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"Since an entry never allows exit, attempting to implement an allows exit subprogram with a task or protected entry is always illegal. However, the Parallel_Iterator aspect can be applied to an entry, so a subprogram with the Parallel_Iterator aspect True can be implemented by an entry. ",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," as its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," shall begin with the reserved word ",(0,n.kt)("strong",null,"parallel")," if and only if the callable entity identified in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," has a Parallel_iterator aspect of True.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"If the actual parameter of an anonymous access-to-subprogram type, passed in an explicit call of a subprogram for which the Parallel_Iterator aspect is True, is of the form ",(0,n.kt)("em",null,"P"),"'Access, the designated subprogram ",(0,n.kt)("em",null,"P")," shall have a Parallel_Calls aspect True (see 9.10.1).",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," as its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," shall contain an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.7#S0193"},"exit_statement")),", return statement, ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.8#S0194"},"goto_statement")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," that leaves the loop only if the callable entity associated with the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," allows exit.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ",(0,n.kt)("br",null),"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," as its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," shall not contain an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," whose ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," occurs outside the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),".",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is not allowed in a procedure (see 9.5.2), it has to be directly in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body")),". Since the loop body here is implemented as  a procedure, we can't allow ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s there, either, even if the loop itself is directly in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body")),". ",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"This includes cases where the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is part of another construct, for instance, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),". ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"dynamic-semantics-2"}),"Dynamic Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0355-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0445-1"),"}"," ",(0,n.kt)("br",null),"[For the execution of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," that has a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator")),", the procedure denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," (the ",(0,n.kt)("em",null,"iterating procedure"),") is invoked, passing an access value designating the loop body procedure as a parameter. The iterating procedure then calls the loop body procedure zero or more times and returns, whereupon the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," is complete. If the ",(0,n.kt)("strong",null,"parallel")," reserved word is present, the iterating procedure is allowed to invoke the loop body procedure from multiple distinct logical threads of control.] The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),", if any, is elaborated prior to the invocation of the iterating procedure.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"proof",title:"Proof: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"The stated dynamic semantics are implied by the static semantics given above and the bounded errors given below. ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"bounded-run-time-errors"}),"Bounded (Run-Time) Errors"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0445-1"),"}"," ",(0,n.kt)("br",null),"If the callable entity identified in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0187"},"iterator_procedure_call"))," allows exit, then it is a bounded error for a call of the loop body procedure to be performed from within an abort-deferred operation (see 9.8), unless the entire ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," was within the same abort-deferred operation. If detected, Program_Error is raised at the point of the call; otherwise, a transfer of control from the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," will not necessarily terminate the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),", and the loop body procedure can be called again.",(0,n.kt)("br",null)),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0445-1"),"}"," ",(0,n.kt)("br",null),"If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement"))," with the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0185"},"procedural_iterator"))," as its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0179"},"iteration_scheme"))," (see 5.5) does not begin with the reserved word ",(0,n.kt)("strong",null,"parallel"),", it is a bounded error if the loop body procedure is invoked from a different logical thread of control than the one that initiates the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),". If detected, Program_Error is raised; otherwise, conflicts associated with concurrent executions of the loop body procedure can occur without being detected by the applicable conflict check policy (see 9.10.1). Furthermore, propagating an exception or making an attempt to exit in the presence of multiple threads of control will not necessarily terminate the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),", deadlock can occur, or the loop body procedure can be called again.",(0,n.kt)("br",null)),(0,n.kt)(r.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,n.kt)("strong",null),"{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ",(0,n.kt)("br",null),"Other Ada rules are still in effect for the allows exit subprogram ",(0,n.kt)("em",null,"A"),", of course. For instance, if a transfer of control causes finalization which raises an exception, Program_Error will be propagated by ",(0,n.kt)("em",null,"A")," (rather than the transfer of control). In such a case, the bounded error above would still apply. Another example is the case where an unrelated task is waiting on the normal completion of the loop body procedure call in ",(0,n.kt)("em",null,"A"),". Such a task might end up waiting forever if a transfer of control happens (this is a deadlock situation). This case does not require additional wording, as the same thing would happen if an exception is propagated from the loop body procedure or if ",(0,n.kt)("em",null,"A")," executed a transfer of control (such as a return statement). ",(0,n.kt)("br",null)),(0,n.kt)("h4",h({},{id:"examples-2"}),"Examples"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0379-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"Example of iterating over a map from My_Key_Type to My_Element_Type (see A.18.4):"),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"for (C : Cursor) of My_Map.Iterate loop","\n","   Put_Line (My_Key_Type'Image (Key (C)) & \" =",">",' " &',"\n","      My_Element_Type'Image (Element (C)));","\n","end loop;","\n","-- The above is equivalent to:","\n","declare","\n","   procedure P (C : Cursor) is","\n","   begin","\n","      Put_Line (My_Key_Type'Image (Key (c)) & \" =",">",' " &',"\n","         My_Element_Type'Image (Element (C)));","\n","   end P;","\n","begin","\n","   My_Map.Iterate (P'Access);","\n","end;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,(0,n.kt)("br",null),"Example of iterating over the environment variables (see A.17):"),(0,n.kt)("br",null)),(0,n.kt)(a.Z,{mdxType:"CodeBlock"},"for (Name, Val) of Ada.Environment_Variables.Iterate(","<",">",") loop","\n",'   --  "(',"<",">",')" is optional because it is the last parameter',"\n",'   Put_Line (Name & " =',">",' " & Val);',"\n","end loop;","\n","-- The above is equivalent to:","\n","declare","\n","   procedure P (Name : String; Val : String) is","\n","   begin","\n",'      Put_Line (Name & " =',">",' " & Val);',"\n","   end P;","\n","begin","\n","   Ada.Environment_Variables.Iterate (P'Access);","\n","end;","\n"),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2012-3"}),"Extensions to Ada 2012"),(0,n.kt)(r.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,n.kt)("em",null,"AI12-0189-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0292-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0294-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0326-2"),"}"," ","{",(0,n.kt)("em",null,"AI12-0344-1"),"}"," ",(0,n.kt)("br",null),"Procedural iterators, and the Allows_Exit and Parallel_Iterator aspects are new in Ada 2022. ",(0,n.kt)("br",null)))}_.isMDXComponent=!0}}]);