"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4900],{1194:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>A,contentTitle:()=>k,default:()=>g,frontMatter:()=>m,metadata:()=>f,toc:()=>y});var o=n(1716),a=n(7556),l=n(7353),i=Object.defineProperty,s=Object.defineProperties,r=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,p=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,h=(e,t)=>{for(var n in t||(t={}))c.call(t,n)&&p(e,n,t[n]);if(d)for(var n of d(t))u.call(t,n)&&p(e,n,t[n]);return e};const m={sidebar_position:49},k="6.1 Subprogram Declarations",f={unversionedId:"arm/AA-6/AA-6.1",id:"arm/AA-6/AA-6.1",title:"6.1 Subprogram Declarations",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-6/AA-6.1.mdx",sourceDirName:"arm/AA-6",slug:"/arm/AA-6/AA-6.1",permalink:"/docs/arm/AA-6/AA-6.1",draft:!1,tags:[],version:"current",sidebarPosition:49,frontMatter:{sidebar_position:49},sidebar:"referenceManualSidebar",previous:{title:"6 Subprograms",permalink:"/docs/arm/AA-6/"},next:{title:"6.2 Formal Parameter Modes",permalink:"/docs/arm/AA-6/AA-6.2"}},A={},y=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"6.1.1  Preconditions and Postconditions",id:"611--preconditions-and-postconditions",level:2},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"6.1.2  The Global and Global&#39;Class Aspects",id:"612--the-global-and-globalclass-aspects",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-2",level:4}],b={toc:y};function g(e){var t,n=e,{components:i}=n,p=((e,t)=>{var n={};for(var o in e)c.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&d)for(var o of d(e))t.indexOf(o)<0&&u.call(e,o)&&(n[o]=e[o]);return n})(n,["components"]);return(0,o.kt)("wrapper",(t=h(h({},b),p),s(t,r({components:i,mdxType:"MDXLayout"}))),(0,o.kt)("h1",h({},{id:"61-subprogram-declarations"}),"6.1 Subprogram Declarations"),(0,o.kt)("admonition",h({},{type:"warning"}),(0,o.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,o.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,o.kt)("p",null,"[A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," declares a procedure or function.] "),(0,o.kt)("h4",h({},{id:"syntax"}),"Syntax"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00218-03"),"}"," ","{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," ",(0,o.kt)("code",null,"subprogram_declaration"),(0,o.kt)("a",{id:"S0195"}),(0,o.kt)("code",null," ::= "),"    [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"]    ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification")),"        [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];"),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ",(0,o.kt)("code",null,"subprogram_specification"),(0,o.kt)("a",{id:"S0196"}),(0,o.kt)("code",null," ::= "),"    ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0197"},"procedure_specification")),"  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0198"},"function_specification"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ",(0,o.kt)("code",null,"procedure_specification"),(0,o.kt)("a",{id:"S0197"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("strong",null,"procedure")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ",(0,o.kt)("code",null,"function_specification"),(0,o.kt)("a",{id:"S0198"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("strong",null,"function")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0200"},"defining_designator"))," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0205"},"parameter_and_result_profile"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"designator"),(0,o.kt)("a",{id:"S0199"}),(0,o.kt)("code",null," ::= "),"[",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name"))," . ]",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"defining_designator"),(0,o.kt)("a",{id:"S0200"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0203"},"defining_operator_symbol"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"defining_program_unit_name"),(0,o.kt)("a",{id:"S0201"}),(0,o.kt)("code",null," ::= "),"[",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name"))," . ]",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))),(0,o.kt)("p",null,"[The optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name"))," is only allowed for library units (see 10.1.1).] "),(0,o.kt)("p",null,(0,o.kt)("code",null,"operator_symbol"),(0,o.kt)("a",{id:"S0202"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-2/AA-2.6#S0016"},"string_literal"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00395-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," The sequence of characters in an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," shall form a reserved word, a delimiter, or compound delimiter that corresponds to an operator belonging to one of the six categories of operators defined in subclause 4.5."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI95-00395-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0090-1"),"}",' The "sequence of characters" of the string literal of the operator is a technical term (see 2.6), and does not include the surrounding quote characters. As defined in 2.2, lexical elements are "formed" from a sequence of characters. Spaces are not allowed, and upper and lower case is not significant. ')),(0,o.kt)("p",null,(0,o.kt)("code",null,"defining_operator_symbol"),(0,o.kt)("a",{id:"S0203"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"parameter_profile"),(0,o.kt)("a",{id:"S0204"}),(0,o.kt)("code",null," ::= "),"[",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),"]"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," ",(0,o.kt)("code",null,"parameter_and_result_profile"),(0,o.kt)("a",{id:"S0205"}),(0,o.kt)("code",null," ::= "),"    [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),"] ",(0,o.kt)("strong",null,"return")," [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"] ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),"  | [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),"] ",(0,o.kt)("strong",null,"return")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"formal_part"),(0,o.kt)("a",{id:"S0206"}),(0,o.kt)("code",null," ::= "),"   (",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," ","{","; ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),"}",")"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," ","{",(0,o.kt)("em",null,"AI12-0395-1"),"}"," ",(0,o.kt)("code",null,"parameter_specification"),(0,o.kt)("a",{id:"S0207"}),(0,o.kt)("code",null," ::= "),"    ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : [",(0,o.kt)("strong",null,"aliased"),"] ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0208"},"mode"))," [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"] ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," [:= ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),"]        [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.3#S0033"},"defining_identifier_list"))," : ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," [:= ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),"]        [",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI12-0395-1"),"}"," Only implementation-defined aspects are allowed on formal parameters in Ada 2022. Implementers are cautioned that any aspect allowed on a formal parameter will need conformance rules. If, for instance, an aspect changed the representation of a parameter, rules would be needed to ensure that the representation is the same for the specification and body. ")),(0,o.kt)("p",null,(0,o.kt)("code",null,"mode"),(0,o.kt)("a",{id:"S0208"}),(0,o.kt)("code",null," ::= "),"[",(0,o.kt)("strong",null,"in"),"] | ",(0,o.kt)("strong",null,"in")," ",(0,o.kt)("strong",null,"out")," | ",(0,o.kt)("strong",null,"out")),(0,o.kt)("h4",h({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",null,"formal parameter")," is an object [directly visible within a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),"] that represents the actual parameter passed to the subprogram in a call; it is declared by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),". For a formal parameter, the expected type for its ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),", if any, is that of the formal parameter. "),(0,o.kt)("h4",h({},{id:"legality-rules"}),"Legality Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0143-1"),"}"," The ",(0,o.kt)("em",null,"parameter mode")," of a formal parameter conveys the direction of information transfer with the actual parameter: ",(0,o.kt)("strong",null,"in"),", ",(0,o.kt)("strong",null,"in out"),", or ",(0,o.kt)("strong",null,"out"),". Mode ",(0,o.kt)("strong",null,"in")," is the default, and is the mode of a parameter defined by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),". "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0143-1"),"}"," ")),(0,o.kt)("p",null,"A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is only allowed in a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," for a formal parameter of mode ",(0,o.kt)("strong",null,"in"),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," or a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-12/AA-12.1#S0311"},"generic_subprogram_declaration"))," requires a completion [unless the Import aspect (see B.1) is True for the declaration; the completion shall be a body or a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration"))," (see 8.5)]. [A completion is not allowed for an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.9#S0076"},"abstract_subprogram_declaration"))," (see 3.9.3), a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.7#S0227"},"null_procedure_declaration"))," (see 6.7), or an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.8#S0228"},"expression_function_declaration"))," (see 6.8).] "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," Abstract subprograms , null procedures, and expression functions are not declared by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),"s, and so do not require completion (although the latter two can ",(0,o.kt)("em",null,"be")," completions). Protected subprograms are declared by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),"s, and so require completion. Note that an abstract subprogram is a subprogram, a null procedure is a subprogram, an expression function is a subprogram, and a protected subprogram is a subprogram, but a generic subprogram is not a subprogram. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),"{",(0,o.kt)("em",null,"AI05-0229-1"),"}"," When the Import aspect is True for any entity, no completion is allowed (see B.1). ")),(0,o.kt)("p",null,"A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a formal parameter is not allowed within the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," in which it is declared, nor within the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," of a corresponding body or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),". "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"By contrast, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-12/AA-12.1#S0314"},"generic_formal_parameter_declaration")),"s are visible to subsequent declarations in the same ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-12/AA-12.1#S0313"},"generic_formal_part")),". ")),(0,o.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",null,"profile")," of (a view of) a callable entity is either a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0205"},"parameter_and_result_profile")),"[; it embodies information about the interface to that entity - for example, the profile includes information about parameters passed to the callable entity. All callable entities have a profile - enumeration literals, other subprograms, and entries. An access-to-subprogram type has a designated profile.] Associated with a profile is a calling convention. A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," declares a procedure or a function, as indicated by the initial reserved word, with name and profile as given by its specification."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," The nominal subtype of a formal parameter is the subtype determined by the optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," and the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),", or defined by the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", in the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),". The nominal subtype of a function result is the subtype determined by the optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," and the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),", or defined by the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),", in the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0205"},"parameter_and_result_profile")),". "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," An ",(0,o.kt)("em",null,"explicitly aliased parameter")," is a formal parameter whose ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," includes the reserved word ",(0,o.kt)("strong",null,"aliased"),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00254-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," An ",(0,o.kt)("em",null,"access parameter")," is a formal ",(0,o.kt)("strong",null,"in")," parameter specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),". An ",(0,o.kt)("em",null,"access result type")," is a function result type specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),". An access parameter or result type is of an anonymous access type (see 3.10). [Access parameters of an access-to-object type allow dispatching calls to be controlled by access values. Access parameters of an access-to-subprogram type permit calls to subprograms passed as parameters irrespective of their accessibility level.]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," Access result types have normal accessibility and thus don't have any special properties worth noting here. ")),(0,o.kt)("p",null,"The ",(0,o.kt)("em",null,"subtypes of a profile")," are: "),(0,o.kt)("p",null,"For any non-access parameters, the nominal subtype of the parameter."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00254-01"),"}"," For any access parameters of an access-to-object type, the designated subtype of the parameter type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00254-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0164-1"),"}"," For any access parameters of an access-to-subprogram type, the subtypes of the designated profile of the parameter type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," For any non-access result, the nominal subtype of the function result."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," For any access result type of an access-to-object type, the designated subtype of the result type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," ","{",(0,o.kt)("em",null,"AI05-0164-1"),"}"," For any access result type of an access-to-subprogram type, the subtypes of the designated profile of the result type."),(0,o.kt)("p",null,"[ The ",(0,o.kt)("em",null,"types of a profile")," are the types of those subtypes.]"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," [A subprogram declared by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.9#S0076"},"abstract_subprogram_declaration"))," is abstract; a subprogram declared by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),' is not. See 3.9.3, "Abstract Types and Subprograms". Similarly, a procedure declared by a ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.7#S0227"},"null_procedure_declaration"))," is a null procedure; a procedure declared by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),' is not. See 6.7, "Null Procedures". Finally, a function declared by an ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.8#S0228"},"expression_function_declaration"))," is an expression function; a function declared by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),' is not. See 6.8, "Expression Functions".]'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00218-03"),"}"," [An ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),' is used to indicate whether overriding is intended. See 8.3.1, "Overriding Indicators".] '),(0,o.kt)("h4",h({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," The elaboration of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," has no effect. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 1   A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," with several identifiers is equivalent to a sequence of single ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),"s, as explained in 3.3.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,'NOTE 2   Abstract subprograms do not have bodies, and cannot be used in a nondispatching call (see 3.9.3, "Abstract Types and Subprograms").')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 3   The evaluation of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),"s is caused by certain calls, as described in 6.4.1. They are not evaluated during the elaboration of the subprogram declaration.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 4   Subprograms can be called recursively and can be called concurrently from multiple tasks. ")),(0,o.kt)("h4",h({},{id:"examples"}),"Examples"),(0,o.kt)("p",null,(0,o.kt)("em",null,"Examples of subprogram declarations:")," "),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Traverse_Tree;","\n","procedure Increment(X : in out Integer);","\n","procedure Right_Indent(Margin : out Line_Size);          --  see 3.5.4","\n","procedure Switch(From, To : in out Link);                --  see 3.10.1","\n"),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"function Random return Probability;                      --  see 3.5.7","\n"),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"{","AI12-0056-1","}"," function Min_Cell(X : Link) return Cell;                 --  see 3.10.1","\n","function Next_Frame(K : Positive) return Frame;          --  see 3.10","\n","function Dot_Product(Left, Right : Vector) return Real;  --  see 3.6","\n","function Find(B : aliased in out Barrel; Key : String) return Real;","\n","                                                         --  see 4.1.5","\n"),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},'function "*"(Left, Right : Matrix) return Matrix;        --  see 3.6',"\n"),(0,o.kt)("p",null,(0,o.kt)("em",null,"Examples of ",(0,o.kt)("strong",null,"in")," parameters with default expressions:")," "),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Print_Header(Pages  : in Natural;","\n","            Header : in Line    :=  (1 .. Line'Last =",">"," ' ');  --  see 3.6","\n","            Center : in Boolean := True);","\n"),(0,o.kt)("h4",h({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"The syntax for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.9#S0076"},"abstract_subprogram_declaration"))," is added. The syntax for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," is revised to allow for access parameters (see 3.10)")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," Program units that are library units may have a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name"))," to indicate the parent of a child (see 10.1.1). ")),(0,o.kt)("h4",h({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,'We have incorporated the rules from RM83-6.5, "Function Subprograms" here and in 6.3, "Subprogram Bodies"')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,'We have incorporated the definitions of RM83-6.6, "Parameter and Result Type Profile - Overloading of Subprograms" here.')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"The syntax rule for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0203"},"defining_operator_symbol"))," is new. It is used for the defining occurrence of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),", analogously to ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),". Usage occurrences use the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," syntactic categories. The syntax rules for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0200"},"defining_designator"))," and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0201"},"defining_program_unit_name"))," are new. ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00218-03"),"}"," Subprograms now allow ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"s for better error checking of overriding.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00231-01"),"}"," An optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," can be used in a formal parameter declaration. Similarly, an optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion"))," can be used in a function result.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," The return type of a function can be an anonymous access type. ")),(0,o.kt)("h4",h({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00254-01"),"}"," A description of the purpose of anonymous access-to-subprogram parameters and the definition of the profile of subprograms containing them was added.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," Split the production for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0196"},"subprogram_specification"))," in order to make the declaration of null procedures (see 6.7) easier.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," Moved the Syntax and Dynamic Semantics for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.9#S0076"},"abstract_subprogram_declaration"))," to 3.9.3, so that the syntax and semantics are together. This also keeps abstract and null subprograms similar.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00395-01"),"}"," Revised to allow ",(0,o.kt)("code",null,"other_format")," characters in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),"s in the same way as the underlying constructs. ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," Parameters can now be explicitly aliased, allowing parts of function results to designate parameters and forcing by-reference parameter passing.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0143-1"),"}"," The parameters of a function can now have any mode.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," An optional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),". This is described in 13.1.1. ")),(0,o.kt)("h4",h({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0177-1"),"}"," Added expression functions (see 6.8) to the wording. ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0395-1"),"}"," Parameters now can have an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),", allowing the specification of (implementation-defined) aspects for individual parameters. ")),(0,o.kt)("h2",h({},{id:"611--preconditions-and-postconditions"}),"6.1.1  Preconditions and Postconditions"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0045-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0272-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0396-1"),"}"," For a noninstance subprogram [(including a generic formal subprogram)], a generic subprogram, an entry, or an access-to-subprogram type, the following language-defined assertion aspects may be specified with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," (see 13.1.1):"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0045-1"),"}",' "Noninstance subprogram" excludes a subprogram that is an instance of a generic subprogram. In that case, the aspects should be specified on the generic subprogram. If preconditions or postconditions need to be added to an instance of a generic subprogram, it can be accomplished by creating a separate subprogram specification and then completing that specification with a renames-as-body of the instance. ')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),"{",(0,o.kt)("em",null,"AI12-0272-1"),"}"," A generic formal subprogram is a subprogram, and there are no rules to prevent using these attributes on it. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," PreThis aspect specifies a specific precondition for a callable entity or an access-to-subprogram type; it shall be specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", called a ",(0,o.kt)("em",null,"specific precondition expression"),". If not specified for an entity, the specific precondition expression for the entity is the enumeration literal True."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"In this and the following rules, we are talking about the enumeration literal True declared in package Standard (see A.1), and not some other value or identifier True. That matters as some rules depend on full conformance of these expressions, which depends on the specific declarations involved. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Pre: "),"Precondition; a condition that is expected to hold true before a call.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0418-1"),"}"," Pre'ClassThis aspect specifies a class-wide precondition for a dispatching operation of a tagged type and its descendants; it shall be specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", called a ",(0,o.kt)("em",null,"class-wide precondition expression"),". If not specified for an entity, then if no other class-wide precondition applies to the entity, the class-wide precondition expression for the entity is the enumeration literal True."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," If other class-wide preconditions apply to the entity and no class-wide precondition is specified, no class-wide precondition is defined for the entity; of course, the class-wide preconditions (of ancestors) that apply are still going to be checked. We need subprograms that don't have ancestors and don't specify a class-wide precondition to have a class-wide precondition of True, so that adding such a precondition to a descendant has no effect (necessary as a dispatching call through the root routine would not check any precondition).")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," Pre'Class cannot be specified on an access-to-subprogram type because of a Legality Rule found in 13.1.1 that limits 'Class aspects to tagged types and primitive subprograms of tagged types. The same is true for Post'Class (below). ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Pre'Class: "),"Precondition that applies to corresponding subprograms of descendant types.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," PostThis aspect specifies a specific postcondition for a callable entity or an access-to-subprogram type; it shall be specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", called a ",(0,o.kt)("em",null,"specific postcondition expression"),". If not specified for an entity, the specific postcondition expression for the entity is the enumeration literal True."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Post: "),"Postcondition; a condition that will hold true after a call.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0418-1"),"}"," Post'ClassThis aspect specifies a class-wide postcondition for a dispatching operation of a tagged type and its descendants; it shall be specified by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", called a ",(0,o.kt)("em",null,"class-wide postcondition expression"),". If not specified for an entity, the class-wide postcondition expression for the entity is the enumeration literal True. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Post'Class: "),"Postcondition that applies to corresponding subprograms of descendant types.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI12-0005-1"),"}",' In the AARM notes below, we use the terms "inherited" and "inheritance" informally with respect to class-wide pre/post-conditions, to mean that the aspect applies to corresponding subprograms in descendant types. ')),(0,o.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[S],Term=[precondition], Def=[an assertion that is expected to be True when a given subprogram is called] Version=[5],Kind=(AddedNormal),Group=[S],Term=[postcondition], Def=[an assertion that is expected to be True when a given subprogram returns normally] "),(0,o.kt)("h4",h({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," The expected type for a precondition or postcondition expression is any boolean type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0170-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0418-1"),"}"," Within the expression for a Pre'Class or Post'Class aspect for a primitive subprogram ",(0,o.kt)("em",null,"S")," of a tagged type ",(0,o.kt)("em",null,"T"),", a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a formal parameter (or ",(0,o.kt)("em",null,"S"),"'Result) of type ",(0,o.kt)("em",null,"T")," is interpreted as though it had a (notional) nonabstract  type ",(0,o.kt)("em",null,"NT")," that is a formal derived type whose ancestor type is ",(0,o.kt)("em",null,"T"),", with directly visible primitive operations. Similarly, a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a formal access parameter (or ",(0,o.kt)("em",null,"S"),"'Result for an access result) of type access-to-",(0,o.kt)("em",null,"T")," is interpreted as having type access-to-",(0,o.kt)("em",null,"NT"),". [The result of this interpretation is that the only operations that can be applied to such ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are those defined for such a formal derived type.]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," This ensures that the expression is well-defined for any primitive subprogram of a type descended from ",(0,o.kt)("em",null,"T"),". ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0170-1"),"}"," The operations of ",(0,o.kt)("em",null,"NT")," are also nonabstract, so the rule against a call of an abstract subprogram does not trigger for a class-wide precondition or postcondition. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0264-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0418-1"),"}"," For an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," with ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," Old, if the attribute reference has an expected type (or class of types) or shall resolve to a given type, the same applies to the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"; otherwise, the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," shall be resolved independently of context."),(0,o.kt)("h4",h({},{id:"legality-rules-1"}),"Legality Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0230-1"),"}"," The Pre or Post aspect shall not be specified for an abstract subprogram or a null procedure. [Only the Pre'Class and Post'Class aspects may be specified for such a subprogram.]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0183-1"),"}"," Pre'Class and Post'Class can only be specified on primitive routines of tagged types, by a blanket rule found in 13.1.1. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," If a type ",(0,o.kt)("em",null,"T")," has an implicitly declared subprogram ",(0,o.kt)("em",null,"P")," inherited from a parent type ",(0,o.kt)("em",null,"T1")," and a homograph (see 8.3) of ",(0,o.kt)("em",null,"P")," from a progenitor type ",(0,o.kt)("em",null,"T2"),", and"),(0,o.kt)("p",null,"the corresponding primitive subprogram ",(0,o.kt)("em",null,"P1")," of type ",(0,o.kt)("em",null,"T1")," is neither null nor abstract; and"),(0,o.kt)("p",null,"the class-wide precondition expression True does not apply to ",(0,o.kt)("em",null,"P1")," (implicitly or explicitly); and"),(0,o.kt)("p",null,"there is a class-wide precondition expression that applies to the corresponding primitive subprogram ",(0,o.kt)("em",null,"P2")," of ",(0,o.kt)("em",null,"T2")," that does not fully conform to any class-wide precondition expression that applies to ",(0,o.kt)("em",null,"P1"),", "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," then:"),(0,o.kt)("p",null,"If the type ",(0,o.kt)("em",null,"T")," is abstract, the implicitly declared subprogram ",(0,o.kt)("em",null,"P")," is ",(0,o.kt)("em",null,"abstract"),"."),(0,o.kt)("p",null,"Otherwise, the subprogram ",(0,o.kt)("em",null,"P")," ",(0,o.kt)("em",null,"requires overriding")," and shall be overridden with a nonabstract subprogram."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),'We use the term "requires overriding" here so that this rule is taken into account when calculating visibility in 8.3; otherwise we would have a mess when this routine is overridden. ')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),'Such an inherited subprogram would necessarily violate the Liskov Substitutability Principle (LSP) if called via a dispatching call from an ancestor other than the one that provides the called body. In such a case, the class-wide precondition of the actual body is stronger than the class-wide precondition of the ancestor. If we did not enforce that precondition for the body, the body could be called when the precondition it knows about is False - such "counterfeiting" of preconditions has to be avoided. But enforcing the precondition violates LSP. We do not want the language to be implicitly creating bodies that violate LSP; the programmer can still write an explicit body that calls the appropriate parent subprogram. In that case, the violation of LSP is explicitly in the code and obvious to code reviewers (both human and automated).')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"We have to say that the subprogram is abstract for an abstract type in this case, so that the next concrete type has to override it for the reasons above. Otherwise, inserting an extra level of abstract types would eliminate the requirement to override (as there is only one declared operation for the concrete type), and that would be bad for the reasons given above. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),'This requires the set of class-wide preconditions that apply to the interface routine to be strictly stronger than those that apply to the concrete routine. Since full conformance requires each name to denote the same declaration, it is unlikely that independently declared preconditions would conform. This rule does allow "diamond inheritance" of preconditions, and of course no preconditions at all match.')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"We considered adopting a rule that would allow examples where the expressions would conform after all inheritance has been applied, but this is complex and is not likely to be common in practice. Since the penalty here is just that an explicit overriding is required, the complexity is too much. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," If a renaming of a subprogram or entry ",(0,o.kt)("em",null,"S1")," overrides an inherited subprogram ",(0,o.kt)("em",null,"S2"),", then the overriding is illegal unless each class-wide precondition expression that applies to ",(0,o.kt)("em",null,"S1")," fully conforms to some class-wide precondition expression that applies to ",(0,o.kt)("em",null,"S2")," and each class-wide precondition expression that applies to ",(0,o.kt)("em",null,"S2")," fully conforms to some class-wide precondition expression that applies to ",(0,o.kt)("em",null,"S1"),"."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"Such an overriding subprogram would violate LSP, as the precondition of ",(0,o.kt)("em",null,"S1")," would usually be different (and thus stronger) than the one known to a dispatching call through an ancestor routine of ",(0,o.kt)("em",null,"S2"),". This is always OK if the preconditions match, so we always allow that. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This only applies to primitives of tagged types; other routines cannot have class-wide preconditions. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0131-1"),"}"," Pre'Class shall not be specified for an overriding primitive subprogram of a tagged type ",(0,o.kt)("em",null,"T")," unless the Pre'Class aspect is specified for the corresponding primitive subprogram of some ancestor of ",(0,o.kt)("em",null,"T"),"."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"Any such Pre'Class will have no effect, as it will be ",(0,o.kt)("strong",null,"or"),"ed with True. As such, it is highly misleading for readers, especially for those who are determining the assumptions that can be made in the body of the primitive subprogram. Note that in this case there is nothing explicit that might indicate that the class-wide precondition is ineffective. This rule does not prevent explicitly writing an ineffective class-wide precondition (for instance, if the parent subprogram has explicitly specified a precondition of True). ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0131-1"),"}"," In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit. "),(0,o.kt)("h4",h({},{id:"static-semantics-1"}),"Static Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0131-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0170-1"),"}"," If a Pre'Class or Post'Class aspect is specified for a primitive subprogram ",(0,o.kt)("em",null,"S")," of a tagged type ",(0,o.kt)("em",null,"T"),", or such an aspect defaults to True, then a corresponding expression also applies to the corresponding primitive subprogram ",(0,o.kt)("em",null,"S")," of each descendant of ",(0,o.kt)("em",null,"T")," [(including ",(0,o.kt)("em",null,"T")," itself)]. The ",(0,o.kt)("em",null,"corresponding expression")," is constructed from the associated expression as follows: "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"A Pre'Class defaults to True only if no class-wide preconditions are inherited for the subprogram. The same is true for Post'Class. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We have to inherit precondition expressions that default to True, so that later overridings don't strengthen the precondition (a violation of LSP). We do the same for postconditions for consistency. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," References to formal parameters of ",(0,o.kt)("em",null,"S")," (or to ",(0,o.kt)("em",null,"S")," itself) are replaced with references to the corresponding formal parameters of the corresponding inherited or overriding subprogram ",(0,o.kt)("em",null,"S")," (or to the corresponding subprogram ",(0,o.kt)("em",null,"S")," itself)."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We have to define the corresponding expression this way as overriding routines are only required to be subtype conformant; in particular, the parameter names can be different. So we have to talk about corresponding parameters without mentioning any names. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0412-1"),"}"," If the primitive subprogram ",(0,o.kt)("em",null,"S")," is not abstract, but the given descendant of ",(0,o.kt)("em",null,"T")," is abstract, then a nondispatching call on ",(0,o.kt)("em",null,"S")," is illegal if any Pre'Class or Post'Class aspect that applies to ",(0,o.kt)("em",null,"S")," is other than a static boolean expression. Similarly, a primitive subprogram of an abstract type ",(0,o.kt)("em",null,"T"),", to which a non-static Pre'Class or Post'Class aspect applies, shall neither be the prefix of an Access attribute_reference, nor shall it be a generic actual subprogram for a formal subprogram declared by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-12/AA-12.6#S0336"},"formal_concrete_subprogram_declaration")),"."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."))),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0412-1"),"}"," The above rules mean that a concrete primitive of an abstract type is effectively treated as abstract, if any nontrivial Pre'Class or Post'Class aspects apply to it. This makes sense because we are using a notional formal derived type model for such aspects, and an abstract type is not permitted as an actual type for such a formal type. If we didn't do this, the evaluation of the precondition or postcondition of a concrete subprogram of an abstract type could possibly call abstract functions.. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI12-0412-1"),"}"," As this Reference Manual was frozen, a significant incompatibility has come to light with the above rule. The wording makes some calls to non-abstract primitives of a tagged abstract type illegal even if no abstract routines are involved in the Pre'Class or Post'Class. It is likely that the above rule will be adjusted; check with ARG work at ",(0,o.kt)("a",{href:"http://www.ada_auth.org/arg.html"},"www.ada_auth.org/arg.html")," to find the adjusted rules. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0290-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," If performing checks is required by the Pre, Pre'Class, Post, or Post'Class assertion policies (see 11.4.2) in effect at the point of a corresponding aspect specification applicable to a given subprogram, entry, or access-to-subprogram type, then the respective precondition or postcondition expressions are considered ",(0,o.kt)("em",null,"enabled"),"."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0290-1"),"}"," If a class-wide precondition or postcondition expression is enabled, it remains enabled when inherited by an overriding subprogram, even if the policy in effect is Ignore for the inheriting subprogram. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A subexpression of a postcondition expression is ",(0,o.kt)("em",null,"known on entry")," if it is any of:"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a static subexpression (see 4.9);"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a literal whose type does not have any Integer_Literal, Real_Literal, or String_Literal aspect specified, or the function specified by such an attribute has aspect Global specified to be ",(0,o.kt)("strong",null,"null"),";"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," We mention literals explicitly in case they are not static (as when their subtype is not static, they are the literal ",(0,o.kt)("strong",null,"null"),", and so on). We exclude literals of types with the aspects that are not Global =",">"," ",(0,o.kt)("strong",null,"null")," as those cause a user-written subprogram with possible side effects to be called. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," ","{",(0,o.kt)("em",null,"AI12-0422-1"),"}"," a name statically denoting a full constant declaration which is known to have no variable views (see 3.3);"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Constants of types with immutably limited or controlled parts are not allowed by this rule. Generic formal in objects are allowed by this rule (as they are defined to be full constant declarations). ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),'We only want things that cannot be changed. We can\'t just say "constant" since that includes views of variables in some cases (for instance, a dereference of an access to constant object can be a view of a variable). There are other things we could have allowed (like a loop parameter), but having a subprogram declaration where those could be used (like inside of a loop) seems unusual enough to not be worth defining. ')),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a name statically denoting a nonaliased ",(0,o.kt)("strong",null,"in")," parameter of an elementary type;"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"All such parameters are by-copy, so the value won't change during the execution of the subprogram. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," an invocation of a predefined operator where all of the operands are known on entry;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a function call where the function has aspect Global =",">"," ",(0,o.kt)("strong",null,"null")," where all of the actual parameters are known on entry;"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"Such a function can only depend on the values of its parameters. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," of a known-on-entry ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," of a known-on-entry ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," where all index ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s are known on entry;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a parenthesized known-on-entry ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion"))," whose operand is a known-on-entry expression;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0148"},"conditional_expression"))," where all of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),"s, ",(0,o.kt)("em",null,"selecting_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s, and ",(0,o.kt)("em",null,"dependent_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s are known on entry."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"It's OK if such an expression raises an exception, so long as every evaluation of the expression raises the same exception. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0198-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A subexpression of a postcondition expression is ",(0,o.kt)("em",null,"unconditionally evaluated"),", ",(0,o.kt)("em",null,"conditionally evaluated"),", or ",(0,o.kt)("em",null,"repeatedly evaluated"),". A subexpression is considered unconditionally evaluated unless it is conditionally evaluated or repeatedly evaluated."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," The following subexpressions are repeatedly evaluated:"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A subexpression of a predicate of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0153"},"quantified_expression")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A subexpression of the expression of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.3#S0118"},"array_component_association")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A subexpression of the expression of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.3#S0128"},"container_element_association")),". "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," For a subexpression that is conditionally evaluated, there is a set of ",(0,o.kt)("em",null,"determining expressions")," that determine whether the subexpression is actually evaluated at run time. Subexpressions that are conditionally evaluated and their determining expressions are as follows:"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," For an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0149"},"if_expression"))," that is not repeatedly evaluated, a subexpression of any part other than the first condition is conditionally evaluated, and its determining expressions include all ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),"s of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0149"},"if_expression"))," that precede the subexpression textually;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," For a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0151"},"case_expression"))," that is not repeatedly evaluated, a subexpression of any ",(0,o.kt)("em",null,"dependent_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is conditionally evaluated, and its determining expressions include the ",(0,o.kt)("em",null,"selecting_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0151"},"case_expression")),";"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," For a short-circuit control form that is not repeatedly evaluated, a subexpression of the right-hand operand is conditionally evaluated, and its determining expressions include the left-hand operand of the short-circuit control form;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," For a membership test that is not repeatedly evaluated, a subexpression of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0137"},"membership_choice"))," other than the first is conditionally evaluated, and its determining expressions include the ",(0,o.kt)("em",null,"tested_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression"))," and the preceding ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0137"},"membership_choice")),"s of the membership test. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," A conditionally evaluated subexpression is ",(0,o.kt)("em",null,"determined to be unevaluated")," at run time if its set of determining expressions are all known on entry, and when evaluated on entry their values are such that the given subexpression is not evaluated. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"To be precise, a conditionally evaluated expression is determined to be unevaluated (including all of its subexpressions) under the following circumstances: ")),(0,o.kt)("p",null,"Within an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0149"},"if_expression")),", a ",(0,o.kt)("em",null,"dependent_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," with an associated ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," that evaluates to False, or a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," or ",(0,o.kt)("em",null,"dependent_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," where a condition of a preceding part of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0149"},"if_expression"))," evaluates to True;"),(0,o.kt)("p",null,"Within a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0151"},"case_expression")),", a ",(0,o.kt)("em",null,"dependent_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.8#S0073"},"discrete_choice_list"))," that is not covered by the value of the ",(0,o.kt)("em",null,"selecting_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),";"),(0,o.kt)("p",null,"The right-hand operand of a short-circuit control form where the left-hand operand evaluates to False for ",(0,o.kt)("strong",null,"and then")," or True for ",(0,o.kt)("strong",null,"or else"),";"),(0,o.kt)("p",null,"A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0137"},"membership_choice"))," of a membership test where the individual membership test defined by any prior ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0137"},"membership_choice"))," evaluates to True. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," For a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," X that denotes an object of a nonlimited type, the following attribute is defined: "),(0,o.kt)("p",null,"X'Old","{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," Each X'Old in a postcondition expression that is enabled, other than those that occur in subexpressions that are determined to be unevaluated, denotes a constant that is implicitly declared at the beginning of the subprogram body, entry body, or accept statement."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," If X'Old occurs in a subexpression that is determined to be unevaluated, then there is no associated constant, and no evaluation of the prefix takes place. In general, this will require evaluating one or more known-on-entry subexpressions before creating and initializing any X'Old constants. Note that any 'Old in a known-on-entry subexpression evaluated this way represents the current value of the prefix (the 'Old itself can be ignored).")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0193-1"),"}"," In the case of an accept statement, the constant is declared inside of the rendezvous. It is considered part of the initialization of the postcondition check, which is part of the rendezvous by definition (see 9.5.2). ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," The implicitly declared entity denoted by each occurrence of X'Old is declared as follows:"),(0,o.kt)("p",null,"If X is of an anonymous access type defined by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," ",(0,o.kt)("em",null,"A")," then "),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"X'Old : constant A := X;","\n"),(0,o.kt)("p",null,"If X is of a specific tagged type ",(0,o.kt)("em",null,"T")," then "),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"anonymous : constant T'Class := T'Class(X);","\n","X'Old : T renames T(anonymous);","\n"),(0,o.kt)("p",null,"where the name X'Old denotes the object renaming. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This means that the underlying tag associated with X'Old is that of X and not that of the nominal type of X. ")),(0,o.kt)("p",null,"Otherwise "),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"X'Old : constant S := X;","\n"),(0,o.kt)("p",null,"where ",(0,o.kt)("em",null,"S")," is the nominal subtype of X. This includes the case where the type of ",(0,o.kt)("em",null,"S")," is an anonymous array type or a universal type. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0185-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0388-1"),"}"," The type and nominal subtype of X'Old are as implied by the above definitions."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0217-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," Reference to this attribute is only allowed within a postcondition expression. The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," shall not contain a Result ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),", nor an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),", nor a use of an entity declared within the postcondition expression but not within ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," itself (for example, the loop parameter of an enclosing ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0153"},"quantified_expression")),"). The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," shall statically name (see 4.9) an entity, unless the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," is unconditionally evaluated, or is conditionally evaluated where all of the determining expressions are known on entry."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," X can be any nonlimited object that obeys the syntax for prefix other than the few exceptions given above (discussed below). Useful cases are: the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a formal parameter of mode [",(0,o.kt)("strong",null,"in"),"] ",(0,o.kt)("strong",null,"out"),", the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a global variable updated by the subprogram, a function call passing those as parameters, a subcomponent of those things, etc.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"A qualified expression can be used to make an arbitrary expression into a valid prefix, so T'(X + Y)'Old is legal, even though (X + Y)'Old is not. The value being saved here is the sum of X and Y (a function result is an object). Of course, in this case \"+\"(X, Y)'Old is also legal, but the qualified expression is arguably more readable.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"Note that F(X)'Old and F(X'Old) are not necessarily equal. The former calls F(X) and saves that value for later use during the postcondition. The latter saves the value of X, and during the postcondition, passes that saved value to F. In most cases, the former is what one wants (but it is not always legal, see below).")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," If X has controlled parts, adjustment and finalization are implied by the implicit constant declaration. Similarly, the implicit constant declaration defines the accessibility level of X'Old.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"If postconditions are disabled, we want the compiler to avoid any overhead associated with saving 'Old values.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"'Old makes no sense for limited types, because its implementation involves copying. It might make semantic sense to allow build-in-place, but it's not worth the trouble. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," Since the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," is evaluated when the subprogram is called (if it is evaluated at all), we cannot allow it to include values that do not exist at that time (like 'Result and loop parameters of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.5#S0153"},"quantified_expression")),"s). We also do not allow the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," itself to include 'Old references, as those would be redundant (because the evaluation of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),", if it occurs, already happens on entry to the subprogram ), and allowing them would require some sort of order to the implicit constant declarations (because in A(I'Old)'Old, we surely would want the value of I'Old evaluated before the A(I'Old) is evaluated).")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," An additional rule applies when it cannot be determined on entry to the subprogram whether the Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," will or will not be evaluated when the overall postcondition expression is evaluated. In such cases, we require that the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," to statically name some object. This is necessary because the Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es have to be evaluated when the subprogram is called if there is any possibility that they might be needed; the compiler cannot in general know whether they will be needed in the postcondition expression. To see the problem, consider:")),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"Table : array (1..10) of Integer := ...","\n","procedure Bar (I : in out Natural)","\n","   with Post =",">"," I ",">"," 0 and then Table(I)'Old = 1; -- Illegal","\n"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," In this example, the compiler cannot know on entry what will be the value of I when the subprogram returns (since the subprogram execution can change it), and thus it does not know whether Table(I)'Old will be needed then. Thus it has to always create an implicit constant and evaluate Table(I) when Bar is called (because not having the value when it is needed is not acceptable). But if I = 0 when the subprogram is called, that evaluation will raise Constraint_Error, and that will happen even if I is unchanged by the subprogram and the value of Table(I)'Old is not ultimately needed. It's easy to see how a similar problem could occur for a dereference of an access type. This would be mystifying (since the point of the short circuit is to eliminate this possibility, but it cannot do so). Therefore, we require the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of any Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," in such a context to statically name an object, which eliminates anything that could change during execution.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"It is easy to work around most errors that occur because of this rule. Just move the 'Old to the outer object, before any indexing, dereferences, or components. (That does not work for function calls, however, nor does it work for array indexing if the index can change during the execution of the subprogram.) ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," An accept statement for a task entry with enabled postconditions such as ")),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"accept E do","\n","   statements","\n","exception","\n","   handlers","\n","end;","\n"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"behaves (at runtime) as follows: ")),(0,o.kt)(a.Z,{mdxType:"CodeBlock"},"accept E do","\n","   declare","\n","      declarations, if any, of 'Old constants","\n","   begin","\n","      begin","\n","         statements","\n","      exception","\n","         handlers","\n","      end;","\n","      postcondition checks","\n","   end;","\n","end;","\n"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," Preconditions are checked by the caller before the rendezvous begins. Postcondition expressions might, of course, reference 'Old constants.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," In the case of a protected operation with enabled postconditions, 'Old constant declarations (if any) are elaborated after the start of the protected action. Postcondition checks (which might reference these constants) are performed before the end of the protected action as described below.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," has to statically name an entity if it appears within a repeatedly evaluated expression. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0220-1"),"}"," For a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," F that denotes a function declaration or an access-to-function type, the following attribute is defined: "),(0,o.kt)("p",null,"F'Result","{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0185-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0388-1"),"}"," Within a postcondition expression for F, denotes the return object of the function call for which the postcondition expression is evaluated. The type of this attribute is that of the result subtype of the function or access-to-function type  except within a Post'Class postcondition expression for a function with a controlling result or with a controlling access result; in those cases the type of the attribute is described above as part of the Name Resolution Rules for Post'Class."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," Use of this attribute is allowed only within a postcondition expression for F. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI05-0220-1"),"}",' An "access-to-function type" is an access-to-subprogram type whose designated profile is a function profile. ')),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0143-1"),"}"," For a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," E that denotes an entry declaration of an entry family (see 9.5.2), the following attribute is defined: "),(0,o.kt)("p",null,"E'Index","{",(0,o.kt)("em",null,"AI12-0143-1"),"}"," Within a precondition or postcondition expression for entry family E, denotes the value of the entry index for the call of E. The nominal subtype of this attribute is the entry index subtype."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0143-1"),"}"," Use of this attribute is allowed only within a precondition or postcondition expression for E. "),(0,o.kt)("h4",h({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0290-1"),"}"," Upon a call of the subprogram or entry, after evaluating any actual parameters, precondition checks are performed as follows:"),(0,o.kt)("p",null,"The specific precondition check begins with the evaluation of the specific precondition expression that applies to the subprogram or entry, if it is enabled; if the expression evaluates to False, Assertions.Assertion_Error is raised; if the expression is not enabled, the check succeeds."),(0,o.kt)("p",null,"The class-wide precondition check begins with the evaluation of any enabled class-wide precondition expressions that apply to the subprogram or entry. If and only if all the class-wide precondition expressions evaluate to False, Assertions.Assertion_Error is raised."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"The class-wide precondition expressions of the entity itself as well as those of any parent or progenitor operations are evaluated, as these expressions apply to the corresponding operations of all descendants.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"Class-wide precondition checks are performed for all appropriate calls, but only enabled precondition expressions are evaluated. Thus, the check would be trivial if no precondition expressions are enabled. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0269-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0166-1"),"}"," The precondition checks are performed in an arbitrary order, and if any of the class-wide precondition expressions evaluate to True, it is not specified whether the other class-wide precondition expressions are evaluated. The precondition checks and any check for elaboration of the subprogram body are performed in an arbitrary order. In a call on a protected operation, the checks are performed before starting the protected action. For an entry call, the checks are performed prior to checking whether the entry is open."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We need to explicitly allow short-circuiting of the evaluation of the class-wide precondition check if any expression fails, as it consists of multiple expressions; we don't need a similar permission for the specific precondition check as it consists only of a single expression. Nothing is evaluated for the call after a check fails, as the failed check propagates an exception. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0290-1"),"}"," Upon successful return from a call of the subprogram or entry, prior to copying back any by-copy ",(0,o.kt)("strong",null,"in out")," or ",(0,o.kt)("strong",null,"out")," parameters, the postcondition check is performed. This consists of the evaluation of any enabled specific and class-wide postcondition expressions that apply to the subprogram or entry. If any of the postcondition expressions evaluate to False, then Assertions.Assertion_Error is raised. The postcondition expressions are evaluated in an arbitrary order, and if any postcondition expression evaluates to False, it is not specified whether any other postcondition expressions are evaluated. The postcondition check, and any constraint or predicate checks associated with ",(0,o.kt)("strong",null,"in out")," or ",(0,o.kt)("strong",null,"out")," parameters are performed in an arbitrary order."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"The class-wide postcondition expressions of the entity itself as well as those of any parent or progenitor operations are evaluated, as these apply to all descendants; in contrast, only the specific postcondition of the entity applies. Postconditions can always be evaluated inside the invoked body. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," For a call to a task entry, the postcondition check is performed before the end of the rendezvous; for a call to a protected operation, the postcondition check is performed before the end of the protected action of the call. The postcondition check for any call is performed before the finalization of any implicitly-declared constants associated (as described above) with Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),"s but after the finalization of any other entities whose accessibility level is that of the execution of the callable construct. "),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0032-1"),"}",' If a postcondition references the implicitly-declared constant associated with an Old attribute, the postcondition must be evaluated before the constant is finalized. One way to think of this is to imagine declaring a controlled object between any implicit "\'Old" constant declarations and any explicit declarations, then performing postcondition checks during the finalization of this object. ')),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," If a precondition or postcondition check fails, the exception is raised at the point of the call[; the exception cannot be handled inside the called subprogram or entry]. Similarly, any exception raised by the evaluation of a precondition or postcondition expression is raised at the point of call."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," For any call to a subprogram or entry ",(0,o.kt)("em",null,"S")," (including dispatching calls), the checks that are performed to verify specific precondition expressions and specific and class-wide postcondition expressions are determined by those for the subprogram or entry actually invoked. Note that the class-wide postcondition expressions verified by the postcondition check that is part of a call on a primitive subprogram of type ",(0,o.kt)("em",null,"T")," includes all class-wide postcondition expressions originating in any progenitor of ",(0,o.kt)("em",null,"T"),"[, even if the primitive subprogram called is inherited from a type ",(0,o.kt)("em",null,"T1")," and some of the postcondition expressions do not apply to the corresponding primitive subprogram of ",(0,o.kt)("em",null,"T1"),"]. Any operations within a class-wide postcondition expression that were resolved as primitive operations of the (notional) formal derived type ",(0,o.kt)("em",null,"NT"),", are in the evaluation of the postcondition bound to the corresponding operations of the type identified by the controlling tag of the call on ",(0,o.kt)("em",null,"S"),".[ This applies to both dispatching and non-dispatching calls on ",(0,o.kt)("em",null,"S"),".]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This applies to access-to-subprogram calls, dispatching calls, and to statically bound calls. We need this rule to cover statically bound calls as well, as specific pre- and postconditions are not inherited, but the subprogram might be.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"For concrete subprograms, we require the original specific postcondition to be evaluated as well as the inherited class-wide postconditions in order that the semantics of an explicitly defined wrapper that does nothing but call the original subprogram is the same as that of an inherited subprogram.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"Note that this rule does not apply to class-wide preconditions; they have their own rules mentioned below. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," The class-wide precondition check for a call to a subprogram or entry ",(0,o.kt)("em",null,"S")," consists solely of checking the class-wide precondition expressions that apply to the denoted callable entity (not necessarily to the one that is invoked). Any operations within such an expression that were resolved as primitive operations of the (notional) formal derived type ",(0,o.kt)("em",null,"NT")," are in the evaluation of the precondition bound to the corresponding operations of the type identified by the controlling tag of the call on ",(0,o.kt)("em",null,"S"),".[ This applies to both dispatching and non-dispatching calls on ",(0,o.kt)("em",null,"S"),".]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"For a dispatching call, we are talking about the Pre'Class(es) that apply to the subprogram that the dispatching call is resolving to, not the Pre'Class(es) for the subprogram that is ultimately dispatched to. The class-wide precondition of the resolved call is necessarily the same or stronger than that of the invoked call. For a statically bound call, these are the same; for an access-to-subprogram, (which has no class-wide preconditions of its own), we check the class-wide preconditions of the invoked routine.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0233-1"),"}",' Since this check is based on the "callable entity", it does not depend on the view of the entity. This matters any time the ancestor type (if any) of the partial view differs from the parent type of the full view. In such a case, the view of the callable entity associated with the full view might inherit a Pre\'Class while the view of the same callable entity associated with the partial view does not. ')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"These rules imply that logically, class-wide preconditions of routines must be checked at the point of call (other than for access-to-subprogram calls, which must be checked in the body, probably using a wrapper). Specific preconditions that might be called with a dispatching call or via an access-to-subprogram value must be checked inside of the subprogram body. In contrast, the postcondition checks always need to be checked inside the body of the routine. Of course, an implementation can evaluate all of these at the point of call for statically bound calls if the implementation uses wrappers for dispatching bodies and for 'Access values.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"There is no requirement for an implementation to generate special code for routines that are imported from outside of the Ada program. That's because there is a requirement on the programmer that the use of interfacing aspects do not violate Ada semantics (see B.1). That includes making pre- and postcondition checks. For instance, if the implementation expects routines to make their own postcondition checks in the body before returning, C code can be assumed to do this (even though that is highly unlikely). That's even though the formal definition of those checks is that they are evaluated at the call site. Note that pre- and postconditions can be very useful for verification tools (even if they aren't checked), because they tell the tool about the expectations on the foreign code that it most likely cannot analyze. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0195-1"),"}"," For the purposes of the above rules, a call on an inherited subprogram is considered to involve a call on a subprogram ",(0,o.kt)("em",null,"S"),"' whose body consists only of a call (with appropriate conversions) on the non-inherited subprogram ",(0,o.kt)("em",null,"S")," from which the inherited subprogram was derived. It is not specified whether class-wide precondition or postcondition expressions that are equivalent (with respect to which non-inherited function bodies are executed) for ",(0,o.kt)("em",null,"S")," and ",(0,o.kt)("em",null,"S"),"' are evaluated once or twice. If evaluated only once, the value returned is used for both associated checks."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"If the class-wide pre- and postcondition expressions are equivalent for ",(0,o.kt)("em",null,"S")," and ",(0,o.kt)("em",null,"S"),"' because none of the primitive subprograms called in those expressions were overridden, no wrapper is needed. Otherwise, a wrapper is presumably needed to provide the correct logic. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," For a call via an access-to-subprogram value, precondition and postcondition checks performed are as determined by the subprogram or entry denoted by the prefix of the Access attribute reference that produced the value. In addition, a precondition check of any precondition expression associated with the access-to-subprogram type is performed. Similarly, a postcondition check of any postcondition expression associated with the access-to-subprogram type is performed."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"{",(0,o.kt)("em",null,"AI12-0220-1"),"}",' A call via an access-to-subprogram value can be considered equivalent (with respect to dynamic semantics) to a call to a notional "wrapper" subprogram which has the Pre and Post aspects and the profile of the access-to-subprogram type and whose body contains (and returns, in the case of a function) only a call to the designated subprogram. However, other evaluation orders for the checks are allowed beyond those allowed by strictly following this model. This equivalence can be used to determine the appropriate point at which the constant associated with an Old attribute reference in the Post aspect for an access-to-subprogram type is elaborated and finalized. ')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0220-1"),"}",' In the case of type conversion between two access-to-subprogram types, the Pre and Post aspects of the source type of the conversion play no role in any subsequent call via the conversion result; only the Pre and Post aspects of the target type of the conversion are relevant in that case. The same applies in the case of a "conversion" (using the term loosely) which is accomplished by combining a dereference and an Access attribute reference, as in Some_Pointer.',(0,o.kt)("strong",null,"all"),"'Access. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0272-1"),"}"," [For a call on a generic formal subprogram, precondition and postcondition checks performed are as determined by the subprogram or entry denoted by the actual subprogram, along with any specific precondition and specific postcondition of the formal subprogram itself.]"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Proof: "),"{",(0,o.kt)("em",null,"AI12-0272-1"),"}"," This follows from the general Dynamic Semantics rules given above, but we mention it explicitly so that there can be no doubt that it is intended. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI12-0371-1"),"}"," The specific precondition and postcondition that apply to a generic formal subprogram also apply to any renaming of that subprogram, even if that renaming is visible in the instance and called from outside of the generic instance. ")),(0,o.kt)("h4",h({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," ","{",(0,o.kt)("em",null,"AI12-0373-1"),"}"," An implementation may evaluate a known-on-entry subexpression of a postcondition expression of an entity at the place where X'Old constants are created for the entity, with the normal evaluation of the postcondition expression, or both."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," We allow the evaluation of known-on-entry subexpressions when they might be needed to determine whether to create a particular 'Old constant. We allow them to be evaluated later as well, or for the results to be saved somehow. This permission shouldn't matter, as the results ought to be same wherever they are evaluated and there should not be any side effects. The main effect of the permission is to determine when any exceptions caused by such subexpressions may be raised. We never require waiting to determine the value of such subexpressions, even if they aren't used to determine the creation of a constant for 'Old. ")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 1   ","{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0442-1"),"}"," A precondition is checked just before the call. If another task can change any value that the precondition expression depends on, the precondition can evaluate to False within the subprogram or entry body.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 2   ","{",(0,o.kt)("em",null,"AI12-0312-1"),"}"," For an example of the use of these aspects and attributes, see the Streams Subsystem definitions in 13.13.1. ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0145-2"),"}"," ","{",(0,o.kt)("em",null,"AI05-0230-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0247-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0254-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0273-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0274-1"),"}"," Pre and Post aspects are new. ")),(0,o.kt)("h4",h({},{id:"inconsistencies-with-ada-2012"}),"Inconsistencies With Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0032-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," The Old attribute is defined more carefully. This changes the nominal subtype and place of declaration of the attribute compared to the published Ada 2012 Reference Manual. In extreme cases, this could change the runtime behavior of the attribute (for instance, the tag might be different). The changes are most likely going to prevent bugs by being more intuitive, but it is possible that a program that previously worked might fail.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0113-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0159-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Eliminated unintentional redispatching from class-wide preconditions and postconditions. This means that a different body might be evaluated for a statically bound call to a routine that has a class-wide precondition or postcondition. The change means that the behavior of Pre and Pre'Class will be the same for a particular subprogram, and that the known behavior of the operations can be assumed within the body of that subprogram for Pre'Class. We expect that this change will primarily fix bugs, as it will make Pre'Class and Post'Class work more like expected. In the case where redispatching is desired, an explicit conversion to a class-wide type can be used.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0166-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Specified that precondition checks always take place before starting a protected action. Original Ada 2012 left this unspecified, so if an implementation made the checks after starting the protected action, and a program depended upon that, the program might fail in a different compiler. But such a program was depending on unspecified behavior anyway, and thus was never portable; as such, such programs should be rare.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0195-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Specified that an inherited subprogram check both the original and new versions of a class-wide precondition. If a call on an inherited subprogram fails the original class-wide precondition when it passes the new class-wide precondition, then the call will fail the precondition check whereas it would have passed in original Ada 2012. (A similar possibility exists for class-wide postconditions.) This can only happen if the overriding subprograms somehow fail to follow the guidelines of LSP, so this should be rare (the entire point of class-wide preconditions and postconditions is to use them in cases where LSP is followed). ")),(0,o.kt)("h4",h({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0045-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Precondition and postcondition aspects cannot be specified on instances of generic subprograms (they should be specified on the generic subprogram instead). This was (unintentionally) allowed by the Ada 2012 standard. These are not allowed on instances as there is no corresponding way to add preconditions and postconditions to subprograms declared within the instance of a generic package. Therefore, allowing specification on a subprogram instance could present a maintenance problem in the future if the entity needs to be converted to a generic package (a common conversion).")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0131-1"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Pre'Class is no longer allowed to be specified for an overriding primitive subprogram unless there are also inherited class-wide precondittions. This incompatibility prevents cases where the explicit Pre'Class is counterfeited by an implicit class-wide precondition of True. This rule should catch more bugs than it creates; the programmer should have written Pre rather than Pre'Class in this case (or written Pre'Class on the original subprogram, not an overriding). Note that this incompatibility eliminates what otherwise would be an inconsistency with original Ada 2012, where precondition checks that would have previously been made for a statically bound call would no longer be made. That dynamic change was necessary to eliminate cases where the evaluated class-wide precondition on a dispatching call would have been weaker than the class-wide precondition of a statically bound call. (The original Ada 2012 violated the LSP semantics that class-wide preconditions were intended to model.)")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0198-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," A component ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," in an array aggregate can now be potentially unevaluated, requiring the prefix to be statically determined. Existing code that uses the Old attribute with a dynamic prefix in such contexts will now be illegal. However, in many cases, the existing code will not do what the programmer is expecting (as Old is evaluated textually, once per occurrence, while array aggregate components are evaluated once per component). In addition, Old is a new Ada 2012 feature, so most Ada legacy code will not contain it. The problem is usually easily fixed by moving Old to an outer object (such as the entire aggregate). ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-2012-1"}),"Extensions to Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0143-1"),"}"," The Index attribute is new.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0217-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a statically unevaluated Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," can be a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),". This is considered a correction as the old rule is unintentionally too fierce, rejecting safe cases.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0280-2"),"}"," We make no restriction on the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Old ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," if we can determine when the subprogram is entered (which is the point when Old prefixes are evaluated) whether it will be needed in the evaluation of the postcondition.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0220-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0272-1"),"}"," Pre and Post can be given on an access-to-subprogram type and on a generic formal subprogram.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0412-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," We now allow the definition of a concrete subprogram ",(0,o.kt)("em",null,"S")," that has applicable Pre'Class or Post'Class expressions that is primitive for an abstract type ",(0,o.kt)("em",null,"T")," even when a Pre'Class or Post'Class may call an abstract subprogram. Rather, ",(0,o.kt)("em",null,"S")," is treated as if it is abstract (meaning that uses that might require evaluating a statically bound Pre'Class or Post'Class expression are not allowed). ")),(0,o.kt)("h4",h({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0170-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Clarified the wording about the meaning of the notional type ",(0,o.kt)("em",null,"NT")," and the corresponding expression. Both changes follow from other rules but are nonobvious.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0185-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Removed redundant (and sometimes incorrect) wording about the resolution of the Old and Result attributes. ")),(0,o.kt)("h2",h({},{id:"612--the-global-and-globalclass-aspects"}),"6.1.2  The Global and Global'Class Aspects"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0425-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0439-1"),"}"," The Global and Global'Class aspects of a program unit are used to identify the objects global to the unit that can be read or written during its execution. "),(0,o.kt)("h4",h({},{id:"syntax-1"}),"Syntax"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0380-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0425-1"),"}"," ",(0,o.kt)("code",null,"global_aspect_definition"),(0,o.kt)("a",{id:"S0209"}),(0,o.kt)("code",null," ::= "),"    ",(0,o.kt)("strong",null,"null"),"  | Unspecified  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0214"},"global_designator")),"  | (",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0210"},"global_aspect_element")),"{","; ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0210"},"global_aspect_element")),"}",")"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0380-1"),"}"," ",(0,o.kt)("code",null,"global_aspect_element"),(0,o.kt)("a",{id:"S0210"}),(0,o.kt)("code",null," ::= "),"    ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0213"},"global_set")),"  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," ",(0,o.kt)("strong",null,"all"),"  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," ",(0,o.kt)("strong",null,"synchronized")),(0,o.kt)("p",null,(0,o.kt)("code",null,"global_mode"),(0,o.kt)("a",{id:"S0211"}),(0,o.kt)("code",null," ::= "),"    ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0212"},"basic_global_mode")),"  | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-H/AA-H.7#S0361"},"extended_global_mode"))),(0,o.kt)("p",null,(0,o.kt)("code",null,"basic_global_mode"),(0,o.kt)("a",{id:"S0212"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("strong",null,"in")," | ",(0,o.kt)("strong",null,"in out")," | ",(0,o.kt)("strong",null,"out")),(0,o.kt)("p",null,(0,o.kt)("code",null,"global_set"),(0,o.kt)("a",{id:"S0213"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name"))," ","{",", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),"}"),(0,o.kt)("p",null,(0,o.kt)("code",null,"global_designator"),(0,o.kt)("a",{id:"S0214"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("strong",null,"all")," | ",(0,o.kt)("strong",null,"synchronized")," | ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name"))),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0310-1"),"}"," ",(0,o.kt)("code",null,"global_name"),(0,o.kt)("a",{id:"S0215"}),(0,o.kt)("code",null," ::= "),(0,o.kt)("em",null,"object_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," | ",(0,o.kt)("em",null,"package_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))),(0,o.kt)("h4",h({},{id:"name-resolution-rules-2"}),"Name Resolution Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0425-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0427-1"),"}"," A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name"))," shall resolve to statically name an object or a package (including a limited view of a package). "),(0,o.kt)("h4",h({},{id:"static-semantics-2"}),"Static Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," For a subprogram, an entry, an access-to-subprogram type, a task unit, a protected unit, or a library package or generic library package, the following language-defined aspect may be specified with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," (see 13.1.1):"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0425-1"),"}"," GlobalThe Global aspect shall be specified with a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition")),"."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Global: "),"Global object usage contract.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0422-1"),"}"," The Global aspect identifies the set of variables (which, for the purposes of this clause, includes all constants except those which are known to have no variable views (see 3.3)) that are global to a callable entity or task body, and that are read or updated as part of the execution of the callable entity or task body. If specified for a protected unit, it refers to all of the protected operations of the protected unit. Constants of any type may also be mentioned in a Global aspect."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," If not specified or otherwise defined below, the aspect defaults to the Global aspect for the enclosing library unit if the entity is declared at library level, and to Unspecified otherwise. If not specified for a library unit, the aspect defaults to Global =",">"," ",(0,o.kt)("strong",null,"null")," for a library unit that is declared Pure, and to Global =",">"," Unspecified otherwise. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," For a dispatching subprogram, the following language-defined aspect may be specified with an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," (see 13.1.1):"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0425-1"),"}"," Global'ClassThe Global'Class aspect shall be specified with a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition")),". This aspect identifies an upper bound on the set of variables global to a dispatching operation that can be read or updated as a result of a dispatching call on the operation. If not specified, the aspect defaults to the Global aspect for the dispatching subprogram."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Aspect Description for "),(0,o.kt)("strong",null,"Global'Class: "),"Global object usage contract inherited on derivation.")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0380-1"),"}"," Together, we refer to the Global and Global'Class aspects as ",(0,o.kt)("em",null,"global")," aspects."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition"))," defines the Global or Global'Class aspect of some entity. The Global aspect identifies the sets of global variables that can be read, written, or modified as a side effect of executing the operation(s) associated with the entity. The Global'Class aspect associated with a dispatching operation of type ",(0,o.kt)("em",null,"T")," represents a restriction on the Global aspect on a corresponding operation of any descendant of type ",(0,o.kt)("em",null,"T"),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0416-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0442-1"),"}"," The Global aspect for a callable entity defines the global variables that can be referenced as part of a call on the entity, including any assertion expressions that apply to the call (even if not enabled), such as preconditions, postconditions, predicates, and type invariants."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0439-1"),"}"," The Global aspect for an access-to-subprogram object (or subtype) identifies the global variables that can be referenced when calling via the object (or any object of that subtype) including assertion expressions that apply."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0405-1"),"}"," For a predefined operator of an elementary type, the function representing an enumeration literal, or any other static function (see 4.9), the Global aspect is ",(0,o.kt)("strong",null,"null"),". For a predefined operator of a composite type, the Global aspect of the operator defaults to that of the enclosing library unit (unless a Global aspect is specified for the type - see H.7)."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0380-1"),"}"," The following is defined in terms of operations that are performed by or on behalf of an entity. The rules on operations apply to the entity(s) associated with those operations."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI12-0380-1"),"}"," The operations performed by a callable entity are those associated with the body of the entity. For other kinds of entities (such as subtypes, see H.7), we explicitly list the associated operations. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," The global variables associated with any ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," can be read as a side effect of an operation. The ",(0,o.kt)("strong",null,"in out")," and ",(0,o.kt)("strong",null,"out")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode")),"s together identify the set of global variables that can be updated as a side effect of an operation. Creating an access-to-variable value that designates an object is considered an update of the designated object, and creating an access-to-constant value that designates an object is considered a read of the designated object."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," The overall set of objects associated with each ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," includes all objects identified for the mode in the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition")),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," A ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0213"},"global_set"))," identifies a ",(0,o.kt)("em",null,"global variable set")," as follows:"),(0,o.kt)("p",null,(0,o.kt)("strong",null,"all")," identifies the set of all global variables;"),(0,o.kt)("p",null,(0,o.kt)("strong",null,"synchronized")," identifies the set of all synchronized variables (see 9.10), as well as variables of a composite type all of whose non-discriminant subcomponents are synchronized;"),(0,o.kt)("p",null,(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),"{",", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),"}"," identifies the union of the sets of variables identified by the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),"s in the list, for the following forms of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),":"),(0,o.kt)("p",null,(0,o.kt)("em",null,"object_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," identifies the specified global variable (or constant);"),(0,o.kt)("p",null,(0,o.kt)("em",null,"package_"),(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," identifies the set of all variables declared in the private part or body of the package, or anywhere within a private descendant of the package. "),(0,o.kt)("h4",h({},{id:"legality-rules-2"}),"Legality Rules"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-1"),"}"," Within a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition")),", a given ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," shall be specified at most once. Similarly, within a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0209"},"global_aspect_definition")),", a given entity shall be named at most once by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0215"},"global_name")),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," If an entity (other than a library package or generic library package) has a Global aspect other than Unspecified or ",(0,o.kt)("strong",null,"in out all"),", then the associated operation(s) shall read only those variables global to the entity that are within the global variable set associated with the ",(0,o.kt)("strong",null,"in"),", ",(0,o.kt)("strong",null,"in out"),", or ",(0,o.kt)("strong",null,"out")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode")),"s, and the operation(s) shall update only those variables global to the entity that are within the global variable set associated with either the ",(0,o.kt)("strong",null,"in out")," or ",(0,o.kt)("strong",null,"out")," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode")),"s. In the absence of the No_Hidden_Indirect_Globals restriction (see H.4), this ignores objects reached via a dereference of an access value.  The above rule includes any possible Global effects of calls occurring during the execution of the operation, except for the following excluded calls:"),(0,o.kt)("p",null,"calls to formal subprograms;"),(0,o.kt)("p",null,"calls associated with operations on formal subtypes;"),(0,o.kt)("p",null,"calls through formal objects of an access-to-subprogram type;"),(0,o.kt)("p",null,"calls through access-to-subprogram parameters;"),(0,o.kt)("p",null,"calls on operations with Global aspect Unspecified."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," The possible Global effects of these excluded calls (other than those that are Unspecified) are taken into account by the caller of the original operation, by presuming they occur at least once during its execution. For calls that are not excluded, the possible Global effects of the call are those permitted by the Global aspect of the associated entity, or by its Global'Class aspect if a dispatching call."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"For a predefined equality operator of a composite type, the possible Global effects includes those of the equality operations invoked as part of the evaluation of the operator (which might not be predefined and thus might have a different Global specification than the component types). ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," If a Global aspect other than Unspecified or ",(0,o.kt)("strong",null,"in out all")," applies to an access-to-subprogram type, then the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Access ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," producing a value of such a type shall denote a subprogram whose Global aspect is not Unspecified and is ",(0,o.kt)("em",null,"covered")," by that of the result type, where a global aspect ",(0,o.kt)("em",null,"G1")," is ",(0,o.kt)("em",null,"covered")," by a global aspect ",(0,o.kt)("em",null,"G2")," if the set of variables that ",(0,o.kt)("em",null,"G1")," identifies as readable or updatable is a subset of the corresponding set for ",(0,o.kt)("em",null,"G2"),". Similarly on a conversion to such a type, the operand shall be of a named access-to-subprogram type whose Global aspect is covered by that of the target type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," If an implementation-defined ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode"))," applies to a given set of variables, an implementation-defined rule determines what sort of references to them are permitted."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-1"),"}"," For a subprogram that is a dispatching operation of a tagged type ",(0,o.kt)("em",null,"T"),", each mode of its Global aspect shall identify a subset of the variables identified by the corresponding mode, or by the ",(0,o.kt)("strong",null,"in out")," mode, of the Global'Class aspect of a corresponding dispatching subprogram of any ancestor of ",(0,o.kt)("em",null,"T"),", unless the aspect of that ancestor is Unspecified."),(0,o.kt)("h4",h({},{id:"implementation-permissions-1"}),"Implementation Permissions"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," ","{",(0,o.kt)("em",null,"AI12-0444-1"),"}"," An implementation can allow some references to a constant object which are not accounted for by the Global or Global'Class aspect when it is considered a variable in the above rules, if the implementation can determine that the object is in fact immutable."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"In particular, this allows the implementation to violate privacy in order to determine whether a constant needs to be covered by a Global aspect. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," Implementations may perform additional checks on calls to operations with an Unspecified Global aspect to ensure that they do not violate any limitations associated with the point of call."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"In this sense, Global =",">"," Unspecified is not permission to violate the caller's Global restrictions. It is rather that the implementor of the subprogram is presuming other means are being used to ensure safety. Note the No_Unspecified_Globals Restriction (H.4), which prevents the use of Unspecified with the Global aspect in a given partition. ")),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-3"),"}"," Implementations may extend the syntax or semantics of the Global aspect in an implementation-defined manner[; for example, supporting additional ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"../AA-6/AA-6.1#S0211"},"global_mode")),"s]."),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation defined: "),"Any extensions of the Global aspect.")),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),'This is intended to allow preexisting usages from SPARK 2014 to remain acceptable in conforming implementations, as well as to provide flexibility for future enhancements. Note the word "extend" in this permission; we expect that any aspect usage that conforms with the (other) rules of this clause will be accepted by any Ada implementation, regardless of any implementation-defined extensions. ')),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"NOTE 1   ","{",(0,o.kt)("em",null,"AI12-0312-1"),"}"," For an example of the use of these aspects and attributes, see the Vector container definition in A.18.2. ")),(0,o.kt)("h4",h({},{id:"extensions-to-ada-2012-2"}),"Extensions to Ada 2012"),(0,o.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0079-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0240-6"),"}"," ","{",(0,o.kt)("em",null,"AI12-0310-1"),"}"," The Global and Global'Class aspects are new. ")))}g.isMDXComponent=!0}}]);