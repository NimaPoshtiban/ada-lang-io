"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9629],{1716:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>f});var n=a(6687);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(a),f=r,m=h["".concat(l,".").concat(f)]||h[f]||d[f]||o;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4343:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(9440),r=(a(6687),a(1716));const o={sidebar_position:51},i="6.3  Subprogram Bodies",s={unversionedId:"arm/AA-6.3",id:"arm/AA-6.3",title:"6.3  Subprogram Bodies",description:"A [subprogram_body specifies the execution of a subprogram.]",source:"@site/docs/arm/AA-6.3.md",sourceDirName:"arm",slug:"/arm/AA-6.3",permalink:"/docs/arm/AA-6.3",draft:!1,tags:[],version:"current",sidebarPosition:51,frontMatter:{sidebar_position:51},sidebar:"tutorialSidebar",previous:{title:"6.2  Formal Parameter Modes",permalink:"/docs/arm/AA-6.2"},next:{title:"6.4  Subprogram Calls",permalink:"/docs/arm/AA-6.4"}},l={},p=[{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"6.3.1  Conformance Rules",id:"631--conformance-rules",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"6.3.2  Inline Expansion of Subprograms",id:"632--inline-expansion-of-subprograms",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4}],c={toc:p};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"63--subprogram-bodies"},"6.3  Subprogram Bodies"),(0,r.kt)("p",null,"[A ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," specifies the execution of a subprogram.] "),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"{AI95-00218-03} {AI05-0183-1} subprogram_body",(0,r.kt)("a",{id:"S0216"})," ::=\n","[[overriding_indicator](./AA-8.3#S0234)][subprogram_specification]","(./AA-6.1#S0196)\n[",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"] is\n",(0,r.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part"),"\nbegin\n",(0,r.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements"),"\nend [",(0,r.kt)("a",{parentName:"p",href:"./AA-6.1#S0199"},"designator"),"];"),(0,r.kt)("p",null,"If a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.1#S0199"},"designator")," appears at the end of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body"),", it shall repeat the ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.1#S0200"},"defining_designator")," of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.1#S0196"},"subprogram_specification"),". "),(0,r.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,r.kt)("p",null,"{AI12-0444-1} ","[In contrast to other bodies,]"," a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," is allowed to be defined without it being the completion of a previous declaration","[, in which case the body declares the subprogram]",". If the body is a completion, it shall be the completion of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.1#S0195"},"subprogram_declaration")," or ",(0,r.kt)("a",{parentName:"p",href:"./AA-12.1#S0311"},"generic_subprogram_declaration"),". The profile of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," that completes a declaration shall conform fully to that of the declaration. "),(0,r.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," is considered a declaration. It can either complete a previous declaration, or itself be the initial declaration of the subprogram. "),(0,r.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,r.kt)("p",null,"The elaboration of a nongeneric ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," has no other effect than to establish that the subprogram can from then on be called without failing the Elaboration_Check. "),(0,r.kt)("p",null,"Ramification: See 12.2 for elaboration of a generic body. Note that protected subprogram_bodies never get elaborated; the elaboration of the containing ",(0,r.kt)("a",{parentName:"p",href:"./AA-9.4#S0254"},"protected_body")," allows them to be called without failing the Elaboration_Check. "),(0,r.kt)("p",null,"[The execution of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," is invoked by a subprogram call.] For this execution the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part")," is elaborated, and the ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements")," is then executed. "),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Example of procedure body: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Push(E : in Element_Type; S : in out Stack) is\nbegin\n   if S.Index = S.Size then\n      raise Stack_Overflow;\n   else\n      S.Index := S.Index + 1;\n      S.Space(S.Index) := E;\n   end if;\nend Push;\n\n")),(0,r.kt)("p",null,"Example of a function body: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"function Dot_Product(Left, Right : Vector) return Real is\n   Sum : Real := 0.0;\nbegin\n   Check(Left'First = Right'First and Left'Last = Right'Last);\n   for J in Left'Range loop\n      Sum := Sum + Left(J)*Right(J);\n   end loop;\n   return Sum;\nend Dot_Product;\n\n")),(0,r.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"./AA-8.5#S0238"},"renaming_declaration")," may be used instead of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body"),". "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,"The syntax rule for ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," now uses the syntactic category ",(0,r.kt)("a",{parentName:"p",href:"./AA-11.2#S0304"},"handled_sequence_of_statements"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part")," of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," is now required; that doesn't make any real difference, because a ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.11#S0086"},"declarative_part")," can be empty."),(0,r.kt)("p",null,"We have incorporated some rules from RM83-6.5 here."),(0,r.kt)("p",null,"RM83 forgot to restrict the definition of elaboration of a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body")," to nongenerics. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,r.kt)("p",null,"{AI95-00218-03} ",(0,r.kt)("a",{parentName:"p",href:"./AA-8.3#S0234"},"Overriding_indicator")," is added to ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body"),". "),(0,r.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,r.kt)("p",null,"{AI05-0183-1} An optional ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," can be used in a ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.3#S0216"},"subprogram_body"),". This is described in 13.1.1. "),(0,r.kt)("h2",{id:"631--conformance-rules"},"6.3.1  Conformance Rules"),(0,r.kt)("p",null,"[When subprogram profiles are given in more than one place, they are required to conform in one of four ways: type conformance, mode conformance, subtype conformance, or full conformance.]"," "),(0,r.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,r.kt)("p",null,"{8652/0011} {AI95-00117-01} ",'[As explained in B.1, "Interfacing Aspects", a convention can be specified for an entity.]'," Unless this document states otherwise, the default convention of an entity is Ada. ","[For a callable entity or access-to-subprogram type, the convention is called the calling convention.]"," The following conventions are defined by the language: "),(0,r.kt)("p",null,"{AI05-0229-1} The default calling convention for any subprogram not listed below is Ada. ","[The Convention aspect may be specified to override the default calling convention (see B.1)]",". "),(0,r.kt)("p",null,"Ramification: See also the rule about renamings-as-body in 8.5.4. "),(0,r.kt)("p",null,'The Intrinsic calling convention represents subprograms that are "built in" to the compiler. The default calling convention is Intrinsic for the following: '),(0,r.kt)("p",null,"an enumeration literal;"),(0,r.kt)("p",null,'a "/=" operator declared implicitly due to the declaration of "=" (see 6.6);'),(0,r.kt)("p",null,"any other implicitly declared subprogram unless it is a dispatching operation of a tagged type;"),(0,r.kt)("p",null,"an inherited subprogram of a generic formal tagged type with unknown discriminants; "),(0,r.kt)("p",null,"Reason: Consider: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type Root is tagged null record;\n    procedure Proc(X: Root);\nend P;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type Formal(&lt&gt) is new Root with private;\npackage G is\n    ...\nend G;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package body G is\n    ...\n    X: Formal := ...;\n    ...\n    Proc(X); -- This is a dispatching call in Instance, because\n             -- the actual type for Formal is class-wide.\n    ...\n    -- Proc'Access would be illegal here, because it is of\n    -- convention Intrinsic, by the above rule.\nend G;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"type Actual is new Root with ...;\nprocedure Proc(X: Actual);\npackage Instance is new G(Formal =&gt Actual'Class);\n    -- It is legal to pass in a class-wide actual, because Formal\n    -- has unknown discriminants.\n\n")),(0,r.kt)("p",null,"Within Instance, all calls to Proc will be dispatching calls, so Proc doesn't really exist in machine code, so we wish to avoid taking 'Access of it. This rule applies to those cases where the actual type might be class-wide, and makes these Intrinsic, thus forbidding 'Access. "),(0,r.kt)("p",null,"an attribute that is a subprogram;"),(0,r.kt)("p",null,"{AI95-00252-01} a subprogram declared immediately within a ",(0,r.kt)("a",{parentName:"p",href:"./AA-9.4#S0254"},"protected_body"),";"),(0,r.kt)("p",null,"{AI95-00252-01} {AI95-00407-01} {AI12-0107-1} any prefixed view of a subprogram (see 4.1.3) without synchronization kind (see 9.5) By_Entry or By_Protected_Procedure. "),(0,r.kt)("p",null,"Reason: {AI12-0005-1} The profile of a prefixed view is different from the \"real\" profile of the subprogram (it doesn't have the first parameter), so we don't want to be able to take 'Access of it, as that would require generating a wrapper of some sort."),(0,r.kt)("p",null,"{AI12-0107-1} We except prefixed views that have synchronization kind By_Protected_Procedure so that they can be used with an access-to-protected-procedure type. These don't require special wrappers (this is the normal form for a protected subprogram call). The By_Entry part is just for consistency (there is no access-to-entry type in Ada). "),(0,r.kt)("p",null,"[The Access attribute is not allowed for Intrinsic subprograms.]"," "),(0,r.kt)("p",null,"Ramification: The Intrinsic calling convention really represents any number of calling conventions at the machine code level; the compiler might have a different instruction sequence for each intrinsic. That's why the Access attribute is disallowed. We do not wish to require the implementation to generate an out of line body for an intrinsic."),(0,r.kt)("p",null,'{AI05-0229-1} Whenever we wish to disallow the Access attribute in order to ease implementation, we make the subprogram Intrinsic. Several language-defined subprograms have "with Convention =',">",' Intrinsic;". An implementation might actually implement this as "with Import =',">"," True, Convention =",">",' Intrinsic;", if there is really no body, and the implementation of the subprogram is built into the code generator.'),(0,r.kt)("p",null,'Subprograms declared in protected_bodies will generally have a special calling convention so as to pass along the identification of the current instance of the protected type. The convention is not protected since such local subprograms need not contain any "locking" logic since they are not callable via "external" calls; this rule prevents an access value designating such a subprogram from being passed outside the protected unit.'),(0,r.kt)("p",null,'The "implicitly declared subprogram" above refers to predefined operators (other than the "=" of a tagged type) and the inherited subprograms of untagged types. '),(0,r.kt)("p",null,"{AI12-0107-1} {AI12-0159-1} The default calling convention is protected for a protected subprogram, for a prefixed view of a subprogram with a synchronization kind of By_Protected_Procedure, and for an access-to-subprogram type with the reserved word protected in its definition."),(0,r.kt)("p",null,"{AI12-0107-1} {AI12-0159-1} The default calling convention is entry for an entry and for a prefixed view of a subprogram with a synchronization kind of By_Entry."),(0,r.kt)("p",null,"{AI95-00254-01} {AI95-00409-01} {AI05-0264-1} {AI12-0207-1} The calling convention for an anonymous access-to-subprogram parameter or anonymous access-to-subprogram result is protected if the reserved word protected appears in its definition; otherwise, it is the convention of the entity that has the parameter or result, unless that entity has convention protected, entry, or Intrinsic, in which case the convention is Ada. "),(0,r.kt)("p",null,"Ramification: The calling convention for other anonymous access-to-subprogram types is Ada. "),(0,r.kt)("p",null,"{8652/0011} {AI95-00117-01} ","[If not specified above as Intrinsic, the calling convention for any inherited or overriding dispatching operation of a tagged type is that of the corresponding subprogram of the parent type.]"," The default calling convention for a new dispatching operation of a tagged type is the convention of the type. "),(0,r.kt)("p",null,"Reason: The first rule is officially stated in 3.9.2. The second is intended to make interfacing to foreign OOP languages easier, by making the default be that the type and operations all have the same convention. "),(0,r.kt)("p",null,"{AI05-0229-1} Of these four conventions, only Ada and Intrinsic are allowed as a convention_",(0,r.kt)("a",{parentName:"p",href:"./AA-2.3#S0002"},"identifier")," in the specification of a Convention aspect. "),(0,r.kt)("p",null,"Discussion: {AI05-0229-1} The names of the protected and entry calling conventions cannot be used in the specification of Convention. Note that protected and entry are reserved words. "),(0,r.kt)("p",null,"{AI95-00409-01} Two profiles are type conformant if they have the same number of parameters, and both have a result if either does, and corresponding parameter and result types are the same, or, for access parameters or access results, corresponding designated types are the same, or corresponding designated profiles are type conformant. "),(0,r.kt)("p",null,"Discussion: {AI95-00409-01} For anonymous access-to-object parameters, the designated types have to be the same for type conformance, not the access types, since in general each access parameter has its own anonymous access type, created when the subprogram is called. Of course, corresponding parameters have to be either both access parameters or both not access parameters."),(0,r.kt)("p",null,"{AI95-00409-01} Similarly, for anonymous access-to-subprogram parameters, the designated profiles of the types, not the types themselves, have to be conformant. "),(0,r.kt)("p",null,"{AI95-00318-02} {AI95-00409-01} {AI05-0142-4} Two profiles are mode conformant if:"),(0,r.kt)("p",null,"{AI05-0142-4} {AI05-0262-1} they are type conformant; and"),(0,r.kt)("p",null,"{AI05-0142-4} corresponding parameters have identical modes and both or neither are explicitly aliased parameters; and"),(0,r.kt)("p",null,"{AI05-0207-1} for corresponding access parameters and any access result type, the designated subtypes statically match and either both or neither are access-to-constant, or the designated profiles are subtype conformant. "),(0,r.kt)("p",null,"{AI05-0239-1} Two profiles are subtype conformant if they are mode conformant, corresponding subtypes of the profile statically match, and the associated calling conventions are the same. The profile of a generic formal subprogram is not subtype conformant with any other profile. "),(0,r.kt)("p",null,"Ramification: "),(0,r.kt)("p",null,"{AI05-0134-1} {AI05-0262-1} Two profiles are fully conformant if they are subtype conformant, if they have access-to-subprogram results whose designated profiles are fully conformant, and for corresponding parameters: "),(0,r.kt)("p",null,"{AI05-0262-1} they have the same names; and"),(0,r.kt)("p",null,"{AI05-0046-1} both or neither have ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion"),"s; and"),(0,r.kt)("p",null,"neither have ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s, or they both have ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s that are fully conformant with one another; and"),(0,r.kt)("p",null,"{AI05-0134-1} for access-to-subprogram parameters, the designated profiles are fully conformant. "),(0,r.kt)("p",null,"Ramification: Full conformance requires subtype conformance, which requires the same calling conventions. However, the calling convention of the declaration and body of a subprogram or entry are always the same by definition. "),(0,r.kt)("p",null,"Reason: {AI05-0046-1} The part about ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion"),"s is necessary to prevent controlling parameters from having different exclusions, as such a parameter is defined to exclude null whether or not an exclusion is given."),(0,r.kt)("p",null,"{AI05-0134-1} The parts about access-to-subprogram parameters and results is necessary to prevent such types from having different ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s in the specification and body of a subprogram. If that was allowed, it would be undefined which ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression")," was used in a call of an access-to-subprogram parameter. "),(0,r.kt)("p",null,"Two expressions are fully conformant if, [after replacing each use of an operator with the equivalent ",(0,r.kt)("a",{parentName:"p",href:"./AA-6.4#S0218"},"function_call"),":] "),(0,r.kt)("p",null,"each constituent construct of one corresponds to an instance of the same syntactic category in the other, except that an expanded name may correspond to a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," (or ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),") or to a different expanded name in the other; and"),(0,r.kt)("p",null,"{AI12-0050-1} corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),"s occurring within the two expressions are the same; and"),(0,r.kt)("p",null,"{AI12-0050-1} each ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name"),", ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", and ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," that is not part of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," of an expanded name in one denotes the same declaration as the corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name"),", ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),", or ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," in the other, or they denote corresponding declarations occurring within the two expressions; and "),(0,r.kt)("p",null,'Ramification: {AI12-0300-1} Note that it doesn\'t say "respectively" because a ',(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," can correspond to a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name"),", and vice versa, by the previous bullet. This rule allows the ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," of an expanded name to be removed, or replaced with a different ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," that denotes a renaming of the same entity. However, it does not allow a ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name")," or ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name")," to be replaced with one denoting a distinct renaming (except for ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0092"},"direct_name"),"s and ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0099"},"selector_name"),"s in ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix"),"es of expanded names). Note that calls using operator notation are equivalent to calls using prefix notation."),(0,r.kt)("p",null,"Given the following declarations: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"package A is\n    function F(X : Integer := 1) return Boolean;\nend A;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"{AI05-0005-1} with A;\npackage B is\n    package A_View renames A;\n    function F_View(X : Integer := 9999) return Boolean renames A.F;\nend B;\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"with A, B; use A, B;\nprocedure Main is ...\n\n")),(0,r.kt)("p",null,'Within Main, the expressions "F", "A.F", "B.A_View.F", and "A_View.F" are all fully conformant with one another. However, "F" and "F_View" are not fully conformant. If they were, it would be bad news, since the two denoted views have different ',(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s. "),(0,r.kt)("p",null,"Discussion: {AI12-0050-1} We talk about ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),'s and "corresponding declarations" because of the possibility of ',(0,r.kt)("a",{parentName:"p",href:"./AA-5.5#S0183"},"iterator_specification"),"s occurring within the expressions; each ",(0,r.kt)("a",{parentName:"p",href:"./AA-5.5#S0183"},"iterator_specification")," is a separate declaration, which we need to allow, but we do want to require that the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),"s are the same. "),(0,r.kt)("p",null,"{8652/0018} {AI95-00175-01} {AI05-0092-1} each ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," in one is the same as the corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," in the other; and"),(0,r.kt)("p",null,"{AI12-0342-1} each ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0141"},"primary")," that is a literal in one is a user-defined literal if and only if the corresponding literal in the other is also a user-defined literal. Furthermore, if neither are user-defined literals then they shall have the same values","[, but they may have differing textual representations]","; if both are user-defined literals then they shall have the same textual representation."),(0,r.kt)("p",null,"Ramification: {AI12-0342-1} This rule applies to ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.5#S0015"},"character_literal"),"s, so even though other rules would allow a rename of a character literal to conform to the literal, this rule prevents that. "),(0,r.kt)("p",null,"Ramification: Note that the above definition makes full conformance a transitive relation. "),(0,r.kt)("p",null,"Two ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part"),"s are fully conformant if they have the same number of discriminants, and discriminants in the same positions have the same names, statically matching subtypes, and ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0063"},"default_expression"),"s that are fully conformant with one another. "),(0,r.kt)("p",null,"Two ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"s are fully conformant if they are both ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"s or are both ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),"s, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),"s (if any) denote the same subtype, and the corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),"s (if any) fully conform. "),(0,r.kt)("p",null,"Ramification: In the ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," case, any ranges have to be corresponding; that is, two ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"s cannot conform unless both or neither has a ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". "),(0,r.kt)("p",null,'Discussion: This definition is used in 9.5.2, "Entries and Accept Statements" for the conformance required between the ',(0,r.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"s of an ",(0,r.kt)("a",{parentName:"p",href:"./AA-9.5#S0257"},"entry_declaration")," for a family of entries and the corresponding ",(0,r.kt)("a",{parentName:"p",href:"./AA-9.5#S0263"},"entry_index_specification")," of the ",(0,r.kt)("a",{parentName:"p",href:"./AA-9.5#S0260"},"entry_body"),". "),(0,r.kt)("p",null,"{AI95-00345-01} {AI95-00397-01} The prefixed view profile of a subprogram is the profile obtained by omitting the first parameter of that subprogram. There is no prefixed view profile for a parameterless subprogram. For the purposes of defining subtype and mode conformance, the convention of a prefixed view profile is considered to match that of either an entry or a protected operation."),(0,r.kt)("p",null,"Discussion: This definition is used to define how primitive subprograms of interfaces match operations in task and protected type definitions (see 9.1 and 9.4). "),(0,r.kt)("p",null,"Reason: The weird rule about conventions is pretty much required for synchronized interfaces to make any sense. There will be wrappers all over the place for interfaces anyway. Of course, this doesn't imply that entries have the same convention as protected operations. "),(0,r.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,r.kt)("p",null,"An implementation may declare an operator declared in a language-defined library unit to be intrinsic. "),(0,r.kt)("p",null,"NOTE 1   {AI12-0398-1} Any conformance requirements between ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s that are part of a profile or ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.7#S0061"},"known_discriminant_part")," are defined by the semantics of each particular aspect. In particular, there is no general requirement for ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s to match in conforming profiles or discriminant parts. "),(0,r.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,r.kt)("p",null,'The rules for full conformance are relaxed - they are now based on the structure of constructs, rather than the sequence of lexical elements. This implies, for example, that "(X, Y: T)" conforms fully with "(X: T; Y: T)", and "(X: T)" conforms fully with "(X: in T)". '),(0,r.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,r.kt)("p",null,"{8652/0011} {AI95-00117-01} Corrigendum: Clarified that the default convention is Ada. Also clarified that the convention of a primitive operation of a tagged type is the same as that of the type."),(0,r.kt)("p",null,"{8652/0018} {AI95-00175-01} Corrigendum: Added wording to ensure that two attributes conform only if they have the same ",(0,r.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator"),"."),(0,r.kt)("p",null,"{AI95-00252-01} {AI95-00254-01} {AI95-00407-01} Defined the calling convention for anonymous access-to-subprogram types and for prefixed views of subprograms (see 4.1.3)."),(0,r.kt)("p",null,"{AI95-00318-02} Defined the conformance of access result types (see 6.1)."),(0,r.kt)("p",null,"{AI95-00345-01} {AI95-00397-01} Defined the prefixed view profile of subprograms for later use."),(0,r.kt)("p",null,"{AI95-00409-01} Defined the conformance of anonymous access-to-subprogram parameters. "),(0,r.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,r.kt)("p",null,"{AI05-0046-1} Correction: Now require ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion"),"s to match for full conformance. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage of the ability to write mismatching exclusions. In any case, it is easy to fix: add a ",(0,r.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion")," where needed for conformance."),(0,r.kt)("p",null,"{AI05-0134-1} Correction: Now require full conformance of anonymous access-to-subprogram parameters and results for full conformance. This is necessary so that there is no confusion about the default expression that is used for a call. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage and writing different default expressions. In any case, it is easy to fix: change any default expressions that don't conform so that they do conform."),(0,r.kt)("p",null,"{AI05-0207-1} Correction: Now include the presence or absence of constant in access parameters to be considered when checking mode conformance. This is necessary to prevent modification of constants. While this is technically incompatible with Ada 2005 as defined by Amendment 1, it is a new Ada 2005 feature and it is unlikely that users have been intentionally taking advantage and writing mismatching access types. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,r.kt)("p",null,"{AI05-0142-4} Explicitly aliased parameters are included as part of mode conformance (since it affects the parameter passing mechanism). "),(0,r.kt)("h4",{id:"incompatibilities-with-ada-2012"},"Incompatibilities With Ada 2012"),(0,r.kt)("p",null,"{AI12-0207-1} Correction: The convention of an anonymous access-to-subprogram parameter of a protected entry or subprogram is Ada; if one wants it to be protected it can be declared with the keyword protected. This is incompatible, but only in a very rare case; usually the intent is to pass a normal subprogram to a protected subprogram (and this was impossible in Ada 2012). "),(0,r.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,r.kt)("p",null,"{AI12-0107-1} {AI12-0159-1} Corrigendum: We now define that a prefixed view of a subprogram with synchronization kind By_Protected_Procedure can be used as the prefix of 'Access for an access-to-protected type. We consider this a correction as it certainly appears that it ought to work, but in original Ada 2012 it would have had a convention mismatch. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,r.kt)("p",null,"{AI12-0050-1} Corrigendum: We now define how two expressions containing quantified expressions can fully conform. This isn't incompatible, as the original Ada 2012 never allowed such expressions to conform (the declarations in each formally being different). Neither is it an extension as one would expect these to conform."),(0,r.kt)("p",null,"{AI12-0342-1} The conformance of literals is tightened up to not assume anything about the value of a user-defined literal. "),(0,r.kt)("h2",{id:"632--inline-expansion-of-subprograms"},"6.3.2  Inline Expansion of Subprograms"),(0,r.kt)("p",null,"[Subprograms may be expanded in line at the call site.]"," "),(0,r.kt)("p",null,'Paragraphs 2 through 4 were moved to Annex J, "Obsolescent Features". '),(0,r.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,r.kt)("p",null,"{AI05-0229-1} For a callable entity or a generic subprogram, the following language-defined representation aspect may be specified:"),(0,r.kt)("p",null,"InlineThe type of aspect Inline is Boolean. When aspect Inline is True for a callable entity, inline expansion is desired for all calls to that entity. When aspect Inline is True for a generic subprogram, inline expansion is desired for all calls to all instances of that generic subprogram."),(0,r.kt)("p",null,"If directly specified, the ",(0,r.kt)("a",{parentName:"p",href:"./AA-13.1#S0348"},"aspect_definition")," shall be a static expression. ","[This aspect is never inherited;]"," if not directly specified, the aspect is False."),(0,r.kt)("p",null,"Aspect Description for Inline: For efficiency, Inline calls are requested for a subprogram."),(0,r.kt)("p",null,"This paragraph was deleted.{AI05-0229-1} "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"This paragraph was deleted.\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"This paragraph was deleted.\n\n")),(0,r.kt)("p",null,"Ramification: {AI05-0229-1} The meaning of a subprogram can be changed by inline expansion as requested by aspect Inline only in the presence of failing checks (see 11.6). "),(0,r.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,r.kt)("p",null,"{AI05-0229-1} For each call, an implementation is free to follow or to ignore the recommendation determined by the Inline aspect. "),(0,r.kt)("p",null,"Ramification: Note, in particular, that the recommendation cannot always be followed for a recursive call, and is often infeasible for entries. Note also that the implementation can inline calls even when no such desire was expressed via the Inline aspect, so long as the semantics of the program remains unchanged. "),(0,r.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00309-01} {AI05-0229-1} "),(0,r.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,r.kt)("p",null,"This paragraph was deleted.{AI05-0229-1} "),(0,r.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00309-01} {AI05-0229-1} "),(0,r.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,r.kt)("p",null,"{AI05-0229-1} Aspect Inline is new; ",(0,r.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Inline is now obsolescent."))}d.isMDXComponent=!0}}]);