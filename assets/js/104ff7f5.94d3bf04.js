"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8406],{8466:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var l=a(9440),n=(a(6687),a(1716)),i=a(2526);const s={sidebar_position:68},o="8.4  Use Clauses",r={unversionedId:"arm/AA-8.4",id:"arm/AA-8.4",title:"8.4  Use Clauses",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-8.4.mdx",sourceDirName:"arm",slug:"/arm/AA-8.4",permalink:"/docs/arm/AA-8.4",draft:!1,tags:[],version:"current",sidebarPosition:68,frontMatter:{sidebar_position:68},sidebar:"tutorialSidebar",previous:{title:"8.3  Visibility",permalink:"/docs/arm/AA-8.3"},next:{title:"8.5  Renaming Declarations",permalink:"/docs/arm/AA-8.5"}},u={},c=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}],d={toc:c};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,l.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"84--use-clauses"},"8.4  Use Clauses"),(0,n.kt)("admonition",{type:"warning"},(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,n.kt)("p",null,"[A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0236"},"use_package_clause"))," achieves direct visibility of declarations that appear in the visible part of a package; a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," achieves direct visibility of the primitive operators of a type.] "),(0,n.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,n.kt)("p",null,'If and only if the visibility rules allow P.A, "',(0,n.kt)("strong",null,"use"),' P;" should make A directly visible (barring name conflicts). This means, for example, that child library units, and generic formals of a formal package whose ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-12.7#S0341"},"formal_package_actual_part"))," is (","<",">","), should be made visible by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," for the appropriate package."),(0,n.kt)("p",null,"The rules for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),"s were carefully constructed to avoid so-called ",(0,n.kt)("em",null,"Beaujolais")," effects, where the addition or removal of a single ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),', or a single declaration in a "use"d package, would change the meaning of a program from one legal interpretation to another. '),(0,n.kt)("h4",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,(0,n.kt)("code",null,"use_clause"),(0,n.kt)("a",{id:"S0235"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0236"},"use_package_clause"))," | ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))),(0,n.kt)("p",null,(0,n.kt)("code",null,"use_package_clause"),(0,n.kt)("a",{id:"S0236"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("strong",null,"use")," ",(0,n.kt)("em",null,"package_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," ","{",", ",(0,n.kt)("em",null,"package_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),"}",";"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," ",(0,n.kt)("code",null,"use_type_clause"),(0,n.kt)("a",{id:"S0237"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("strong",null,"use")," [",(0,n.kt)("strong",null,"all"),"] ",(0,n.kt)("strong",null,"type")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.2#S0028"},"subtype_mark"))," ","{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.2#S0028"},"subtype_mark")),"}",";"),(0,n.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," A ",(0,n.kt)("em",null,"package_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0236"},"use_package_clause"))," shall denote a nonlimited view of a package. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This includes formal packages. "),(0,n.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,n.kt)("p",null,"For each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),", there is a certain region of text called the ",(0,n.kt)("em",null,"scope")," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),". For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0292"},"context_clause"))," of a ",(0,n.kt)("code",null,"[library_unit_declaration](./AA-10.1#S0288)")," or ",(0,n.kt)("code",null,"[library_unit_renaming_declaration](./AA-10.1#S0289)"),", the scope is the entire declarative region of the declaration. For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0292"},"context_clause"))," of a body, the scope is the entire body [and any subunits (including multiply nested subunits). The scope does not include ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0292"},"context_clause")),"s themselves.]"),(0,n.kt)("p",null,"For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," immediately within a declarative region, the scope is the portion of the declarative region starting just after the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," and extending to the end of the declarative region. However, the scope of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," in the private part of a library unit does not include the visible part of any public descendant of that library unit. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),'The exception echoes the similar exception for "immediate scope (of a declaration)" (see 8.2). It makes ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),"s work like this: "),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"package P is","\n","    type T is range 1..10;","\n","end P;","\n"),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"with P;","\n","package Parent is","\n","private","\n","    use P;","\n","    X : T;","\n","end Parent;","\n"),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"package Parent.Child is","\n","    Y : T; -- Illegal!","\n","    Z : P.T;","\n","private","\n","    W : T;","\n","end Parent.Child;","\n"),(0,n.kt)("p",null,'The declaration of Y is illegal because the scope of the "',(0,n.kt)("strong",null,"use"),' P" does not include that place, so T is not directly visible there. The declarations of X, Z, and W are legal. '),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," A package is ",(0,n.kt)("em",null,"named")," in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0236"},"use_package_clause"))," if it is denoted by a ",(0,n.kt)("em",null,"package_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," of that clause. A type is ",(0,n.kt)("em",null,"named")," in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," if it is determined by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.2#S0028"},"subtype_mark"))," of that clause."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," ","{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," For each package named in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0236"},"use_package_clause"))," whose scope encloses a place, each declaration that occurs immediately within the declarative region of the package is ",(0,n.kt)("em",null,"potentially use-visible")," at this place if the declaration is visible at this place. For each type ",(0,n.kt)("em",null,"T")," or ",(0,n.kt)("em",null,"T"),"'Class named in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," whose scope encloses a place, the declaration of each primitive operator of type ",(0,n.kt)("em",null,"T")," is potentially use-visible at this place if its declaration is visible at this place. If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," whose scope encloses a place includes the reserved word ",(0,n.kt)("strong",null,"all"),", then the following entities are also potentially use-visible at this place if the declaration of the entity is visible at this place: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," Each primitive subprogram of ",(0,n.kt)("em",null,"T")," including each enumeration literal (if any);"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," Each subprogram that is declared immediately within the declarative region in which an ancestor type of ",(0,n.kt)("em",null,"T")," is declared and that operates on a class-wide type that covers ",(0,n.kt)("em",null,"T"),". "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," Primitive subprograms whose defining name is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier"))," are ",(0,n.kt)("em",null,"not")," made potentially visible by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," unless reserved word ",(0,n.kt)("strong",null,"all")," is included. A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," without ",(0,n.kt)("strong",null,"all")," is only for operators."),(0,n.kt)("p",null,'The semantics described here should be similar to the semantics for expanded names given in 4.1.3, "Selected Components" so as to achieve the effect requested by the "principle of equivalence of ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause")),"s and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0098"},"selected_component")),"s\". Thus, child library units and generic formal parameters of a formal package are potentially use-visible when their enclosing package is use'd."),(0,n.kt)("p",null,'The "visible at that place" part implies that applying a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," to a parent unit does not make all of its children use-visible - only those that have been made visible by a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0294"},"with_clause")),'. It also implies that we don\'t have to worry about hiding in the definition of "directly visible" - a declaration cannot be use-visible unless it is visible.'),(0,n.kt)("p",null,'Note that "',(0,n.kt)("strong",null,"use type"),' T\'Class;" is equivalent to "',(0,n.kt)("strong",null,"use type"),' T;", which helps avoid breaking the generic contract model. '),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0131-1"),"}"," Certain implicit declarations may become potentially use-visible in certain contexts as described in 12.6."),(0,n.kt)("p",null,"A declaration is ",(0,n.kt)("em",null,"use-visible")," if it is potentially use-visible, except in these naming-conflict cases: "),(0,n.kt)("p",null,"A potentially use-visible declaration is not use-visible if the place considered is within the immediate scope of a homograph of the declaration."),(0,n.kt)("p",null,"Potentially use-visible declarations that have the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier"))," are not use-visible unless each of them is an overloadable declaration. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Overloadable declarations don't cancel each other out, even if they are homographs, though if they are not distinguishable by formal parameter names or the presence or absence of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.7#S0063"},"default_expression")),"s, any use will be ambiguous. We only mention ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier")),"s here, because declarations named by ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.1#S0202"},"operator_symbol")),"s are always overloadable, and hence never cancel each other. Direct visibility is irrelevant for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.5#S0015"},"character_literal")),"s. "),(0,n.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,n.kt)("p",null,"The elaboration of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," has no effect. "),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a use clause in a context clause:")," "),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"with Ada.Calendar; use Ada;","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Example of a use type clause:")," "),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"use type Rational_Numbers.Rational; -- see 7.1","\n","Two_Thirds: Rational_Numbers.Rational := 2/3;","\n"),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'In "',(0,n.kt)("strong",null,"use"),' X, Y;", Y cannot refer to something made visible by the "',(0,n.kt)("strong",null,"use"),'" of X. Thus, it\'s not (quite) equivalent to "',(0,n.kt)("strong",null,"use")," X; ",(0,n.kt)("strong",null,"use"),' Y;".'),(0,n.kt)("p",null,"If a given declaration is already immediately visible, then a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0235"},"use_clause"))," that makes it potentially use-visible has no effect. Therefore, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," for a type whose declaration appears in a place other than the visible part of a package has no effect; it cannot make a declaration use-visible unless that declaration is already immediately visible."),(0,n.kt)("p",null,'"',(0,n.kt)("strong",null,"Use")," ",(0,n.kt)("strong",null,"type"),' S1;" and "',(0,n.kt)("strong",null,"use")," ",(0,n.kt)("strong",null,"type"),' S2;" are equivalent if S1 and S2 are both subtypes of the same type. In particular, "',(0,n.kt)("strong",null,"use")," ",(0,n.kt)("strong",null,"type"),' S;" and "',(0,n.kt)("strong",null,"use")," ",(0,n.kt)("strong",null,"type")," S'Base;\" are equivalent. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"We considered adding a rule that prevented several declarations of views of the same entity that all have the same semantics from cancelling each other out. For example, if a (possibly implicit) ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.1#S0195"},"subprogram_declaration")),' for "+" is potentially use-visible, and a fully conformant renaming of it is also potentially use-visible, then they (annoyingly) cancel each other out; neither one is use-visible. The considered rule would have made just one of them use-visible. We gave up on this idea due to the complexity of the rule. It would have had to account for both overloadable and nonoverloadable ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.5#S0238"},"renaming_declaration")),"s, the case where the rule should apply only to some subset of the declarations with the same defining name, and the case of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.2#S0026"},"subtype_declaration")),"s (since they are claimed to be sufficient for renaming of subtypes). "),(0,n.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," is new to Ada 95. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The phrase "omitting from this set any packages that enclose this place" is no longer necessary to avoid making something visible outside its scope, because we explicitly state that the declaration has to be visible in order to be potentially use-visible. '),(0,n.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," Limited views of packages are not allowed in use clauses. Defined ",(0,n.kt)("em",null,"named in a use clause")," for use in other limited view rules (see 10.1.2). "),(0,n.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0150-1"),"}"," The ",(0,n.kt)("strong",null,"use all type")," version of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-8.4#S0237"},"use_type_clause"))," is new to Ada 2012. It works similarly to prefixed views. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0131-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Added wording to allow other declarations to be potentially use-visible, to support corrections to formal subprograms. "))}h.isMDXComponent=!0}}]);