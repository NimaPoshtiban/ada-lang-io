"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7301],{1716:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var i=a(6687);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),c=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(a),u=n,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||o;return a?i.createElement(m,r(r({ref:t},d),{},{components:a})):i.createElement(m,r({ref:t},d))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1322:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=a(9440),n=(a(6687),a(1716));const o={sidebar_position:9},r="8 Visibility Rules",l={unversionedId:"arm/AA-8",id:"arm/AA-8",title:"8 Visibility Rules",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-8.md",sourceDirName:"arm",slug:"/arm/AA-8",permalink:"/docs/arm/AA-8",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"7 Packages",permalink:"/docs/arm/AA-7"},next:{title:"9 Tasks and Synchronization",permalink:"/docs/arm/AA-9"}},s={},c=[{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"8.1  Declarative Region",id:"81--declarative-region",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"8.2  Scope of Declarations",id:"82--scope-of-declarations",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"8.3  Visibility",id:"83--visibility",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"8.4  Use Clauses",id:"84--use-clauses",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"8.5  Renaming Declarations",id:"85--renaming-declarations",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"8.5.1  Object Renaming Declarations",id:"851--object-renaming-declarations",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4},{value:"8.5.2  Exception Renaming Declarations",id:"852--exception-renaming-declarations",level:3},{value:"Syntax",id:"syntax-3",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Examples",id:"examples-2",level:4},{value:"8.5.3  Package Renaming Declarations",id:"853--package-renaming-declarations",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Examples",id:"examples-3",level:4},{value:"8.5.4  Subprogram Renaming Declarations",id:"854--subprogram-renaming-declarations",level:3},{value:"Syntax",id:"syntax-5",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-4",level:4},{value:"8.5.5  Generic Renaming Declarations",id:"855--generic-renaming-declarations",level:3},{value:"Syntax",id:"syntax-6",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-7",level:4},{value:"8.6  The Context of Overload Resolution",id:"86--the-context-of-overload-resolution",level:2},{value:"Language Design Principles",id:"language-design-principles-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-8",level:4}],d={toc:c};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"8-visibility-rules"},"8 Visibility Rules"),(0,n.kt)("admonition",{type:"warning"},(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,n.kt)("p",null,"[The rules defining the scope of declarations and the rules defining which identifiers, character_literals, and operator_symbols are visible at (or from) various places in the text of the program are described in this section. The formulation of these rules uses the notion of a declarative region."),(0,n.kt)("p",null,"As explained in Section 3, a declaration declares a view of an entity and associates a defining name with that view. The view comprises an identification of the viewed entity, and possibly additional properties. A usage name denotes a declaration. It also denotes the view declared by that declaration, and denotes the entity of that view. Thus, two different usage names might denote two different views of the same entity; in this case they denote the same entity.] "),(0,n.kt)("p",null,"To be honest: In some cases, a usage name that denotes a declaration does not denote the view declared by that declaration, nor the entity of that view, but instead denotes a view of the current instance of the entity, and denotes the current instance of the entity. This sometimes happens when the usage name occurs inside the declarative region of the declaration. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'We no longer define the term "basic operation;" thus we no longer have to worry about the visibility of them. Since they were essentially always visible in Ada 83, this change has no effect. The reason for this change is that the definition in Ada 83 was confusing, and not quite correct, and we found it difficult to fix. For example, one wonders why an if_statement was not a basic operation of type Boolean. For another example, one wonders what it meant for a basic operation to be "inherent in" something. Finally, this fixes the problem addressed by AI83-00027/07. '),(0,n.kt)("h2",{id:"81--declarative-region"},"8.1  Declarative Region"),(0,n.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,n.kt)("p",null,"For each of the following constructs, there is a portion of the program text called its declarative region, ","[within which nested declarations can occur]",": "),(0,n.kt)("p",null,"any declaration, other than that of an enumeration type, that is not a completion ","[of a previous declaration]",";"),(0,n.kt)("p",null,"a block_statement;"),(0,n.kt)("p",null,"a loop_statement;"),(0,n.kt)("p",null,"an accept_statement;"),(0,n.kt)("p",null,"an exception_handler. "),(0,n.kt)("p",null,"The declarative region includes the text of the construct together with additional text determined ","[(recursively)]",", as follows: "),(0,n.kt)("p",null,"If a declaration is included, so is its completion, if any."),(0,n.kt)("p",null,"If the declaration of a library unit ","[(including Standard - see 10.1.1)]"," is included, so are the declarations of any child units ","[(and their completions, by the previous rule)]",". The child declarations occur after the declaration."),(0,n.kt)("p",null,"If a body_stub is included, so is the corresponding subunit."),(0,n.kt)("p",null,"If a type_declaration is included, then so is a corresponding record_representation_clause, if any. "),(0,n.kt)("p",null,"Reason: This is so that the component_declarations can be directly visible in the record_representation_clause. "),(0,n.kt)("p",null,"The declarative region of a declaration is also called the declarative region of any view or entity declared by the declaration. "),(0,n.kt)("p",null,"Reason: The constructs that have declarative regions are the constructs that can have declarations nested inside them. Nested declarations are declared in that declarative region. The one exception is for enumeration literals; although they are nested inside an enumeration type declaration, they behave as if they were declared at the same level as the type. "),(0,n.kt)("p",null,"To be honest: A declarative region does not include parent_unit_names. "),(0,n.kt)("p",null,"Ramification: A declarative region does not include context_clauses. "),(0,n.kt)("p",null,"A declaration occurs immediately within a declarative region if this region is the innermost declarative region that encloses the declaration (the immediately enclosing declarative region), not counting the declarative region (if any) associated with the declaration itself. "),(0,n.kt)("p",null,"Discussion: Don't confuse the declarative region of a declaration with the declarative region in which it immediately occurs. "),(0,n.kt)("p",null,"[ A declaration is local to a declarative region if the declaration occurs immediately within the declarative region.][An entity is local to a declarative region if the entity is declared by a declaration that is local to the declarative region.]"," "),(0,n.kt)("p",null,'Ramification: "Occurs immediately within" and "local to" are synonyms (when referring to declarations).'),(0,n.kt)("p",null,'Thus, "local to" applies to both declarations and entities, whereas "occurs immediately within" only applies to declarations. We use this term only informally; for cases where precision is required, we use the term "occurs immediately within", since it is less likely to cause confusion. '),(0,n.kt)("p",null,"A declaration is global to a declarative region if the declaration occurs immediately within another declarative region that encloses the declarative region. An entity is global to a declarative region if the entity is declared by a declaration that is global to the declarative region. "),(0,n.kt)("p",null,'NOTE 1   The children of a parent library unit are inside the parent\'s declarative region, even though they do not occur inside the parent\'s declaration or body. This implies that one can use (for example) "P.Q" to refer to a child of P whose defining name is Q, and that after "use P;" Q can refer (directly) to that child.'),(0,n.kt)("p",null,'NOTE 2   As explained above and in 10.1.1, "Compilation Units - Library Units", all library units are descendants of Standard, and so are contained in the declarative region of Standard. They are not inside the declaration or body of Standard, but they are inside its declarative region.'),(0,n.kt)("p",null,"NOTE 3   For a declarative region that comes in multiple parts, the text of the declarative region does not contain any text that might appear between the parts. Thus, when a portion of a declarative region is said to extend from one place to another in the declarative region, the portion does not contain any text that might appear between the parts of the declarative region. "),(0,n.kt)("p",null,"Discussion: It is necessary for the things that have a declarative region to include anything that contains declarations (except for enumeration type declarations). This includes any declaration that has a profile (that is, subprogram_declaration, subprogram_body, entry_declaration, subprogram_renaming_declaration, formal_subprogram_declaration, access-to-subprogram type_declaration), anything that has a discriminant_part (that is, various kinds of type_declaration), anything that has a component_list (that is, record type_declaration and record extension type_declaration), and finally the declarations of task and protected units and packages. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"It was necessary to extend Ada 83's definition of declarative region to take the following Ada 95 features into account: "),(0,n.kt)("p",null,"Child library units."),(0,n.kt)("p",null,"Derived types/type extensions - we need a declarative region for inherited components and also for new components."),(0,n.kt)("p",null,"All the kinds of types that allow discriminants."),(0,n.kt)("p",null,"Protected units."),(0,n.kt)("p",null,"Entries that have bodies instead of accept statements."),(0,n.kt)("p",null,"The choice_parameter_specification of an exception_handler."),(0,n.kt)("p",null,"The formal parameters of access-to-subprogram types."),(0,n.kt)("p",null,"Renamings-as-body. "),(0,n.kt)("p",null,"Discriminated and access-to-subprogram type declarations need a declarative region. Enumeration type declarations cannot have one, because you don't have to say \"Color.Red\" to refer to the literal Red of Color. For other type declarations, it doesn't really matter whether or not there is an associated declarative region, so for simplicity, we give one to all types except enumeration types."),(0,n.kt)("p",null,'We now say that an accept_statement has its own declarative region, rather than being part of the declarative region of the entry_declaration, so that declarative regions are properly nested regions of text, so that it makes sense to talk about "inner declarative regions", and "...extends to the end of a declarative region". Inside an accept_statement, the name of one of the parameters denotes the parameter_specification of the accept_statement, not that of the entry_declaration. If the accept_statement is nested within a block_statement, these parameter_specifications can hide declarations of the block_statement. The semantics of such cases was unclear in RM83. '),(0,n.kt)("p",null,"To be honest: Unfortunately, we have the same problem for the entry name itself - it should denote the accept_statement, but accept_statements are not declarations. They should be, and they should hide the entry from all visibility within themselves. "),(0,n.kt)("p",null,"Note that we can't generalize this to entry_bodies, or other bodies, because the declarative_part of a body is not supposed to contain (explicit) homographs of things in the declaration. It works for accept_statements only because an accept_statement does not have a declarative_part."),(0,n.kt)("p",null,'To avoid confusion, we use the term "local to" only informally in Ada 95. Even RM83 used the term incorrectly (see, for example, RM83-12.3(13)).'),(0,n.kt)("p",null,"In Ada 83, (root) library units were inside Standard; it was not clear whether the declaration or body of Standard was meant. In Ada 95, they are children of Standard, and so occur immediately within Standard's declarative region, but not within either the declaration or the body. (See RM83-8.6(2) and RM83-10.1.1(5).) "),(0,n.kt)("h2",{id:"82--scope-of-declarations"},"8.2  Scope of Declarations"),(0,n.kt)("p",null,"[For each declaration, the language rules define a certain portion of the program text called the scope of the declaration. The scope of a declaration is also called the scope of any view or entity declared by the declaration. Within the scope of an entity, and only there, there are places where it is legal to refer to the declared entity. These places are defined by the rules of visibility and overloading.]"," "),(0,n.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,n.kt)("p",null,"The immediate scope of a declaration is a portion of the declarative region immediately enclosing the declaration. The immediate scope starts at the beginning of the declaration, except in the case of an overloadable declaration, in which case the immediate scope starts just after the place where the profile of the callable entity is determined (which is at the end of the _specification for the callable entity, or at the end of the generic_instantiation if an instance). The immediate scope extends to the end of the declarative region, with the following exceptions: "),(0,n.kt)("p",null,"Reason: The reason for making overloadable declarations with profiles special is to simplify compilation: until the compiler has determined the profile, it doesn't know which other declarations are homographs of this one, so it doesn't know which ones this one should hide. Without this rule, two passes over the _specification or generic_instantiation would be required to resolve names that denote things with the same name as this one. "),(0,n.kt)("p",null,"The immediate scope of a library_item includes only its semantic dependents. "),(0,n.kt)("p",null,"Reason: Section 10 defines only a partial ordering of library_items. Therefore, it is a good idea to restrict the immediate scope (and the scope, defined below) to semantic dependents."),(0,n.kt)("p",null,"Consider also examples like this: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package P is end P;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package P.Q is\n    I : Integer := 0;\nend P.Q;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with P;\npackage R is\n    package X renames P;\n    X.Q.I := 17; -- Illegal!\nend R;\n\n")),(0,n.kt)("p",null,"The scope of P.Q does not contain R. Hence, neither P.Q nor X.Q are visible within R. However, the name R.X.Q would be visible in some other library unit where both R and P.Q are visible (assuming R were made legal by removing the offending declaration). "),(0,n.kt)("p",null,"The immediate scope of a declaration in the private part of a library unit does not include the visible part of any public descendant of that library unit. "),(0,n.kt)("p",null,"Ramification: In other words, a declaration in the private part can be visible within the visible part, private part and body of a private child unit. On the other hand, such a declaration can be visible within only the private part and body of a public child unit. "),(0,n.kt)("p",null,"Reason: The purpose of this rule is to prevent children from giving private information to clients. "),(0,n.kt)("p",null,"Ramification: For a public child subprogram, this means that the parent's private part is not visible in the formal_parts of the declaration and of the body. This is true even for subprogram_bodies that are not completions. For a public child generic unit, it means that the parent's private part is not visible in the generic_formal_part, as well as in the first list of basic_declarative_items (for a generic package), or the formal_part(s) (for a generic subprogram). "),(0,n.kt)("p",null,"[The visible part of (a view of) an entity is a portion of the text of its declaration containing declarations that are visible from outside.]"," The private part of (a view of) an entity that has a visible part contains all declarations within the declaration of (the view of) the entity, except those in the visible part; ","[these are not visible from outside. Visible and private parts are defined only for these kinds of entities: callable entities, other program units, and composite types.]"," "),(0,n.kt)("p",null,"The visible part of a view of a callable entity is its profile."),(0,n.kt)("p",null,"The visible part of a composite type other than a task or protected type consists of the declarations of all components declared ","[(explicitly or implicitly)]"," within the type_declaration."),(0,n.kt)("p",null,"The visible part of a generic unit includes the generic_formal_part. For a generic package, it also includes the first list of basic_declarative_items of the package_specification. For a generic subprogram, it also includes the profile. "),(0,n.kt)("p",null,"Reason: Although there is no way to reference anything but the formals from outside a generic unit, they are still in the visible part in the sense that the corresponding declarations in an instance can be referenced (at least in some cases). In other words, these declarations have an effect on the outside world. The visible part of a generic unit needs to be defined this way in order to properly support the rule that makes a parent's private part invisible within a public child's visible part. "),(0,n.kt)("p",null,"Ramification: The visible part of an instance of a generic unit is as defined for packages and subprograms; it is not defined in terms of the visible part of a generic unit. "),(0,n.kt)("p",null,"[The visible part of a package, task unit, or protected unit consists of declarations in the program unit's declaration other than those following the reserved word private, if any; see 7.1 and 12.7 for packages, 9.1 for task units, and 9.4 for protected units.]"," "),(0,n.kt)("p",null,"The scope of a declaration always contains the immediate scope of the declaration. In addition, for a given declaration that occurs immediately within the visible part of an outer declaration, or is a public child of an outer declaration, the scope of the given declaration extends to the end of the scope of the outer declaration, except that the scope of a library_item includes only its semantic dependents. "),(0,n.kt)("p",null,"Ramification: Note the recursion. If a declaration appears in the visible part of a library unit, its scope extends to the end of the scope of the library unit, but since that only includes dependents of the declaration of the library unit, the scope of the inner declaration also only includes those dependents. If X renames library package P, which has a child Q, a with_clause mentioning P.Q is necessary to be able to refer to X.Q, even if P.Q is visible at the place where X is declared. "),(0,n.kt)("p",null,"The immediate scope of a declaration is also the immediate scope of the entity or view declared by the declaration. Similarly, the scope of a declaration is also the scope of the entity or view declared by the declaration. "),(0,n.kt)("p",null,"Ramification: The rule for immediate scope implies the following: "),(0,n.kt)("p",null,"If the declaration is that of a library unit, then the immediate scope includes the declarative region of the declaration itself, but not other places, unless they are within the scope of a with_clause that mentions the library unit."),(0,n.kt)("p",null,"It is necessary to attach the semantics of with_clauses to ","[immediate]",' scopes (as opposed to visibility), in order for various rules to work properly. A library unit should hide a homographic implicit declaration that appears in its parent, but only within the scope of a with_clause that mentions the library unit. Otherwise, we would violate the "legality determinable via semantic dependences" rule of 10, "Program Structure and Compilation Issues". The declaration of a library unit should be allowed to be a homograph of an explicit declaration in its parent\'s body, so long as that body does not mention the library unit in a with_clause.'),(0,n.kt)("p",null,"This means that one cannot denote the declaration of the library unit, but one might still be able to denote the library unit via another view."),(0,n.kt)("p",null,"A with_clause does not make the declaration of a library unit visible; the lack of a with_clause prevents it from being visible. Even if a library unit is mentioned in a with_clause, its declaration can still be hidden."),(0,n.kt)("p",null,"The completion of the declaration of a library unit (assuming that's also a declaration) is not visible, neither directly nor by selection, outside that completion."),(0,n.kt)("p",null,"The immediate scope of a declaration immediately within the body of a library unit does not include any child of that library unit."),(0,n.kt)("p",null,"This is needed to prevent children from looking inside their parent's body. The children are in the declarative region of the parent, and they might be after the parent's body. Therefore, the scope of a declaration that occurs immediately within the body might include some children. "),(0,n.kt)("p",null,"NOTE   There are notations for denoting visible declarations that are not directly visible. For example, parameter_specifications are in the visible part of a subprogram_declaration so that they can be used in named-notation calls appearing outside the called subprogram. For another example, declarations of the visible part of a package can be denoted by expanded names appearing outside the package, and can be made directly visible by a use_clause. "),(0,n.kt)("p",null,"Ramification: There are some obscure involving generics cases in which there is no such notation. See Section 12. "),(0,n.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The fact that the immediate scope of an overloadable declaration does not include its profile is new to Ada 95. It replaces RM83-8.3(16), which said that within a subprogram specification and within the formal part of an entry declaration or accept statement, all declarations with the same designator as the subprogram or entry were hidden from all visibility. The RM83-8.3(16) rule seemed to be overkill, and created both implementation difficulties and unnecessary semantic complexity. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"We no longer need to talk about the scope of notations, identifiers, character_literals, and operator_symbols."),(0,n.kt)("p",null,'The notion of "visible part" has been extended in Ada 95. The syntax of task and protected units now allows private parts, thus requiring us to be able to talk about the visible part as well. It was necessary to extend the concept to subprograms and to generic units, in order for the visibility rules related to child library units to work properly. It was necessary to define the concept separately for generic formal packages, since their visible part is slightly different from that of a normal package. Extending the concept to composite types made the definition of scope slightly simpler. We define visible part for some things elsewhere, since it makes a big difference to the user for those things. For composite types and subprograms, however, the concept is used only in arcane visibility rules, so we localize it to this clause.'),(0,n.kt)("p",null,"In Ada 83, the semantics of with_clauses was described in terms of visibility. It is now described in terms of ","[immediate]"," scope."),(0,n.kt)("p",null,"We have clarified that the following is illegal (where Q and R are library units): "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package Q is\n    I : Integer := 0;\nend Q;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package R is\n    package X renames Standard;\n    X.Q.I := 17; -- Illegal!\nend R;\n\n")),(0,n.kt)("p",null,"even though Q is declared in the declarative region of Standard, because R does not mention Q in a with_clause. "),(0,n.kt)("h2",{id:"83--visibility"},"8.3  Visibility"),(0,n.kt)("p",null,"[ The visibility rules, given below, determine which declarations are visible and directly visible at each place within a program. The visibility rules apply to both explicit and implicit declarations.]"," "),(0,n.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,n.kt)("p",null,"A declaration is defined to be directly visible at places where a name consisting of only an identifier or operator_symbol is sufficient to denote the declaration; that is, no selected_component notation or special context (such as preceding =",">"," in a named association) is necessary to denote the declaration. A declaration is defined to be visible wherever it is directly visible, as well as at other places where some name (such as a selected_component) can denote the declaration."),(0,n.kt)("p",null,"The syntactic category direct_name is used to indicate contexts where direct visibility is required. The syntactic category selector_name is used to indicate contexts where visibility, but not direct visibility, is required."),(0,n.kt)("p",null,"There are two kinds of direct visibility: immediate visibility and use-visibility. A declaration is immediately visible at a place if it is directly visible because the place is within its immediate scope. A declaration is use-visible if it is directly visible because of a use_clause (see 8.4). Both conditions can apply."),(0,n.kt)("p",null,"A declaration can be hidden, either from direct visibility, or from all visibility, within certain parts of its scope. Where hidden from all visibility, it is not visible at all (neither using a direct_name nor a selector_name). Where hidden from direct visibility, only direct visibility is lost; visibility using a selector_name is still possible."),(0,n.kt)("p",null,"[ Two or more declarations are overloaded if they all have the same defining name and there is a place where they are all directly visible.]"," "),(0,n.kt)("p",null,"Ramification: Note that a name can have more than one possible interpretation even if it denotes a nonoverloadable entity. For example, if there are two functions F that return records, both containing a component called C, then the name F.C has two possible interpretations, even though component declarations are not overloadable. "),(0,n.kt)("p",null,"The declarations of callable entities ","[(including enumeration literals)]"," are overloadable","[, meaning that overloading is allowed for them]",". "),(0,n.kt)("p",null,"Ramification: A generic_declaration is not overloadable within its own generic_formal_part. This follows from the rules about when a name denotes a current instance. See AI83-00286. This implies that within a generic_formal_part, outer declarations with the same defining name are hidden from direct visibility. It also implies that if a generic formal parameter has the same defining name as the generic itself, the formal parameter hides the generic from direct visibility. "),(0,n.kt)("p",null,"Two declarations are homographs if they have the same defining name, and, if both are overloadable, their profiles are type conformant. ","[An inner declaration hides any outer homograph from direct visibility.]"),(0,n.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[S]",",Term=","[overriding operation]",", Def=","[an operation that replaces an inherited primitive operation]",", Note1=","[Operations can be marked explicitly as overriding or not overriding.]"),(0,n.kt)("p",null,"[Two homographs are not generally allowed immediately within the same declarative region unless one overrides the other (see Legality Rules below).]"," A declaration overrides another homograph that occurs immediately within the same declarative region in the following cases: "),(0,n.kt)("p",null,"An explicit declaration overrides an implicit declaration of a primitive subprogram, ","[regardless of which declaration occurs first]","; "),(0,n.kt)("p",null,"Ramification: And regardless of whether the explicit declaration is overloadable or not. "),(0,n.kt)("p",null,'The "regardless of which declaration occurs first" is there because the explicit declaration could be a primitive subprogram of a partial view, and then the full view might inherit a homograph. We are saying that the explicit one wins (within its scope), even though the implicit one comes later.'),(0,n.kt)("p",null,"If the overriding declaration is also a subprogram, then it is a primitive subprogram."),(0,n.kt)("p",null,'As explained in 7.3.1, "Private Operations", some inherited primitive subprograms are never declared. Such subprograms cannot be overridden, although they can be reached by dispatching calls in the case of a tagged type. '),(0,n.kt)("p",null,"The implicit declaration of an inherited operator overrides that of a predefined operator; "),(0,n.kt)("p",null,'Ramification: In a previous version of Ada 9X, we tried to avoid the notion of predefined operators, and say that they were inherited from some magical root type. However, this seemed like too much mechanism. Therefore, a type can have a predefined "+" as well as an inherited "+". The above rule says the inherited one wins.'),(0,n.kt)("p",null,'The "regardless of which declaration occurs first" applies here as well, in the case where derived_type_declaration in the visible part of a public library unit derives from a private type declared in the parent unit, and the full view of the parent type has additional predefined operators, as explained in 7.3.1, "Private Operations". Those predefined operators can be overridden by inherited subprograms implicitly declared earlier. '),(0,n.kt)("p",null,"An implicit declaration of an inherited subprogram overrides a previous implicit declaration of an inherited subprogram."),(0,n.kt)("p",null,"[For an implicit declaration of a primitive subprogram in a generic unit, there is a copy of this declaration in an instance.]"," However, a whole new set of primitive subprograms is implicitly declared for each type declared within the visible part of the instance. These new declarations occur immediately after the type declaration, and override the copied ones. ","[The copied ones can be called only from within the instance; the new ones can be called only from outside the instance, although for tagged types, the body of a new one can be executed by a call to an old one.]"," "),(0,n.kt)("p",null,'Discussion: In addition, this is also stated redundantly (again), and is repeated, in 12.3, "Generic Instantiation". The rationale for the rule is explained there. '),(0,n.kt)("p",null,"A declaration is visible within its scope, except where hidden from all visibility, as follows: "),(0,n.kt)("p",null,"An overridden declaration is hidden from all visibility within the scope of the overriding declaration. "),(0,n.kt)("p",null,"Ramification: We have to talk about the scope of the overriding declaration, not its visibility, because it hides even when it is itself hidden."),(0,n.kt)("p",null,"Note that the scope of an explicit subprogram_declaration does not start until after its profile. "),(0,n.kt)("p",null,"A declaration is hidden from all visibility until the end of the declaration, except: "),(0,n.kt)("p",null,"For a record type or record extension, the declaration is hidden from all visibility only until the reserved word record;"),(0,n.kt)("p",null,"For a package_declaration, task declaration, protected declaration, generic_package_declaration, or subprogram_body, the declaration is hidden from all visibility only until the reserved word is of the declaration. "),(0,n.kt)("p",null,"Ramification: We're talking about the is of the construct itself, here, not some random is that might appear in a generic_formal_part. "),(0,n.kt)("p",null,"If the completion of a declaration is a declaration, then within the scope of the completion, the first declaration is hidden from all visibility. Similarly, a discriminant_specification or parameter_specification is hidden within the scope of a corresponding discriminant_specification or parameter_specification of a corresponding completion, or of a corresponding accept_statement. "),(0,n.kt)("p",null,"Ramification: This rule means, for example, that within the scope of a full_type_declaration that completes a private_type_declaration, the name of the type will denote the full_type_declaration, and therefore the full view of the type. On the other hand, if the completion is not a declaration, then it doesn't hide anything, and you can't denote it. "),(0,n.kt)("p",null,"The declaration of a library unit (including a library_unit_renaming_declaration) is hidden from all visibility except at places that are within its declarative region or within the scope of a with_clause that mentions it.","[For each declaration or renaming of a generic unit as a child of some parent generic package, there is a corresponding declaration nested immediately within each instance of the parent.]"," Such a nested declaration is hidden from all visibility except at places that are within the scope of a with_clause that mentions the child."),(0,n.kt)("p",null,"Discussion: This is the rule that prevents with_clauses from being transitive; the ","[immediate]"," scope includes indirect semantic dependents. "),(0,n.kt)("p",null,"A declaration with a defining_identifier or defining_operator_symbol is immediately visible ","[(and hence directly visible)]"," within its immediate scope  except where hidden from direct visibility, as follows: "),(0,n.kt)("p",null,"A declaration is hidden from direct visibility within the immediate scope of a homograph of the declaration, if the homograph occurs within an inner declarative region;"),(0,n.kt)("p",null,"A declaration is also hidden from direct visibility where hidden from all visibility. "),(0,n.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,n.kt)("p",null,"A direct_name shall resolve to denote a directly visible declaration whose defining name is the same as the direct_name. A selector_name shall resolve to denote a visible declaration whose defining name is the same as the selector_name. "),(0,n.kt)("p",null,'Discussion: "The same as" has the obvious meaning here, so for +, the possible interpretations are declarations whose defining name is "+" (an operator_symbol). '),(0,n.kt)("p",null,'These rules on visibility and direct visibility do not apply in a context_clause, a parent_unit_name, or a pragma that appears at the place of a compilation_unit. For those contexts, see the rules in 10.1.6, "Environment-Level Visibility Rules". '),(0,n.kt)("p",null,"Ramification: Direct visibility is irrelevant for character_literals. In terms of overload resolution character_literals are similar to other literals, like null - see 4.2. For character_literals, there is no need to worry about hiding, since there is no way to declare homographs. "),(0,n.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,n.kt)("p",null,"An explicit declaration is illegal if there is a homograph occurring immediately within the same declarative region that is visible at the place of the declaration, and is not hidden from all visibility by the explicit declaration. Similarly, the context_clause for a subunit is illegal if it mentions (in a with_clause) some library unit, and there is a homograph of the library unit that is visible at the place of the corresponding stub, and the homograph and the mentioned library unit are both declared immediately within the same declarative region. These rules also apply to dispatching operations declared in the visible part of an instance of a generic unit. However, they do not apply to other overloadable declarations in an instance","[; such declarations may have type conformant profiles in the instance, so long as the corresponding declarations in the generic were not type conformant]",". "),(0,n.kt)("p",null,"Discussion: Normally, these rules just mean you can't explicitly declare two homographs immediately within the same declarative region. The wording is designed to handle the following special cases: "),(0,n.kt)("p",null,"If the second declaration completes the first one, the second declaration is legal."),(0,n.kt)("p",null,"If the body of a library unit contains an explicit homograph of a child of that same library unit, this is illegal only if the body mentions the child in its context_clause, or if some subunit mentions the child. Here's an example: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\nend P;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package P.Q is\nend P.Q;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package body P is\n    Q : Integer; -- OK; we cannot see package P.Q here.\n    procedure Sub is separate;\nend P;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with P.Q;\nseparate(P)\nprocedure Sub is -- Illegal.\nbegin\n    null;\nend Sub;\n\n")),(0,n.kt)("p",null,'If package body P said "with P.Q;", then it would be illegal to declare the homograph Q: Integer. But it does not, so the body of P is OK. However, the subunit would be able to see both P.Q\'s, and is therefore illegal.'),(0,n.kt)("p",null,"A previous version of Ada 9X allowed the subunit, and said that references to P.Q would tend to be ambiguous. However, that was a bad idea, because it requires overload resolution to resolve references to directly visible nonoverloadable homographs, which is something compilers have never before been required to do."),(0,n.kt)("p",null,'Note that we need to be careful which things we make "hidden from all visibility" versus which things we make simply illegal for names to denote. The distinction is subtle. The rules that disallow names denoting components within a type declaration (see 3.7) do not make the components invisible at those places, so that the above rule makes components with the same name illegal. The same is true for the rule that disallows names denoting formal parameters within a formal_part (see 6.1). '),(0,n.kt)("p",null,'Discussion: The part about instances is from AI83-00012. The reason it says "overloadable declarations" is because we don\'t want it to apply to type extensions that appear in an instance; components are not overloadable. '),(0,n.kt)("p",null,"NOTE 1   Visibility for compilation units follows from the definition of the environment in 10.1.4, except that it is necessary to apply a with_clause to obtain visibility to a library_unit_declaration or library_unit_renaming_declaration."),(0,n.kt)("p",null,"NOTE 2   In addition to the visibility rules given above, the meaning of the occurrence of a direct_name or selector_name at a given place in the text can depend on the overloading rules (see 8.6)."),(0,n.kt)("p",null,"NOTE 3   Not all contexts where an identifier, character_literal, or operator_symbol are allowed require visibility of a corresponding declaration. Contexts where visibility is not required are identified by using one of these three syntactic categories directly in a syntax rule, rather than using direct_name or selector_name. "),(0,n.kt)("p",null,"Ramification: An identifier, character_literal or operator_symbol that occurs in one of the following contexts is not required to denote a visible or directly visible declaration: "),(0,n.kt)("p",null,"a)A defining name."),(0,n.kt)("p",null,'b)The identifiers or operator_symbol that appear after the reserved word end in a proper_body. Similarly for "end loop", etc.'),(0,n.kt)("p",null,"c)An attribute_designator."),(0,n.kt)("p",null,"d)A pragma identifier."),(0,n.kt)("p",null,"e)A pragma_argument_identifier."),(0,n.kt)("p",null,"f)An identifier specific to a pragma used in a pragma argument."),(0,n.kt)("p",null,"The visibility rules have nothing to do with the above cases; the meanings of such things are defined elsewhere. Reserved words are not identifiers; the visibility rules don't apply to them either."),(0,n.kt)("p",null,'Because of the way we have defined "declaration", it is possible for a usage name to denote a subprogram_body, either within that body, or (for a nonlibrary unit) after it (since the body hides the corresponding declaration, if any). Other bodies do not work that way. Completions of type_declarations and deferred constant declarations do work that way. Accept_statements are never denoted, although the parameter_specifications in their profiles can be.'),(0,n.kt)("p",null,"The scope of a subprogram does not start until after its profile. Thus, the following is legal: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"X : constant Integer := 17;\n...\npackage P is\n    procedure X(Y : in Integer := X);\nend P;\n\n")),(0,n.kt)("p",null,"The body of the subprogram will probably be illegal, however, since the constant X will be hidden by then."),(0,n.kt)("p",null,"The rule is different for generic subprograms, since they are not overloadable; the following is illegal: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"X : constant Integer := 17;\npackage P is\n    generic\n      Z : Integer := X; -- Illegal!\n    procedure X(Y : in Integer := X); -- Illegal!\nend P;\n\n")),(0,n.kt)("p",null,"The constant X is hidden from direct visibility by the generic declaration. "),(0,n.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,n.kt)("p",null,"Declarations with the same defining name as that of a subprogram or entry being defined are nevertheless visible within the subprogram specification or entry declaration. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The term "visible by selection" is no longer defined. We use the terms "directly visible" and "visible" (among other things). There are only two regions of text that are of interest, here: the region in which a declaration is visible, and the region in which it is directly visible.'),(0,n.kt)("p",null,"Visibility is defined only for declarations. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-95"},"Incompatibilities With Ada 95"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"]\n\n")),(0,n.kt)("h2",{id:"84--use-clauses"},"8.4  Use Clauses"),(0,n.kt)("p",null,"[A use_package_clause achieves direct visibility of declarations that appear in the visible part of a package; a use_type_clause achieves direct visibility of the primitive operators of a type.]"," "),(0,n.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,n.kt)("p",null,'If and only if the visibility rules allow P.A, "use P;" should make A directly visible (barring name conflicts). This means, for example, that child library units, and generic formals of a formal package whose formal_package_actual_part is (',"<",">","), should be made visible by a use_clause for the appropriate package."),(0,n.kt)("p",null,'The rules for use_clauses were carefully constructed to avoid so-called Beaujolais effects, where the addition or removal of a single use_clause, or a single declaration in a "use"d package, would change the meaning of a program from one legal interpretation to another. '),(0,n.kt)("h4",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"use_clause ::= use_package_clause | use_type_clause"),(0,n.kt)("p",null,"use_package_clause ::= use package_name {, package_name};"),(0,n.kt)("p",null,"use_type_clause ::= use type subtype_mark {, subtype_mark};"),(0,n.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,n.kt)("p",null,"A package_name of a use_package_clause shall denote a package. "),(0,n.kt)("p",null,"Ramification: This includes formal packages. "),(0,n.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,n.kt)("p",null,"For each use_clause, there is a certain region of text called the scope of the use_clause. For a use_clause within a context_clause of a library_unit_declaration or library_unit_renaming_declaration, the scope is the entire declarative region of the declaration. For a use_clause within a context_clause of a body, the scope is the entire body ","[and any subunits (including multiply nested subunits). The scope does not include context_clauses themselves.]"),(0,n.kt)("p",null,"For a use_clause immediately within a declarative region, the scope is the portion of the declarative region starting just after the use_clause and extending to the end of the declarative region. However, the scope of a use_clause in the private part of a library unit does not include the visible part of any public descendant of that library unit. "),(0,n.kt)("p",null,'Reason: The exception echoes the similar exception for "immediate scope (of a declaration)" (see 8.2). It makes use_clauses work like this: '),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package P is\n    type T is range 1..10;\nend P;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with P;\npackage Parent is\nprivate\n    use P;\n    X : T;\nend Parent;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package Parent.Child is\n    Y : T; -- Illegal!\n    Z : P.T;\nprivate\n    W : T;\nend Parent.Child;\n\n")),(0,n.kt)("p",null,'The declaration of Y is illegal because the scope of the "use P" does not include that place, so T is not directly visible there. The declarations of X, Z, and W are legal. '),(0,n.kt)("p",null,"For each package denoted by a package_name of a use_package_clause whose scope encloses a place, each declaration that occurs immediately within the declarative region of the package is potentially use-visible at this place if the declaration is visible at this place. For each type T or T'Class determined by a subtype_mark of a use_type_clause whose scope encloses a place, the declaration of each primitive operator of type T is potentially use-visible at this place if its declaration is visible at this place. "),(0,n.kt)("p",null,"Ramification: Primitive subprograms whose defining name is an identifier are not made potentially visible by a use_type_clause. A use_type_clause is only for operators."),(0,n.kt)("p",null,'The semantics described here should be similar to the semantics for expanded names given in 4.1.3, "Selected Components" so as to achieve the effect requested by the "principle of equivalence of use_clauses and selected_components". Thus, child library units and generic formal parameters of a formal package are potentially use-visible when their enclosing package is use\'d.'),(0,n.kt)("p",null,'The "visible at that place" part implies that applying a use_clause to a parent unit does not make all of its children use-visible - only those that have been made visible by a with_clause. It also implies that we don\'t have to worry about hiding in the definition of "directly visible" - a declaration cannot be use-visible unless it is visible.'),(0,n.kt)("p",null,'Note that "use type T\'Class;" is equivalent to "use type T;", which helps avoid breaking the generic contract model. '),(0,n.kt)("p",null,"A declaration is use-visible if it is potentially use-visible, except in these naming-conflict cases: "),(0,n.kt)("p",null,"A potentially use-visible declaration is not use-visible if the place considered is within the immediate scope of a homograph of the declaration."),(0,n.kt)("p",null,"Potentially use-visible declarations that have the same identifier are not use-visible unless each of them is an overloadable declaration. "),(0,n.kt)("p",null,"Ramification: Overloadable declarations don't cancel each other out, even if they are homographs, though if they are not distinguishable by formal parameter names or the presence or absence of default_expressions, any use will be ambiguous. We only mention identifiers here, because declarations named by operator_symbols are always overloadable, and hence never cancel each other. Direct visibility is irrelevant for character_literals. "),(0,n.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,n.kt)("p",null,"The elaboration of a use_clause has no effect. "),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("p",null,"Example of a use clause in a context clause: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Calendar; use Ada;\n\n")),(0,n.kt)("p",null,"Example of a use type clause: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"use type Rational_Numbers.Rational; -- see 7.1\nTwo_Thirds: Rational_Numbers.Rational := 2/3;\n\n")),(0,n.kt)("p",null,'Ramification: In "use X, Y;", Y cannot refer to something made visible by the "use" of X. Thus, it\'s not (quite) equivalent to "use X; use Y;".'),(0,n.kt)("p",null,"If a given declaration is already immediately visible, then a use_clause that makes it potentially use-visible has no effect. Therefore, a use_type_clause for a type whose declaration appears in a place other than the visible part of a package has no effect; it cannot make a declaration use-visible unless that declaration is already immediately visible."),(0,n.kt)("p",null,'"Use type S1;" and "use type S2;" are equivalent if S1 and S2 are both subtypes of the same type. In particular, "use type S;" and "use type S\'Base;" are equivalent. '),(0,n.kt)("p",null,'Reason: We considered adding a rule that prevented several declarations of views of the same entity that all have the same semantics from cancelling each other out. For example, if a (possibly implicit) subprogram_declaration for "+" is potentially use-visible, and a fully conformant renaming of it is also potentially use-visible, then they (annoyingly) cancel each other out; neither one is use-visible. The considered rule would have made just one of them use-visible. We gave up on this idea due to the complexity of the rule. It would have had to account for both overloadable and nonoverloadable renaming_declarations, the case where the rule should apply only to some subset of the declarations with the same defining name, and the case of subtype_declarations (since they are claimed to be sufficient for renaming of subtypes). '),(0,n.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The use_type_clause is new to Ada 95. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The phrase "omitting from this set any packages that enclose this place" is no longer necessary to avoid making something visible outside its scope, because we explicitly state that the declaration has to be visible in order to be potentially use-visible. '),(0,n.kt)("h2",{id:"85--renaming-declarations"},"8.5  Renaming Declarations"),(0,n.kt)("p",null,"[A renaming_declaration declares another name for an entity, such as an object, exception, package, subprogram, entry, or generic unit. Alternatively, a subprogram_renaming_declaration can be the completion of a previous subprogram_declaration.]"),(0,n.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[renaming]",", Def=","[a declaration that does not define a new entity, but instead defines a new view of an existing entity]"," "),(0,n.kt)("h4",{id:"syntax-1"},"Syntax"),(0,n.kt)("p",null,"renaming_declaration ::=\nobject_renaming_declaration\n| exception_renaming_declaration\n| package_renaming_declaration\n| subprogram_renaming_declaration\n| generic_renaming_declaration"),(0,n.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,n.kt)("p",null,"The elaboration of a renaming_declaration evaluates the name that follows the reserved word renames and thereby determines the view and entity denoted by this name (the renamed view and renamed entity). ","[A name that denotes the renaming_declaration denotes (a new view of) the renamed entity.]"," "),(0,n.kt)("p",null,"NOTE 1   Renaming may be used to resolve name conflicts and to act as a shorthand. Renaming with a different identifier or operator_symbol does not hide the old name; the new name and the old name need not be visible at the same places."),(0,n.kt)("p",null,"NOTE 2   A task or protected object that is declared by an explicit object_declaration can be renamed as an object. However, a single task or protected object cannot be renamed since the corresponding type is anonymous (meaning it has no nameable subtypes). For similar reasons, an object of an anonymous array or access type cannot be renamed."),(0,n.kt)("p",null,"NOTE 3   A subtype defined without any additional constraint can be used to achieve the effect of renaming another subtype (including a task or protected subtype) as in "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   subtype Mode is Ada.Text_IO.File_Mode;\n\n")),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The second sentence of RM83-8.5(3), "At any point where a renaming declaration is visible, the identifier, or operator symbol of this declaration denotes the renamed entity." is incorrect. It doesn\'t say directly visible. Also, such an identifier might resolve to something else.'),(0,n.kt)("p",null,'The verbiage about renamings being legal "only if exactly one...", which appears in RM83-8.5(4) (for objects) and RM83-8.5(7) (for subprograms) is removed, because it follows from the normal rules about overload resolution. For language lawyers, these facts are obvious; for programmers, they are irrelevant, since failing these tests is highly unlikely. '),(0,n.kt)("h3",{id:"851--object-renaming-declarations"},"8.5.1  Object Renaming Declarations"),(0,n.kt)("p",null,"[An object_renaming_declaration is used to rename an object.]"," "),(0,n.kt)("h4",{id:"syntax-2"},"Syntax"),(0,n.kt)("p",null,"object_renaming_declaration ::= defining_identifier : subtype_mark renames object_name;"),(0,n.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,n.kt)("p",null,"The type of the object_name shall resolve to the type determined by the subtype_mark."),(0,n.kt)("p",null,'Reason: A previous version of Ada 9X used the usual "expected type" wording:\n"The expected type for the object_name is that determined by the subtype_mark."\nWe changed it so that this would be illegal: '),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"X: T;\nY: T'Class renames X; -- Illegal!\n\n")),(0,n.kt)("p",null,"When the above was legal, it was unclear whether Y was of type T or T'Class. Note that we still allow this: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"Z: T'Class := ...;\nW: T renames F(Z);\n\n")),(0,n.kt)("p",null,"where F is a function with a controlling parameter and result. This is admittedly a bit odd."),(0,n.kt)("p",null,"Note that the matching rule for generic formal parameters of mode in out was changed to keep it consistent with the rule for renaming. That makes the rule different for in vs. in out."),(0,n.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,n.kt)("p",null,"The renamed entity shall be an object."),(0,n.kt)("p",null,"The renamed entity shall not be a subcomponent that depends on discriminants of a variable whose nominal subtype is unconstrained, unless this subtype is indefinite, or the variable is aliased. A slice of an array shall not be renamed if this restriction disallows renaming of the array. "),(0,n.kt)("p",null,"Reason: This prevents renaming of subcomponents that might disappear, which might leave dangling references. Similar restrictions exist for the Access attribute."),(0,n.kt)("p",null,"Implementation Note: Note that if an implementation chooses to deallocate-then-reallocate on assignment_statements assigning to unconstrained definite objects, then it cannot represent renamings and access values as simple addresses, because the above rule does not apply to all components of such an object. "),(0,n.kt)("p",null,"Ramification: If it is a generic formal object, then the assume-the-best or assume-the-worst rules are applied as appropriate. "),(0,n.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,n.kt)("p",null,"An object_renaming_declaration declares a new view ","[of the renamed object]"," whose properties are identical to those of the renamed view. ","[Thus, the properties of the renamed object are not affected by the renaming_declaration. In particular, its value and whether or not it is a constant are unaffected; similarly, the constraints that apply to an object are not affected by renaming (any constraint implied by the subtype_mark of the object_renaming_declaration is ignored).]"," "),(0,n.kt)("p",null,"Discussion: Because the constraints are ignored, it is a good idea to use the nominal subtype of the renamed object when writing an object_renaming_declaration."),(0,n.kt)("h4",{id:"examples-1"},"Examples"),(0,n.kt)("p",null,"Example of renaming an object: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"declare\n   L : Person renames Leftmost_Person; -- see 3.10.1\nbegin\n   L.Age := L.Age + 1;\nend;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"Uno renames One;  -- see 3.3.2\n\n")),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The phrase "subtype ... as defined in a corresponding object declaration, component declaration, or component subtype indication", from RM83-8.5(5), is incorrect in Ada 95; therefore we removed it. It is incorrect in the case of an object with an indefinite unconstrained nominal subtype. '),(0,n.kt)("h3",{id:"852--exception-renaming-declarations"},"8.5.2  Exception Renaming Declarations"),(0,n.kt)("p",null,"[An exception_renaming_declaration is used to rename an exception.]"," "),(0,n.kt)("h4",{id:"syntax-3"},"Syntax"),(0,n.kt)("p",null,"exception_renaming_declaration ::= defining_identifier : exception renames exception_name;"),(0,n.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,n.kt)("p",null,"The renamed entity shall be an exception. "),(0,n.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,n.kt)("p",null,"An exception_renaming_declaration declares a new view ","[of the renamed exception]",". "),(0,n.kt)("h4",{id:"examples-2"},"Examples"),(0,n.kt)("p",null,"Example of renaming an exception: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"EOF : exception renames Ada.IO_Exceptions.End_Error; -- see A.13\n\n")),(0,n.kt)("h3",{id:"853--package-renaming-declarations"},"8.5.3  Package Renaming Declarations"),(0,n.kt)("p",null,"[A package_renaming_declaration is used to rename a package.]"," "),(0,n.kt)("h4",{id:"syntax-4"},"Syntax"),(0,n.kt)("p",null,"package_renaming_declaration ::= package defining_program_unit_name renames package_name;"),(0,n.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,n.kt)("p",null,"The renamed entity shall be a package."),(0,n.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,n.kt)("p",null,"A package_renaming_declaration declares a new view ","[of the renamed package]","."),(0,n.kt)("h4",{id:"examples-3"},"Examples"),(0,n.kt)("p",null,"Example of renaming a package: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package TM renames Table_Manager;\n\n")),(0,n.kt)("h3",{id:"854--subprogram-renaming-declarations"},"8.5.4  Subprogram Renaming Declarations"),(0,n.kt)("p",null,"A subprogram_renaming_declaration can serve as the completion of a subprogram_declaration; such a renaming_declaration is called a renaming-as-body. A subprogram_renaming_declaration that is not a completion is called a renaming-as-declaration","[, and is used to rename a subprogram (possibly an enumeration literal) or an entry]",". "),(0,n.kt)("p",null,"Ramification: A renaming-as-body is a declaration, as defined in Section 3. "),(0,n.kt)("h4",{id:"syntax-5"},"Syntax"),(0,n.kt)("p",null,"subprogram_renaming_declaration ::= subprogram_specification renames callable_entity_name;"),(0,n.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,n.kt)("p",null,"The expected profile for the callable_entity_name is the profile given in the subprogram_specification. "),(0,n.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,n.kt)("p",null,"The profile of a renaming-as-declaration shall be mode-conformant with that of the renamed callable entity. "),(0,n.kt)("p",null,"The profile of a renaming-as-body shall be subtype-conformant with that of the renamed callable entity, and shall conform fully to that of the declaration it completes. If the renaming-as-body completes that declaration before the subprogram it declares is frozen, the subprogram it declares takes its convention from the renamed subprogram; otherwise the convention of the renamed subprogram shall not be Intrinsic. "),(0,n.kt)("p",null,'Reason: The first part of the first sentence is to allow an implementation of a renaming-as-body as a single jump instruction to the target subprogram. Among other things, this prevents a subprogram from being completed with a renaming of an entry. (In most cases, the target of the jump can be filled in at link time. In some cases, such as a renaming of a name like "A(I).all", an indirect jump is needed. Note that the name is evaluated at renaming time, not at call time.)'),(0,n.kt)("p",null,"The second part of the first sentence is the normal rule for completions of subprogram_declarations. "),(0,n.kt)("p",null,"Ramification: An entry_declaration, unlike a subprogram_declaration, cannot be completed with a renaming_declaration. Nor can a generic_subprogram_declaration."),(0,n.kt)("p",null,"The syntax rules prevent a protected subprogram declaration from being completed by a renaming. This is fortunate, because it allows us to avoid worrying about whether the implicit protected object parameter of a protected operation is involved in the conformance rules. "),(0,n.kt)("p",null,"A name that denotes a formal parameter of the subprogram_specification is not allowed within the callable_entity_name. "),(0,n.kt)("p",null,"Reason: This is to prevent things like this: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function F(X : Integer) return Integer renames Table(X).all;\n\n")),(0,n.kt)("p",null,"A similar rule in 6.1 forbids things like this: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function F(X : Integer; Y : Integer := X) return Integer;\n\n")),(0,n.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,n.kt)("p",null,"A renaming-as-declaration declares a new view of the renamed entity. The profile of this new view takes its subtypes, parameter modes, and calling convention from the original profile of the callable entity, while taking the formal parameter names and default_expressions from the profile given in the subprogram_renaming_declaration. The new view is a function or procedure, never an entry. "),(0,n.kt)("p",null,"To be honest: When renaming an entry as a procedure, the compile-time rules apply as if the new view is a procedure, but the run-time semantics of a call are that of an entry call. "),(0,n.kt)("p",null,"Ramification: For example, it is illegal for the entry_call_statement of a timed_entry_call to call the new view. But what looks like a procedure call will do things like barrier waiting."),(0,n.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,n.kt)("p",null,"For a call on a renaming of a dispatching subprogram that is overridden, if the overriding occurred before the renaming, then the body executed is that of the overriding declaration, even if the overriding declaration is not visible at the place of the renaming; otherwise, the inherited or predefined subprogram is called. "),(0,n.kt)("p",null,"Discussion: Note that whether or not the renaming is itself primitive has nothing to do with the renamed subprogram."),(0,n.kt)("p",null,"Note that the above rule is only for tagged types."),(0,n.kt)("p",null,"Consider the following example: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'package P is\n    type T is tagged null record;\n    function Predefined_Equal(X, Y : T) return Boolean renames "=";\nprivate\n    function "="(X, Y : T) return Boolean; -- Override predefined "=".\nend P;\n\n')),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'with P; use P;\npackage Q is\n    function User_Defined_Equal(X, Y : T) return Boolean renames P."=";\nend Q;\n\n')),(0,n.kt)("p",null,"A call on Predefined_Equal will execute the predefined equality operator of T, whereas a call on User_Defined_Equal will execute the body of the overriding declaration in the private part of P."),(0,n.kt)("p",null,"Thus a renaming allows one to squirrel away a copy of an inherited or predefined subprogram before later overriding it. "),(0,n.kt)("p",null,"NOTE 1   A procedure can only be renamed as a procedure. A function whose defining_designator is either an identifier or an operator_symbol can be renamed with either an identifier or an operator_symbol; for renaming as an operator, the subprogram specification given in the renaming_declaration is subject to the rules given in 6.6 for operator declarations. Enumeration literals can be renamed as functions; similarly, attribute_references that denote functions (such as references to Succ and Pred) can be renamed as functions. An entry can only be renamed as a procedure; the new name is only allowed to appear in contexts that allow a procedure name. An entry of a family can be renamed, but an entry family cannot be renamed as a whole."),(0,n.kt)("p",null,"NOTE 2   The operators of the root numeric types cannot be renamed because the types in the profile are anonymous, so the corresponding specifications cannot be written; the same holds for certain attributes, such as Pos."),(0,n.kt)("p",null,"NOTE 3   Calls with the new name of a renamed entry are procedure",(0,n.kt)("em",{parentName:"p"},"call_statements and are not allowed at places where the syntax requires an entry_call_statement in conditional")," and timed_entry_calls, nor in an asynchronous_select; similarly, the Count attribute is not available for the new name."),(0,n.kt)("p",null,"NOTE 4   The primitiveness of a renaming-as-declaration is determined by its profile, and by where it occurs, as for any declaration of (a view of) a subprogram; primitiveness is not determined by the renamed view. In order to perform a dispatching call, the subprogram name has to denote a primitive subprogram, not a nonprimitive renaming of a primitive subprogram. "),(0,n.kt)("p",null,"Reason: A subprogram_renaming_declaration could more properly be called renaming_as_subprogram_declaration, since you're renaming something as a subprogram, but you're not necessarily renaming a subprogram. But that's too much of a mouthful. Or, alternatively, we could call it a callable_entity_renaming_declaration, but that's even worse. Not only is it a mouthful, it emphasizes the entity being renamed, rather than the new view, which we think is a bad idea. We'll live with the oddity. "),(0,n.kt)("h4",{id:"examples-4"},"Examples"),(0,n.kt)("p",null,"Examples of subprogram renaming declarations: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"procedure My_Write(C : in Character) renames Pool(K).Write; --  see 4.1.3\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'function Real_Plus(Left, Right : Real   ) return Real    renames "+";\nfunction Int_Plus (Left, Right : Integer) return Integer renames "+";\n\n')),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Rouge return Color renames Red;  --  see 3.5.1\nfunction Rot   return Color renames Red;\nfunction Rosso return Color renames Rouge;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Next(X : Color) return Color renames Color'Succ; -- see 3.5.1\n\n")),(0,n.kt)("p",null,"Example of a subprogram renaming declaration with new parameter names: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'function "*" (X,Y : Vector) return Real renames Dot_Product; -- see 6.1\n\n')),(0,n.kt)("p",null,"Example of a subprogram renaming declaration with a new default expression: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Minimum(L : Link := Head) return Cell renames Min_Cell; -- see 6.1\n\n")),(0,n.kt)("h3",{id:"855--generic-renaming-declarations"},"8.5.5  Generic Renaming Declarations"),(0,n.kt)("p",null,"[A generic_renaming_declaration is used to rename a generic unit.]"," "),(0,n.kt)("h4",{id:"syntax-6"},"Syntax"),(0,n.kt)("p",null,"generic_renaming_declaration ::=\ngeneric package\tdefining_program_unit_name renames generic_package_name;\n| generic procedure\tdefining_program_unit_name renames generic_procedure_name;\n| generic function\tdefining_program_unit_name renames generic_function_name;"),(0,n.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,n.kt)("p",null,"The renamed entity shall be a generic unit of the corresponding kind. "),(0,n.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,n.kt)("p",null,"A generic_renaming_declaration declares a new view ","[of the renamed generic unit]",". "),(0,n.kt)("p",null,"NOTE 1   Although the properties of the new view are the same as those of the renamed view, the place where the generic_renaming_declaration occurs may affect the legality of subsequent renamings and instantiations that denote the generic_renaming_declaration, in particular if the renamed generic unit is a library unit (see 10.1.1). "),(0,n.kt)("h4",{id:"examples-5"},"Examples"),(0,n.kt)("p",null,"Example of renaming a generic unit: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"generic package Enum_IO renames Ada.Text_IO.Enumeration_IO;  -- see A.10.10\n\n")),(0,n.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,n.kt)("p",null,"Renaming of generic units is new to Ada 95. It is particularly important for renaming child library units that are generic units. For example, it might be used to rename Numerics.Generic_Elementary_Functions as simply Generic_Elementary_Functions, to match the name for the corresponding Ada-83-based package. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-7"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'The information in RM83-8.6, "The Package Standard", has been updated for the child unit feature, and moved to Annex A, except for the definition of "predefined type", which has been moved to 3.2.1. '),(0,n.kt)("h2",{id:"86--the-context-of-overload-resolution"},"8.6  The Context of Overload Resolution"),(0,n.kt)("p",null,"[ Because declarations can be overloaded, it is possible for an occurrence of a usage name to have more than one possible interpretation; in most cases, ambiguity is disallowed. This clause describes how the possible interpretations resolve to the actual interpretation."),(0,n.kt)("p",null,'Certain rules of the language (the Name Resolution Rules) are considered "overloading rules". If a possible interpretation violates an overloading rule, it is assumed not to be the intended interpretation; some other possible interpretation is assumed to be the actual interpretation. On the other hand, violations of nonoverloading rules do not affect which interpretation is chosen; instead, they cause the construct to be illegal. To be legal, there usually has to be exactly one acceptable interpretation of a construct that is a "complete context", not counting any nested complete contexts.'),(0,n.kt)("p",null,"The syntax rules of the language and the visibility rules given in 8.3 determine the possible interpretations. Most type checking rules (rules that require a particular type, or a particular class of types, for example) are overloading rules. Various rules for the matching of formal and actual parameters are overloading rules.] "),(0,n.kt)("h4",{id:"language-design-principles-1"},"Language Design Principles"),(0,n.kt)("p",null,"The type resolution rules are intended to minimize the need for implicit declarations and preference rules associated with implicit conversion and dispatching operations. "),(0,n.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,n.kt)("p",null,"[Overload resolution is applied separately to each complete context, not counting inner complete contexts.]"," Each of the following constructs is a complete context: "),(0,n.kt)("p",null,"A context_item."),(0,n.kt)("p",null,"A declarative_item or declaration. "),(0,n.kt)("p",null,"Ramification: A loop_parameter_specification is a declaration, and hence a complete context. "),(0,n.kt)("p",null,"A statement."),(0,n.kt)("p",null,"A pragma_argument_association. "),(0,n.kt)("p",null,"Reason: We would make it the whole pragma, except that certain pragma arguments are allowed to be ambiguous, and ambiguity applies to a complete context. "),(0,n.kt)("p",null,"The expression of a case_statement. "),(0,n.kt)("p",null,"Ramification: This means that the expression is resolved without looking at the choices. "),(0,n.kt)("p",null,"An (overall) interpretation of a complete context embodies its meaning, and includes the following information about the constituents of the complete context, not including constituents of inner complete contexts: "),(0,n.kt)("p",null,"for each constituent of the complete context, to which syntactic categories it belongs, and by which syntax rules; and "),(0,n.kt)("p",null,"Ramification: Syntactic categories is plural here, because there are lots of trivial productions - an expression might also be all of the following, in this order: identifier, name, primary, factor, term, simple_expression, and relation. Basically, we're trying to capture all the information in the parse tree here, without using compiler-writer's jargon like \"parse tree\". "),(0,n.kt)("p",null,"for each usage name, which declaration it denotes (and, therefore, which view and which entity it denotes); and "),(0,n.kt)("p",null,"Ramification: In most cases, a usage name denotes the view declared by the denoted declaration. However, in certain cases, a usage name that denotes a declaration and appears inside the declarative region of that same declaration, denotes the current instance of the declaration. For example, within a task_body, a usage name that denotes the task_type_declaration denotes the object containing the currently executing task, and not the task type declared by the declaration. "),(0,n.kt)("p",null,"for a complete context that is a declarative_item, whether or not it is a completion of a declaration, and (if so) which declaration it completes. "),(0,n.kt)("p",null,"Ramification: Unfortunately, we are not confident that the above list is complete. We'll have to live with that. "),(0,n.kt)("p",null,'To be honest: For "possible" interpretations, the above information is tentative. '),(0,n.kt)("p",null,'Discussion: A possible interpretation (an input to overload resolution) contains information about what a usage name might denote, but what it actually does denote requires overload resolution to determine. Hence the term "tentative" is needed for possible interpretations; otherwise, the definition would be circular. '),(0,n.kt)("p",null,"A possible interpretation is one that obeys the syntax rules and the visibility rules. An acceptable interpretation is a possible interpretation that obeys the overloading rules","[, that is, those rules that specify an expected type or expected profile, or specify how a construct shall resolve or be interpreted.]"," "),(0,n.kt)("p",null,"To be honest: One rule that falls into this category, but does not use the above-mentioned magic words, is the rule about numbers of parameter associations in a call (see 6.4). "),(0,n.kt)("p",null,"Ramification: The Name Resolution Rules are the ones that appear under the Name Resolution Rules heading. Some Syntax Rules are written in English, instead of BNF. No rule is a Syntax Rule or Name Resolution Rule unless it appears under the appropriate heading. "),(0,n.kt)("p",null,"The interpretation of a constituent of a complete context is determined from the overall interpretation of the complete context as a whole. ",'[Thus, for example, "interpreted as a function_call", means that the construct\'s interpretation says that it belongs to the syntactic category function_call.]'),(0,n.kt)("p",null,"[Each occurrence of]"," a usage name denotes the declaration determined by its interpretation. It also denotes the view declared by its denoted declaration, except in the following cases: "),(0,n.kt)("p",null,"Ramification: As explained below, a pragma argument is allowed to be ambiguous, so it can denote several declarations, and all of the views declared by those declarations. "),(0,n.kt)("p",null,"If a usage name appears within the declarative region of a type_declaration and denotes that same type_declaration, then it denotes the current instance of the type (rather than the type itself). The current instance of a type is the object or value of the type that is associated with the execution that evaluates the usage name. "),(0,n.kt)("p",null,"Reason: This is needed, for example, for references to the Access attribute from within the type_declaration. Also, within a task_body or protected_body, we need to be able to denote the current task or protected object. (For a single_task_declaration or single_protected_declaration, the rule about current instances is not needed.) "),(0,n.kt)("p",null,"If a usage name appears within the declarative region of a generic_declaration (but not within its generic_formal_part) and it denotes that same generic_declaration, then it denotes the current instance of the generic unit (rather than the generic unit itself). See also 12.3. "),(0,n.kt)("p",null,"To be honest: The current instance of a generic unit is the instance created by whichever generic_instantiation is of interest at any given time. "),(0,n.kt)("p",null,"Ramification: Within a generic_formal_part, a name that denotes the generic_declaration denotes the generic unit, which implies that it is not overloadable. "),(0,n.kt)("p",null,"A usage name that denotes a view also denotes the entity of that view. "),(0,n.kt)("p",null,"Ramification: Usually, a usage name denotes only one declaration, and therefore one view and one entity. "),(0,n.kt)("p",null,"The expected type for a given expression, name, or other construct determines, according to the type resolution rules given below, the types considered for the construct during overload resolution. ","[ The type resolution rules provide support for class-wide programming, universal numeric literals, dispatching operations, and anonymous access types:]"," "),(0,n.kt)("p",null,"Ramification: Expected types are defined throughout the RM95. The most important definition is that, for a subprogram, the expected type for the actual parameter is the type of the formal parameter."),(0,n.kt)("p",null,"The type resolution rules are trivial unless either the actual or expected type is universal, class-wide, or of an anonymous access type. "),(0,n.kt)("p",null,"If a construct is expected to be of any type in a class of types, or of the universal or class-wide type for a class, then the type of the construct shall resolve to a type in that class or to a universal type that covers the class. "),(0,n.kt)("p",null,"Ramification: This matching rule handles (among other things) cases like the Val attribute, which denotes a function that takes a parameter of type universal_integer."),(0,n.kt)("p",null,'The last part of the rule, "or to a universal type that includes the class" implies that if the expected type for an expression is universal_fixed, then an expression whose type is universal_real (such as a real literal) is OK. '),(0,n.kt)("p",null,"If the expected type for a construct is a specific type T, then the type of the construct shall resolve either to T, or: "),(0,n.kt)("p",null,"Ramification: This rule is not intended to create a preference for the specific type - such a preference would cause Beaujolais effects. "),(0,n.kt)("p",null,"to T'Class; or "),(0,n.kt)("p",null,'Ramification: This will only be legal as part of a call on a dispatching operation; see 3.9.2, "Dispatching Operations of Tagged Types". Note that that rule is not a Name Resolution Rule. '),(0,n.kt)("p",null,"to a universal type that covers T; or"),(0,n.kt)("p",null,"when T is an anonymous access type (see 3.10) with designated type D, to an access-to-variable type whose designated type is D'Class or is covered by D."),(0,n.kt)("p",null,'Ramification: Because it says "access-to-variable" instead of "access-to-object", two subprograms that differ only in that one has a parameter of an access-to-constant type, and the other has an access parameter, are distinguishable during overload resolution.'),(0,n.kt)("p",null,'The case where the actual is access-to-D\'Class will only be legal as part of a call on a dispatching operation; see 3.9.2, "Dispatching Operations of Tagged Types". Note that that rule is not a Name Resolution Rule. '),(0,n.kt)("p",null,"In certain contexts, ","[such as in a subprogram_renaming_declaration,]"," the Name Resolution Rules define an expected profile for a given name; in such cases, the name shall resolve to the name of a callable entity whose profile is type conformant with the expected profile. "),(0,n.kt)("p",null,"Ramification: The parameter and result subtypes are not used in overload resolution. Only type conformance of profiles is considered during overload resolution. Legality rules generally require at least mode-conformance in addition, but those rules are not used in overload resolution. "),(0,n.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,n.kt)("p",null,"When the expected type for a construct is required to be a single type in a given class, the type expected for the construct shall be determinable solely from the context in which the construct appears, excluding the construct itself, but using the requirement that it be in the given class; the type of the construct is then this single expected type. Furthermore, the context shall not be one that expects any type in some class that contains types of the given class; in particular, the construct shall not be the operand of a type_conversion."),(0,n.kt)("p",null,'Ramification: For example, the expected type for the literal null is required to be a single access type. But the expected type for the operand of a type_conversion is any type. Therefore, the literal null is not allowed as the operand of a type_conversion. This is true even if there is only one access type in scope. The reason for these rules is so that the compiler will not have to search "everywhere" to see if there is exactly one type in a class in scope. '),(0,n.kt)("p",null,"A complete context shall have at least one acceptable interpretation; if there is exactly one, then that one is chosen. "),(0,n.kt)("p",null,"Ramification: This, and the rule below about ambiguity, are the ones that suck in all the Syntax Rules and Name Resolution Rules as compile-time rules. Note that this and the ambiguity rule have to be Legality Rules. "),(0,n.kt)("p",null,"There is a preference for the primitive operators (and ranges) of the root numeric types root_integer and root_real. In particular, if two acceptable interpretations of a constituent of a complete context differ only in that one is for a primitive operator (or range) of the type root_integer or root_real, and the other is not, the interpretation using the primitive operator (or range) of the root numeric type is preferred."),(0,n.kt)("p",null,"Reason: The reason for this preference is so that expressions involving literals and named numbers can be unambiguous. For example, without the preference rule, the following would be ambiguous: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'N : constant := 123;\nif N &gt 100 then -- Preference for root_integer "&lt" operator.\n    ...\nend if;\n\n')),(0,n.kt)("p",null,"For a complete context, if there is exactly one overall acceptable interpretation where each constituent's interpretation is the same as or preferred (in the above sense) over those in all other overall acceptable interpretations, then that one overall acceptable interpretation is chosen. Otherwise, the complete context is ambiguous."),(0,n.kt)("p",null,"A complete context other than a pragma_argument_association shall not be ambiguous."),(0,n.kt)("p",null,"A complete context that is a pragma_argument_association is allowed to be ambiguous (unless otherwise specified for the particular pragma), but only if every acceptable interpretation of the pragma argument is as a name that statically denotes a callable entity. Such a name denotes all of the declarations determined by its interpretations, and all of the views declared by these declarations. "),(0,n.kt)("p",null,'Ramification: This applies to Inline, Suppress, Import, Export, and Convention pragmas. For example, it is OK to say "pragma Suppress(Elaboration_Check, On =',">"," P.Q);\", even if there are two directly visible P's, and there are two Q's declared in the visible part of each P. In this case, P.Q denotes four different declarations. This rule also applies to certain pragmas defined in the Specialized Needs Annexes. It almost applies to Pure, Elaborate_Body, and Elaborate_All pragmas, but those can't have overloading for other reasons. "),(0,n.kt)("p",null,"Note that if a pragma argument denotes a call to a callable entity, rather than the entity itself, this exception does not apply, and ambiguity is disallowed."),(0,n.kt)("p",null,"Note that we need to carefully define which pragma-related rules are Name Resolution Rules, so that, for example, a pragma Inline does not pick up subprograms declared in enclosing declarative regions, and therefore make itself illegal."),(0,n.kt)("p",null,'We say "statically denotes" in the above rule in order to avoid having to worry about how many times the name is evaluated, in case it denotes more than one callable entity. '),(0,n.kt)("p",null,"NOTE   If a usage name has only one acceptable interpretation, then it denotes the corresponding entity. However, this does not mean that the usage name is necessarily legal since other requirements exist which are not considered for overload resolution; for example, the fact that an expression is static, whether an object is constant, mode and subtype conformance rules, freezing rules, order of elaboration, and so on."),(0,n.kt)("p",null,"Similarly, subtypes are not considered for overload resolution (the violation of a constraint does not make a program illegal but raises an exception during program execution). "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,n.kt)("p",null,"The new preference rule for operators of root numeric types is upward incompatible, but only in cases that involved Beaujolais effects in Ada 83. Such cases are ambiguous in Ada 95. "),(0,n.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,n.kt)("p",null,'The rule that allows an expected type to match an actual expression of a universal type, in combination with the new preference rule for operators of root numeric types, subsumes the Ada 83 "implicit conversion" rules for universal types. '),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-8"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'In Ada 83, it is not clear what the "syntax rules" are. AI83-00157 states that a certain textual rule is a syntax rule, but it\'s still not clear how one tells in general which textual rules are syntax rules. We have solved the problem by stating exactly which rules are syntax rules - the ones that appear under the "Syntax" heading.'),(0,n.kt)("p",null,'RM83 has a long list of the "forms" of rules that are to be used in overload resolution (in addition to the syntax rules). It is not clear exactly which rules fall under each form. We have solved the problem by explicitly marking all rules that are used in overload resolution. Thus, the list of kinds of rules is unnecessary. It is replaced with some introductory (intentionally vague) text explaining the basic idea of what sorts of rules are overloading rules.'),(0,n.kt)("p",null,'It is not clear from RM83 what information is embodied in a "meaning" or an "interpretation". "Meaning" and "interpretation" were intended to be synonymous; we now use the latter only in defining the rules about overload resolution. "Meaning" is used only informally. This clause attempts to clarify what is meant by "interpretation".'),(0,n.kt)("p",null,'For example, RM83 does not make it clear that overload resolution is required in order to match subprogram_bodies with their corresponding declarations (and even to tell whether a given subprogram_body is the completion of a previous declaration). Clearly, the information needed to do this is part of the "interpretation" of a subprogram_body. The resolution of such things is defined in terms of the "expected profile" concept. Ada 95 has some new cases where expected profiles are needed - the resolution of P\'Access, where P might denote a subprogram, is an example.'),(0,n.kt)("p",null,"RM83-8.7(2) might seem to imply that an interpretation embodies information about what is denoted by each usage name, but not information about which syntactic category each construct belongs to. However, it seems necessary to include such information, since the Ada grammar is highly ambiguous. For example, X(Y) might be a function_call or an indexed_component, and no context-free/syntactic information can tell the difference. It seems like we should view X(Y) as being, for example, \"interpreted as a function_call\" (if that's what overload resolution decides it is). Note that there are examples where the denotation of each usage name does not imply the syntactic category. However, even if that were not true, it seems that intuitively, the interpretation includes that information. Here's an example: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"type T;\ntype A is access T;\ntype T is array(Integer range 1..10) of A;\nI : Integer := 3;\nfunction F(X : Integer := 7) return A;\nY : A := F(I); -- Ambiguous? (We hope so.)\n\n")),(0,n.kt)("p",null,"Consider the declaration of Y (a complete context). In the above example, overload resolution can easily determine the declaration, and therefore the entity, denoted by Y, A, F, and I. However, given all of that information, we still don't know whether F(I) is a function_call or an indexed_component whose prefix is a function_call. (In the latter case, it is equivalent to F(7).all(I).)"),(0,n.kt)("p",null,"It seems clear that the declaration of Y ought to be considered ambiguous. We describe that by saying that there are two interpretations, one as a function_call, and one as an indexed_component. These interpretations are both acceptable to the overloading rules. Therefore, the complete context is ambiguous, and therefore illegal."),(0,n.kt)("p",null,"It is the intent that the Ada 95 preference rule for root numeric operators is more locally enforceable than that of RM83-4.6(15). It should also eliminate interpretation shifts due to the addition or removal of a use_clause (the so called Beaujolais effect)."),(0,n.kt)("p",null,'RM83-8.7 seems to be missing some complete contexts, such as pragma_argument_associations, declarative_items that are not declarations or representation_clauses, and context_items. We have added these, and also replaced the "must be determinable" wording of RM83-5.4(3) with the notion that the expression of a case_statement is a complete context.'),(0,n.kt)("p",null,'Cases like the Val attribute are now handled using the normal type resolution rules, instead of having special cases that explicitly allow things like "any integer type".'))}h.isMDXComponent=!0}}]);