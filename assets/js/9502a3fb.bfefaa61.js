"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6947],{19953:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>k,frontMatter:()=>u,metadata:()=>m,toc:()=>y});var a=n(91716),i=Object.defineProperty,r=Object.defineProperties,o=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&d(e,n,t[n]);if(s)for(var n of s(t))p.call(t,n)&&d(e,n,t[n]);return e};const u={title:"8.3 Adaptability"},h=void 0,m={unversionedId:"style-guide/s8/03",id:"style-guide/s8/03",title:"8.3 Adaptability",description:"Reusable parts often need to be changed before they can be used in a",source:"@site/docs/style-guide/s8/03.mdx",sourceDirName:"style-guide/s8",slug:"/style-guide/s8/03",permalink:"/docs/style-guide/s8/03",draft:!1,tags:[],version:"current",frontMatter:{title:"8.3 Adaptability"},sidebar:"styleGuideSidebar",previous:{title:"8.2 Robustness",permalink:"/docs/style-guide/s8/02"},next:{title:"8.4 Independence",permalink:"/docs/style-guide/s8/04"}},g={},y=[{value:"Complete Functionality",id:"complete-functionality",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Generic Units",id:"generic-units",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Formal Private and Limited Private Types",id:"formal-private-and-limited-private-types",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"notes",id:"notes-1",level:4},{value:"Using Generic Units to Encapsulate Algorithms",id:"using-generic-units-to-encapsulate-algorithms",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Iterators",id:"iterators",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4},{value:"Decimal Type Output and Information Systems Annex",id:"decimal-type-output-and-information-systems-annex",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"Implementing Mixins",id:"implementing-mixins",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-7",level:4}],f={toc:y};function k(e){var t,n=e,{components:i}=n,d=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},f),d),r(t,o({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Reusable parts often need to be changed before they can be used in a\nspecific application. They should be structured so that change is easy\nand as localized as possible. One way of achieving adaptability is to\ncreate general parts with complete functionality, only a subset of which\nmight be needed in a given application. Another way to achieve\nadaptability is to use Ada's generic construct to produce parts that can\nbe appropriately instantiated with different parameters. Both of these\napproaches avoid the error-prone process of adapting a part by changing\nits code but have limitations and can carry some overhead. Anticipated\nchanges, that is, changes that can be reasonably foreseen by the\ndeveloper of the part, should be provided for as far as possible.\nUnanticipated changes can only be accommodated by carefully structuring\na part to be adaptable. Many of the considerations pertaining to\nmaintainability apply. If the code is of high quality, clear, and\nconforms to well-established design principles such as information\nhiding, it is easier to adapt in unforeseen ways."),(0,a.kt)("h3",c({},{id:"complete-functionality"}),"Complete Functionality"),(0,a.kt)("h4",c({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide core functionality in a reusable part or set of parts so\nthat the functionality in this abstraction can be meaningfully\nextended by its reusers."),(0,a.kt)("li",{parentName:"ul"},"More specifically, provide initialization and finalization\nprocedures for every data structure that may contain dynamic data."),(0,a.kt)("li",{parentName:"ul"},"For data structures needing initialization and finalization,\nconsider deriving them, when possible, from the types\nAda.Finalization.Controlled or Ada.Finalization.Limited_Controlled.")),(0,a.kt)("h4",c({},{id:"example"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Incoming : Queue;\n   ...\n   Set_Initial (Incoming);     -- initialization operation\n   ...\n   if Is_Full (Incoming) then  -- query operation\n      ...\n   end if;\n   ...\n   Clean_Up (Incoming);        -- finalization operation\n")),(0,a.kt)("h4",c({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"This functionality is particularly important in designing/programming an\nabstraction. You have to balance the completeness of the abstraction\nagainst its extensibility. Completeness ensures that you have configured\nthe abstraction correctly, without built-in assumptions about its\nexecution environment. It also ensures the proper separation of\nfunctions so that they are useful to the current application and, in\nother combinations, to other applications. Extensibility ensures that\nreusers can add functionality by extension, using tagged type\nhierarchies (see Guideline 8.4.8 and Chapter 9) or child library\npackages (see Guidelines 4.1.6, 8.4.1, and 9.4.1)."),(0,a.kt)("p",null,"In designing for reuse, you need to think in terms of clean\nabstractions. If you provide too little functionality and rely on your\nreusers to extend the abstraction, they risk having an abstraction that\nlacks cohesion. This hodgepodge abstraction has inherited many\noperations, not all of which are necessary or work together."),(0,a.kt)("p",null,"When a reusable part can be implemented reasonably using dynamic data,\nthen any application that must control memory can use the initialization\nand finalization routines to guard against memory leakage. Then, if data\nstructures become dynamic, the applications that are sensitive to these\nconcerns can be easily adapted."),(0,a.kt)("p",null,"The predefined types Ada.Finalization.Controlled or\nAda.Finalization.Limited_Controlled provide automatic, user-definable\ninitialization, adjustment, and finalization procedures. When you\ndeclare controlled types and objects, you are guaranteed that the\ncompiler will insert the necessary calls to initialization, adjustment,\nand finalization, making your code less error-prone and more\nmaintainable. When overriding the Initialize and Finalize routines on\nthe controlled types, make sure to call the parent Initialize or\nFinalize."),(0,a.kt)("h4",c({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"The example illustrates end condition functions. An abstraction should\nbe automatically initialized before its user gets a chance to damage it.\nWhen that is not possible, it should be supplied with initialization\noperations. In any case, it needs finalization operations. One way to\nsupply the initialization and finalization operations is to derive the\nabstraction from the predefined types Ada.Finalization.Controlled or\nAda.Finalization.Limited_Controlled. Wherever possible, query\noperations should be provided to determine when limits are about to be\nexceeded, so that the user can avoid causing exceptions to be raised."),(0,a.kt)("p",null,'It is also useful to provide reset operations for many objects. To see\nthat a reset and an initiation can be different, consider the analogous\nsituation of a "warm boot" and a "cold boot" on a personal computer.'),(0,a.kt)("p",null,"Even if all of these operations are not appropriate for the abstraction,\nthe exercise of considering them aids in formulating a complete set of\noperations, others of which may be used by another application."),(0,a.kt)("p",null,"Some implementations of the language link all subprograms of a package\ninto the executable file, ignoring whether they are used or not, making\nunused operations a liability (see Guideline 8.4.5). In such cases,\nwhere the overhead is significant, create a copy of the fully functional\npart and comment out the unused operations with an indication that they\nare redundant in this application."),(0,a.kt)("h3",c({},{id:"generic-units"}),"Generic Units"),(0,a.kt)("h4",c({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use generic units to avoid code duplication."),(0,a.kt)("li",{parentName:"ul"},"Parameterize generic units for maximum adaptability."),(0,a.kt)("li",{parentName:"ul"},"Reuse common instantiations of generic units, as well as the generic\nunits themselves.")),(0,a.kt)("h4",c({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Ada does not allow data types to be passed as actual parameters to\nsubprograms during execution. Such parameters must be specified as\ngeneric formal parameters to a generic unit when it is instantiated.\nTherefore, if you want to write a subprogram for which there is\nvariation from call to call in the data type of objects on which it\noperates, then you must write the subprogram as a generic unit and\ninstantiate it once for each combination of data type parameters. The\ninstantiations of the unit can then be called as regular subprograms."),(0,a.kt)("p",null,"You can pass subprograms as actual parameters either by declaring\naccess-to-subprogram values or generic formal subprogram parameters. See\nGuideline 5.3.4 for a discussion of the tradeoffs."),(0,a.kt)("p",null,"If you find yourself writing two very similar routines differing only in\nthe data type they operate on or the subprograms they call, then it is\nprobably better to write the routine once as a generic unit and\ninstantiate it twice to get the two versions you need. When the need\narises later to modify the two routines, the change only needs to be\nmade in one place. This greatly facilitates maintenance."),(0,a.kt)("p",null,"Once you have made such a choice, consider other aspects of the routine\nthat these two instances may have in common but that are not essential\nto the nature of the routine. Factor these out as generic formal\nparameters. When the need arises later for a third similar routine, it\ncan be automatically produced by a third instantiation if you have\nforeseen all the differences between it and the other two. A\nparameterized generic unit can be very reusable."),(0,a.kt)("p",null,"It may seem that the effort involved in writing generic rather than\nnongeneric units is substantial. However, making units generic is not\nmuch more difficult or time-consuming than making them nongeneric once\nyou become familiar with the generic facilities. It is, for the most\npart, a matter of practice. Also, any effort put into the development of\nthe unit will be recouped when the unit is reused, as it surely will be\nif it is placed in a reuse library with sufficient visibility. Do not\nlimit your thinking about potential reuse to the application you are\nworking on or to other applications with which you are very familiar.\nApplications with which you are not familiar or future applications\nmight be able to reuse your software."),(0,a.kt)("p",null,"After writing a generic unit and placing it in your reuse library, the\nfirst thing you are likely to do is to instantiate it once for your\nparticular needs. At this time, it is a good idea to consider whether\nthere are instantiations that are very likely to be widely used. If so,\nplace each such instantiation in your reuse library so that they can be\nfound and shared by others."),(0,a.kt)("p",null,"See also Guideline 9.3.5."),(0,a.kt)("h3",c({},{id:"formal-private-and-limited-private-types"}),"Formal Private and Limited Private Types"),(0,a.kt)("h4",c({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private type for a generic formal type when\nyou do not need assignment on objects of the type inside the generic\nbody."),(0,a.kt)("li",{parentName:"ul"},"Consider using a nonlimited private type for a generic formal type\nwhen you need normal assignment on objects of the type inside the\nbody of the generic."),(0,a.kt)("li",{parentName:"ul"},"Consider using a formal tagged type derived from\nAda.Finalization.Controlled when you need to enforce special\nassignment semantics on objects of the type in the body of the\ngeneric."),(0,a.kt)("li",{parentName:"ul"},"Export the least restrictive type that maintains the integrity of\nthe data and abstraction while allowing alternate implementations."),(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private abstract type for generic formal\ntypes of a generic that extends a formal private tagged type.")),(0,a.kt)("h4",c({},{id:"example-1"}),"example"),(0,a.kt)("p",null,"The first example shows a case of a template providing only a data\nstructure, a case in which assignment is clearly not needed in the body\nof the generic:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element_Type is limited private;\npackage Generic_Doubly_Linked_Lists is\n   type Cell_Type;\n   type List_Type is access all Element_Type;\n   type Cell_Type is\n      record\n         Data     : Element_Type;\n         Next     : List_Type;\n         Previous : List_Type;\n      end record;\nend Generic_Doubly_Linked_Lists;\n")),(0,a.kt)("p",null,"The second example shows a template that composes new operations out of\n(nonassignment) operations passed as generic formal parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type Element_Type is limited private;\n   with procedure Process_Element (X : in out Element_Type);\n   type List_Type is array (Positive range <>) of Element_Type;\nprocedure Process_List (L : in out List_Type);\nprocedure Process_List (L : in out List_Type) is\nbegin -- Process_List\n   for I in L'Range loop\n      Process_Element (L(I));\n   end loop;\nend Process_List;\n------------------------------------------------------------------------\ngeneric\n   type Domain_Type is limited private;\n   type Intermediate_Type is limited private;\n   type Range_Type is limited private;\n   with function Left (X : Intermediate_Type) return Range_Type;\n   with function Right (X : Domain_Type) return Intermediate_Type;\nfunction Generic_Composition (X : Domain_Type) return Range_Type;\n-- the function Left o Right\nfunction Generic_Composition (X : Domain_Type) return Range_Type is\nbegin  -- generic_Composition\n   return Left (Right (X));\nend Generic_Composition;\n")),(0,a.kt)("p",null,"The third example shows how to use Ada's controlled types to provide\nspecial assignment semantics:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Finalization;\ngeneric\n   type Any_Element is new Ada.Finalization.Controlled with private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   type Stack is private;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Any_Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Any_Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n")),(0,a.kt)("h4",c({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"For a generic component to be usable in as many contexts as possible, it\nshould minimize the assumptions that it makes about its environment and\nshould make explicit any assumptions that are necessary. In Ada, the\nassumptions made by generic units can be stated explicitly by the types\nof the generic formal parameters. A limited private generic formal type\nprevents the generic unit from making any assumptions about the\nstructure of objects of the type or about operations defined for such\nobjects. A private (nonlimited) generic formal type allows the\nassumption that assignment and equality comparison operations are\ndefined for the type. Thus, a limited private data type cannot be\nspecified as the actual parameter for a private generic formal type."),(0,a.kt)("p",null,"In general, you should choose the private or limited private generic\nformal type based on the need for assignment inside a generic. Limited\nprivate types should be used for abstractions that do not need\nassignment, as in the first two examples above. In the third example,\nwhere assignment is needed, a type derived from a controlled type is\nspecified to ensure that the correct assignment semantics will be\navailable. If you need equality in the body of the generic, you may need\nto redefine equality as well to get the correct semantics; you would\nthen need to include a formal generic subprogram parameter for the =\nfunction."),(0,a.kt)("p",null,"The situation is reversed for types exported by a reusable part. For\nexported types, the restrictions specified by limited and limited\nprivate are restrictions on the user of the part, not on the part\nitself. To provide maximum capability to the user of a reusable part,\nexport types with as few restrictions as possible. Apply restrictions as\nnecessary to protect the integrity of the exported data structures and\nthe abstraction for the various implementations envisioned for that\ngeneric."),(0,a.kt)("p",null,"Because they are so restrictive, limited private types are not always\nthe best choice for types exported by a reusable part. In a case where\nit makes sense to allow the user to make copies of and compare data\nobjects, and when the underlying data type does not involve access types\n(so that the entire data structure gets copied or compared), then it is\nbetter to export a (nonlimited) private type. In a case where it makes\nsense to allow the user to make copies of and compare data objects and\nwhen the underlying data type involves access types (so that the entire\ndata structure gets copied or compared), then it is better to export a\ncontrolled type and an (overridden) equality operation. In cases where\nit does not detract from the abstraction to reveal even more about the\ntype, then a nonprivate type (e.g., a numeric, enumerated, record, or\narray type) should be used."),(0,a.kt)("p",null,"One use of generic units is to create a mixin generic (see Guideline\n8.3.8) to extend a tagged type. In this situation, you want to use the\nmost restrictive type as the generic formal type, that is, a formal type\nthat is both limited and abstract. When you instantiate the generic, if\nthe actual type is nonlimited, the type extension will also be\nnonlimited. In the generic package, you must declare the type extension\nas abstract. The instantiator of the generic can then extend the type\nagain to achieve the desired mixin configuration."),(0,a.kt)("h4",c({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"The predefined packages, Sequential_IO and Direct_IO, take private\ntypes. This will complicate I/O requirements for limited private types\nand should be considered during design."),(0,a.kt)("p",null,"There are also some cases where you must use a limited private formal\ntype. These cases arise when the formal type has an access discriminant,\nor the formal is used as the parent type in defining a type extension\nthat itself includes a component of a limited type (e.g., task type), or\nthe formal defines a new discriminant part with an access discriminant."),(0,a.kt)("h3",c({},{id:"using-generic-units-to-encapsulate-algorithms"}),"Using Generic Units to Encapsulate Algorithms"),(0,a.kt)("h4",c({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use generic units to encapsulate algorithms independently of data\ntype.")),(0,a.kt)("h4",c({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"This is the specification of a generic sort procedure:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   type Data    is array (Positive range <>) of Element;\n   with function Should_Precede (Left  : in     Element;\n                                 Right : in     Element)\n          return Boolean is <>;\n with procedure Swap (Left  : in out Element;\n                        Right : in out Element) is <>;\nprocedure Generic_Sort (Data_To_Sort : in out Data);\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The generic body looks just like a regular procedure body and can make\nfull use of the generic formal parameters in implementing the sort\nalgorithm:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nprocedure Generic_Sort (Data_To_Sort : in out Data) is\nbegin\n   ...\n   for I in Data_To_Sort'Range loop\n      ...\n         ...\n         if Should_Precede (Data_To_Sort(J), Data_To_Sort(I)) then\n            Swap(Data_To_Sort(I), Data_To_Sort(J));\n         end if;\n         ...\n      ...\n   end loop;\n   ...\nend Generic_Sort;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The generic procedure can be instantiated as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   type Integer_Array is array (Positive range <>) of Integer;\n   function Should_Precede (Left  : in     Integer;\n                            Right : in     Integer)\n     return Boolean;\n\n   procedure Swap (Left  : in out Integer;\n                   Right : in out Integer);\n   procedure Sort is\n      new Generic_Sort (Element => Integer,\n                        Data    => Integer_Array);\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype String_80    is String (1 .. 80);\n   type    String_Array is array (Positive range <>) of String_80;\n   function Should_Precede (Left  : in     String_80;\n                            Right : in     String_80)\n     return Boolean;\n\n   procedure Swap (Left  : in out String_80;\n                   Right : in out String_80);\n\n   procedure Sort is\n      new Generic_Sort (Element => String_80,\n                        Data    => String_Array);\n")),(0,a.kt)("p",null,"and called as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Integer_Array_1 : Integer_Array (1 .. 100);\n   ...\n   Sort (Integer_Array_1);\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   String_Array_1  : String_Array  (1 .. 100);\n   ...\n   Sort (String_Array_1);\n")),(0,a.kt)("h4",c({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"A sort algorithm can be described independently of the data type being\nsorted. This generic procedure takes the Element data type as a generic\nlimited private type parameter so that it assumes as little as possible\nabout the data type of the objects actually being operated on. It also\ntakes Data as a generic formal parameter so that instantiations can have\nentire arrays passed to them for sorting. Finally, it explicitly\nrequires the two operators that it needs to do the sort: Should_Precede\nand Swap. The sort algorithm is encapsulated without reference to any\ndata type. The generic can be instantiated to sort an array of any data\ntype. 8.3.5 Using Generic Units for Data Abstraction"),(0,a.kt)("h4",c({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using abstract data types (not to be confused with Ada's\nabstract types) in preference to abstract data objects."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic units to implement abstract data types\nindependently of their component data type.")),(0,a.kt)("h4",c({},{id:"example-3"}),"example"),(0,a.kt)("p",null,"This example presents a series of different techniques that can be used\nto generate abstract data types and objects. A discussion of the merits\nof each follows in the rationale section below. The first is an abstract\ndata object (ADO), which can be used to encapsulate an abstract state\nmachine. It encapsulates one stack of integers:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Bounded_Stack is\n   subtype Element is Integer;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The second example is an abstract data type (ADT). It differs from the\nADO by exporting the Stack type, which allows the user to declare any\nnumber of stacks of integers. Because multiple stacks may now exist, it\nis necessary to specify a Stack argument on calls to Push and Pop:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Bounded_Stack is\n   subtype Element is Integer;\n   type    Stack   is limited private;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The third example is a parameterless generic abstract data object\n(GADO). It differs from the ADO (the first example) simply by being\ngeneric, so that the user can instantiate it multiple times to obtain\nmultiple stacks of integers:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\npackage Bounded_Stack is\n   subtype Element is Integer;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The fourth example is a slight variant on the third, still a GADO but\nwith parameters. It differs from the third example by making the data\ntype of the stack a generic parameter so that stacks of data types other\nthan Integer can be created. Also, Maximum_Stack_Size has been made a\ngeneric parameter that defaults to 100 but can be specified by the user,\nrather than a constant defined by the package:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The fifth example is a generic abstract data type (GADT). It differs\nfrom the GADO in the fourth example in the same way that the ADT in the\nsecond example differed from the ADO in the first example; it exports\nthe Stack type, which allows the user to declare any number of stacks:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   type Stack is private;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"The biggest advantage of an ADT over an ADO (or a GADT over a GADO) is\nthat the user of the package can declare as many objects as desired with\nan ADT. These objects can be declared as standalone variables or as\ncomponents of arrays and records. They can also be passed as parameters.\nNone of this is possible with an ADO, where the single data object is\nencapsulated inside of the package. Furthermore, an ADO provides no more\nprotection of the data structure than an ADT. When a private type is\nexported by the ADT package, as in the example above, then for both the\nADO and ADT, the only legal operations that can modify the data are\nthose defined explicitly by the package (in this case, Push and Pop).\nFor these reasons, an ADT or GADT is almost always preferable to an ADO\nor GADO, respectively."),(0,a.kt)("p",null,"A GADO is similar to an ADT in one way: it allows multiple objects to be\ncreated by the user. With an ADT, multiple objects can be declared using\nthe type defined by the ADT package. With a GADO (even a GADO with no\ngeneric formal parameters, as shown in the third example), the package\ncan be instantiated multiple times to produce multiple objects. However,\nthe similarity ends there. The multiple objects produced by the\ninstantiations suffer from all restrictions described above for ADOs;\nthey cannot be used in arrays or records or passed as parameters.\nFurthermore, the objects are each of a different type, and no operations\nare defined to operate on more than one of them at a time. For example,\nthere cannot be an operation to compare two such objects or to assign\none to another. The multiple objects declared using the type defined by\nan ADT package suffer from no such restrictions; they can be used in\narrays and records and can be passed as parameters. Also, they are all\ndeclared to be of the same type, so that it is possible for the ADT\npackage to provide operations to assign, compare, copy, etc. For these\nreasons, an ADT is almost always preferable to a parameterless GADO."),(0,a.kt)("p",null,"The biggest advantage of a GADT or GADO over an ADT or ADO,\nrespectively, is that the GADT and GADO are generic and can thus be\nparameterized with types, subprograms, and other configuration\ninformation. Thus, as shown above, a single generic package can support\nbounded stacks of any data type and any stack size, while the ADT and\nADO above are restricted to stacks of Integer, no more than 100 in size.\nFor this reason, a GADO or GADT is almost always preferable to an ADO or\nADT."),(0,a.kt)("p",null,"The list of examples above is given in order of increasing power and\nflexibility, starting with an ADO and ending with a GADT. These\nadvantages are not expensive in terms of complexity or development time.\nThe specification of the GADT above is not significantly harder to write\nor understand than the specification of the ADO. The bodies are also\nnearly identical."),(0,a.kt)("p",null,"Compare the body for the simplest version, the ADO:"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"package body Bounded_Stack is"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," type Stack_Slots is array (Natural range <>) of Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"type Stack_Information is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"record"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Slots : Stack_Slots (1 .. Maximum_Stack_Size);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Index : Natural := 0;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end record;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack : Stack_Information;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Push (New_Element : in Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if Stack.Index >= Maximum_Stack_Size then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Overflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Index := Stack.Index + 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Slots(Stack.Index) := New_Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Push;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Pop (Top_Element : out Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if Stack.Index <= 0 then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Underflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element := Stack.Slots(Stack.Index);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Index := Stack.Index - 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Pop;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"...")),(0,a.kt)("p",null,"end Bounded_Stack;"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"with the body for the most powerful and flexible version, the GADT:"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"package body Bounded_Stack is"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," type Stack_Slots is array (Natural range <>) of Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"type Stack_Information is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"record"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Slots : Stack_Slots (1 .. Maximum_Stack_Size);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Index : Natural := 0;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end record;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Push (On_Top : in out Stack;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"New_Element : in Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if On_Top.Index >= Maximum_Stack_Size then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Overflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"On_Top.Index := On_Top.Index + 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"On_Top.Slots(On_Top.Index) := New_Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Push;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Pop (From_Top : in out Stack;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element : out Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if From_Top.Index <= 0 then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Underflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element := From_Top.Slots(From_Top.Index);")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," From_Top.Index := From_Top.Index - 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Pop;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"...")),(0,a.kt)("p",null,"end Bounded_Stack;"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"There is only one difference. The ADO declares a local object called\nStack, while the GADT has one additional parameter (called Stack) on\neach of the exported procedures Push and Pop."),(0,a.kt)("h3",c({},{id:"iterators"}),"Iterators"),(0,a.kt)("h4",c({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide iterators for traversing complex data structures within\nreusable parts."),(0,a.kt)("li",{parentName:"ul"},"Consider providing both active and passive iterators."),(0,a.kt)("li",{parentName:"ul"},"Protect the iterators from errors due to modification of the data\nstructure during iteration."),(0,a.kt)("li",{parentName:"ul"},"Document the behavior of the iterators when the data structure is\nmodified during traversal.")),(0,a.kt)("h4",c({},{id:"example-4"}),"example"),(0,a.kt)("p",null,'Ada provides several mechanisms for building reusable iterators. The\nfollowing examples discuss the alternatives of "simple" generics, access\ndiscriminants, and type extension. The terms active and passive are used\nto differentiate whether the iteration mechanism (i.e., the way in which\nthe complex data structure is traversed) is exposed or hidden. A passive\niterator hides the traversal (e.g., looping mechanism) and consists of a\nsingle operation, iterate, that is parameterized by the processing you\ndo on each element of the data structure. By contrast, an active\niterator exposes the primitive operations by which you traverse the data\nstructure (Booch 1987).'),(0,a.kt)("p",null,"The first example shows a generic package that defines an abstract list\ndata type, with both active and passive iterators for traversing a list:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'------------------------------------------------------------------------\ngeneric\n   type Element is limited private;\n   ...\npackage Unbounded_List is\n   type List is limited private;\n   procedure Insert (New_Element : in     Element;\n                     Into        : in out List);\n   -- Passive (generic) iterator.\n   generic\n      with procedure Process (Each : in out Element);\n   procedure Iterate (Over : in     List);\n   -- Active iterator\n   type Iterator is limited private;\n\n   procedure Initialize (Index         : in out Iterator;\n                         Existing_List : in     List);\n\n   function  More       (Index         : in     Iterator)\n     return Boolean;\n\n   -- The procedure Get_Next combines an "Advance" and "Current" function\n   procedure Get_Next   (Index           : in out Iterator;\n                         Current_Element :    out Element);\n   ...\nprivate\n   ...\nend Unbounded_List;\n------------------------------------------------------------------------\n')),(0,a.kt)("p",null,"After instantiating the generic package and declaring a list as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Unbounded_List;\nprocedure List_User is\n   type Employee is ...;\n   package Roster is\n      new Unbounded_List (Element => Employee, ...);\n   Employee_List : Roster.List;\n")),(0,a.kt)("p",null,"the passive iterator is instantiated, specifying the name of the routine\nthat should be called for each list element when the iterator is called."),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ---------------------------------------------------------------------\n   procedure Process_Employee (Each : in out Employee) is\n   begin\n      ...\n      -- Perform the required action for EMPLOYEE here.\n   end Process_Employee;\n   ---------------------------------------------------------------------\n   procedure Process_All is\n      new Roster.Iterate (Process => Process_Employee);\n")),(0,a.kt)("p",null,"The passive iterator can then be called as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"begin  -- List_User\n   Process_All (Employee_List);\nend List_User;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"Alternatively, the active iterator can be used without the second\ninstantiation required by the passive iterator:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Iterator         : Roster.Iterator;\n   Current_Employee : Employee;\n   procedure Process_Employee (Each : in     Employee) is separate;\nbegin  -- List_User\n   Roster.Initialize (Index         => Iterator,\n                      Existing_List => Employee_List);\n\n   while Roster.More (Iterator) loop\n\n      Roster.Get_Next (Index           => Iterator,\n                       Current_Element => Current_Employee);\n\n      Process_Employee (Current_Employee);\n\n   end loop;\nend List_User;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The second example shows a code excerpt from Rationale (1995, \xa73.7.1) on\nhow to construct iterators using access discriminants:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type Element is private;\npackage Sets is\n   type Set is limited private;\n   ... -- various set operations\n   type Iterator (S : access Set) is limited private;\n   procedure Start (I : Iterator);\n   function Done (I : Iterator) return Boolean;\n   procedure Next (I : in out Iterator);\n   ...  -- other iterator operations\nprivate\n   type Node;\n   type Ptr is access Node;\n   type Node is\n      record\n         E    : Element;\n         Next : Ptr;\n      end record;\n   type Set is new Ptr;\n   type Iterator (S : access Set) is\n      record\n         This : Ptr;\n      end record;\nend Sets;\npackage body Sets is\n   ...  -- bodies of the various set operations\n   procedure Start (I : in out Iterator) is\n   begin\n      I.This := Ptr(I.S.all);\n   end Start;\n   function Done (I : Iterator) return Boolean is\n   begin\n      return I.This = null;\n   end Done;\n   procedure Next (I : in out Iterator) is\n   begin\n      I.This := I.This.Next;\n   end Next;\n   ...\nend Sets;\n")),(0,a.kt)("p",null,"The iterator operations allow you to iterate over the elements of the\nset with the component This of the iterator object accessing the current\nelement. The access discriminant always points to the enclosing set to\nwhich the current element belongs."),(0,a.kt)("p",null,"The third example uses code fragments from Rationale (1995, \xa74.4.4) to\nshow an iterator using type extension and dispatching:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Element is ...\npackage Sets is\n   type Set is limited private;\n   -- various set operations\n   type Iterator is abstract tagged null record;\n   procedure Iterate (S : in Set; IC : in out Iterator'Class);\n   procedure Action (E : in out Element;\n                     I : in out Iterator) is abstract;\nprivate\n   -- definition of Node, Ptr (to Node), and Set\nend Sets;\npackage body Sets is\n   ...\n   procedure Iterate (S : in Set; IC : in out Iterator'Class) is\n      This : Ptr := Ptr (S);\n   begin\n      while This /= null loop\n         Action (This.E, IC);  -- dispatch\n         This := This.Next;\n      end loop;\n   end Iterate;\nend Sets;\n")),(0,a.kt)("p",null,"The general purpose iterator looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"package Sets.Something is\n   procedure Do_Something (S : Set; P : Parameters);\nend Sets.Something;\npackage body Sets.Something is\n   type My_Iterator is new Iterator with\n      record\n         -- components for parameters and workspace\n      end record;\n   procedure Action (E : in out Element;\n                     I : in out My_Iterator) is\n   begin\n      -- do something to element E using data from iterator I\n   end Action;\n   procedure Do_Something (S : Set; P : Parameters) is\n      I : My_Iterator;\n   begin  -- Do_Something\n      ...  -- copy parameters into iterator\n      Iterate (S, I);\n      ... copy any results from iterator back to parameters\n   end Do_Something;\n\nend Sets.Something;\n")),(0,a.kt)("h4",c({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"Iteration over complex data structures is often required and, if not\nprovided by the part itself, can be difficult to implement without\nviolating information hiding principles."),(0,a.kt)("p",null,"Active and passive iterators each have their advantages, but neither is\nappropriate in all situations. Therefore, it is recommended that both be\nprovided to give the user a choice of which to use in each situation."),(0,a.kt)("p",null,"Passive iterators are simpler and less error-prone than active\niterators, in the same way that the for loop is simpler and less\nerror-prone than the while loop. There are fewer mistakes that the user\ncan make in using a passive iterator. Simply instantiate it with the\nroutine to be executed for each list element, and call the instantiation\nfor the desired list. Active iterators require more care by the user.\nCare must be taken to invoke the iterator operations in the proper\nsequence and to associate the proper iterator variable with the proper\nlist variable. It is possible for a change made to the software during\nmaintenance to introduce an error, perhaps an infinite loop."),(0,a.kt)("p",null,"On the other hand, active iterators are more flexible than passive\niterators. With a passive iterator, it is difficult to perform multiple,\nconcurrent, synchronized iterations. For example, it is much easier to\nuse active iterators to iterate over two sorted lists, merging them into\na third sorted list. Also, for multidimensional data structures, a small\nnumber of active iterator routines may be able to replace a large number\nof passive iterators, each of which implements one combination of the\nactive iterators. Finally, active iterators can be passed as generic\nformal parameters while passive iterators cannot because passive\niterators are themselves generic, and generic units cannot be passed as\nparameters to other generic units."),(0,a.kt)("p",null,'For either type of iterator, semantic questions can arise about what\nhappens when the data structure is modified as it is being iterated.\nWhen writing an iterator, be sure to consider this possibility, and\nindicate with comments the behavior that occurs in such a case. It is\nnot always obvious to the user what to expect. For example, to determine\nthe "closure" of a mathematical "set" with respect to some operation, a\ncommon algorithm is to iterate over the members of the set, generating\nnew elements and adding them to the set. In such a case, it is important\nthat elements added to the set during the iteration be encountered\nsubsequently during the iteration. On the other hand, for other\nalgorithms, it may be important that the iterated set is the same set\nthat existed at the beginning of the iteration. In the case of a\nprioritized list data structure, if the list is iterated in priority\norder, it may be important that elements inserted at lower priority than\nthe current element during iteration not be encountered subsequently\nduring the iteration but that elements inserted at a higher priority\nshould be encountered. In any case, make a conscious decision about how\nthe iterator should operate, and document that behavior in the package\nspecification.'),(0,a.kt)("p",null,"Deletions from the data structure also pose a problem for iterators. It\nis a common mistake for a user to iterate over a data structure,\ndeleting it piece by piece during the iteration. If the iterator is not\nprepared for such a situation, it is possible to end up dereferencing a\nnull pointer or committing a similar error. Such situations can be\nprevented by storing extra information with each data structure, which\nindicates whether it is currently being iterated, and using this\ninformation to disallow any modifications to the data structure during\niteration. When the data structure is declared as a limited private\ntype, as should usually be the case when iterators are involved, the\nonly operations defined on the type are declared explicitly in the\npackage that declares the type, making it possible to add such tests to\nall modification operations."),(0,a.kt)("p",null,"The Rationale (1995, \xa74.4.4) notes that the access discriminant and type\nextension techniques are inversions of each other. In the access\ndiscriminant approach, you have to write out the looping mechanism for\neach action. In the type extension approach, you write one loop and\ndispatch to the desired action. Thus, an iterator that uses the access\ndiscriminant technique would be considered active, while an iterator\nthat uses the type extension technique would be considered passive."),(0,a.kt)("h4",c({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"You can use an access to subprogram type as an alternative to generic\ninstantiation, using a nongeneric parameter as a pointer to subprogram.\nYou would then apply the referenced subprogram to every element in a\ncollection ( Rationale 1995, \xa73.7.2). There are drawbacks to this\napproach, however, because you cannot use it to create a general purpose\niterator. Anonymous access to subprogram parameters is not allowed in\nAda; thus, the following fragment is illegal:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"procedure Iterate (C      : Collection;\n                   Action : access procedure (E : in out Element));\n")),(0,a.kt)("p",null,"The formal parameter Action must be of a named access subtype, as in:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Action_Type is access procedure (E : in out Element);\nprocedure Iterate (C      : Collection;\n                   Action : Action_Type);\n")),(0,a.kt)("p",null,"In order for this to work, you must make sure that the action subprogram\nis in scope and not defined internal to another subprogram. If it is\ndefined as a nested procedure, it would be illegal to access it. See the\nRationale (1995, \xa74.4.4) for a more complete example."),(0,a.kt)("p",null,"For further discussion of passive and active iterators, see the\nRationale (1995, \xa73.7.1 and \xa74.4.4), Ross (1989), and Booch (1987)."),(0,a.kt)("h3",c({},{id:"decimal-type-output-and-information-systems-annex"}),"Decimal Type Output and Information Systems Annex"),(0,a.kt)("h4",c({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Localize the currency symbol, digits separator, radix mark, and fill\ncharacter in picture output."),(0,a.kt)("li",{parentName:"ul"},"Consider using the ","#"," character in picture layouts so that the\nedited numeric output lengths are invariant across currency symbols\nof different lengths.")),(0,a.kt)("h4",c({},{id:"example-5"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Text_IO.Editing;\npackage Currency is\n\n   type Dollars is delta 0.01 digits 10;\n   type Marks   is delta 0.01 digits 10;\n\n   package Dollar_Output is\n      new Ada.Text_IO.Editing.Decimal_Output\n             (Num                => Dollars,\n              Default_Currency   => \"$\",\n              Default_Fill       => '*',\n              Default_Separator  => ',',\n              Default_Radix_Mark => '.');\n\n   package Mark_Output is\n      new Ada.Text_IO.Editing.Decimal_Output\n             (Num                => Marks,\n              Default_Currency   => \"DM\",\n              Default_Fill       => '*',\n              Default_Separator  => '.',\n              Default_Radix_Mark => ',');\n\nend Currency;\nwith Ada.Text_IO.Editing;\nwith Currency;  use Currency;\nprocedure Test_Picture_Editing is\n\n   DM_Amount     : Marks;\n   Dollar_Amount : Dollars;\n\n   Amount_Picture : constant Ada.Text_IO.Editing.Picture\n      := Ada.Text_IO.Editing.To_Picture (\"##ZZ_ZZZ_ZZ9.99\");\n\nbegin   -- Test_Picture_Editing\n\n   DM_Amount     := 1_234_567.89;\n   Dollar_Amount := 1_234_567.89;\n\n   DM_Output.Put (Item => DM_Amount,\n                  Pic  => Amount_Picture);\n\n   Dollar_Output.Put (Item => Dollar_Amount,\n                      Pic  => Amount_Picture);\n\nend Test_Picture_Editing;\n")),(0,a.kt)("h4",c({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"Currencies differ in how they are displayed in a report. Currencies use\ndifferent symbols of different lengths (e.g., the American $, the German\nDM, and the Austrian \xd6S). They use different symbols to separate digits.\nThe United States and the United Kingdom use the comma to separate\ngroups of thousands, whereas Continental Europe uses the period. The\nUnited States and the United Kingdom use a period as a decimal point;\nContinental Europe uses the comma. For a program involving financial\ncalculations that is to be reused across countries, you need to take\nthese differences into account. By encapsulating them, you limit the\nimpact of change in adapting the financial package."),(0,a.kt)("h3",c({},{id:"implementing-mixins"}),"Implementing Mixins"),(0,a.kt)("h4",c({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Consider using abstract tagged types and generics to define reusable\nunits of functionality that can be "mixed into" core abstractions\n(also known as mixins).')),(0,a.kt)("h4",c({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"Note the use of an abstract tagged type as a generic formal parameter\nand as the exported extended type in the pattern that follows, excerpted\nfrom the Rationale (1995, \xa74.6.2):"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type S is abstract tagged private;\npackage P is\n   type T is abstract new S with private;\n   -- operations on T\nprivate\n   type T is abstract new S with\n      record\n         -- additional components\n      end record;\nend P;\n")),(0,a.kt)("p",null,'The following code shows how the generic might be instantiated to\n"mixin" the desired features in the final type extension. See also\nGuideline 9.5.1 for a related example of code.'),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"-- Assume that packages P1, P2, P3, and P4 are generic packages which take a tagged\n-- type as generic formal type parameter and which export a tagged type T\npackage Q is\n   type My_T is new Basic_T with private;\n   ... -- exported operations\nprivate\n   package Feature_1 is new P1 (Basic_T);\n   package Feature_2 is new P2 (Feature_1.T);\n   package Feature 3 is new P3 (Feature_2.T);\n   package Feature_4 is new P4 (Feature_3.T);\n   -- etc.\n   type My_T is new Feature_4.T with null record;\nend Q;\n")),(0,a.kt)("h4",c({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"The Rationale (1995, \xa74.6.2) discusses the use of a generic template to\ndefine the properties to be mixed in to your abstraction:"),(0,a.kt)("p",null,"The generic template defines the mixin. The type supplied as generic\nactual parameter determines the parent . . . the body provides the\noperations and the specification exports the extended type."),(0,a.kt)("p",null,"If you have defined a series of generic mixin packages, you would then\nserialize the instantiations. The actual parameter to the next\ninstantiation is the exported tagged type from the previous\ninstantiation. This is shown in the second code segment in the example.\nEach extension is derived from a previous extension, so you have a\nlinearized succession of overriding subprograms. Because they are\nlinearized, you have a derivation order you can use to resolve any\nconflicts."),(0,a.kt)("p",null,"You should encapsulate one extension (and related operations) per\ngeneric package. This provides a better separation of concerns and more\nmaintainable, reusable components."),(0,a.kt)("p",null,"See Guideline 9.5.1 for a full discussion of the use of mixins."))}k.isMDXComponent=!0}}]);