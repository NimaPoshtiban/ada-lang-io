"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2859],{1716:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(a),h=i,u=p["".concat(s,".").concat(h)]||p[h]||d[h]||r;return a?n.createElement(u,l(l({ref:t},m),{},{components:a})):n.createElement(u,l({ref:t},m))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=a[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},9829:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:3},l="2 Lexical Elements",o={unversionedId:"arm/AA-2",id:"arm/AA-2",title:"2 Lexical Elements",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-2.md",sourceDirName:"arm",slug:"/arm/AA-2",permalink:"/docs/arm/AA-2",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"1 General",permalink:"/docs/arm/AA-1"},next:{title:"3 Declarations and Types",permalink:"/docs/arm/AA-3"}},s={},c=[{value:"2.1  Character Set",id:"21--character-set",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"2.2  Lexical Elements, Separators, and Delimiters",id:"22--lexical-elements-separators-and-delimiters",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"2.3  Identifiers",id:"23--identifiers",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"2.4  Numeric Literals",id:"24--numeric-literals",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"2.4.1  Decimal Literals",id:"241--decimal-literals",level:3},{value:"Syntax",id:"syntax-3",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"2.4.2  Based Literals",id:"242--based-literals",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"2.5  Character Literals",id:"25--character-literals",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"2.6  String Literals",id:"26--string-literals",level:2},{value:"Syntax",id:"syntax-6",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"2.7  Comments",id:"27--comments",level:2},{value:"Syntax",id:"syntax-7",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Examples",id:"examples-5",level:4},{value:"2.8  Pragmas",id:"28--pragmas",level:2},{value:"Syntax",id:"syntax-8",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-6",level:4},{value:"Syntax",id:"syntax-9",level:4},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"Examples",id:"examples-6",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-7",level:4},{value:"2.9  Reserved Words",id:"29--reserved-words",level:2},{value:"Syntax",id:"syntax-10",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-8",level:4}],m={toc:c};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2-lexical-elements"},"2 Lexical Elements"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"[The text of a program consists of the texts of one or more compilations. The text of a compilation is a sequence of lexical elements, each composed of characters; the rules of composition are given in this section. Pragmas, which provide certain information for the compiler, are also described in this section.]"," "),(0,i.kt)("h2",{id:"21--character-set"},"2.1  Character Set"),(0,i.kt)("p",null,"The only characters allowed outside of comments are the graphic_characters and format_effectors."),(0,i.kt)("p",null,"Ramification: Any character, including an other_control_function, is allowed in a comment."),(0,i.kt)("p",null,"Note that this rule doesn't really have much force, since the implementation can represent characters in the source in any way it sees fit. For example, an implementation could simply define that what seems to be a nongraphic, non-format-effector character is actually a representation of the space character. "),(0,i.kt)("p",null,'Discussion: It is our intent to follow the terminology of ISO 10646 BMP where appropriate, and to remain compatible with the character classifications defined in A.3, "Character Handling".Note that our definition for graphic_character is more inclusive than that of ISO 10646-1. '),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"character ::= graphic_character | format_effector | other_control_function"),(0,i.kt)("p",null,"graphic_character ::= identifier_letter | digit | space_character | special_character"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The character repertoire for the text of an Ada program consists of the collection of characters called the Basic Multilingual Plane (BMP) of the ISO 10646 Universal Multiple-Octet Coded Character Set, plus a set of format_effectors and, in comments only, a set of other_control_functions; the coded representation for these characters is implementation defined ","[(it need not be a representation defined within ISO-10646-1)]",". "),(0,i.kt)("p",null,"Implementation defined: The coded representation for the text of an Ada program."),(0,i.kt)("p",null,"The description of the language definition in this document uses the graphic symbols defined for Row 00: Basic Latin and Row 00: Latin-1 Supplement of the ISO 10646 BMP; these correspond to the graphic symbols of ISO 8859-1 (Latin-1); no graphic symbols are used in this document for characters outside of Row 00 of the BMP. The actual set of graphic symbols used by an implementation for the visual representation of the text of an Ada program is not specified. "),(0,i.kt)("p",null,"The categories of characters are defined as follows: "),(0,i.kt)("p",null,"identifier_letterupper_case_identifier_letter | lower_case_identifier_letter "),(0,i.kt)("p",null,'Discussion: We use identifier_letter instead of simply letter because ISO 10646 BMP includes many other characters that would generally be considered "letters". '),(0,i.kt)("p",null,'upper_case_identifier_letterAny character of Row 00 of ISO 10646 BMP whose name begins "Latin Capital Letter".'),(0,i.kt)("p",null,'lower_case_identifier_letterAny character of Row 00 of ISO 10646 BMP whose name begins "Latin Small Letter". '),(0,i.kt)("p",null,"To be honest: The above rules do not include the ligatures \ufffd and \ufffd. However, the intent is to include these characters as identifier letters. This problem was pointed out by a comment from the Netherlands. "),(0,i.kt)("p",null,"digitOne of the characters 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9."),(0,i.kt)("p",null,'space_characterThe character of ISO 10646 BMP named "Space".'),(0,i.kt)("p",null,"special_characterAny character of the ISO 10646 BMP that is not reserved for a control function, and is not the space_character, an identifier_letter, or a digit. "),(0,i.kt)("p",null,"Ramification: Note that the no break space and soft hyphen are special_characters, and therefore graphic_characters. They are not the same characters as space and hyphen-minus. "),(0,i.kt)("p",null,"format_effectorThe control functions of ISO 6429 called character tabulation (HT), line tabulation (VT), carriage return (CR), line feed (LF), and form feed (FF). "),(0,i.kt)("p",null,"other_control_functionAny control function, other than a format_effector, that is allowed in a comment; the set of other_control_functions allowed in comments is implementation defined. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: The control functions allowed in comments."),(0,i.kt)("p",null,"The following names are used when referring to certain special_characters: "),(0,i.kt)("p",null,"Discussion: These are the ones that play a special role in the syntax of Ada 95, or in the syntax rules; we don't bother to define names for all characters. The first name given is the name from ISO 10646-1; the subsequent names, if any, are those used within the standard, depending on context. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  symbol\n\n     \"\n     #\n     &\n     '\n     (\n     )\n     *\n     +\n     ,\n     \n     .\n\n     / \n")),(0,i.kt)("p",null,"name"),(0,i.kt)("p",null,"quotation mark\nnumber sign\nampersand\napostrophe, tick\nleft parenthesis\nright parenthesis\nasterisk, multiply\nplus sign\ncomma\nhyphen-minus, minus\nfull stop, dot, point"),(0,i.kt)("p",null,"solidus, divide"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  symbol\n\n     :\n     ;\n     &lt\n     =\n     &gt\n     _\n     |\n     [\n     ]\n     {\n")),(0,i.kt)("p",null,",Old=","<",">",">","],Old=","<","         }",">",">"," "),(0,i.kt)("p",null,"name"),(0,i.kt)("p",null,"colon\nsemicolon\nless-than sign\nequals sign\ngreater-than sign\nlow line, underline\nvertical line\nleft square bracket\nright square bracket\nleft curly bracket"),(0,i.kt)("p",null,"right curly bracket "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"In a nonstandard mode, the implementation may support a different character repertoire","[; in particular, the set of characters that are considered identifier_letters can be extended or changed to conform to local conventions]",". "),(0,i.kt)("p",null,'Ramification: If an implementation supports other character sets, it defines which characters fall into each category, such as "identifier_letter", and what the corresponding rules of this section are, such as which characters are allowed in the text of a program.'),(0,i.kt)("p",null,"NOTE   Every code position of ISO 10646 BMP that is not reserved for a control function is defined to be a graphic_character by this document. This includes all code positions other than 0000 - 001F, 007F - 009F, and FFFE - FFFF."),(0,i.kt)("p",null,"NOTE   The language does not specify the source representation of programs. "),(0,i.kt)("p",null,"Discussion: Any source representation is valid so long as the implementer can produce an (information-preserving) algorithm for translating both directions between the representation and the standard character set. (For example, every character in the standard character set has to be representable, even if the output devices attached to a given computer cannot print all of those characters properly.) From a practical point of view, every implementer will have to provide some way to process the ACVC. It is the intent to allow source representations, such as parse trees, that are not even linear sequences of characters. It is also the intent to allow different fonts: reserved words might be in bold face, and that should be irrelevant to the semantics. "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Ada 95 allows 8-bit and 16-bit characters, as well as implementation-specified character sets. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The syntax rules in this clause are modified to remove the emphasis on basic characters vs. others. (In this day and age, there is no need to point out that you can write programs without using (for example) lower case letters.) In particular, character (representing all characters usable outside comments) is added, and basic_graphic_character, other_special_character, and basic_character are removed. Special_character is expanded to include Ada 83\'s other_special_character, as well as new 8-bit characters not present in Ada 83. Note that the term "basic letter" is used in A.3, "Character Handling" to refer to letters without diacritical marks.'),(0,i.kt)("p",null,"Character names now come from ISO 10646."),(0,i.kt)("p",null,"We use identifier_letter rather than letter since ISO 10646 BMP includes many \"letters' that are not permitted in identifiers (in the standard mode). "),(0,i.kt)("h2",{id:"22--lexical-elements-separators-and-delimiters"},"2.2  Lexical Elements, Separators, and Delimiters"),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"The text of a program consists of the texts of one or more compilations. The text of each compilation is a sequence of separate lexical elements. Each lexical element is formed from a sequence of characters, and is either a delimiter, an identifier, a reserved word, a numeric_literal, a character_literal, a string_literal, or a comment. The meaning of a program depends only on the particular sequences of lexical elements that form its compilations, excluding comments."),(0,i.kt)("p",null,"The text of a compilation is divided into lines. In general, the representation for an end of line is implementation defined. However, a sequence of one or more format_effectors other than character tabulation (HT) signifies at least one end of line. "),(0,i.kt)("p",null,"Implementation defined: The representation for an end of line."),(0,i.kt)("p",null,"[In some cases an explicit separator is required to separate adjacent lexical elements.]"," A separator is any of a space character, a format effector, or the end of a line, as follows: "),(0,i.kt)("p",null,'Discussion: It might be useful to define "white space" and use it here. '),(0,i.kt)("p",null,"A space character is a separator except within a comment, a string_literal, or a character_literal."),(0,i.kt)("p",null,"Character tabulation (HT) is a separator except within a comment."),(0,i.kt)("p",null,"The end of a line is always a separator. "),(0,i.kt)("p",null,"One or more separators are allowed between any two adjacent lexical elements, before the first of each compilation, or after the last. At least one separator is required between an identifier, a reserved word, or a numeric_literal and an adjacent identifier, reserved word, or numeric_literal."),(0,i.kt)("p",null,"A delimiter is either one of the following special characters "),(0,i.kt)("p",null,"&    '    (    )    *    +    ,        .    /    :    ;    ","<","    =    ",">","    |"),(0,i.kt)("p",null,"or one of the following compound delimiters each composed of two adjacent special characters "),(0,i.kt)("p",null,"=",">","    ..    **    :=    /=    ",">","=    ","<","=    ","<","<","    ",">",">","    ","<",">"),(0,i.kt)("p",null,"Each of the special characters listed for single character delimiters is a single delimiter except if this character is used as a character of a compound delimiter, or as a character of a comment, string_literal, character_literal, or numeric_literal."),(0,i.kt)("p",null,"The following names are used when referring to compound delimiters:"),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"delimiter name=",">",'arrow..double dot**double star, exponentiate:=assignment (pronounced: "becomes")/=inequality (pronounced: "not equal")',">","=greater than or equal","<","=less than or equal","<","<","left label bracket",">",">","right label bracket","<",">","boxAn implementation shall support lines of at least 200 characters in length, not counting any characters used to signify the end of a line. An implementation shall support lexical elements of at least 200 characters in length. The maximum supported line length and lexical element length are implementation defined. "),(0,i.kt)("p",null,"Implementation defined: Maximum supported line length and lexical element length."),(0,i.kt)("p",null,"Discussion: From URG recommendation. "),(0,i.kt)("h2",{id:"23--identifiers"},"2.3  Identifiers"),(0,i.kt)("p",null,"Identifiers are used as names. "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"identifier ::=\nidentifier_letter {","[underline]"," letter_or_digit}"),(0,i.kt)("p",null,"letter_or_digit ::= identifier_letter | digit"),(0,i.kt)("p",null,"An identifier shall not be a reserved word. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"All characters of an identifier are significant, including any underline character. Identifiers differing only in the use of corresponding upper and lower case letters are considered the same. "),(0,i.kt)("p",null,'Discussion: Two of the letters of ISO 8859-1 appear only as lower case, "sharp s" and "y with diaeresis". These two letters have no corresponding upper case letter (in particular, they are not considered equivalent to one another).'),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"In a nonstandard mode, an implementation may support other upper/lower case equivalence rules for identifiers","[, to accommodate local conventions]",". "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of identifiers: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Count      X    Get_Symbol   Ethelyn   Marion\nSnobol_4   X1   Page_Count   Store_Next_Item\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We no longer include reserved words as identifiers. This is not a language change. In Ada 83, identifier included reserved words. However, this complicated several other rules (for example, regarding implementation-defined attributes and pragmas, etc.). We now explicitly allow certain reserved words for attribute designators, to make up for the loss. "),(0,i.kt)("p",null,"Ramification: Because syntax rules are relevant to overload resolution, it means that if it looks like a reserved word, it is not an identifier. As a side effect, implementations cannot use reserved words as implementation-defined attributes or pragma names. "),(0,i.kt)("h2",{id:"24--numeric-literals"},"2.4  Numeric Literals"),(0,i.kt)("p",null,"There are two kinds of numeric_literals, real literals and integer literals. A real literal is a numeric_literal that includes a point; an integer literal is a numeric_literal without a point. "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"numeric_literal ::= decimal_literal | based_literal"),(0,i.kt)("p",null,"NOTE 1   The type of an integer literal is universal_integer. The type of a real literal is universal_real. "),(0,i.kt)("h3",{id:"241--decimal-literals"},"2.4.1  Decimal Literals"),(0,i.kt)("p",null,"A decimal_literal is a numeric_literal in the conventional decimal notation (that is, the base is ten). "),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"decimal_literal ::= numeral ","[.numeral][exponent]"),(0,i.kt)("p",null,"numeral ::= digit {","[underline]"," digit}"),(0,i.kt)("p",null,"exponent ::= E ","[+]"," numeral | E  numeral"),(0,i.kt)("p",null,"An exponent for an integer literal shall not have a minus sign. "),(0,i.kt)("p",null,"Ramification: Although this rule is in this subclause, it applies also to the next subclause. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"An underline character in a numeric_literal does not affect its meaning. The letter E of an exponent can be written either in lower case or in upper case, with the same meaning. "),(0,i.kt)("p",null,"Ramification: Although these rules are in this subclause, they apply also to the next subclause. "),(0,i.kt)("p",null,"An exponent indicates the power of ten by which the value of the decimal_literal without the exponent is to be multiplied to obtain the value of the decimal_literal with the exponent. "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Examples of decimal literals: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"12        0      1E6    123_456    --  integer literals\n\n12.0      0.0    0.456  3.14159_26 --  real literals\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have changed the syntactic category name integer to be numeral. We got this idea from ACID. It avoids the confusion between this and integers. (Other places don't offer similar confusions. For example, a string_literal is different from a string.) "),(0,i.kt)("h3",{id:"242--based-literals"},"2.4.2  Based Literals"),(0,i.kt)("p",null,"[ A based_literal is a numeric_literal expressed in a form that specifies the base explicitly.]"," "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"based_literal ::=\nbase # based_numeral ","[.based_numeral]"," # ","[exponent]"),(0,i.kt)("p",null,"base ::= numeral"),(0,i.kt)("p",null,"based_numeral ::=\nextended_digit {","[underline]"," extended_digit}"),(0,i.kt)("p",null,"extended_digit ::= digit | A | B | C | D | E | F"),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"The base (the numeric value of the decimal numeral preceding the first #) shall be at least two and at most sixteen. The extended_digits A through F represent the digits ten through fifteen, respectively. The value of each extended_digit of a based_literal shall be less than the base. "),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"The conventional meaning of based notation is assumed. An exponent indicates the power of the base by which the value of the based_literal without the exponent is to be multiplied to obtain the value of the based_literal with the exponent. The base and the exponent, if any, are in decimal notation."),(0,i.kt)("p",null,"The extended_digits A through F can be written either in lower case or in upper case, with the same meaning. "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Examples of based literals: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"2#1111_1111#  16#FF#       016#0ff#   --  integer literals of value 255\n16#E#E1       2#1110_0000#            --  integer literals of value 224\n16#F.FF#E+2   2#1.1111_1111_1110#E11  --  real literals of value 4095.0\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The rule about which letters are allowed is now encoded in BNF, as suggested by Mike Woodger. This is clearly more readable. "),(0,i.kt)("h2",{id:"25--character-literals"},"2.5  Character Literals"),(0,i.kt)("p",null,"[A character_literal is formed by enclosing a graphic character between two apostrophe characters.]"," "),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("p",null,"character_literal ::= 'graphic_character'"),(0,i.kt)("p",null,"NOTE 1   A character_literal is an enumeration literal of a character type. See 3.5.2. "),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Examples of character literals: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"'A'     '*'     '''     ' '\n\n")),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The definitions of the values of literals are in Sections 3 and 4, rather than here, since it requires knowledge of types. "),(0,i.kt)("h2",{id:"26--string-literals"},"2.6  String Literals"),(0,i.kt)("p",null,"[A string_literal is formed by a sequence of graphic characters (possibly none) enclosed between two quotation marks used as string brackets. They are used to represent operator_symbols (see 6.1), values of a string type (see 4.2), and array subaggregates (see 4.3.3). ]"),(0,i.kt)("h4",{id:"syntax-6"},"Syntax"),(0,i.kt)("p",null,'string_literal ::= "{string_element}"'),(0,i.kt)("p",null,'string_element ::= "" | non_quotation_mark_graphic_character'),(0,i.kt)("p",null,'A string_element is either a pair of quotation marks (""), or a single graphic_character other than a quotation mark. '),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,'The sequence of characters of a string_literal is formed from the sequence of string_elements between the bracketing quotation marks, in the given order, with a string_element that is "" becoming a single quotation mark in the sequence of characters, and any other string_element being reproduced in the sequence.'),(0,i.kt)("p",null,"A null string literal is a string_literal with no string_elements between the quotation marks."),(0,i.kt)("p",null,"NOTE 1   An end of line cannot appear in a string_literal."),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Examples of string literals: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'"Message of the day:"\n\n""                    --  a null string literal\n" "   "A"   """"      --  three string literals of length 1\n\n"Characters such as $, %, and } are allowed in string literals"\n\n\n')),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The wording has been changed to be strictly lexical. No mention is made of string or character values, since string_literals are also used to represent operator_symbols, which don't have a defined value."),(0,i.kt)("p",null,"The syntax is described differently. "),(0,i.kt)("h2",{id:"27--comments"},"2.7  Comments"),(0,i.kt)("p",null,"A comment starts with two adjacent hyphens and extends up to the end of the line. "),(0,i.kt)("h4",{id:"syntax-7"},"Syntax"),(0,i.kt)("p",null,"comment ::= --{non_end_of_line_character}"),(0,i.kt)("p",null,"A comment may appear on any line of a program. "),(0,i.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,i.kt)("p",null,"The presence or absence of comments has no influence on whether a program is legal or illegal. Furthermore, comments do not influence the meaning of a program; their sole purpose is the enlightenment of the human reader. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"Examples of comments: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  the last sentence above echoes the Algol 68 report \n\nend;  --  processing of Line is complete \n\n--  a long comment may be split onto\n--  two or more consecutive lines   \n\n----------------  the first two hyphens start the comment  \n\n")),(0,i.kt)("h2",{id:"28--pragmas"},"2.8  Pragmas"),(0,i.kt)("p",null,"A pragma is a compiler directive. There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation may support additional (implementation-defined) pragmas. Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[pragma]",", Def=","[a compiler directive to provide control over and above that provided by the other syntactic constructs of the language]",", Note1=","[There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation can support additional (implementation-defined) pragmas.]"," "),(0,i.kt)("h4",{id:"syntax-8"},"Syntax"),(0,i.kt)("p",null,"pragma ::=\npragma identifier ","[(pragma_argument_association {, pragma_argument_association})]",";"),(0,i.kt)("p",null,"pragma_argument_association ::=\n","[pragma_argument_identifier =",">]"," name\n| ","[pragma_argument_identifier =",">]"," expression"),(0,i.kt)("p",null,"In a pragma, any pragma_argument_associations without a pragma_argument_identifier shall precede any associations with a pragma_argument_identifier."),(0,i.kt)("p",null,"Pragmas are only allowed at the following places in a program: "),(0,i.kt)("p",null,"After a semicolon delimiter, but not within a formal_part or discriminant_part."),(0,i.kt)("p",null,'At any place where the syntax rules allow a construct defined by a syntactic category whose name ends with "declaration", "statement", "clause", or "alternative", or one of the syntactic categories variant or exception_handler; but not in place of such a construct. Also at any place where a compilation_unit would be allowed.'),(0,i.kt)("p",null,"Additional syntax rules and placement restrictions exist for specific pragmas. "),(0,i.kt)("p",null,"Discussion: The above rule is written in text, rather than in BNF; the syntactic category pragma is not used in any BNF syntax rule. "),(0,i.kt)("p",null,"Ramification: A pragma is allowed where a generic_formal_parameter_declaration is allowed. "),(0,i.kt)("p",null,"The name of a pragma is the identifier following the reserved word pragma. The name or expression of a pragma_argument_association is a pragma argument."),(0,i.kt)("p",null,"An identifier specific to a pragma is an identifier that is used in a pragma argument with special meaning for that pragma. "),(0,i.kt)("p",null,'To be honest: Whenever the syntax rules for a given pragma allow "identifier" as an argument of the pragma, that identifier is an identifier specific to that pragma.'),(0,i.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,i.kt)("p",null,"If an implementation does not recognize the name of a pragma, then it has no effect on the semantics of the program. Inside such a pragma, the only rules that apply are the Syntax Rules. "),(0,i.kt)("p",null,"To be honest: This rule takes precedence over any other rules that imply otherwise. "),(0,i.kt)("p",null,"Ramification: Note well: this rule applies only to pragmas whose name is not recognized. If anything else is wrong with a pragma (at compile time), the pragma is illegal. This is true whether the pragma is language defined or implementation defined."),(0,i.kt)("p",null,'For example, an expression in an unrecognized pragma does not cause freezing, even though the rules in 13.14, "Freezing Rules" say it does; the above rule overrules those other rules. On the other hand, an expression in a recognized pragma causes freezing, even if this makes something illegal.'),(0,i.kt)("p",null,"For another example, an expression that would be ambiguous is not illegal if it is inside an unrecognized pragma."),(0,i.kt)("p",null,"Note, however, that implementations have to recognize pragma Inline(Foo) and freeze things accordingly, even if they choose to never do inlining."),(0,i.kt)("p",null,'Obviously, the contradiction needs to be resolved one way or the other. The reasons for resolving it this way are: The implementation is simple - the compiler can just ignore the pragma altogether. The interpretation of constructs appearing inside implementation-defined pragmas is implementation defined. For example: "pragma Mumble(X);". If the current implementation has never heard of Mumble, then it doesn\'t know whether X is a name, an expression, or an identifier specific to the pragma Mumble. '),(0,i.kt)("p",null,"To be honest: The syntax of individual pragmas overrides the general syntax for pragma. "),(0,i.kt)("p",null,"Ramification: Thus, an identifier specific to a pragma is not a name, syntactically; if it were, the visibility rules would be invoked, which is not what we want."),(0,i.kt)("p",null,'This also implies that named associations do not allow one to give the arguments in an arbitrary order - the order given in the syntax rule for each individual pragma must be obeyed. However, it is generally possible to leave out earlier arguments when later ones are given; for example, this is allowed by the syntax rule for pragma Import (see B.1, "Interfacing Pragmas"). As for subprogram calls, positional notation precedes named notation.'),(0,i.kt)("p",null,"Note that Ada 83 had no pragmas for which the order of named associations mattered, since there was never more than one argument that allowed named associations. "),(0,i.kt)("p",null,"To be honest: The interpretation of the arguments of implementation-defined pragmas is implementation defined. However, the syntax rules have to be obeyed. "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"Any pragma that appears at the place of an executable construct is executed. Unless otherwise specified for a particular pragma, this execution consists of the evaluation of each evaluable pragma argument in an arbitrary order. "),(0,i.kt)("p",null,"Ramification: For a pragma that appears at the place of an elaborable construct, execution is elaboration."),(0,i.kt)("p",null,"An identifier specific to a pragma is neither a name nor an expression - such identifiers are not evaluated (unless an implementation defines them to be evaluated in the case of an implementation-defined pragma)."),(0,i.kt)("p",null,'The "unless otherwise specified" part allows us (and implementations) to make exceptions, so a pragma can contain an expression that is not evaluated. Note that pragmas in type_definitions may contain expressions that depend on discriminants.'),(0,i.kt)("p",null,"When we wish to define a pragma with some run-time effect, we usually make sure that it appears in an executable context; otherwise, special rules are needed to define the run-time effect and when it happens. "),(0,i.kt)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall give a warning message for an unrecognized pragma name. "),(0,i.kt)("p",null,"Ramification: An implementation is also allowed to have modes in which a warning message is suppressed, or in which the presence of an unrecognized pragma is a compile-time error. "),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation may provide implementation-defined pragmas; the name of an implementation-defined pragma shall differ from those of the language-defined pragmas. "),(0,i.kt)("p",null,"Implementation defined: Implementation-defined pragmas."),(0,i.kt)("p",null,"Ramification: The semantics of implementation-defined pragmas, and any associated rules (such as restrictions on their placement or arguments), are, of course, implementation defined. Implementation-defined pragmas may have run-time effects. "),(0,i.kt)("p",null,"An implementation may ignore an unrecognized pragma even if it violates some of the Syntax Rules, if detecting the syntax error is too complex. "),(0,i.kt)("p",null,"Reason: Many compilers use extra post-parsing checks to enforce the syntax rules, since the Ada syntax rules are not LR(k) (for any k). (The grammar is ambiguous, in fact.) This paragraph allows them to ignore an unrecognized pragma, without having to perform such post-parsing checks. "),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"Normally, implementation-defined pragmas should have no semantic effect for error-free programs; that is, if the implementation-defined pragmas are removed from a working program, the program should still be legal, and should still have the same semantics. "),(0,i.kt)("p",null,'Ramification: Note that "semantics" is not the same as "effect;" as explained in , the semantics defines a set of possible effects.'),(0,i.kt)("p",null,"Note that adding a pragma to a program might cause an error (either at compile time or at run time). On the other hand, if the language-specified semantics for a feature are in part implementation defined, it makes sense to support pragmas that control the feature, and that have real semantics; thus, this paragraph is merely a recommendation. "),(0,i.kt)("p",null,"Normally, an implementation should not define pragmas that can make an illegal program legal, except as follows: "),(0,i.kt)("p",null,"A pragma used to complete a declaration, such as a pragma Import;"),(0,i.kt)("p",null,"A pragma used to configure the environment by adding, removing, or replacing library_items. "),(0,i.kt)("p",null,"Ramification: For example, it is OK to support Interface, System_Name, Storage_Unit, and Memory_Size pragmas for upward compatibility reasons, even though all of these pragmas can make an illegal program legal. (The latter three can affect legality in a rather subtle way: They affect the value of named numbers in System, and can therefore affect the legality in cases where static expressions are required.)"),(0,i.kt)("p",null,"On the other hand, adding implementation-defined pragmas to a legal program can make it illegal. For example, a common kind of implementation-defined pragma is one that promises some property that allows more efficient code to be generated. If the promise is a lie, it is best if the user gets an error message. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,'In Ada 83, "bad" pragmas are ignored. In Ada 95, they are illegal, except in the case where the name of the pragma itself is not recognized by the implementation. '),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Implementation-defined pragmas may affect the legality of a program. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-6"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'Implementation-defined pragmas may affect the run-time semantics of the program. This was always true in Ada 83 (since it was not explicitly forbidden by RM83), but it was not clear, because there was no definition of "executing" or "elaborating" a pragma. '),(0,i.kt)("h4",{id:"syntax-9"},"Syntax"),(0,i.kt)("p",null,"The forms of List, Page, and Optimize pragmas are as follows:"),(0,i.kt)("p",null,"  pragma List(identifier);"),(0,i.kt)("p",null,"  pragma Page;"),(0,i.kt)("p",null,"  pragma Optimize(identifier);"),(0,i.kt)("p",null,"[Other pragmas are defined throughout this Reference Manual, and are summarized in Annex L.]"," "),(0,i.kt)("p",null,'Ramification: The language-defined pragmas are supported by every implementation, although "supporting" some of them (for example, Inline) requires nothing more than checking the arguments, since they act only as advice to the implementation. '),(0,i.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,i.kt)("p",null,"A pragma List takes one of the identifiers On or Off as the single argument. This pragma is allowed anywhere a pragma is allowed. It specifies that listing of the compilation is to be continued or suspended until a List pragma with the opposite argument is given within the same compilation. The pragma itself is always listed if the compiler is producing a listing."),(0,i.kt)("p",null,"A pragma Page is allowed anywhere a pragma is allowed. It specifies that the program text which follows the pragma should start on a new page (if the compiler is currently producing a listing)."),(0,i.kt)("p",null,"A pragma Optimize takes one of the identifiers Time, Space, or Off as the single argument. This pragma is allowed anywhere a pragma is allowed, and it applies until the end of the immediately enclosing declarative region, or for a pragma at the place of a compilation_unit, to the end of the compilation. It gives advice to the implementation as to whether time or space is the primary optimization criterion, or that optional optimizations should be turned off. ","[It is implementation defined how this advice is followed.]"," "),(0,i.kt)("p",null,"Implementation defined: Effect of pragma Optimize."),(0,i.kt)("p",null,"Discussion: For example, a compiler might use Time vs. Space to control whether generic instantiations are implemented with a macro-expansion model, versus a shared-generic-body model."),(0,i.kt)("p",null,'We don\'t define what constitutes an "optimization" - in fact, it cannot be formally defined in the context of Ada. One compiler might call something an optional optimization, whereas another compiler might consider that same thing to be a normal part of code generation. Thus, the programmer cannot rely on this pragma having any particular portable effect on the generated code. Some compilers might even ignore the pragma altogether. '),(0,i.kt)("h4",{id:"examples-6"},"Examples"),(0,i.kt)("p",null,"Examples of pragmas: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"pragma List(Off); -- turn off listing generation\npragma Optimize(Off); -- turn off optional optimizations\npragma Inline(Set_Mask); -- generate code for Set_Mask inline\npragma Suppress(Range_Check, On =&gt Index); -- turn off range checking on Index\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The Optimize pragma now allows the identifier Off to request that normal optimization be turned off."),(0,i.kt)("p",null,"An Optimize pragma may appear anywhere pragmas are allowed. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-7"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'We now describe the pragmas Page, List, and Optimize here, to act as examples, and to remove the normative material from Annex L, "Language-Defined Pragmas", so it can be entirely an informative annex. '),(0,i.kt)("h2",{id:"29--reserved-words"},"2.9  Reserved Words"),(0,i.kt)("h4",{id:"syntax-10"},"Syntax"),(0,i.kt)("p",null,"The following are the reserved words (ignoring upper/lower case distinctions): "),(0,i.kt)("p",null,"Discussion: Reserved words have special meaning in the syntax. In addition, certain reserved words are used as attribute names."),(0,i.kt)("p",null,"The syntactic category identifier no longer allows reserved words. We have added the few reserved words that are legal explicitly to the syntax for attribute_reference. Allowing identifier to include reserved words has been a source of confusion for some users, and differs from the way they are treated in the C and Pascal language definitions."),(0,i.kt)("p",null,"abort\nabs\nabstract\naccept\naccess\naliased\nall\nand\narray\nat"),(0,i.kt)("p",null,"begin\nbody"),(0,i.kt)("p",null,"case\nconstant"),(0,i.kt)("p",null,"declare\ndelay\ndelta\ndigits\ndo"),(0,i.kt)("p",null,"else\nelsif\nend\nentry\nexception\nexit"),(0,i.kt)("p",null,"for\nfunction"),(0,i.kt)("p",null,"generic\ngoto"),(0,i.kt)("p",null,"if\nin"),(0,i.kt)("p",null,"is"),(0,i.kt)("p",null,"limited\nloop"),(0,i.kt)("p",null,"mod"),(0,i.kt)("p",null,"new\nnot\nnull"),(0,i.kt)("p",null,"of\nor\nothers\nout"),(0,i.kt)("p",null,"package"),(0,i.kt)("p",null,"pragma\nprivate\nprocedure\nprotected"),(0,i.kt)("p",null,"raise\nrange\nrecord\nrem\nrenames\nrequeue"),(0,i.kt)("p",null,"return\nreverse"),(0,i.kt)("p",null,"select\nseparate"),(0,i.kt)("p",null,"subtype"),(0,i.kt)("p",null,"tagged\ntask\nterminate\nthen\ntype"),(0,i.kt)("p",null,"until\nuse"),(0,i.kt)("p",null,"when\nwhile\nwith"),(0,i.kt)("p",null,"xor"),(0,i.kt)("p",null,"NOTE 1   The reserved words appear in lower case boldface in this document, except when used in the designator of an attribute (see 4.1.4). Lower case boldface is also used for a reserved word in a string_literal used as an operator_symbol. This is merely a convention - programs may be written in whatever typeface is desired and available. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"The following words are not reserved in Ada 83, but are reserved in Ada 95: abstract, aliased, protected, requeue, tagged, until. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-8"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The clause entitled "Allowed Replacements of Characters" has been moved to Annex J, "Obsolescent Features".'))}d.isMDXComponent=!0}}]);