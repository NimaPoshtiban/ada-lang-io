"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8072],{1716:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>u});var n=a(6687);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(a),u=r,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||i;return a?n.createElement(m,o(o({ref:t},h),{},{components:a})):n.createElement(m,o({ref:t},h))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},1947:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(9440),r=(a(6687),a(1716));const i={sidebar_position:7},o="2.1  Character Set",s={unversionedId:"arm/AA-2.1",id:"arm/AA-2.1",title:"2.1  Character Set",description:"{AI95-00395-01} {AI05-0266-1} {AI12-0263-1} The character repertoire for the text of an Ada program consists of the entire coding space described by the ISO/IEC 10646:2017 Universal Coded Character Set. This coding space is organized in planes, each plane comprising 65536 characters.",source:"@site/docs/arm/AA-2.1.md",sourceDirName:"arm",slug:"/arm/AA-2.1",permalink:"/docs/arm/AA-2.1",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"2 Lexical Elements",permalink:"/docs/arm/AA-2"},next:{title:"2.2  Lexical Elements, Separators, and Delimiters",permalink:"/docs/arm/AA-2.2"}},l={},c=[{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],h={toc:c};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"21--character-set"},"2.1  Character Set"),(0,r.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} {AI05-0266-1} {AI12-0263-1} The character repertoire for the text of an Ada program consists of the entire coding space described by the ISO/IEC 10646:2017 Universal Coded Character Set. This coding space is organized in planes, each plane comprising 65536 characters. "),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00285-01} "),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00285-01} "),(0,r.kt)("p",null,'Discussion: {AI95-00285-01} {AI05-0266-1} {AI12-0263-1} It is our intent to follow the terminology of ISO/IEC 10646:2017 where appropriate, and to remain compatible with the character classifications defined in A.3, "Character Handling". '),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("p",null,"Paragraphs 2 and 3 were deleted. "),(0,r.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} {AI05-0266-1} {AI12-0263-1} A character is defined by this Reference Manual for each cell in the coding space described by ISO/IEC 10646:2017, regardless of whether or not ISO/IEC 10646:2017 allocates a character to that cell. "),(0,r.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,r.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} {AI05-0079-1} {AI05-0262-1} {AI05-0266-1} {AI12-0263-1} {AI12-0444-1} The coded representation for characters is implementation defined ","[(it can be a representation that is not defined within ISO/IEC 10646:2017)]",". A character whose relative code point in its plane is 16#FFFE# or 16#FFFF# is not allowed anywhere in the text of a program. The only characters allowed outside of comments are those in categories other_format, format_effector, and graphic_character. "),(0,r.kt)("p",null,"Implementation defined: The coded representation for the text of an Ada program."),(0,r.kt)("p",null,"Ramification: {AI95-00285-01} Note that this rule doesn't really have much force, since the implementation can represent characters in the source in any way it sees fit. For example, an implementation could simply define that what seems to be an other_private_use character is actually a representation of the space character. "),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0266-1} {AI05-0299-1} {AI12-0004-1} {AI12-0263-1} The semantics of an Ada program whose text is not in Normalization Form C (as defined by Clause 21 of ISO/IEC 10646:2017) is implementation defined. "),(0,r.kt)("p",null,"Implementation defined: The semantics of an Ada program whose text is not in Normalization Form C."),(0,r.kt)("p",null,"Ramification: {AI12-0004-1} In particular, an implementation can reject such program source. It is easy during lexical analysis to reject source that contains any code point not present in Normalization Form C. Portable programs should always be encoded in Normalization Form C. "),(0,r.kt)("p",null,"Reason: {AI12-0004-1} Normalization Form C ensures that all source is in a unique format; it eliminates ambiguities and security issues potentially caused by source using unusual sequences of characters. Note that WC3 (the Internet standards group) recommends that all Internet content be in Normalization Form C. We don't require this as there is a potentially significant cost to checking this (just rejecting unallowed code points is not enough), and some implementations may need to be interoperable with tools that produce unnormalized text. "),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0266-1} {AI05-0299-1} {AI12-0263-1} The description of the language definition in this document uses the character properties General Category, Simple Uppercase Mapping, Uppercase Mapping, and Special Case Condition of the documents referenced by Clause 2 of ISO/IEC 10646:2017. The actual set of graphic symbols used by an implementation for the visual representation of the text of an Ada program is not specified. "),(0,r.kt)("p",null,'Discussion: {AI12-0263-1} The "documents referenced" means Unicode, Chapter 4. See the Discussion after the the character categorization definition for a source for machine-readable definitions of these properties. '),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0266-1} Characters are categorized as follows: "),(0,r.kt)("p",null,"Discussion: {AI05-0005-1} {AI05-0262-1} {AI05-0266-1} {AI12-0263-1} Our character classification considers that the cells not allocated in ISO/IEC 10646:2017 are graphic characters, except for those whose relative code point in their plane is 16#FFFE# or 16#FFFF#. This seems to provide the best compatibility with future versions of ISO/IEC 10646, as future characters can already be used in Ada character and string literals. "),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00285-01} "),(0,r.kt)("p",null,'{AI95-00285-01} letter_uppercaseAny character whose General Category is defined to be "Letter, Uppercase".'),(0,r.kt)("p",null,'{AI95-00285-01} letter_lowercaseAny character whose General Category is defined to be "Letter, Lowercase". '),(0,r.kt)("p",null,"This paragraph was deleted.{8652/0001} {AI95-00124-01} "),(0,r.kt)("p",null,'{AI95-00285-01} letter_titlecaseAny character whose General Category is defined to be "Letter, Titlecase".'),(0,r.kt)("p",null,'{AI95-00285-01} letter_modifierAny character whose General Category is defined to be "Letter, Modifier".'),(0,r.kt)("p",null,'{AI95-00285-01} letter_otherAny character whose General Category is defined to be "Letter, Other".'),(0,r.kt)("p",null,'{AI95-00285-01} mark_non_spacingAny character whose General Category is defined to be "Mark, Non-Spacing".'),(0,r.kt)("p",null,'{AI95-00285-01} mark_spacing_combiningAny character whose General Category is defined to be "Mark, Spacing Combining".'),(0,r.kt)("p",null,'{AI95-00285-01} number_decimalAny character whose General Category is defined to be "Number, Decimal".'),(0,r.kt)("p",null,'{AI95-00285-01} number_letterAny character whose General Category is defined to be "Number, Letter".'),(0,r.kt)("p",null,'{AI95-00285-01} punctuation_connectorAny character whose General Category is defined to be "Punctuation, Connector".'),(0,r.kt)("p",null,'{AI95-00285-01} other_formatAny character whose General Category is defined to be "Other, Format".'),(0,r.kt)("p",null,'{AI95-00285-01} separator_spaceAny character whose General Category is defined to be "Separator, Space".'),(0,r.kt)("p",null,'{AI95-00285-01} separator_lineAny character whose General Category is defined to be "Separator, Line". '),(0,r.kt)("p",null,'{AI95-00285-01} separator_paragraphAny character whose General Category is defined to be "Separator, Paragraph".'),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0262-1} format_effectorThe characters whose code points are 16#09# (CHARACTER TABULATION), 16#0A# (LINE FEED), 16#0B# (LINE TABULATION), 16#0C# (FORM FEED), 16#0D# (CARRIAGE RETURN), 16#85# (NEXT LINE), and the characters in categories separator_line and separator_paragraph. "),(0,r.kt)("p",null,"Discussion: ISO/IEC 10646:2003 does not define the names of control characters, but rather refers to the names defined by ISO/IEC 6429:1992. These are the names that we use here. "),(0,r.kt)("p",null,'{AI95-00285-01} other_controlAny character whose General Category is defined to be "Other, Control", and which is not defined to be a format_effector.'),(0,r.kt)("p",null,'{AI95-00285-01} other_private_useAny character whose General Category is defined to be "Other, Private Use".'),(0,r.kt)("p",null,'{AI95-00285-01} other_surrogateAny character whose General Category is defined to be "Other, Surrogate".'),(0,r.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} {AI05-0262-1} graphic_characterAny character that is not in the categories other_control, other_private_use, other_surrogate, format_effector, and whose relative code point in its plane is neither 16#FFFE# nor 16#FFFF#. "),(0,r.kt)("p",null,"This paragraph was deleted."),(0,r.kt)("p",null,"Discussion: {AI95-00285-01} We considered basing the definition of lexical elements on Annex A of ISO/IEC TR 10176 (4th edition), which lists the characters which should be supported in identifiers for all programming languages, but we finally decided against this option. Note that it is not our intent to diverge from ISO/IEC TR 10176, except to the extent that ISO/IEC TR 10176 itself diverges from ISO/IEC 10646:2003 (which is the case at the time of this writing ","[January 2005]",")."),(0,r.kt)("p",null,"More precisely, we intend to align strictly with ISO/IEC 10646:2003. It must be noted that ISO/IEC TR 10176 is a Technical Report while ISO/IEC 10646:2003 is a Standard. If one has to make a choice, one should conform with the Standard rather than with the Technical Report. And, it turns out that one must make a choice because there are important differences between the two:"),(0,r.kt)("p",null,"ISO/IEC TR 10176 is still based on ISO/IEC 10646:2000 while ISO/IEC 10646:2003 has already been published for a year. We cannot afford to delay the adoption of our amendment until ISO/IEC TR 10176 has been revised."),(0,r.kt)("p",null,"There are considerable differences between the two editions of ISO/IEC 10646, notably in supporting characters beyond the BMP (this might be significant for some languages, e.g. Korean)."),(0,r.kt)("p",null,"ISO/IEC TR 10176 does not define case conversion tables, which are essential for a case-insensitive language like Ada. To get case conversion tables, we would have to reference either ISO/IEC 10646:2003 or Unicode, or we would have to invent our own. "),(0,r.kt)("p",null,"For the purpose of defining the lexical elements of the language, we need character properties like categorization, as well as case conversion tables. These are mentioned in ISO/IEC 10646:2003 as useful for implementations, with a reference to Unicode. Machine-readable tables are available on the web at URLs: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"[http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt](http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt)\n[http://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt](http://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt)\n\n")),(0,r.kt)("p",null,"with an explanatory document found at URL: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ada"},"[http://www.unicode.org/reports/tr44/tr44-20.html](http://www.unicode.org/reports/tr44/tr44-20.html)\n\n")),(0,r.kt)("p",null,"{AI12-0263-1} The actual text of the standard only makes specific references to the corresponding clauses of ISO/IEC 10646, not to Unicode."),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0266-1} {AI12-0263-1} The following names are used when referring to certain characters (the first name is that given in ISO/IEC 10646:2017): "),(0,r.kt)("p",null,"Discussion: {AI95-00285-01} {AI05-0266-1} {AI12-0125-3} {AI12-0212-1} {AI12-0263-1} This table serves to show the correspondence between ISO/IEC 10646:2017 names and the graphic symbols (glyphs) used in this document. These are the characters that play a special role in the syntax of Ada. "),(0,r.kt)("p",null,"  graphic symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"     \"\n     #\n     &\n     '\n     (\n     )\n     *\n     +\n     ,\n     \n     .\n     @\n")),(0,r.kt)("p",null,"name"),(0,r.kt)("p",null,"quotation mark\nnumber sign\nampersand\napostrophe, tick\nleft parenthesis\nright parenthesis\nasterisk, multiply\nplus sign\ncomma\nhyphen-minus, minus\nfull stop, dot, point\ncommercial at, at sign"),(0,r.kt)("p",null,"  graphic symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"     :\n     ;\n     &lt\n     =\n     &gt\n     _\n     |\n     /\n     !\n     %\n     [\n     ] \n")),(0,r.kt)("p",null,"name"),(0,r.kt)("p",null,"colon\nsemicolon\nless-than sign\nequals sign\ngreater-than sign\nlow line, underline\nvertical line\nsolidus, divide\nexclamation point\npercent sign\nleft square bracket\nright square bracket "),(0,r.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,r.kt)("p",null,"{AI05-0286-1} An Ada implementation shall accept Ada source code in UTF-8 encoding, with or without a BOM (see A.4.11), where every character is represented by its code point. The character pair CARRIAGE RETURN/LINE FEED (code points 16#0D# 16#0A#) signifies a single end of line (see 2.2); every other occurrence of a format_effector other than the character whose code point position is 16#09# (CHARACTER TABULATION) also signifies a single end of line."),(0,r.kt)("p",null,'Reason: {AI05-0079-1} {AI05-0286-1} This is simply requiring that an Ada implementation be able to directly process the ACATS, which is provided in the described format. Note that files that only contain characters with code points in the first 128 (which is the majority of the ACATS) are represented in the same way in both UTF-8 and in "plain" string format. The ACATS includes a BOM in files that have any characters with code points greater than 127. Note that the BOM contains characters not legal in Ada source code, so an implementation can use that to automatically distinguish between files formatted as plain Latin-1 strings and UTF-8 with BOM.'),(0,r.kt)("p",null,"We allow line endings to be both represented as the pair CR LF (as in Windows and the ACATS), and as single format_effector characters (usually LF, as in Linux), in order that files created by standard tools on most operating systems will meet the standard format. We specify how many line endings each represent so that compilers use the same line numbering for standard source files."),(0,r.kt)("p",null,"This requirement increases portability by having a format that is accepted by all Ada compilers. Note that implementations can support other source representations, including structured representations like a parse tree."),(0,r.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,r.kt)("p",null,"{AI95-00285-01} {AI05-0266-1} The categories defined above, as well as case mapping and folding, may be based on an implementation-defined version of ISO/IEC 10646 (2003 edition or later). "),(0,r.kt)("p",null,"Ramification: The exact categories, case mapping, and case folding chosen affects identifiers, the result of '[","[Wide_]","Wide_]Image, and packages Wide_Characters.Handling and Wide_Wide_Characters.Handling. "),(0,r.kt)("p",null,"Discussion: This permission allows implementations to upgrade to using a newer character set standard whenever that makes sense, rather than having to wait for the next Ada Standard. But the character set standard used cannot be older than ISO/IEC 10646:2003 (which is essentially similar to Unicode 4.0). "),(0,r.kt)("p",null,"NOTE   {AI95-00285-01} The characters in categories other_control, other_private_use, and other_surrogate are only allowed in comments."),(0,r.kt)("p",null,"This paragraph was deleted.{AI05-0286-1} "),(0,r.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,r.kt)("p",null,"Ada 95 allows 8-bit and 16-bit characters, as well as implementation-specified character sets. "),(0,r.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,r.kt)("p",null,'{AI95-00285-01} {AI05-0299-1} The syntax rules in this subclause are modified to remove the emphasis on basic characters vs. others. (In this day and age, there is no need to point out that you can write programs without using (for example) lower case letters.) In particular, character (representing all characters usable outside comments) is added, and basic_graphic_character, other_special_character, and basic_character are removed. Special_character is expanded to include Ada 83\'s other_special_character, as well as new 8-bit characters not present in Ada 83. Ada 2005 removes special_character altogether; we want to stick to ISO/IEC 10646:2003 character classifications. Note that the term "basic letter" is used in A.3, "Character Handling" to refer to letters without diacritical marks.'),(0,r.kt)("p",null,"{AI95-00285-01} Character names now come from ISO/IEC 10646:2003."),(0,r.kt)("p",null,"This paragraph was deleted.{AI95-00285-01} "),(0,r.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,r.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} Program text can use most characters defined by ISO-10646:2003. This subclause has been rewritten to use the categories defined in that Standard. This should ease programming in languages other than English. "),(0,r.kt)("h4",{id:"inconsistencies-with-ada-2005"},"Inconsistencies With Ada 2005"),(0,r.kt)("p",null,"{AI05-0299-1} {AI05-0266-1} An implementation is allowed (but not required) to use a newer character set standard to determine the categories, case mapping, and case folding. Doing so will change the results of attributes '[","[Wide_]","Wide",(0,r.kt)("em",{parentName:"p"},"]Image and the packages [Wide"),"]Wide_Characters.Handling in the case of a few rarely used characters. (This also could make some identifiers illegal, for characters that are no longer classified as letters.) This is unlikely to be a problem in practice. Moreover, truly portable Ada 2012 programs should avoid using in these contexts any characters that would have different classifications in any character set standards issued since 10646:2003 (since the compiler can use any such standard as the basis for its classifications). "),(0,r.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,r.kt)("p",null,"{AI05-0079-1} Correction: Clarified that only characters in the categories defined here are allowed in the source of an Ada program. This was clear in Ada 95, but Amendment 1 dropped the wording instead of correcting it."),(0,r.kt)("p",null,'{AI05-0286-1} A standard source representation is defined that all compilers are expected to process. Since this is the same format as the ACATS, it seems unlikely that there are any implementations that don\'t meet this requirement. Moreover, other representations are still permitted, and the "impossible or impractical" loophole (see ) can be invoked for any implementations that cannot directly process the ACATS. '),(0,r.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,r.kt)("p",null,"{AI12-0004-1} Correction: The interpretation of Ada source that is in Normalization Form C but not in Normalization Form KC is no longer implementation-defined. This change could potentially change the meaning of a program for a compiler that normalized all program source to Normalization Form KC before processing it. We don't document this as an inconsistency as such handling was previously implementation defined (so any such code was already defined to be not portable), and we're not aware of any compiler that normalized source code (so we don't expect to see this problem in the real world)."))}d.isMDXComponent=!0}}]);