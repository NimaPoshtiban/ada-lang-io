"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[4660],{1973:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>m,default:()=>k,frontMatter:()=>c,metadata:()=>h,toc:()=>y});var a=t(1716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,p=(e,n,t)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,u=(e,n)=>{for(var t in n||(n={}))s.call(n,t)&&p(e,t,n[t]);if(l)for(var t of l(n))d.call(n,t)&&p(e,t,n[t]);return e};const c={title:"Programming Practices",sidebar_position:5},m=void 0,h={unversionedId:"style-guide/Programming_Practices",id:"style-guide/Programming_Practices",title:"Programming Practices",description:"Software is always subject to change. The need for this change,",source:"@site/docs/style-guide/Programming_Practices.mdx",sourceDirName:"style-guide",slug:"/style-guide/Programming_Practices",permalink:"/docs/style-guide/Programming_Practices",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Programming Practices",sidebar_position:5},sidebar:"styleGuideSidebar",previous:{title:"Program Structure",permalink:"/docs/style-guide/Program_Structure"},next:{title:"Concurrency",permalink:"/docs/style-guide/Concurrency"}},g={},y=[{value:"Optional Parts of the Syntax",id:"optional-parts-of-the-syntax",level:2},{value:"Loop Names",id:"loop-names",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Block Names",id:"block-names",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Exit Statements",id:"exit-statements",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Naming End Statements",id:"naming-end-statements",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Parameter Lists",id:"parameter-lists",level:2},{value:"Formal Parameters",id:"formal-parameters",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Named Association",id:"named-association",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"instantiation",id:"instantiation",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes",level:4},{value:"caution",id:"caution",level:4},{value:"Default Parameters",id:"default-parameters",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Mode Indication",id:"mode-indication",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Types",id:"types",level:2},{value:"Derived Types and Subtypes",id:"derived-types-and-subtypes",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"notes",id:"notes-1",level:4},{value:"Anonymous Types",id:"anonymous-types",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"notes",id:"notes-2",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Private Types",id:"private-types",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"notes",id:"notes-3",level:4},{value:"Subprogram Access Types",id:"subprogram-access-types",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Data Structures",id:"data-structures",level:2},{value:"Discriminated Records",id:"discriminated-records",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"Heterogeneous Related Data",id:"heterogeneous-related-data",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"example",id:"example-13",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"notes",id:"notes-4",level:4},{value:"exceptions",id:"exceptions-3",level:4},{value:"Heterogeneous Polymorphic Data",id:"heterogeneous-polymorphic-data",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-14",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"exceptions",id:"exceptions-4",level:4},{value:"Nested Records",id:"nested-records",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"example",id:"example-15",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"notes",id:"notes-5",level:4},{value:"Dynamic Data",id:"dynamic-data",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-16",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"exceptions",id:"exceptions-5",level:4},{value:"Aliased Objects",id:"aliased-objects",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"example",id:"example-17",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"Access Discriminants",id:"access-discriminants",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"example",id:"example-18",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"Modular Types",id:"modular-types",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"example",id:"example-19",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"Expressions",id:"expressions",level:2},{value:"Range Values",id:"range-values",level:3},{value:"guideline",id:"guideline-20",level:4},{value:"example",id:"example-20",level:4},{value:"rationale",id:"rationale-20",level:4},{value:"caution",id:"caution-1",level:4},{value:"Array Attributes",id:"array-attributes",level:3},{value:"guideline",id:"guideline-21",level:4},{value:"example",id:"example-21",level:4},{value:"rationale",id:"rationale-21",level:4},{value:"Parenthetical Expressions",id:"parenthetical-expressions",level:3},{value:"guideline",id:"guideline-22",level:4},{value:"example",id:"example-22",level:4},{value:"rationale",id:"rationale-22",level:4},{value:"Positive Forms of Logic",id:"positive-forms-of-logic",level:3},{value:"guideline",id:"guideline-23",level:4},{value:"example",id:"example-23",level:4},{value:"rationale",id:"rationale-23",level:4},{value:"exceptions",id:"exceptions-6",level:4},{value:"Short Circuit Forms of the Logical Operators",id:"short-circuit-forms-of-the-logical-operators",level:3},{value:"guideline",id:"guideline-24",level:4},{value:"example",id:"example-24",level:4},{value:"rationale",id:"rationale-24",level:4},{value:"notes",id:"notes-6",level:4},{value:"Accuracy of Operations With Real Operands",id:"accuracy-of-operations-with-real-operands",level:3},{value:"guideline",id:"guideline-25",level:4},{value:"example",id:"example-25",level:4},{value:"rationale",id:"rationale-25",level:4},{value:"notes",id:"notes-7",level:4},{value:"exceptions",id:"exceptions-7",level:4},{value:"Statements",id:"statements",level:2},{value:"Nesting",id:"nesting",level:3},{value:"guideline",id:"guideline-26",level:4},{value:"instantiation",id:"instantiation-1",level:4},{value:"example",id:"example-26",level:4},{value:"rationale",id:"rationale-26",level:4},{value:"notes",id:"notes-8",level:4},{value:"exceptions",id:"exceptions-8",level:4},{value:"Slices",id:"slices",level:3},{value:"guideline",id:"guideline-27",level:4},{value:"example",id:"example-27",level:4},{value:"rationale",id:"rationale-27",level:4},{value:"Case Statements",id:"case-statements",level:3},{value:"guideline",id:"guideline-28",level:4},{value:"example",id:"example-28",level:4},{value:"rationale",id:"rationale-28",level:4},{value:"notes",id:"notes-9",level:4},{value:"exceptions",id:"exceptions-9",level:4}],f={toc:y};function k(e){var n,t=e,{components:i}=t,p=((e,n)=>{var t={};for(var a in e)s.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(null!=e&&l)for(var a of l(e))n.indexOf(a)<0&&d.call(e,a)&&(t[a]=e[a]);return t})(t,["components"]);return(0,a.kt)("wrapper",(n=u(u({},f),p),o(n,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Software is always subject to change. The need for this change,\neuphemistically known as ",(0,a.kt)("em",{parentName:"p"},'"maintenance"')," arises from a variety of\nsources. Errors need to be corrected as they are discovered. System\nfunctionality may need to be enhanced in planned or unplanned ways.\nInevitably, the requirements change over the lifetime of the system,\nforcing continual system evolution. Often, these modifications are\nconducted long after the software was originally written, usually by\nsomeone other than the original author."),(0,a.kt)("p",null,"Easy and successful modification requires that the software be readable,\nunderstandable, and structured according to accepted practice. If a\nsoftware component cannot be easily understood by a programmer who is\nfamiliar with its intended function, that software component is not\nmaintainable. Techniques that make code readable and comprehensible\nenhance its maintainability. Previous chapters presented techniques such\nas consistent use of naming conventions, clear and well-organized\ncommentary, and proper modularization. This chapter presents consistent\nand logical use of language features."),(0,a.kt)("p",null,"Correctness is one aspect of reliability. While style guidelines cannot\nenforce the use of correct algorithms, they can suggest the use of\ntechniques and language features known to reduce the number or\nlikelihood of failures. Such techniques include program construction\nmethods that reduce the likelihood of errors or that improve program\npredictability by defining behavior in the presence of errors."),(0,a.kt)("h2",u({},{id:"optional-parts-of-the-syntax"}),"Optional Parts of the Syntax"),(0,a.kt)("p",null,"Parts of the Ada syntax, while optional, can enhance the readability of\nthe code. The guidelines given below concern use of some of these\noptional features."),(0,a.kt)("h3",u({},{id:"loop-names"}),"Loop Names"),(0,a.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Associate names with loops when they are nested (Booch 1986, 1987)."),(0,a.kt)("li",{parentName:"ul"},"Associate names with any loop that contains an ",(0,a.kt)("inlineCode",{parentName:"li"},"exit"),"statement.")),(0,a.kt)("h4",u({},{id:"example"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"Process_Each_Page:\n   loop\n      Process_All_The_Lines_On_This_Page:\n         loop\n            ...\n            exit Process_All_The_Lines_On_This_Page when Line_Number = Max_Lines_On_Page;\n            ...\n            Look_For_Sentinel_Value:\n               loop\n                  ...\n                  exit Look_For_Sentinel_Value when Current_Symbol = Sentinel;\n                  ...\n               end loop Look_For_Sentinel_Value;\n            ...\n         end loop Process_All_The_Lines_On_This_Page;\n      ...\n      exit Process_Each_Page when Page_Number = Maximum_Pages;\n      ...\n   end loop Process_Each_Page;\n")),(0,a.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"When you associate a name with a loop, you must include that name with\nthe associated end for that loop (Ada Reference Manual 1995). This helps\nreaders find the associated end for any given loop. This is especially\ntrue if loops are broken over screen or page boundaries. The choice of a\ngood name for the loop documents its purpose, reducing the need for\nexplanatory comments. If a name for a loop is very difficult to choose,\nthis could indicate a need for more thought about the algorithm."),(0,a.kt)("p",null,"Regularly naming loops helps you follow Guideline 5.1.3. Even in the\nface of code changes, for example, adding an outer or inner loop, the\n",(0,a.kt)("inlineCode",{parentName:"p"},"exit")," statement does not become ambiguous."),(0,a.kt)("p",null,"It can be difficult to think up a name for every loop; therefore, the\nguideline specifies nested loops. The benefits in readability and second\nthought outweigh the inconvenience of naming the loops."),(0,a.kt)("h3",u({},{id:"block-names"}),"Block Names"),(0,a.kt)("h4",u({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Associate names with blocks when they are nested.")),(0,a.kt)("h4",u({},{id:"example-1"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"Trip:\n   declare\n      ...\n   begin  -- Trip\n      Arrive_At_Airport:\n         declare\n            ...\n         begin  -- Arrive_At_Airport\n            Rent_Car;\n            Claim_Baggage;\n            Reserve_Hotel;\n            ...\n         end Arrive_At_Airport;\n      Visit_Customer:\n         declare\n            ...\n         begin  -- Visit_Customer\n            -- again a set of activities...\n            ...\n         end Visit_Customer;\n      Departure_Preparation:\n         declare\n            ...\n         begin  -- Departure_Preparation\n            Return_Car;\n            Check_Baggage;\n            Wait_For_Flight;\n            ...\n         end Departure_Preparation;\n      Board_Return_Flight;\n   end Trip;\n")),(0,a.kt)("h4",u({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"When there is a nested block structure, it can be difficult to determine\nwhich ",(0,a.kt)("inlineCode",{parentName:"p"},"end")," corresponds to which block. Naming blocks alleviates this\nconfusion. The choice of a good name for the block documents its\npurpose, reducing the need for explanatory comments. If a name for the\nblock is very difficult to choose, this could indicate a need for more\nthought about the algorithm."),(0,a.kt)("p",null,"This guideline is also useful if nested blocks are broken over a screen\nor page boundary."),(0,a.kt)("p",null,"It can be difficult to think up a name for each block; therefore, the\nguideline specifies nested blocks. The benefits in readability and\nsecond thought outweigh the inconvenience of naming the blocks."),(0,a.kt)("h3",u({},{id:"exit-statements"}),"Exit Statements"),(0,a.kt)("h4",u({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use loop names on all ",(0,a.kt)("inlineCode",{parentName:"li"},"exit")," statements from nested loops.")),(0,a.kt)("h4",u({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"See the example in 5.1.1 ."),(0,a.kt)("h4",u({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"exit"),"statement is an implicit ",(0,a.kt)("inlineCode",{parentName:"p"},"goto"),". It should specify its source\nexplicitly. When there is a nested loop structure and an ",(0,a.kt)("inlineCode",{parentName:"p"},"exit"),"statement\nis used, it can be difficult to determine which loop is being exited.\nAlso, future changes that may introduce a nested loop are likely to\nintroduce an error, with the ",(0,a.kt)("inlineCode",{parentName:"p"},"exit")," accidentally exiting from the wrong\nloop. Naming loops and their exits alleviates this confusion. This\nguideline is also useful if nested loops are broken over a screen or\npage boundary."),(0,a.kt)("h3",u({},{id:"naming-end-statements"}),"Naming End Statements"),(0,a.kt)("h4",u({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Include the defining program unit name at the end of a package\nspecification and body."),(0,a.kt)("li",{parentName:"ul"},"Include the defining identifier at the end of a task specification\nand body."),(0,a.kt)("li",{parentName:"ul"},"Include the entry identifier at the end of an ",(0,a.kt)("inlineCode",{parentName:"li"},"accept"),"statement."),(0,a.kt)("li",{parentName:"ul"},"Include the designator at the end of a subprogram body."),(0,a.kt)("li",{parentName:"ul"},"Include the defining identifier at the end of a protected unit\ndeclaration.")),(0,a.kt)("h4",u({},{id:"example-3"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Autopilot is\n   function Is_Engaged return Boolean;\n   procedure Engage;\n   procedure Disengage;\nend Autopilot;\n------------------------------------------------------------------------\npackage body Autopilot is\n   ...\n   ---------------------------------------------------------------------\n   task Course_Monitor is\n      entry Reset (Engage : in     Boolean);\n   end Course_Monitor;\n   ---------------------------------------------------------------------\n   function Is_Engaged return Boolean is\n   ...\n   end Is_Engaged;\n   ---------------------------------------------------------------------\n   procedure Engage is\n   ...\n   end Engage;\n   ---------------------------------------------------------------------\n   procedure Disengage is\n   ...\n   end Disengage;\n   ---------------------------------------------------------------------\n   task body Course_Monitor is\n   ...\n         accept Reset (Engage : in     Boolean) do\n            ...\n         end Reset;\n   ...\n   end Course_Monitor;\n   ---------------------------------------------------------------------\nend Autopilot;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",u({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"Repeating names on the end of these compound statements ensures\nconsistency throughout the code. In addition, the named ",(0,a.kt)("inlineCode",{parentName:"p"},"end")," provides a\nreference for the reader if the unit spans a page or screen boundary or\nif it contains a nested unit."),(0,a.kt)("h2",u({},{id:"parameter-lists"}),"Parameter Lists"),(0,a.kt)("p",null,"A subprogram or entry parameter list is the interface to the abstraction\nimplemented by the subprogram or entry. It is important that it is clear\nand that it is expressed in a consistent style. Careful decisions about\nformal parameter naming and ordering can make the purpose of the\nsubprogram easier to understand, which can make it easier to use."),(0,a.kt)("h3",u({},{id:"formal-parameters"}),"Formal Parameters"),(0,a.kt)("h4",u({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Name formal parameters descriptively to reduce the need for\ncomments.")),(0,a.kt)("h4",u({},{id:"example-4"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"List_Manager.Insert (Element     => New_Employee,\n                     Into_List   => Probationary_Employees,\n                     At_Position => 1);\n")),(0,a.kt)("h4",u({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"Following the variable naming guidelines ( 3.2.1 and 3.2.3 ) for formal\nparameters can make calls to subprograms read more like regular prose,\nas shown in the example above, where no comments are necessary.\nDescriptive names of this sort can also make the code in the body of the\nsubprogram more clear."),(0,a.kt)("h3",u({},{id:"named-association"}),"Named Association"),(0,a.kt)("h4",u({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use named parameter association in calls of infrequently used\nsubprograms or entries with many formal parameters."),(0,a.kt)("li",{parentName:"ul"},"Use named association when instantiating generics."),(0,a.kt)("li",{parentName:"ul"},"Use named association for clarification when the actual parameter is\nany literal or expression."),(0,a.kt)("li",{parentName:"ul"},"Use named association when supplying a nondefault value to an\noptional parameter.")),(0,a.kt)("h4",u({},{id:"instantiation"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use named parameter association in calls of subprograms or entries\ncalled from less than five places in a single source file or with\nmore than two formal parameters.")),(0,a.kt)("h4",u({},{id:"example-5"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Encode_Telemetry_Packet (Source         => Power_Electronics,\n                         Content        => Temperature,\n                         Value          => Read_Temperature_Sensor(Power_Electronics),\n                         Time           => Current_Time,\n                         Sequence       => Next_Packet_ID,\n                         Vehicle        => This_Spacecraft,\n                         Primary_Module => True);\n")),(0,a.kt)("h4",u({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"Calls of infrequently used subprograms or entries with many formal\nparameters can be difficult to understand without referring to the\nsubprogram or entry code. Named parameter association can make these\ncalls more readable."),(0,a.kt)("p",null,"When the formal parameters have been named appropriately, it is easier\nto determine exactly what purpose the subprogram serves without looking\nat its code. This reduces the need for named constants that exist solely\nto make calls more readable. It also allows variables used as actual\nparameters to be given names indicating what they are without regard to\nwhy they are being passed in a call. An actual parameter, which is an\nexpression rather than a variable, cannot be named otherwise."),(0,a.kt)("p",null,"Named association allows subprograms to have new parameters inserted\nwith minimal ramifications to existing calls."),(0,a.kt)("h4",u({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"The judgment of when named parameter association improves readability is\nsubjective. Certainly, simple or familiar subprograms, such as a swap\nroutine or a sine function, do not require the extra clarification of\nnamed association in the procedure call."),(0,a.kt)("h4",u({},{id:"caution"}),"caution"),(0,a.kt)("p",null,"A consequence of named parameter association is that the formal\nparameter names may not be changed without modifying the text of each\ncall."),(0,a.kt)("h3",u({},{id:"default-parameters"}),"Default Parameters"),(0,a.kt)("h4",u({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide default parameters to allow for occasional, special use of\nwidely used subprograms or entries."),(0,a.kt)("li",{parentName:"ul"},"Place default parameters at the end of the formal parameter list."),(0,a.kt)("li",{parentName:"ul"},"Consider providing default values to new parameters added to an\nexisting subprogram.")),(0,a.kt)("h4",u({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"Ada Reference Manual (1995) contains many examples of this practice."),(0,a.kt)("h4",u({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"Often, the majority of uses of a subprogram or entry need the same value\nfor a given parameter. Providing that value, as the default for the\nparameter, makes the parameter optional on the majority of calls. It\nalso allows the remaining calls to customize the subprogram or entry by\nproviding different values for that parameter."),(0,a.kt)("p",null,"Placing default parameters at the end of the formal parameter list\nallows the caller to use positional association on the call; otherwise,\ndefaults are available only when named association is used."),(0,a.kt)("p",null,"Often during maintenance activities, you increase the functionality of a\nsubprogram or entry. This requires more parameters than the original\nform for some calls. New parameters may be required to control this new\nfunctionality. Give the new parameters default values that specify the\nold functionality. Calls needing the old functionality need not be\nchanged; they take the defaults. This is true if the new parameters are\nadded to the end of the parameter list, or if named association is used\non all calls. New calls needing the new functionality can specify that\nby providing other values for the new parameters."),(0,a.kt)("p",null,"This enhances maintainability in that the places that use the modified\nroutines do not themselves have to be modified, while the previous\nfunctionality levels of the routines are allowed to be ",(0,a.kt)("em",{parentName:"p"},'"reused."')),(0,a.kt)("h4",u({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"Do not go overboard. If the changes in functionality are truly radical,\nyou should be preparing a separate routine rather than modifying an\nexisting one. One indicator of this situation would be that it is\ndifficult to determine value combinations for the defaults that uniquely\nand naturally require the more restrictive of the two functions. In such\ncases, it is better to go ahead with creation of a separate routine."),(0,a.kt)("h3",u({},{id:"mode-indication"}),"Mode Indication"),(0,a.kt)("h4",u({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Show the mode indication of all procedure and entry parameters\n(Nissen and Wallis 1984 )."),(0,a.kt)("li",{parentName:"ul"},"Use the most restrictive parameter mode applicable to your\napplication.")),(0,a.kt)("h4",u({},{id:"example-7"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"procedure Open_File (File_Name   : in     String;\n                     Open_Status :    out Status_Codes);\nentry Acquire (Key      : in     Capability;\n               Resource :    out Tape_Drive);\n")),(0,a.kt)("h4",u({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"By showing the mode of parameters, you aid the reader. If you do not\nspecify a parameter mode, the default mode is ",(0,a.kt)("inlineCode",{parentName:"p"},"in"),". Explicitly showing\nthe mode indication of all parameters is a more assertive action than\nsimply taking the default mode. Anyone reviewing the code later will be\nmore confident that you intended the parameter mode to be ",(0,a.kt)("inlineCode",{parentName:"p"},"in"),"."),(0,a.kt)("p",null,"Use the mode that reflects the actual use of the parameter. You should\navoid the tendency to make all parameters ",(0,a.kt)("inlineCode",{parentName:"p"},"in out")," mode because ",(0,a.kt)("inlineCode",{parentName:"p"},"out"),"\nmode parameters may be examined as well as updated."),(0,a.kt)("h4",u({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"It may be necessary to consider several alternative implementations for\na given abstraction. For example, a bounded stack can be implemented as\na pointer to an array. Even though an update to the object being pointed\nto does not require changing the pointer value itself, you may want to\nconsider making the mode ",(0,a.kt)("inlineCode",{parentName:"p"},"in out")," to allow changes to the implementation\nand to document more accurately what the operation is doing. If you\nlater change the implementation to a simple array, the mode will have to\nbe ",(0,a.kt)("inlineCode",{parentName:"p"},"in out"),", potentially causing changes to all places that the routine\nis called."),(0,a.kt)("h2",u({},{id:"types"}),"Types"),(0,a.kt)("p",null,"In addition to determining the possible values for variables and subtype\nnames, type distinctions can be very valuable aids in developing safe,\nreadable, and understandable code. Types clarify the structure of your\ndata and can limit or restrict the operations performed on that data."),(0,a.kt)("i",null,'"Keeping types distinct has been found to be a very powerful means of detecting logical mistakes when a program is written and to give valuable assistance whenever the program is being subsequently maintained"')," (Pyle 1985 ). Take advantage of Ada's strong typing capability in the form of subtypes, derived types, task types, protected types, private types, and limited private types.",(0,a.kt)("p",null,"The guidelines encourage much code to be written to ensure strong\ntyping. While it might appear that there would be execution penalties\nfor this amount of code, this is usually not the case. In contrast to\nother conventional languages, Ada has a less direct relationship between\nthe amount of code that is written and the size of the resulting\nexecutable program. Most of the strong type checking is performed at\ncompilation time rather than execution time, so the size of the\nexecutable code is not greatly affected."),(0,a.kt)("p",null,"For guidelines on specific kinds of data structures and tagged types,\nsee 9.2.1 , respectively."),(0,a.kt)("h3",u({},{id:"derived-types-and-subtypes"}),"Derived Types and Subtypes"),(0,a.kt)("h4",u({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use existing types as building blocks by deriving new types from\nthem."),(0,a.kt)("li",{parentName:"ul"},"Use range constraints on subtypes."),(0,a.kt)("li",{parentName:"ul"},"Define new types, especially derived types, to include the largest\nset of possible values, including boundary values."),(0,a.kt)("li",{parentName:"ul"},"Constrain the ranges of derived types with subtypes, excluding\nboundary values."),(0,a.kt)("li",{parentName:"ul"},"Use type derivation rather than type extension when there are no\nmeaningful components to add to the type.")),(0,a.kt)("h4",u({},{id:"example-8"}),"example"),(0,a.kt)("p",null,"Type ",(0,a.kt)("inlineCode",{parentName:"p"},"Table")," is a building block for the creation of new types:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Table is\n   record\n      Count : List_Size  := Empty;\n      List  : Entry_List := Empty_List;\n   end record;\ntype Telephone_Directory  is new Table;\ntype Department_Inventory is new Table;\n")),(0,a.kt)("p",null,"The following are distinct types that cannot be intermixed in operations\nthat are not programmed explicitly to use them both:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Dollars is new Number;\ntype Cents   is new Number;\n")),(0,a.kt)("p",null,"Below, ",(0,a.kt)("inlineCode",{parentName:"p"},"Source_Tail")," has a value outside the range of ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper"),"\nwhen the line is empty. All the indices can be mixed in expressions, as\nlong as the results fall within the correct subtypes:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Columns          is range First_Column - 1 .. Listing_Width + 1;\n\nsubtype Listing_Paper is Columns range First_Column .. Listing_Width;\nsubtype Dumb_Terminal is Columns range First_Column .. Dumb_Terminal_Width;\ntype Line             is array (Columns range <>) of Bytes;\nsubtype Listing_Line  is Line (Listing_Paper);\nsubtype Terminal_Line is Line (Dumb_Terminal);\nSource_Tail : Columns       := Columns'First;\nSource      : Listing_Line;\nDestination : Terminal_Line;\n...\nDestination(Destination'First .. Source_Tail - Destination'Last) :=\n      Source(Columns'Succ(Destination'Last) .. Source_Tail);\n")),(0,a.kt)("h4",u({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"The name of a derived type can make clear its intended use and avoid\nproliferation of similar type definitions. Objects of two derived types,\neven though derived from the same type, cannot be mixed in operations\nunless such operations are supplied explicitly or one is converted to\nthe other explicitly. This prohibition is an enforcement of strong\ntyping."),(0,a.kt)("p",null,"Define new types, derived types, and subtypes cautiously and\ndeliberately. The concepts of subtype and derived type are not\nequivalent, but they can be used to advantage in concert. A subtype\nlimits the range of possible values for a type but does not define a new\ntype."),(0,a.kt)("p",null,"Types can have highly constrained sets of values without eliminating\nuseful values. Used in concert, derived types and subtypes can eliminate\nmany flag variables and type conversions within executable statements.\nThis renders the program more readable, enforces the abstraction, and\nallows the compiler to enforce strong typing constraints."),(0,a.kt)("p",null,"Many algorithms begin or end with values just outside the normal range.\nIf boundary values are not compatible within subexpressions, algorithms\ncan be needlessly complicated. The program can become cluttered with\nflag variables and special cases when it could just test for zero or\nsome other sentinel value just outside normal range."),(0,a.kt)("p",null,"The type ",(0,a.kt)("inlineCode",{parentName:"p"},"Columns")," and the subtype ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper")," in the example above\ndemonstrate how to allow sentinel values. The subtype ",(0,a.kt)("inlineCode",{parentName:"p"},"Listing_Paper"),"\ncould be used as the type for parameters of subprograms declared in the\nspecification of a package. This would restrict the range of values that\ncould be specified by the caller. Meanwhile, the type ",(0,a.kt)("inlineCode",{parentName:"p"},"Columns")," could be\nused to store such values internally to the body of the package,\nallowing ",(0,a.kt)("inlineCode",{parentName:"p"},"First_Column - 1")," to be used as a sentinel value. This\ncombination of types and subtypes allows compatibility between subtypes\nwithin subexpressions without type conversions as would happen with\nderived types."),(0,a.kt)("p",null,"The choice between type derivation and type extension depends on what\nkind of changes you expect to occur to objects in the type. In general,\ntype derivation is a very simple form of inheritance: the derived types\ninherit the structure, operations, and values of the parent type\n(Rationale 1995, \xa74.2 ). Although you can add operations, you cannot\naugment the data structure. You can derive from either scalar or\ncomposite types."),(0,a.kt)("p",null,"Type extension is a more powerful form of inheritance, only applied to\n",(0,a.kt)("inlineCode",{parentName:"p"},"tagged")," records, in which you can augment both the type's components\nand operations. When the record implements an abstraction with the\npotential for reuse and/or extension, it is a good candidate for making\nit ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged"),". Similarly, if the abstraction is a member of a family of\nabstractions with well-defined variable and common properties, you\nshould consider a ",(0,a.kt)("inlineCode",{parentName:"p"},"tagged")," record."),(0,a.kt)("h4",u({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"The price of the reduction in the number of independent type\ndeclarations is that subtypes and derived types change when the base\ntype is redefined. This trickle-down of changes is sometimes a blessing\nand sometimes a curse. However, usually it is intended and beneficial."),(0,a.kt)("h3",u({},{id:"anonymous-types"}),"Anonymous Types"),(0,a.kt)("h4",u({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid anonymous array types."),(0,a.kt)("li",{parentName:"ul"},"Use anonymous array types for array variables only when no suitable\ntype exists or can be created and the array will not be referenced\nas a whole (e.g., used as a subprogram parameter)."),(0,a.kt)("li",{parentName:"ul"},"Use access parameters and access discriminants to guarantee that the\nparameter or discriminant is treated as a constant.")),(0,a.kt)("h4",u({},{id:"example-9"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Buffer_Index is range 1 .. 80;\ntype Buffer       is array (Buffer_Index) of Character;\nInput_Line : Buffer;\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Input_Line : array (Buffer_Index) of Character;\n")),(0,a.kt)("h4",u({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"Although Ada allows anonymous types, they have limited usefulness and\ncomplicate program modification. For example, except for arrays, a\nvariable of anonymous type can never be used as an actual parameter\nbecause it is not possible to define a formal parameter of the same\ntype. Even though this may not be a limitation initially, it precludes a\nmodification in which a piece of code is changed to a subprogram.\nAlthough you can declare the anonymous array to be aliased, you cannot\nuse this access value as an actual parameter in a subprogram because the\nsubprogram's formal parameter declaration requires a type mark. Also,\ntwo variables declared using the same anonymous type declaration are\nactually of different types."),(0,a.kt)("p",null,"Even though the implicit conversion of array types during parameter\npassing is supported in Ada, it is difficult to justify not using the\ntype of the parameter. In most situations, the type of the parameter is\nvisible and easily substituted in place of an anonymous array type. The\nuse of an anonymous array type implies that the array is only being used\nas a convenient way to implement a collection of values. It is\nmisleading to use an anonymous type, and then treat the variable as an\nobject."),(0,a.kt)("p",null,"When you use an access parameter or access discriminant, the anonymous\ntype is essentially declared inside the subprogram or object itself\n(Rationale 1995, \xa73.7.1 ). Thus, you have no way of declaring another\nobject of the same type, and the object is treated as a constant. In the\ncase of a self-referential data structure (see"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," Guideline 5.4.6 ), you need the access parameter to be able to")),(0,a.kt)("p",null,"manipulate the data the discriminant accesses (Rationale 1995, \xa73.7.1 )."),(0,a.kt)("h4",u({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"For anonymous task types, see Guideline 6.1.4 ."),(0,a.kt)("h4",u({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("p",null,"If you are creating a unique table, for example, the periodic table of\nthe elements, consider using an anonymous array type."),(0,a.kt)("h3",u({},{id:"private-types"}),"Private Types"),(0,a.kt)("h4",u({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Derive from controlled types in preference to using limited private\ntypes."),(0,a.kt)("li",{parentName:"ul"},"Use limited private types in preference to private types."),(0,a.kt)("li",{parentName:"ul"},"Use private types in preference to nonprivate types."),(0,a.kt)("li",{parentName:"ul"},"Explicitly export needed operations rather than easing restrictions.")),(0,a.kt)("h4",u({},{id:"example-10"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"------------------------------------------------------------------------\nwith Ada.Finalization;\npackage Packet_Telemetry is\n   type Frame_Header is new Ada.Finalization.Controlled with private;\n   type Frame_Data   is private;\n   type Frame_Codes  is (Main_Bus_Voltage, Transmitter_1_Power);\n   ...\nprivate\n   type Frame_Header is new Ada.Finalization.Controlled with\n      record\n         ...\n      end record;\n   -- override adjustment and finalization to get correct assignment semantics\n   procedure Adjust (Object : in out Frame_Header);\n   procedure Finalize (Object : in out Frame_Header);\n   type Frame_Data is\n      record\n         ...\n      end record;\n   ...\nend Packet_Telemetry;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",u({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,"Limited private types and private types support abstraction and\ninformation hiding better than nonprivate types. The more restricted the\ntype, the better information hiding is served. This, in turn, allows the\nimplementation to change without affecting the rest of the program.\nWhile there are many valid reasons to export types, it is better to try\nthe preferred route first, loosening the restrictions only as necessary.\nIf it is necessary for a user of the package to use a few of the\nrestricted operations, it is better to export the operations explicitly\nand individually via exported subprograms than to drop a level of\nrestriction. This practice retains the restrictions on other operations."),(0,a.kt)("p",null,"Limited private types have the most restricted set of operations\navailable to users of a package. Of the types that must be made\navailable to users of a package, as many as possible should be derived\nfrom the controlled types or limited private. Controlled types give you\nthe ability to adjust assignment and to finalize values, so you no\nlonger need to create limited private types to guarantee a client that\nassignment and equality obey deep copy/comparison semantics. Therefore,\nit is possible to export a slightly less restrictive type (i.e., private\ntype that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Finalization.Controlled"),") that has an adjustable\nassignment operator and overridable equality operator. See also\nGuideline 5.4.5 ."),(0,a.kt)("p",null,"The operations available to limited private types are membership tests,\nselected components, components for the selections of any discriminant,\nqualification and explicit conversion, and attributes ",(0,a.kt)("inlineCode",{parentName:"p"},"'Base")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"'Size"),". Objects of a limited private type also have the attribute\n",(0,a.kt)("inlineCode",{parentName:"p"},"'Constrained")," if there are discriminants. None of these operations\nallows the user of the package to manipulate objects in a way that\ndepends on the structure of the type."),(0,a.kt)("h4",u({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"The predefined packages ",(0,a.kt)("inlineCode",{parentName:"p"},"Direct_IO")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Sequential_IO"),"do not accept\nlimited private types as generic parameters. This restriction should be\nconsidered when I/O operations are needed for a type."),(0,a.kt)("p",null,"See Guideline 8.3.3 for a discussion of the use of private and limited\nprivate types in generic units."),(0,a.kt)("h3",u({},{id:"subprogram-access-types"}),"Subprogram Access Types"),(0,a.kt)("h4",u({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access-to-subprogram types for indirect access to subprograms."),(0,a.kt)("li",{parentName:"ul"},"Wherever possible, use abstract tagged types and dispatching rather\nthan access-to-subprogram types to implement dynamic selection and\ninvocation of subprograms.")),(0,a.kt)("h4",u({},{id:"example-11"}),"example"),(0,a.kt)("p",null,"The following example is taken from the Rationale (1995, \xa73.7.2) :"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"generic\n   type Float_Type is digits <>;\npackage Generic_Integration is\n   type Integrand is access function (X : Float_Type) return Float_Type;\n   function Integrate (F        : Integrand;\n                       From     : Float_Type;\n                       To       : Float_Type;\n                       Accuracy : Float_Type := 10.0*Float_Type'Model_Epsilon)\n     return Float_Type;\nend Generic_Integration;\nwith Generic_Integration;\nprocedure Try_Estimate (External_Data : in     Data_Type;\n                        Lower         : in     Float;\n                        Upper         : in     Float;\n                        Answer        :    out Float) is\n   -- external data set by other means\n   function Residue (X : Float) return Float is\n      Result : Float;\n   begin  -- Residue\n      -- compute function value dependent upon external data\n      return Result;\n   end Residue;\n   package Float_Integration is\n      new Generic_Integration (Float_Type => Float);\n\n   use Float_Integration;\nbegin -- Try_Estimate\n   ...\n   Answer := Integrate (F    => Residue'Access,\n                        From => Lower,\n                        To   => Upper);\nend Try_Estimate;\n")),(0,a.kt)("h4",u({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,"Access-to-subprogram types allow you to create data structures that\ncontain subprogram references. There are many uses for this feature, for\ninstance, implementing state machines, call backs in the X Window\nSystem, iterators (the operation to be applied to each element of a\nlist), and numerical algorithms (e.g., integration function) (Rationale\n1995, \xa73.7.2 )."),(0,a.kt)("p",null,"You can achieve the same effect as access-to-subprogram types for\ndynamic selection by using abstract tagged types. You declare an\nabstract type with one abstract operation and then use an\naccess-to-class-wide type to get the dispatching effect. This technique\nprovides greater flexibility and type safety than access-to-subprogram\ntypes (Ada Reference Manual 1995, \xa73.10.2 )."),(0,a.kt)("p",null,"Access-to-subprogram types are useful in implementing dynamic selection.\nReferences to the subprograms can be stored directly in the data\nstructure. In a finite state machine, for example, a single data\nstructure can describe the action to be taken on state transitions.\nStrong type checking is maintained because Ada 95 requires that the\ndesignated subprogram has the same parameter/result profile as the one\nspecified in the subprogram access type."),(0,a.kt)("p",null,"See also Guideline 7.3.2 ."),(0,a.kt)("h2",u({},{id:"data-structures"}),"Data Structures"),(0,a.kt)("p",null,"The data structuring capabilities of Ada are a powerful resource;\ntherefore, use them to model the data as closely as possible. It is\npossible to group logically related data and let the language control\nthe abstraction and operations on the data rather than requiring the\nprogrammer or maintainer to do so. Data can also be organized in a\nbuilding block fashion. In addition to showing how a data structure is\norganized (and possibly giving the reader an indication as to why it was\norganized that way), creating the data structure from smaller components\nallows those components to be reused. Using the features that Ada\nprovides can increase the maintainability of your code."),(0,a.kt)("h3",u({},{id:"discriminated-records"}),"Discriminated Records"),(0,a.kt)("h4",u({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When declaring a discriminant, use as constrained a subtype as\npossible (i.e., subtype with as specific a range constraint as\npossible)."),(0,a.kt)("li",{parentName:"ul"},"Use a discriminated record rather than a constrained array to\nrepresent an array whose actual values are unconstrained.")),(0,a.kt)("h4",u({},{id:"example-12"}),"example"),(0,a.kt)("p",null,"An object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_Holder_1")," could potentially hold a string whose\nlength is ",(0,a.kt)("inlineCode",{parentName:"p"},"Natural'Last"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Number_List is array (Integer range <>) of Integer;\n\ntype Number_Holder_1 (Current_Length : Natural := 0) is\n   record\n      Numbers : Number_List (1 .. Current_Length);\n   end record;\n")),(0,a.kt)("p",null,"An object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_Holder_2")," imposes a more reasonable restriction\non the length of its string component:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type    Number_List is array (Integer range <>) of Integer;\nsubtype Max_Numbers is Natural range 0 .. 42;\n\ntype Number_Holder_2 (Current_Length : Max_Numbers := 0) is\n   record\n      Numbers : Number_List (1 .. Current_Length);\n   end record;\n")),(0,a.kt)("h4",u({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"When you use the discriminant to constrain an array inside a\ndiscriminated record, the larger the range of values the discriminant\ncan assume, the more space an object of the type might require. Although\nyour program may compile and link, it will fail at execution when the\nrun-time system is unable to create an object of the potential size\nrequired."),(0,a.kt)("p",null,"The discriminated record captures the intent of an array whose bounds\nmay vary at run-time. A simple constrained array definition (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"type Number_List is array (1 .. 42) of Integer;"),") does not capture the intent\nthat there are at most 42 possible numbers in the list."),(0,a.kt)("h3",u({},{id:"heterogeneous-related-data"}),"Heterogeneous Related Data"),(0,a.kt)("h4",u({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use records to group heterogeneous but related data."),(0,a.kt)("li",{parentName:"ul"},"Consider records to map to I/O device data.")),(0,a.kt)("h4",u({},{id:"example-13"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Propulsion_Method is (Sail, Diesel, Nuclear);\ntype Craft is\n   record\n      Name   : Common_Name;\n      Plant  : Propulsion_Method;\n      Length : Feet;\n      Beam   : Feet;\n      Draft  : Feet;\n   end record;\ntype Fleet is array (1 .. Fleet_Size) of Craft;\n")),(0,a.kt)("h4",u({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"You help the maintainer find all of the related data by gathering it\ninto the same construct, simplifying any modifications that apply to all\nrather than part. This, in turn, increases reliability. Neither you nor\nan unknown maintainer is liable to forget to deal with all the pieces of\ninformation in the executable statements, especially if updates are done\nwith aggregate assignments whenever possible."),(0,a.kt)("p",null,"The idea is to put the information a maintainer needs to know where it\ncan be found with the minimum of effort. For example, if all information\nrelating to a given ",(0,a.kt)("inlineCode",{parentName:"p"},"Craft")," is in the same place, the relationship is\nclear both in the declarations and especially in the code accessing and\nupdating that information. But, if it is scattered among several data\nstructures, it is less obvious that this is an intended relationship as\nopposed to a coincidental one. In the latter case, the declarations may\nbe grouped together to imply intent, but it may not be possible to group\nthe accessing and updating code that way. Ensuring the use of the same\nindex to access the corresponding element in each of several parallel\narrays is difficult if the accesses are at all scattered."),(0,a.kt)("p",null,"If the application must interface directly to hardware, the use of\nrecords, especially in conjunction with record representation clauses,\ncould be useful to map onto the layout of the hardware in question."),(0,a.kt)("h4",u({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"It may seem desirable to store heterogeneous data in parallel arrays in\nwhat amounts to a FORTRAN-like style. This style is an artifact of\nFORTRAN's data structuring limitations. FORTRAN only has facilities for\nconstructing homogeneous arrays."),(0,a.kt)("h4",u({},{id:"exceptions-3"}),"exceptions"),(0,a.kt)("p",null,"If the application must interface directly to hardware, and the hardware\nrequires that information be distributed among various locations, then\nit may not be possible to use records."),(0,a.kt)("h3",u({},{id:"heterogeneous-polymorphic-data"}),"Heterogeneous Polymorphic Data"),(0,a.kt)("h4",u({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access types to class-wide types to implement heterogeneous\npolymorphic data structures."),(0,a.kt)("li",{parentName:"ul"},"Use tagged types and type extension rather than variant records (in\ncombination with enumeration types and case statements).")),(0,a.kt)("h4",u({},{id:"example-14"}),"example"),(0,a.kt)("p",null,"An array of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee_List")," can contain pointers to part-time and\nfull-time employees (and possibly other kinds of employees in the\nfuture):"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"-----------------------------------------------------------------------------------\npackage Personnel is\n   type Employee  is tagged limited private;\n   type Reference is access all Employee'Class;\n   ...\nprivate\n   ...\nend Personnel;\n-----------------------------------------------------------------------------------\nwith Personnel;\npackage Part_Time_Staff is\n   type Part_Time_Employee is new Personnel.Employee with\n      record\n         ...\n      end record;\n   ...\nend Part_Time_Staff;\n-----------------------------------------------------------------------------------\nwith Personnel;\npackage Full_Time_Staff is\n   type Full_Time_Employee is new Personnel.Employee with\n      record\n         ...\n      end record;\n   ...\nend Full_Time_Staff;\n-----------------------------------------------------------------------------------\n\n...\n\ntype Employee_List is array (Positive range <>) of Personnel.Reference;\n\nCurrent_Employees : Employee_List (1..10);\n\n...\n\nCurrent_Employees(1) := new Full_Time_Staff.Full_Time_Employee;\nCurrent_Employees(2) := new Part_Time_Staff.Part_Time_Employee;\n...\n")),(0,a.kt)("h4",u({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"Polymorphism is a means of factoring out the differences among a\ncollection of abstractions so that programs may be written in terms of\nthe common properties. Polymorphism allows the different objects in a\nheterogeneous data structure to be treated the same way, based on\ndispatching operations defined on the root tagged type. This eliminates\nthe need for ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements to select the processing required for\neach specific type. Guideline 5.6.3 discusses the maintenance impact of\nusing ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements."),(0,a.kt)("p",null,"Enumeration types, variant records, and case statements are hard to\nmaintain because the expertise on a given variant of the data type tends\nto be spread all over the program. When you create a tagged type\nhierarchy (tagged types and type extension), you can avoid the variant\nrecords, case statement, and single enumeration type that only supports\nthe variant record discriminant. Moreover, you localize the\n",(0,a.kt)("em",{parentName:"p"},'"expertise"')," about the variant within the data structure by having all\nthe corresponding primitives for a single operation call common\n",(0,a.kt)("em",{parentName:"p"},'"operation-specific"')," code."),(0,a.kt)("p",null,"See also Guideline 9.2.1 for a more detailed discussion of tagged types."),(0,a.kt)("h4",u({},{id:"exceptions-4"}),"exceptions"),(0,a.kt)("p",null,"In some instances, you may want to use a variant record approach to\norganize modularity around operations. For graphic output, for example,\nyou may find it more maintainable to use variant records. You must make\nthe tradeoff of whether adding a new operation will be less work than\nadding a new variant."),(0,a.kt)("h3",u({},{id:"nested-records"}),"Nested Records"),(0,a.kt)("h4",u({},{id:"guideline-15"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Record structures should not always be flat. Factor out common\nparts."),(0,a.kt)("li",{parentName:"ul"},"For a large record structure, group related components into smaller\nsubrecords."),(0,a.kt)("li",{parentName:"ul"},"For nested records, pick element names that read well when inner\nelements are referenced."),(0,a.kt)("li",{parentName:"ul"},"Consider using type extension to organize large data structures.")),(0,a.kt)("h4",u({},{id:"example-15"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Coordinate is\n   record\n      Row    : Local_Float;\n      Column : Local_Float;\n   end record;\ntype Window is\n   record\n      Top_Left     : Coordinate;\n      Bottom_Right : Coordinate;\n   end record;\n")),(0,a.kt)("h4",u({},{id:"rationale-15"}),"rationale"),(0,a.kt)("p",null,"You can make complex data structures understandable and comprehensible\nby composing them of familiar building blocks. This technique works\nespecially well for large record types with parts that fall into natural\ngroupings. The components factored into separately declared records,\nbased on a common quality or purpose, correspond to a lower level of\nabstraction than that represented by the larger record."),(0,a.kt)("p",null,'When designing a complex data structure, you must consider whether type\ncomposition or type extension is the best suited technique. Type\ncomposition refers to creating a record component whose type is itself a\nrecord. You will often need a hybrid of these techniques, that is, some\ncomponents you include through type composition and others you create\nthrough type extension. Type extension may provide a cleaner design if\nthe "intermediate" records are all instances of the same abstraction\nfamily. See also Guidelines 5.4.2 and 9.2.1 .'),(0,a.kt)("h4",u({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"A carefully chosen name for the component of the larger record that is\nused to select the smaller enhances readability, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Window1.Bottom_Right.Row > Window2.Top_Left.Row then . . .\n")),(0,a.kt)("h3",u({},{id:"dynamic-data"}),"Dynamic Data"),(0,a.kt)("h4",u({},{id:"guideline-16"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Differentiate between static and dynamic data. Use dynamically\nallocated objects with caution."),(0,a.kt)("li",{parentName:"ul"},"Use dynamically allocated data structures only when it is necessary\nto create and destroy them dynamically or to be able to reference\nthem by different names."),(0,a.kt)("li",{parentName:"ul"},"Do not drop pointers to undeallocated objects."),(0,a.kt)("li",{parentName:"ul"},"Do not leave dangling references to deallocated objects."),(0,a.kt)("li",{parentName:"ul"},"Initialize all access variables and components within a record."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on memory deallocation."),(0,a.kt)("li",{parentName:"ul"},"Deallocate explicitly."),(0,a.kt)("li",{parentName:"ul"},"Use length clauses to specify total allocation size."),(0,a.kt)("li",{parentName:"ul"},"Provide handlers for ",(0,a.kt)("inlineCode",{parentName:"li"},"Storage_Error"),"."),(0,a.kt)("li",{parentName:"ul"},"Use controlled types to implement private types that manipulate\ndynamic data."),(0,a.kt)("li",{parentName:"ul"},"Avoid unconstrained record objects unless your run-time environment\nreliably reclaims dynamic heap storage."),(0,a.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage, declare the following items only in the outermost, unnested\ndeclarative part of either a library package, a main subprogram, or\na permanent task:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Access types"),(0,a.kt)("li",{parentName:"ul"},"Constrained composite objects with nonstatic bounds"),(0,a.kt)("li",{parentName:"ul"},"Objects of an unconstrained composite type other than\nunconstrained records"),(0,a.kt)("li",{parentName:"ul"},"Composite objects large enough (at compile time) for the\ncompiler to allocate implicitly on the heap"))),(0,a.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage or you are creating permanent, dynamically allocated tasks,\navoid declaring tasks in the following situations:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Unconstrained array subtypes whose components are tasks"),(0,a.kt)("li",{parentName:"ul"},"Discriminated record subtypes containing a component that is an\narray of tasks, where the array size depends on the value of the\ndiscriminant"),(0,a.kt)("li",{parentName:"ul"},"Any declarative region other than the outermost, unnested\ndeclarative part of either a library package or a main\nsubprogram"),(0,a.kt)("li",{parentName:"ul"},"Arrays of tasks that are not statically constrained")))),(0,a.kt)("h4",u({},{id:"example-16"}),"example"),(0,a.kt)("p",null,"These lines show how a dangling reference might be created:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"P1 := new Object;\nP2 := P1;\nUnchecked_Object_Deallocation(P2);\n")),(0,a.kt)("p",null,"This line can raise an exception due to referencing the deallocated\nobject:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"X := P1.all;\n")),(0,a.kt)("p",null,"In the following three lines, if there is no intervening assignment of\nthe value of ",(0,a.kt)("inlineCode",{parentName:"p"},"P1")," to any other pointer, the object created on the first\nline is no longer accessible after the third line. The only pointer to\nthe allocated object has been dropped:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"P1 := new Object;\n...\nP1 := P2;\n")),(0,a.kt)("p",null,"The following code shows an example of using ",(0,a.kt)("inlineCode",{parentName:"p"},"Finalize")," to make sure\nthat when an object is finalized (i.e., goes out of scope), the\ndynamically allocated elements are chained on a free list:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"with Ada.Finalization;\npackage List is\n   type Object is private;\n   function &quot;=&quot; (Left, Right : Object) return Boolean;  -- element-by-element comparison\n   ... -- Operations go here\nprivate\n   type Handle is access List.Object;\n   type Object is new Ada.Finalization.Controlled with\n      record\n         Next : List.Handle;\n         ... -- Useful information go here\n      end record;\n   procedure Adjust (L : in out List.Object);\n   procedure Finalize (L : in out List.Object);\nend List;\npackage body List is\n   Free_List : List.Handle;\n   ...\n   procedure Adjust (L : in out List.Object) is\n   begin\n      L := Deep_Copy (L);\n   end Adjust;\n   procedure Finalize (L : in out List.Object) is\n   begin\n      -- Chain L to Free_List\n   end Finalize;\nend List;\n")),(0,a.kt)("h4",u({},{id:"rationale-16"}),"rationale"),(0,a.kt)("p",null,"See also 6.3.2 for variations on these problems. A dynamically allocated\nobject is an object created by the execution of an allocator (",(0,a.kt)("inlineCode",{parentName:"p"},"new"),").\nAllocated objects referenced by access variables allow you to generate\naliases ",(0,a.kt)("em",{parentName:"p"},",")," which are multiple references to the same object. Anomalous\nbehavior can arise when you reference a deallocated object by another\nname. This is called a dangling reference. Totally disassociating a\nstill-valid object from all names is called dropping a pointer. A\ndynamically allocated object that is not associated with a name cannot\nbe referenced or explicitly deallocated."),(0,a.kt)("p",null,"A dropped pointer depends on an implicit memory manager for reclamation\nof space. It also raises questions for the reader as to whether the loss\nof access to the object was intended or accidental."),(0,a.kt)("p",null,"An Ada environment is not required to provide deallocation of\ndynamically allocated objects. If provided, it may be provided\nimplicitly (objects are deallocated when their access type goes out of\nscope), explicitly (objects are deallocated when\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," is called), or both. To increase the\nlikelihood of the storage space being reclaimed, it is best to call\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," explicitly for each dynamically created\nobject when you are finished using it. Calls to\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," also document a deliberate decision to\nabandon an object, making the code easier to read and understand. To be\nabsolutely certain that space is reclaimed and reused, manage your own"),(0,a.kt)("i",null,'"free list."')," Keep track of which objects you are finished with, and reuse them instead of dynamically allocating new objects later.",(0,a.kt)("p",null,"The dangers of dangling references are that you may attempt to use them,\nthereby accessing memory that you have released to the memory manager\nand that may have been subsequently allocated for another purpose in\nanother part of your program. When you read from such memory, unexpected\nerrors may occur because the other part of your program may have\npreviously written totally unrelated data there. Even worse, when you\nwrite to such memory you can cause errors in an apparently unrelated\npart of the code by changing values of variables dynamically allocated\nby that code. This type of error can be very difficult to find. Finally,\nsuch errors may be triggered in parts of your environment that you did\nnot write, for example, in the memory management system itself, which\nmay dynamically allocate memory to keep records about your dynamically\nallocated memory."),(0,a.kt)("p",null,"Keep in mind that any unreset component of a record or array can also be\na dangling reference or carry a bit pattern representing inconsistent\ndata. Components of an access type are always initialized by default to\n",(0,a.kt)("inlineCode",{parentName:"p"},"null"),"; however, you should not rely on this default initialization. To\nenhance readability and maintainability, you should include explicit\ninitialization."),(0,a.kt)("p",null,"Whenever you use dynamic allocation, it is possible to run out of space.\nAda provides a facility (a length clause) for requesting the size of the\npool of allocation space at compile time. Anticipate that you can still\nrun out at run time. Prepare handlers for the exception ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error"),",\nand consider carefully what alternatives you may be able to include in\nthe program for each such situation."),(0,a.kt)("p",null,"There is a school of thought that dictates avoidance of all dynamic\nallocation. It is largely based on the fear of running out of memory\nduring execution. Facilities, such as length clauses and exception\nhandlers for ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error"),", provide explicit control over memory\npartitioning and error recovery, making this fear unfounded."),(0,a.kt)("p",null,"When implementing a complex data structure (tree, list, sparse matrices,\netc.), you often use access types. If you are not careful, you can\nconsume all your storage with these dynamically allocated objects. You\ncould export a deallocate operation, but it is impossible to ensure that\nit is called at the proper places; you are, in effect, trusting the\nclients. If you derive from controlled types (see 8.3.3 , and 9.2.3 for\nmore information), you can use finalization to deal with deallocation of\ndynamic data, thus avoiding storage exhaustion. User-defined storage\npools give better control over the allocation policy."),(0,a.kt)("p",null,"A related but distinct issue is that of shared versus copy semantics:\neven if the data structure is implemented using access types, you do not\nnecessarily want shared semantics. In some instances you really want",(0,a.kt)("inlineCode",{parentName:"p"},":="),"\nto create a copy, not a new reference, and you really want ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," to\ncompare the contents, not the reference. You should implement your\nstructure as a controlled type. If you want copy semantics, you can\nredefine ",(0,a.kt)("inlineCode",{parentName:"p"},"Adjust")," to perform a deep copy and ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," to perform a comparison\non the contents. You can also redefine ",(0,a.kt)("inlineCode",{parentName:"p"},"Finalize")," to make sure that when\nan object is finalized (i.e., goes out of scope) the dynamically\nallocated elements are chained on a free list (or deallocated by\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation"),")."),(0,a.kt)("p",null,"The implicit use of dynamic (heap) storage by an Ada program during\nexecution poses significant risks that software failures may occur. An\nAda run-time environment may use implicit dynamic (heap) storage in\nassociation with composite objects, dynamically created tasks, and\ncatenation. Often, the algorithms used to manage the dynamic allocation\nand reclamation of heap storage cause fragmentation or leakage, which\ncan lead to storage exhaustion. It is usually very difficult or\nimpossible to recover from storage exhaustion or ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error")," without\nreloading and restarting the Ada program. It would be very restrictive\nto avoid all uses of implicit allocation. On the other hand, preventing\nboth explicit and implicit deallocation significantly reduces the risks\nof fragmentation and leakage without overly restricting your use of\ncomposite objects, access values, task objects, and catenation."),(0,a.kt)("h4",u({},{id:"exceptions-5"}),"exceptions"),(0,a.kt)("p",null,"If a composite object is large enough to be allocated on the heap, you\ncan still declare it as an ",(0,a.kt)("inlineCode",{parentName:"p"},"in")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"in out")," formal parameter. The\nguideline is meant to discourage declaring the object in an object\ndeclaration, a formal ",(0,a.kt)("inlineCode",{parentName:"p"},"out")," parameter, or the value returned by a\nfunction."),(0,a.kt)("p",null,"You should monitor the leakage and/or fragmentation from the heap. If\nthey become steady-state and do not continually increase during program\nor partition execution, you can use the constructs described in the\nguidelines."),(0,a.kt)("h3",u({},{id:"aliased-objects"}),"Aliased Objects"),(0,a.kt)("h4",u({},{id:"guideline-17"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the use of aliased variables."),(0,a.kt)("li",{parentName:"ul"},"Use aliasing for statically created, ragged arrays (Rationale 1995,\n\xa73.7.1 )."),(0,a.kt)("li",{parentName:"ul"},"Use aliasing to refer to part of a data structure when you want to\nhide the internal connections and bookkeeping information.")),(0,a.kt)("h4",u({},{id:"example-17"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"package Message_Services is\n   type Message_Code_Type is range 0 .. 100;\n   subtype Message is String;\n   function Get_Message (Message_Code: Message_Code_Type)\n     return Message;\n   pragma Inline (Get_Message);\nend Message_Services;\npackage body Message_Services is\n   type Message_Handle is access constant Message;\n   Message_0 : aliased constant Message := &quot;OK&quot;;\n   Message_1 : aliased constant Message := &quot;Up&quot;;\n   Message_2 : aliased constant Message := &quot;Shutdown&quot;;\n   Message_3 : aliased constant Message := &quot;Shutup&quot;;\n   . . .\n   type Message_Table_Type is array (Message_Code_Type) of Message_Handle;\n\n   Message_Table : Message_Table_Type :=\n     (0 => Message_0'Access,\n      1 => Message_1'Access,\n      2 => Message_2'Access,\n      3 => Message_3'Access,\n      -- etc.\n     );\n   function Get_Message (Message_Code : Message_Code_Type)\n     return Message is\n   begin\n      return Message_Table (Message_Code).all;\n   end Get_Message;\nend Message_Services;\n")),(0,a.kt)("p",null,"The following code fragment shows a use of aliased objects, using the\nattribute ",(0,a.kt)("inlineCode",{parentName:"p"},"'Access")," to implement a generic component that manages hashed\ncollections of objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"generic\n   type Hash_Index is mod <>;\n   type Object is tagged private;\n   type Handle is access all Object;\n   with function Hash (The_Object : in Object) return Hash_Index;\npackage Collection is\n   function Insert (Object : in Collection.Object) return Collection.Handle;\n   function Find (Object : in Collection.Object) return Collection.Handle;\n   Object_Not_Found : exception;\n\n   ...\nprivate\n   type Cell;\n   type Access_Cell is access Cell;\nend Collection;\npackage body Collection is\n   type Cell is\n   record\n      Value : aliased Collection.Object;\n      Link  : Access_Cell;\n   end record;\n   type Table_Type is array (Hash_Index) of Access_Cell;\n\n   Table : Table_Type;\n   -- Go through the collision chain and return an access to the useful data.\n   function Find (Object : in Collection.Object;\n                  Index  : in Hash_Index) return Handle is\n      Current : Access_Cell := Table (Index);\n   begin\n      while Current /= null loop\n         if Current.Value = Object then\n            return Current.Value'Access;\n         else\n            Current := Current.Link;\n         end if;\n      end loop;\n      raise Object_Not_Found;\n   end Find;\n   -- The exported one\n   function Find (Object : in Collection.Object) return Collection.Handle is\n      Index : constant Hash_Index := Hash (Object);\n   begin\n      return Find (Object, Index);\n   end Find;\n   ...\nend Collection;\n")),(0,a.kt)("h4",u({},{id:"rationale-17"}),"rationale"),(0,a.kt)("p",null,"Aliasing allows the programmer to have indirect access to declared\nobjects. Because you can update aliased objects through more than one\npath, you must exercise caution to avoid unintended updates. When you\nrestrict the aliased objects to being constant, you avoid having the\nobject unintentionally modified. In the example above, the individual\nmessage objects are aliased constant message strings so their values\ncannot be changed. The ragged array is then initialized with references\nto each of these constant strings."),(0,a.kt)("p",null,"Aliasing allows you to manipulate objects using indirection while\navoiding dynamic allocation. For example, you can insert an object onto\na linked list without dynamically allocating the space for that object\n(Rationale 1995, \xa73.7.1 )."),(0,a.kt)("p",null,"Another use of aliasing is in a linked data structure in which you try\nto hide the enclosing container. This is essentially the inverse of a\nself-referential data structure (see Guideline 5.4.7 ). If a package\nmanages some data using a linked data structure, you may only want to\nexport access values that denote the ",(0,a.kt)("em",{parentName:"p"},'"useful"')," data. You can use an\naccess-to-object to return an access to the useful data, excluding the\npointers used to chain objects."),(0,a.kt)("h3",u({},{id:"access-discriminants"}),"Access Discriminants"),(0,a.kt)("h4",u({},{id:"guideline-18"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access discriminants to create self-referential data structures,\ni.e., a data structure one of whose components points to the\nenclosing structure.")),(0,a.kt)("h4",u({},{id:"example-18"}),"example"),(0,a.kt)("p",null,"See the examples in Guidelines 8.3.6 (using access discriminants to\nbuild an iterator) and 9.5.1 (using access discriminants in multiple\ninheritance)."),(0,a.kt)("h4",u({},{id:"rationale-18"}),"rationale"),(0,a.kt)("p",null,'The access discriminant is essentially a pointer of an anonymous type\nbeing used as a discriminant. Because the access discriminant is of an\nanonymous access type, you cannot declare other objects of the type.\nThus, once you initialize the discriminant, you create a "permanent"\n(for the lifetime of the object) association between the discriminant\nand the object it accesses. When you create a self-referential\nstructure, that is, a component of the structure is initialized to point\nto the enclosing object, the ',(0,a.kt)("em",{parentName:"p"},'"constant"')," behavior of the access\ndiscriminant provides the right behavior to help you maintain the\nintegrity of the structure."),(0,a.kt)("p",null,"See also Rationale (1995, \xa74.6.3) for a discussion of access\ndiscriminants to achieve multiple views of an object."),(0,a.kt)("p",null,"See also Guideline 6.1.3 for an example of an access discriminant for a\ntask type."),(0,a.kt)("h3",u({},{id:"modular-types"}),"Modular Types"),(0,a.kt)("h4",u({},{id:"guideline-19"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use modular types rather than Boolean arrays when you create data\nstructures that need bit-wise operations, such as ",(0,a.kt)("inlineCode",{parentName:"li"},"and")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"or"),".")),(0,a.kt)("h4",u({},{id:"example-19"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"with Interfaces;\nprocedure Main is\n   type Unsigned_Byte is mod 255;\n\n   X : Unsigned_Byte;\n   Y : Unsigned_Byte;\n   Z : Unsigned_Byte;\n   X1 : Interfaces.Unsigned_16;\nbegin -- Main\n   Z := X or Y;  -- does not cause overflow\n\n   -- Show example of left shift\n   X1 := 16#FFFF#;\n   for Counter in 1 .. 16 loop\n      X1 := Interfaces.Shift_Left (Value => X1, Amount => 1);\n   end loop;\nend Main;\n")),(0,a.kt)("h4",u({},{id:"rationale-19"}),"rationale"),(0,a.kt)("p",null,"Modular types are preferred when the number of bits is known to be fewer\nthan the number of bits in a word and/or performance is a serious\nconcern. Boolean arrays are appropriate when the number of bits is not\nparticularly known in advance and performance is not a serious issue.\nSee also Guideline 10.6.3 ."),(0,a.kt)("h2",u({},{id:"expressions"}),"Expressions"),(0,a.kt)("p",null,"Properly coded expressions can enhance the readability and\nunderstandability of a program. Poorly coded expressions can turn a\nprogram into a maintainer's nightmare."),(0,a.kt)("h3",u({},{id:"range-values"}),"Range Values"),(0,a.kt)("h4",u({},{id:"guideline-20"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"'First")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"'Last")," instead of numeric literals to represent the\nfirst or last values of a range."),(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"'Range")," or the subtype name of the range instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"'First .. 'Last"),".")),(0,a.kt)("h4",u({},{id:"example-20"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Temperature      is range All_Time_Low .. All_Time_High;\ntype Weather_Stations is range            1 ..  Max_Stations;\nCurrent_Temperature : Temperature := 60;\nOffset              : Temperature;\n...\nfor I in Weather_Stations loop\n   Offset := Current_Temperature - Temperature'First;\n   ...\nend loop;\n")),(0,a.kt)("h4",u({},{id:"rationale-20"}),"rationale"),(0,a.kt)("p",null,"In the example above, it is better to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Weather_Stations")," in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop than to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Weather_Stations'First")," ",(0,a.kt)("inlineCode",{parentName:"p"},".. Weather_Stations'Last")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"1 .. Max_Stations")," because it is clearer,\nless error-prone, and less dependent on the definition of the type\n",(0,a.kt)("inlineCode",{parentName:"p"},"Weather_Stations"),". Similarly, it is better to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Temperature'First"),"\nin the offset calculation than to use ",(0,a.kt)("inlineCode",{parentName:"p"},"All_Time_Low")," because the code\nwill still be correct if the definition of the subtype ",(0,a.kt)("inlineCode",{parentName:"p"},"Temperature")," is\nchanged. This enhances program reliability."),(0,a.kt)("h4",u({},{id:"caution-1"}),"caution"),(0,a.kt)("p",null,"When you implicitly specify ranges and attributes like this, be careful\nthat you use the correct subtype name. It is easy to refer to a very\nlarge range without realizing it. For example, given the declarations:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type    Large_Range is new Integer;\nsubtype Small_Range is Large_Range range 1 .. 10;\n\ntype Large_Array is array (Large_Range) of Integer;\ntype Small_Array is array (Small_Range) of Integer;\n")),(0,a.kt)("p",null,"then the first declaration below works fine, but the second one is\nprobably an accident and raises an exception on most machines because it\nis requesting a huge array (indexed from the smallest integer to the\nlargest one):"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Array_1 : Small_Array;\nArray_2 : Large_Array;\n")),(0,a.kt)("h3",u({},{id:"array-attributes"}),"Array Attributes"),(0,a.kt)("h4",u({},{id:"guideline-21"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use array attributes ",(0,a.kt)("inlineCode",{parentName:"li"},"'First"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"'Last"),", or ",(0,a.kt)("inlineCode",{parentName:"li"},"'Length")," instead of\nnumeric literals for accessing arrays."),(0,a.kt)("li",{parentName:"ul"},"Use the ",(0,a.kt)("inlineCode",{parentName:"li"},"'Range")," of the array instead of the name of the index\nsubtype to express a range."),(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"'Range")," instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"'First .. 'Last")," to express a range.")),(0,a.kt)("h4",u({},{id:"example-21"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"subtype Name_String is String (1 .. Name_Length);\nFile_Path : Name_String := (others => ' ');\n...\nfor I in File_Path'Range loop\n   ...\nend loop;\n")),(0,a.kt)("h4",u({},{id:"rationale-21"}),"rationale"),(0,a.kt)("p",null,"In the example above, it is better to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String'Range")," in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop than to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String_Size"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String'First .. Name_String'Last"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"1 .. 30")," because it is clearer, less error-prone,\nand less dependent on the definitions of ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String_Size"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_String")," is changed to have a different\nindex type or if the bounds of the array are changed, this will still\nwork correctly. This enhances program reliability."),(0,a.kt)("h3",u({},{id:"parenthetical-expressions"}),"Parenthetical Expressions"),(0,a.kt)("h4",u({},{id:"guideline-22"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use parentheses to specify the order of subexpression evaluation to\nclarify expressions (NASA 1987 )."),(0,a.kt)("li",{parentName:"ul"},"Use parentheses to specify the order of evaluation for\nsubexpressions whose correctness depends on left to right\nevaluation.")),(0,a.kt)("h4",u({},{id:"example-22"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"(1.5 * X**2)/A - (6.5*X + 47.0)\n2*I + 4*Y + 8*Z + C\n")),(0,a.kt)("h4",u({},{id:"rationale-22"}),"rationale"),(0,a.kt)("p",null,"The Ada rules of operator precedence are defined in the Ada Reference\nManual (1995, \xa74.5) and follow the same commonly accepted precedence of\nalgebraic operators. The strong typing facility in Ada combined with the\ncommon precedence rules make many parentheses unnecessary. However, when\nan uncommon combination of operators occurs, it may be helpful to add\nparentheses even when the precedence rules apply. The expression:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"5 + ((Y ** 3) mod 10)\n")),(0,a.kt)("p",null,"is clearer, and equivalent to:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"5 + Y**3 mod 10\n")),(0,a.kt)("p",null,"The rules of evaluation do specify left to right evaluation for\noperators with the same precedence level. However, it is the most\ncommonly overlooked rule of evaluation when checking expressions for\ncorrectness."),(0,a.kt)("h3",u({},{id:"positive-forms-of-logic"}),"Positive Forms of Logic"),(0,a.kt)("h4",u({},{id:"guideline-23"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid names and constructs that rely on the use of negatives."),(0,a.kt)("li",{parentName:"ul"},"Choose names of flags so they represent states that can be used in\npositive form.")),(0,a.kt)("h4",u({},{id:"example-23"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Operator_Missing then\n")),(0,a.kt)("p",null,"rather than either:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if not Operator_Found then\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if not Operator_Missing then\n")),(0,a.kt)("h4",u({},{id:"rationale-23"}),"rationale"),(0,a.kt)("p",null,"Relational expressions can be more readable and understandable when\nstated in a positive form. As an aid in choosing the name, consider that\nthe most frequently used branch in a conditional construct should be\nencountered first."),(0,a.kt)("h4",u({},{id:"exceptions-6"}),"exceptions"),(0,a.kt)("p",null,"There are cases in which the negative form is unavoidable. If the\nrelational expression better reflects what is going on in the code, then\ninverting the test to adhere to this guideline is not recommended."),(0,a.kt)("h3",u({},{id:"short-circuit-forms-of-the-logical-operators"}),"Short Circuit Forms of the Logical Operators"),(0,a.kt)("h4",u({},{id:"guideline-24"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use short-circuit forms of the logical operators to specify the\norder of conditions when the failure of one condition means that the\nother condition will raise an exception.")),(0,a.kt)("h4",u({},{id:"example-24"}),"example"),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Y /= 0 or else (X/Y) /= 10 then\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Y /= 0 then\n   if (X/Y) /= 10 then\n")),(0,a.kt)("p",null,"rather than either:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Y /= 0 and (X/Y) /= 10 then\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if (X/Y) /= 10 then\n")),(0,a.kt)("p",null,"to avoid ",(0,a.kt)("inlineCode",{parentName:"p"},"Constraint_Error.")),(0,a.kt)("p",null,"Use:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Target /= null and then Target.Distance < Threshold then\n")),(0,a.kt)("p",null,"rather than:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Target.Distance < Threshold then\n")),(0,a.kt)("p",null,"to avoid referencing a field in a nonexistent object."),(0,a.kt)("h4",u({},{id:"rationale-24"}),"rationale"),(0,a.kt)("p",null,"The use of short-circuit control forms prevents a class of\ndata-dependent errors or exceptions that can occur as a result of\nexpression evaluation. The short-circuit forms guarantee an order of\nevaluation and an ",(0,a.kt)("inlineCode",{parentName:"p"},"exit")," from the sequence of relational expressions as\nsoon as the expression's result can be determined."),(0,a.kt)("p",null,"In the absence of short-circuit forms, Ada does not provide a guarantee\nof the order of expression evaluation, nor does the language guarantee\nthat evaluation of a relational expression is abandoned when it becomes\nclear that it evaluates to ",(0,a.kt)("inlineCode",{parentName:"p"},"False")," (for ",(0,a.kt)("inlineCode",{parentName:"p"},"and"),") or ",(0,a.kt)("inlineCode",{parentName:"p"},"True")," (for ",(0,a.kt)("inlineCode",{parentName:"p"},"or"),")."),(0,a.kt)("h4",u({},{id:"notes-6"}),"notes"),(0,a.kt)("p",null,"If it is important that all parts of a given expression always be\nevaluated, the expression probably violates Guideline 4.1.4 , which\nlimits side-effects in functions."),(0,a.kt)("h3",u({},{id:"accuracy-of-operations-with-real-operands"}),"Accuracy of Operations With Real Operands"),(0,a.kt)("h4",u({},{id:"guideline-25"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"<=")," and ",(0,a.kt)("inlineCode",{parentName:"li"},">=")," in relational expressions with real operands\ninstead of ",(0,a.kt)("inlineCode",{parentName:"li"},"="),".")),(0,a.kt)("h4",u({},{id:"example-25"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Current_Temperature   : Temperature :=       0.0;\nTemperature_Increment : Temperature := 1.0 / 3.0;\nMaximum_Temperature   : constant    :=     100.0;\n...\nloop\n   ...\n   Current_Temperature :=\n         Current_Temperature + Temperature_Increment;\n   ...\n   exit when Current_Temperature >= Maximum_Temperature;\n   ...\nend loop;\n")),(0,a.kt)("h4",u({},{id:"rationale-25"}),"rationale"),(0,a.kt)("p",null,"Fixed- and floating-point values, even if derived from similar\nexpressions, may not be exactly equal. The imprecise, finite\nrepresentations of real numbers in hardware always have round-off errors\nso that any variation in the construction path or history of two real\nnumbers has the potential for resulting in different numbers, even when\nthe paths or histories are mathematically equivalent."),(0,a.kt)("p",null,"The Ada definition of model intervals also means that the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"<=")," is\nmore portable than either ",(0,a.kt)("inlineCode",{parentName:"p"},"<")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"="),"."),(0,a.kt)("h4",u({},{id:"notes-7"}),"notes"),(0,a.kt)("p",null,"Floating-point arithmetic is treated in Guideline 7.2.7 ."),(0,a.kt)("h4",u({},{id:"exceptions-7"}),"exceptions"),(0,a.kt)("p",null,"If your application must test for an exact value of a real number (e.g.,\ntesting the precision of the arithmetic on a certain machine), then the\n",(0,a.kt)("inlineCode",{parentName:"p"},"=")," would have to be used. But never use ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," on real operands as a\ncondition to exit a loop ."),(0,a.kt)("h2",u({},{id:"statements"}),"Statements"),(0,a.kt)("p",null,"Careless or convoluted use of statements can make a program hard to read\nand maintain even if its global structure is well organized. You should\nstrive for simple and consistent use of statements to achieve clarity of\nlocal program structure. Some of the guidelines in this section counsel\nuse or avoidance of particular statements. As pointed out in the\nindividual guidelines, rigid adherence to those guidelines would be\nexcessive, but experience has shown that they generally lead to code\nwith improved reliability and maintainability."),(0,a.kt)("h3",u({},{id:"nesting"}),"Nesting"),(0,a.kt)("h4",u({},{id:"guideline-26"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the depth of nested expressions (Nissen and Wallis 1984 )."),(0,a.kt)("li",{parentName:"ul"},"Minimize the depth of nested control structures (Nissen and Wallis\n1984 )."),(0,a.kt)("li",{parentName:"ul"},"Try using simplification heuristics (see the following Notes ).")),(0,a.kt)("h4",u({},{id:"instantiation-1"}),"instantiation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not nest expressions or control structures beyond a nesting level\nof five.")),(0,a.kt)("h4",u({},{id:"example-26"}),"example"),(0,a.kt)("p",null,"The following section of code:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if not Condition_1 then\n   if Condition_2 then\n      Action_A;\n   else  -- not Condition_2\n      Action_B;\n   end if;\nelse  -- Condition_1\n   Action_C;\nend if;\n")),(0,a.kt)("p",null,"can be rewritten more clearly and with less nesting as:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Condition_1 then\n   Action_C;\nelsif Condition_2 then\n   Action_A;\nelse  -- not (Condition_1 or Condition_2)\n   Action_B;\nend if;\n")),(0,a.kt)("h4",u({},{id:"rationale-26"}),"rationale"),(0,a.kt)("p",null,"Deeply nested structures are confusing, difficult to understand, and\ndifficult to maintain. The problem lies in the difficulty of determining\nwhat part of a program is contained at any given level. For expressions,\nthis is important in achieving the correct placement of balanced\ngrouping symbols and in achieving the desired operator precedence. For\ncontrol structures, the question involves what part is controlled.\nSpecifically, is a given statement at the proper level of nesting, that\nis, is it too deeply or too shallowly nested, or is the given statement\nassociated with the proper choice, for example, for ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"case"),"\nstatements? Indentation helps, but it is not a panacea. Visually\ninspecting alignment of indented code (mainly intermediate levels) is an\nuncertain job at best. To minimize the complexity of the code, keep the\nmaximum number of nesting levels between three and five."),(0,a.kt)("h4",u({},{id:"notes-8"}),"notes"),(0,a.kt)("p",null,"Ask yourself the following questions to help you simplify the code:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Can some part of the expression be put into a constant or variable?"),(0,a.kt)("li",{parentName:"ul"},"Does some part of the lower nested control structures represent a\nsignificant and, perhaps, reusable computation that I can factor\ninto a subprogram ?"),(0,a.kt)("li",{parentName:"ul"},"Can I convert these nested ",(0,a.kt)("inlineCode",{parentName:"li"},"if")," statements into a ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statement?"),(0,a.kt)("li",{parentName:"ul"},"Am I using ",(0,a.kt)("inlineCode",{parentName:"li"},"else if")," where I could be using ",(0,a.kt)("inlineCode",{parentName:"li"},"elsif"),"?"),(0,a.kt)("li",{parentName:"ul"},"Can I reorder the conditional expressions controlling this nested\nstructure?"),(0,a.kt)("li",{parentName:"ul"},"Is there a different design that would be simpler?")),(0,a.kt)("h4",u({},{id:"exceptions-8"}),"exceptions"),(0,a.kt)("p",null,"If deep nesting is required frequently, there may be overall design\ndecisions for the code that should be changed. Some algorithms require\ndeeply nested loops and segments controlled by conditional branches.\nTheir continued use can be ascribed to their efficiency, familiarity,\nand time-proven utility. When nesting is required, proceed cautiously\nand take special care with the choice of identifiers and loop and block\nnames."),(0,a.kt)("h3",u({},{id:"slices"}),"Slices"),(0,a.kt)("h4",u({},{id:"guideline-27"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use slices rather than a loop to copy part of an array.")),(0,a.kt)("h4",u({},{id:"example-27"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"First  : constant Index := Index'First;\nSecond : constant Index := Index'Succ(First);\nThird  : constant Index := Index'Succ(Second);\ntype Vector is array (Index range <>) of Element;\nsubtype Column_Vector is Vector (Index);\ntype    Square_Matrix is array  (Index) of Column_Vector;\nsubtype Small_Range  is Index range First .. Third;\nsubtype Diagonals    is Vector (Small_Range);\ntype    Tri_Diagonal is array  (Index) of Diagonals;\nMarkov_Probabilities : Square_Matrix;\nDiagonal_Data        : Tri_Diagonal;\n...\n-- Remove diagonal and off diagonal elements.\nDiagonal_Data(Index'First)(First) := Null_Value;\nDiagonal_Data(Index'First)(Second .. Third) :=\n      Markov_Probabilities(Index'First)(First .. Second);\nfor I in Second .. Index'Pred(Index'Last) loop\n   Diagonal_Data(I) :=\n         Markov_Probabilities(I)(Index'Pred(I) .. Index'Succ(I));\nend loop;\nDiagonal_Data(Index'Last)(First .. Second) :=\n      Markov_Probabilities(Index'Last)(Index'Pred(Index'Last) .. Index'Last);\nDiagonal_Data(Index'Last)(Third) := Null_Value;\n")),(0,a.kt)("h4",u({},{id:"rationale-27"}),"rationale"),(0,a.kt)("p",null,"An assignment statement with slices is simpler and clearer than a loop\nand helps the reader see the intended action. See also Guideline 10.5.7\nregarding possible performance issues of slice assignments versus loops."),(0,a.kt)("h3",u({},{id:"case-statements"}),"Case Statements"),(0,a.kt)("h4",u({},{id:"guideline-28"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the use of an ",(0,a.kt)("inlineCode",{parentName:"li"},"others")," choice in a ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statement."),(0,a.kt)("li",{parentName:"ul"},"Do not use ranges of enumeration literals in ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statements."),(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statements rather than ",(0,a.kt)("inlineCode",{parentName:"li"},"if/elsif")," statements, wherever\npossible."),(0,a.kt)("li",{parentName:"ul"},"Use type extension and dispatching rather than ",(0,a.kt)("inlineCode",{parentName:"li"},"case")," statements if,\npossible.")),(0,a.kt)("h4",u({},{id:"example-28"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Color is (Red, Green, Blue, Purple);\nCar_Color : Color := Red;\n...\ncase Car_Color is\n   when Red .. Blue => ...\n   when Purple      => ...\nend case;  -- Car_Color\n")),(0,a.kt)("p",null,"Now consider a change in the type:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Color is (Red, Yellow, Green, Blue, Purple);\n")),(0,a.kt)("p",null,"This change may have an unnoticed and undesired effect in the ",(0,a.kt)("inlineCode",{parentName:"p"},"case"),"\nstatement. If the choices had been enumerated explicitly, as ",(0,a.kt)("inlineCode",{parentName:"p"},"when Red | Green | Blue =>")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"when")," ",(0,a.kt)("inlineCode",{parentName:"p"},"Red .. Blue =>"),", then the ",(0,a.kt)("inlineCode",{parentName:"p"},"case"),"\nstatement would not have compiled. This would have forced the maintainer\nto make a conscious decision about what to do in the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"Yellow"),"."),(0,a.kt)("p",null,"In the following example, assume that a menu has been posted, and the\nuser is expected to enter one of the four choices. Assume that\n",(0,a.kt)("inlineCode",{parentName:"p"},"User_Choice")," is declared as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Character")," and that ",(0,a.kt)("inlineCode",{parentName:"p"},"Terminal_IO.Get"),"\nhandles errors in user input. The less readable alternative with the\n",(0,a.kt)("inlineCode",{parentName:"p"},"if/elsif")," statement is shown after the ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"Do_Menu_Choices_1:\n   loop\n      ...\n\n      case User_Choice is\n         when 'A'    => Item := Terminal_IO.Get (&quot;Item to add&quot;);\n         when 'D'    => Item := Terminal_IO.Get (&quot;Item to delete&quot;);\n         when 'M'    => Item := Terminal_IO.Get (&quot;Item to modify&quot;);\n         when 'Q'    => exit Do_Menu_Choices_1;\n\n         when others => -- error has already been signaled to user\n            null;\n      end case;\n   end loop Do_Menu_Choices_1;\n\nDo_Menu_Choices_2:\n   loop\n      ...\n\n      if User_Choice = 'A' then\n         Item := Terminal_IO.Get (&quot;Item to add&quot;);\n\n      elsif User_Choice = 'D' then\n         Item := Terminal_IO.Get (&quot;Item to delete&quot;);\n\n      elsif User_Choice = 'M' then\n         Item := Terminal_IO.Get (&quot;Item to modify&quot;);\n\n      elsif User_Choice = 'Q' then\n         exit Do_Menu_Choices_2;\n\n      end if;\n   end loop Do_Menu_Choices_2;\n")),(0,a.kt)("h4",u({},{id:"rationale-28"}),"rationale"),(0,a.kt)("p",null,"All possible values for an object should be known and should be assigned\nspecific actions. Use of an ",(0,a.kt)("inlineCode",{parentName:"p"},"others")," clause may prevent the developer\nfrom carefully considering the actions for each value. A compiler warns\nthe user about omitted values if an ",(0,a.kt)("inlineCode",{parentName:"p"},"others")," clause is not used."),(0,a.kt)("p",null,"You may not be able to avoid the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"others")," in a ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statement\nwhen the subtype of the case expression has many values, for example,\n",(0,a.kt)("inlineCode",{parentName:"p"},"universal_integer"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Wide_Character"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"Character"),"). If your choice\nof values is small compared to the range of the subtype, you should\nconsider using an ",(0,a.kt)("inlineCode",{parentName:"p"},"if/elsif")," statement. Note that you must supply an\n",(0,a.kt)("inlineCode",{parentName:"p"},"others")," alternative when your ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," expression is of a generic type."),(0,a.kt)("p",null,"Each possible value should be explicitly enumerated. Ranges can be\ndangerous because of the possibility that the range could change and the\n",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statement may not be reexamined. If you have declared a subtype\nto correspond to the range of interest, you can consider using this\nnamed subtype."),(0,a.kt)("p",null,"In many instances, ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements enhance the readability of the\ncode. See Guideline 10.5.3 for a discussion of the performance\nconsiderations. In many implementations, ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements may be more\nefficient."),(0,a.kt)("p",null,"Type extension and dispatching ease the maintenance burden when you add\na new variant to a data structure. See also Guidelines 5.4.2 and 5.4.4 ."),(0,a.kt)("h4",u({},{id:"notes-9"}),"notes"),(0,a.kt)("p",null,"Ranges that are needed in ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements can use constrained subtypes\nto enhance maintainability. It is easier to maintain because the\ndeclaration of the range can be placed where it is logically part of the\nabstraction, not buried in a ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statement in the executable code:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"subtype Lower_Case is Character range 'a' .. 'z';\nsubtype Upper_Case is Character range 'A' .. 'Z';\nsubtype Control    is Character range Ada.Characters.Latin_1.NUL ..\n                                      Ada.Characters.Latin_1.US;\nsubtype Numbers    is Character range '0' .. '9';\n...\ncase Input_Char is\n   when Lower_Case => Capitalize(Input_Char);\n   when Upper_Case => null;\n   when Control    => raise Invalid_Input;\n   when Numbers    => null;\n   ...\nend case;\n")),(0,a.kt)("h4",u({},{id:"exceptions-9"}),"exceptions"),(0,a.kt)("p",null,"It is acceptable to use ranges for possible values only when the user is\ncertain that new values will never be inserted among the old ones, as\nfor example, in the range of ASCII characters: ",(0,a.kt)("inlineCode",{parentName:"p"},"'a' .. 'z'"),"."),(0,a.kt)("admonition",u({},{type:"note"}),(0,a.kt)("p",{parentName:"admonition"},'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",u({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",u({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work.")))}k.isMDXComponent=!0}}]);