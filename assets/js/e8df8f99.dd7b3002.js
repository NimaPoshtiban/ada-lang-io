"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8311],{6681:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>x,contentTitle:()=>h,default:()=>g,frontMatter:()=>p,metadata:()=>f,toc:()=>y});var a=n(1716),l=n(2787),r=n(2670),o=n(6990),i=Object.defineProperty,d=Object.defineProperties,s=Object.getOwnPropertyDescriptors,m=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable,A=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))c.call(t,n)&&A(e,n,t[n]);if(m)for(var n of m(t))k.call(t,n)&&A(e,n,t[n]);return e};const p={sidebar_position:8},h="2.2 Lexical Elements, Separators, and Delimiters",f={unversionedId:"arm/AA-2/AA-2.2",id:"arm/AA-2/AA-2.2",title:"2.2 Lexical Elements, Separators, and Delimiters",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-2/AA-2.2.mdx",sourceDirName:"arm/AA-2",slug:"/arm/AA-2/AA-2.2",permalink:"/docs/arm/AA-2/AA-2.2",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"referenceManualSidebar",previous:{title:"2.1 Character Set",permalink:"/docs/arm/AA-2/AA-2.1"},next:{title:"2.3 Identifiers",permalink:"/docs/arm/AA-2/AA-2.3"}},x={},y=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],T={toc:y};function g(e){var t,n=e,{components:i}=n,A=((e,t)=>{var n={};for(var a in e)c.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&m)for(var a of m(e))t.indexOf(a)<0&&k.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},T),A),d(t,s({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("h1",u({},{id:"22-lexical-elements-separators-and-delimiters"}),"2.2 Lexical Elements, Separators, and Delimiters"),(0,a.kt)("admonition",u({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("h4",u({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"1")),(0,a.kt)("p",null,"The text of a program consists of the texts of one or more ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation")),"s. The text of each ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation"))," is a sequence of separate ",(0,a.kt)("em",null,"lexical elements"),". Each lexical element is formed from a sequence of characters, and is either a delimiter, an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),", a reserved word, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.4#S0006"},"numeric_literal")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.6#S0016"},"string_literal")),", or a comment. The meaning of a program depends only on the particular sequences of lexical elements that form its ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation")),"s, excluding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.7#S0018"},"comment")),"s.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"2/3")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ",(0,a.kt)("br",null),"The text of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation"))," is divided into ",(0,a.kt)("em",null,"lines"),". In general, the representation for an end of line is implementation defined. However, a sequence of one or more ",(0,a.kt)("code",null,"format_effector"),"s other than the character whose code point is 16#09# (CHARACTER TABULATION) signifies at least one end of line. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"2.a")),(0,a.kt)(l.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The representation for an end of line.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"3/2")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ",(0,a.kt)("br",null),"[In some cases an explicit ",(0,a.kt)("em",null,"separator")," is required to separate adjacent lexical elements.] A separator is any of a ",(0,a.kt)("code",null,"separator_space"),", a ",(0,a.kt)("code",null,"format_effector"),", or the end of a line, as follows: ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"4/2")),(0,a.kt)("ul",null,(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ",(0,a.kt)("br",null),"A ",(0,a.kt)("code",null,"separator_space")," is a separator except within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.7#S0018"},"comment")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.6#S0016"},"string_literal")),", or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),".",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"5/3")),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ",(0,a.kt)("br",null),"The character whose code point is 16#09# (CHARACTER TABULATION) is a separator except within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.7#S0018"},"comment")),".",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"6")),(0,a.kt)("li",null,"The end of a line is always a separator. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"7"))),(0,a.kt)("p",null,"One or more separators are allowed between any two adjacent lexical elements, before the first of each ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation")),", or after the last. At least one separator is required between an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),", a reserved word, or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.4#S0006"},"numeric_literal"))," and an adjacent ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),", reserved word, or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.4#S0006"},"numeric_literal")),".",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"7.1/3")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0079-1"),"}"," ",(0,a.kt)("br",null),"One or more ",(0,a.kt)("code",null,"other_format")," characters are allowed anywhere that a separator is[; any such characters have no effect on the meaning of an Ada program].",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"8/2")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ",(0,a.kt)("br",null),"A ",(0,a.kt)("em",null,"delimiter")," is either one of the following characters: ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"9/5")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0125-3"),"}"," ","{",(0,a.kt)("em",null,"AI12-0212-1"),"}"," ",(0,a.kt)("br",null),"&    '    (    )    *    +    ,        .    /    :    ;    ","<","    =    ",">","    @    [    ]    |",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"10")),(0,a.kt)("p",null,"or one of the following ",(0,a.kt)("em",null,"compound delimiters")," each composed of two adjacent special characters ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"11")),(0,a.kt)("p",null,"=",">","    ..    **    :=    /=    ",">","=    ","<","=    ","<","<","    ",">",">","    ","<",">",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"12")),(0,a.kt)("p",null,"Each of the special characters listed for single character delimiters is a single delimiter except if this character is used as a character of a compound delimiter, or as a character of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.7#S0018"},"comment")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.6#S0016"},"string_literal")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),", or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.4#S0006"},"numeric_literal")),".",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"13")),(0,a.kt)("p",null,"The following names are used when referring to compound delimiters:",(0,a.kt)("br",null)),(0,a.kt)("h4",u({},{id:"implementation-requirements"}),"Implementation Requirements"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14")),(0,a.kt)("p",null,"delimiter name=",">",'arrow..double dot**double star, exponentiate:=assignment (pronounced: "becomes")/=inequality (pronounced: "not equal")',">","=greater than or equal","<","=less than or equal","<","<","left label bracket",">",">","right label bracket","<",">","boxAn implementation shall support lines of at least 200 characters in length, not counting any characters used to signify the end of a line. An implementation shall support lexical elements of at least 200 characters in length. The maximum supported line length and lexical element length are implementation defined. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14.a")),(0,a.kt)(l.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Maximum supported line length and lexical element length.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14.b")),(0,a.kt)(l.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"From URG recommendation. ",(0,a.kt)("br",null)),(0,a.kt)("h4",u({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14.c/3")),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"The wording was updated to use the new character categories defined in the preceding subclause. ",(0,a.kt)("br",null)),(0,a.kt)("h4",u({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14.d/3")),(0,a.kt)(l.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0079-1"),"}"," ",(0,a.kt)("strong",null,(0,a.kt)("br",null))," Clarified that ",(0,a.kt)("code",null,"other_format")," characters are allowed anywhere that separators are allowed. This was intended in Ada 2005, but didn't actually make it into the wording. ",(0,a.kt)("br",null)),(0,a.kt)("h4",u({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(o.Z,{mdxType:"MarginText"},"14.e/5")),(0,a.kt)(l.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0125-3"),"}"," ","{",(0,a.kt)("em",null,"AI12-0212-1"),"}"," ",(0,a.kt)("br",null),"Added square brackets and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0174"},"target_name"))," symbol (see ",(0,a.kt)("a",{href:"../AA-5/AA-5.2#Subclause_5.2.1"},"5.2.1"),") to the list of delimiters. ",(0,a.kt)("br",null)))}g.isMDXComponent=!0}}]);