"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1992],{1716:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>f});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(a),f=i,u=c["".concat(l,".").concat(f)]||c[f]||h[f]||r;return a?n.createElement(u,s(s({ref:t},d),{},{components:a})):n.createElement(u,s({ref:t},d))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},7736:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:22},s="3.6  Array Types",o={unversionedId:"arm/AA-3.6",id:"arm/AA-3.6",title:"3.6  Array Types",description:"An array object is a composite object consisting of components which all have the same subtype. The name for a component of an array uses one or more index values belonging to specified discrete types. The value of an array object is a composite value consisting of the values of the components.",source:"@site/docs/arm/AA-3.6.md",sourceDirName:"arm",slug:"/arm/AA-3.6",permalink:"/docs/arm/AA-3.6",draft:!1,tags:[],version:"current",sidebarPosition:22,frontMatter:{sidebar_position:22},sidebar:"tutorialSidebar",previous:{title:"3.5  Scalar Types",permalink:"/docs/arm/AA-3.5"},next:{title:"3.7  Discriminants",permalink:"/docs/arm/AA-3.7"}},l={},p=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"3.6.1  Index Constraints and Discrete Ranges",id:"361--index-constraints-and-discrete-ranges",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"3.6.2  Operations of Array Types",id:"362--operations-of-array-types",level:2},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples-2",level:4},{value:"3.6.3  String Types",id:"363--string-types",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4}],d={toc:p};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"36--array-types"},"3.6  Array Types"),(0,i.kt)("p",null,"An array object is a composite object consisting of components which all have the same subtype. The name for a component of an array uses one or more index values belonging to specified discrete types. The value of an array object is a composite value consisting of the values of the components. "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"array_type_definition",(0,i.kt)("a",{id:"S0051"})," ::=\n",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0052"},"unconstrained_array_definition")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition")),(0,i.kt)("p",null,"unconstrained_array_definition",(0,i.kt)("a",{id:"S0052"})," ::=\narray(",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0053"},"index_subtype_definition")," {, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0053"},"index_subtype_definition"),"}) of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")),(0,i.kt)("p",null,"index_subtype_definition",(0,i.kt)("a",{id:"S0053"})," ::= ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," range ","<",">"),(0,i.kt)("p",null,"constrained_array_definition",(0,i.kt)("a",{id:"S0054"})," ::=\narray (",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," {, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"}) of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")),(0,i.kt)("p",null,"discrete",(0,i.kt)("em",{parentName:"p"},"subtype_definition",(0,i.kt)("a",{id:"S0055"})," ::= discrete"),(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")),(0,i.kt)("p",null,"{AI95-00230-01} {AI95-00406-01} component_definition",(0,i.kt)("a",{id:"S0056"})," ::=\n","[aliased][subtype_indication]","(./AA-3.2#S0027)\n| ","[aliased][access_definition]","(./AA-3.10#S0084)"),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"For a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," that is a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),", the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," shall resolve to be of some specific discrete type[; which discrete type shall be determined without using any context other than the bounds of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," itself (plus the preference for root_integer - see 8.6).] "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0053"},"index_subtype_definition")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," defines an index subtype; its type (the index type) shall be discrete. "),(0,i.kt)("p",null,"Discussion: An index is a discrete quantity used to select along a given dimension of an array. A component is selected by specifying corresponding values for each of the indices. "),(0,i.kt)("p",null,"The subtype defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," (the component subtype) shall be a definite subtype. "),(0,i.kt)("p",null,"Ramification: This applies to all uses of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),", including in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.8#S0066"},"record_type_definition"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-9.4#S0251"},"protected_definition"),"s."),(0,i.kt)("p",null,"This paragraph was deleted.{AI95-00363-01} "),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"An array is characterized by the number of indices (the dimensionality of the array), the type and position of each index, the lower and upper bounds for each index, and the subtype of the components. The order of the indices is significant."),(0,i.kt)("p",null,"A one-dimensional array has a distinct component for each possible index value. A multidimensional array has a distinct component for each possible sequence of index values that can be formed by selecting one value for each index position (in the given order). The possible values for a given index are all the values between the lower and upper bounds, inclusive; this range of values is called the index range. The bounds of an array are the bounds of its index ranges. The length of a dimension of an array is the number of values of the index range of the dimension (zero for a null range). The length of a one-dimensional array is the length of its only dimension."),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," defines an array type and its first subtype. For each object of this array type, the number of indices, the type and position of each index, and the subtype of the components are as in the type definition","[; the values of the lower and upper bounds for each index belong to the corresponding index subtype of its type, except for null arrays (see 3.6.1)]","."),(0,i.kt)("p",null,"{AI12-0444-1} An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0052"},"unconstrained_array_definition")," defines an array type with an unconstrained first subtype. Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0053"},"index_subtype_definition")," defines the corresponding index subtype to be the subtype denoted by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark"),". [ The compound delimiter ","<",">"," (called a box) of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0053"},"index_subtype_definition")," stands for an undefined range (different objects of the type can have different bounds).]"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition")," defines an array type with a constrained first subtype. Each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," defines the corresponding index subtype, as well as the corresponding index range for the constrained first subtype. The constraint of the first subtype consists of the bounds of the index ranges. "),(0,i.kt)("p",null,"Discussion: {AI05-0005-1} Although there is no nameable unconstrained array subtype in this case, the predefined slicing and concatenation operations can operate on and yield values that do not necessarily belong to the first array subtype. This is also true for Ada 83. "),(0,i.kt)("p",null,"The discrete subtype defined by a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," is either that defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", or a subtype determined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," as follows: "),(0,i.kt)("p",null,"If the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," resolves to root_integer, then the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," defines a subtype of the predefined type Integer with bounds given by a conversion to Integer of the bounds of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),"; "),(0,i.kt)("p",null,"Reason: This ensures that indexing over the discrete subtype can be performed with regular Integers, rather than only universal_integers. "),(0,i.kt)("p",null,'Discussion: We considered doing this by simply creating a "preference" for Integer when resolving the ',(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". However, this can introduce Beaujolais effects when the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0138"},"simple_expression"),"s involve calls on functions visible due to use clauses. "),(0,i.kt)("p",null,"Otherwise, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," defines a subtype of the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),", with the bounds given by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". "),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," defines the nominal subtype of the components. If the reserved word aliased appears in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),", then each component of the array is aliased (see 3.10). "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," creates the array type and its first subtype, and consists of the elaboration of any ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"s and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition"),"."),(0,i.kt)("p",null,"{8652/0002} {AI95-00171-01} {AI95-00230-01} The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," that does not contain any per-object expressions creates the discrete subtype, and consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition")," that contains one or more per-object expressions is defined in 3.8. The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0084"},"access_definition"),". The elaboration of any ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),"s and the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," are performed in an arbitrary order. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"{AI05-0228-1} For an array type with a scalar component type, the following language-defined representation aspect may be specified with an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," (see 13.1.1): "),(0,i.kt)("p",null,"Default_Component_ValueThis aspect shall be specified by a static expression, and that expression shall be explicit, even if the aspect has a boolean type. Default_Component_Value shall be specified only on a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration"),". "),(0,i.kt)("p",null,"Reason: The part about requiring an explicit expression is to disallow omitting the value for this aspect, which would otherwise be allowed by the rules of 13.1.1."),(0,i.kt)("p",null,"This is a representation attribute in order to disallow specifying it on a derived type that has inherited primitive subprograms; that is necessary as the sizes of out parameters could be different whether or not a Default_Value is specified (see 6.4.1). "),(0,i.kt)("p",null,"Aspect Description for Default_Component_Value: Default value for the components of an array-of-scalar subtype."),(0,i.kt)("p",null,"{AI05-0228-1} {AI12-0427-1} If a derived type inherits a boolean Default_Component_Value aspect, the aspect may be specified to have any value for the derived type. "),(0,i.kt)("p",null,"Reason: This overrides the 13.1.1 rule that says that a boolean aspect with a value True cannot be changed. "),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"{AI05-0228-1} The expected type for the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," specified for the Default_Component_Value aspect is the component type of the array type defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0024"},"full_type_declaration")," on which it appears. "),(0,i.kt)("p",null,"NOTE 1   All components of an array have the same subtype. In particular, for an array of components that are one-dimensional arrays, this means that all components have the same bounds and hence the same length."),(0,i.kt)("p",null,"NOTE 2   Each elaboration of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," creates a distinct array type. A consequence of this is that each object whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.3#S0032"},"object_declaration")," contains an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0051"},"array_type_definition")," is of its own unique type. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of type declarations with unconstrained array definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Vector     is array(Integer  range &lt&gt) of Real;\ntype Matrix     is array(Integer  range &lt&gt, Integer range &lt&gt) of Real;\ntype Bit_Vector is array(Integer  range &lt&gt) of Boolean;\ntype Roman      is array(Positive range &lt&gt) of Roman_Digit; -- see 3.5.2\n\n")),(0,i.kt)("p",null,"Examples of type declarations with constrained array definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Table    is array(1 .. 10) of Integer;\ntype Schedule is array(Day) of Boolean;\ntype Line     is array(1 .. Max_Line_Size) of Character;\n\n")),(0,i.kt)("p",null,"Examples of object declarations with array type definitions: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00433-01} Grid      : array(1 .. 80, 1 .. 100) of Boolean;\nMix       : array(Color range Red .. Green) of Boolean;\nMsg_Table : constant array(Error_Code) of access constant String :=\n      (Too_Big =&gt new String'(\"Result too big\"), Too_Small =&gt ...);\nPage      : array(Positive range &lt&gt) of Line :=  --  an array of arrays\n  (1 | 50  =&gt Line'(1 | Line'Last =&gt '+', others =&gt '-'),  -- see 4.3.3\n   2 .. 49 =&gt Line'(1 | Line'Last =&gt '|', others =&gt ' '));\n    -- Page is constrained by its initial value to (1..50)\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," is modified to allow the reserved word aliased."),(0,i.kt)("p",null,"The syntax rules for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0052"},"unconstrained_array_definition")," and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition")," are modified to use ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," (instead of component_",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"). The effect of this change is to allow the reserved word aliased before the component ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")," in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),' may use arbitrary universal expressions for each bound (e.g. 1 .. 3+5), rather than strictly "implicitly convertible" operands. The subtype defined will still be a subtype of Integer. '),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We introduce a new syntactic category, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0055"},"discrete_subtype_definition"),", as distinct from ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range"),". These two constructs have the same syntax, but their semantics are quite different (one defines a subtype, with a preference for Integer subtypes, while the other just selects a subrange of an existing subtype). We use this new syntactic category in for loops and entry families."),(0,i.kt)("p",null,"The syntax for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," have been moved to their own subclause, since they are no longer used here."),(0,i.kt)("p",null,"The syntax rule for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0056"},"component_definition")," (formerly component_subtype_definition) is moved here from RM83-3.7. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00230-01} {AI95-00406-01} Array components can have an anonymous access type."),(0,i.kt)("p",null,"{AI95-00363-01} The prohibition against unconstrained discriminated aliased components has been lifted. It has been replaced by a prohibition against the actual troublemakers: general access discriminant constraints (see 3.7.1). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0002} {AI95-00171-01} Corrigendum: Added wording to allow the elaboration of per-object constraints for constrained arrays. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0228-1} The new aspect Default_Component_Value allows defining implicit initial values (see 3.3.1) for arrays of scalar types. "),(0,i.kt)("h2",{id:"361--index-constraints-and-discrete-ranges"},"3.6.1  Index Constraints and Discrete Ranges"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," determines the range of possible values for every index of an array subtype, and thereby the corresponding array bounds. "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"index_constraint",(0,i.kt)("a",{id:"S0057"})," ::=  (",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," {, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range"),"})"),(0,i.kt)("p",null,"discrete",(0,i.kt)("em",{parentName:"p"},"range",(0,i.kt)("a",{id:"S0058"})," ::= discrete"),(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," | ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range")),(0,i.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,i.kt)("p",null,"The type of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," is the type of the subtype defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),", or the type of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". For an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint"),", each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," shall resolve to be of the type of the corresponding index. "),(0,i.kt)("p",null,"Discussion: In Ada 95, ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint"),"s only appear in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),"; they no longer appear in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition"),"s. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," shall appear only in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," whose ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," denotes either an unconstrained array subtype, or an unconstrained access subtype whose designated subtype is an unconstrained array subtype; in either case, the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," shall provide a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," for each index of the array type. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," defines a range whose bounds are given by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),", or by the range of the subtype defined by the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication"),". "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"An ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," is compatible with an unconstrained array subtype if and only if the index range defined by each ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," is compatible (see 3.5) with the corresponding index subtype. If any of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range"),"s defines a null range, any array thus constrained is a null array, having no components. An array value satisfies an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," if at each index position the array value and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," have the same index bounds. "),(0,i.kt)("p",null,"Ramification: There is no need to define compatibility with a constrained array subtype, because one is not allowed to constrain it again."),(0,i.kt)("p",null,"The elaboration of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," consists of the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range"),"(s), in an arbitrary order. The evaluation of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," consists of the elaboration of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," or the evaluation of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.5#S0037"},"range"),". "),(0,i.kt)("p",null,"NOTE 1   The elaboration of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0027"},"subtype_indication")," consisting of a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," followed by an ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," checks the compatibility of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," with the ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0028"},"subtype_mark")," (see 3.2.2)."),(0,i.kt)("p",null,"NOTE 2   Even if an array value does not satisfy the index constraint of an array subtype, Constraint_Error is not raised on conversion to the array subtype, so long as the length of each dimension of the array value and the array subtype match. See 4.6. "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Examples of array declarations including an index constraint: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0442-1} Board     : Matrix(1 .. 8,  1 .. 8);  --  see 3.6\nRectangle : Matrix(1 .. 20, 1 .. 30);\nInverse   : Matrix(1 .. N,  1 .. N);  --  N can be nonstatic\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI125-0430-1} Filter    : Bit_Vector(0 .. 31);      --  see 3.6\n\n")),(0,i.kt)("p",null,"Example of array declaration with a constrained array subtype: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"My_Schedule : Schedule;  --  all arrays of type Schedule have the same bounds\n\n")),(0,i.kt)("p",null,"Example of record type with a component that is an array: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Var_Line(Length : Natural) is\n   record\n      Image : String(1 .. Length);\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Null_Line : Var_Line(0);  --  Null_Line.Image is a null array\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"We allow the declaration of a variable with a nominally unconstrained array subtype, so long as it has an initialization expression to determine its bounds. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We have moved the syntax for ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint")," and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range")," here since they are no longer used in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition"),"s. We therefore also no longer have to describe the (special) semantics of ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0057"},"index_constraint"),"s and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0058"},"discrete_range"),"s that appear in ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.6#S0054"},"constrained_array_definition"),"s."),(0,i.kt)("p",null,"The rules given in RM83-3.6.1(5,7-10), which define the bounds of an array object, are redundant with rules given elsewhere, and so are not repeated here. RM83-3.6.1(6), which requires that the (nominal) subtype of an array variable be constrained, no longer applies, so long as the variable is explicitly initialized. "),(0,i.kt)("h2",{id:"362--operations-of-array-types"},"3.6.2  Operations of Array Types"),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"[The argument N used in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator"),"s for the N-th dimension of an array shall be a static ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of some integer type.] The value of N shall be positive (nonzero) and no greater than the dimensionality of the array. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"{8652/0006} {AI95-00030-01} The following attributes are defined for a ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," A that is of an array type ","[(after any implicit dereference)]",", or denotes a constrained array subtype: "),(0,i.kt)("p",null,"Ramification: These attributes are not defined if A is a subtype-mark for an access-to-array subtype. They are defined (by implicit dereference) for access-to-array values."),(0,i.kt)("p",null,"A'FirstA'First denotes the lower bound of the first index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'First(N)A'First(N) denotes the lower bound of the N-th index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'LastA'Last denotes the upper bound of the first index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'Last(N)A'Last(N) denotes the upper bound of the N-th index range; its type is the corresponding index type."),(0,i.kt)("p",null,"A'RangeA'Range is equivalent to the range A'First .. A'Last, except that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," A is only evaluated once."),(0,i.kt)("p",null,"A'Range(N)A'Range(N) is equivalent to the range A'First(N) .. A'Last(N), except that the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0093"},"prefix")," A is only evaluated once."),(0,i.kt)("p",null,"A'LengthA'Length denotes the number of values of the first index range (zero for a null range); its type is universal_integer."),(0,i.kt)("p",null,"A'Length(N)A'Length(N) denotes the number of values of the N-th index range (zero for a null range); its type is universal_integer. "),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,'{AI05-0229-1} An implementation should normally represent multidimensional arrays in row-major order, consistent with the notation used for multidimensional array aggregates (see 4.3.3). However, if convention Fortran is specified for a multidimensional array type, then column-major order should be used instead (see B.5, "Interfacing with Fortran"). '),(0,i.kt)("p",null,"Implementation Advice: Multidimensional arrays should be represented in row-major order, unless the array has convention Fortran."),(0,i.kt)("p",null,"NOTE 1   The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),"s A'First and A'First(1) denote the same value. A similar relation exists for the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),"s A'Last, A'Range, and A'Length. The following relation is satisfied (except for a null array) by the above attributes if the index type is an integer type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   A'Length(N) = A'Last(N) - A'First(N) + 1\n\n")),(0,i.kt)("p",null,"NOTE 2   An array type is limited if its component type is limited (see 7.5)."),(0,i.kt)("p",null,"NOTE 3   The predefined operations of an array type include the membership tests, qualification, and explicit conversion. If the array type is not limited, they also include assignment and the predefined equality operators. For a one-dimensional array type, they include the predefined concatenation operators (if nonlimited) and, if the component type is discrete, the predefined relational operators; if the component type is boolean, the predefined logical operators are also included."),(0,i.kt)("p",null,"NOTE 4   {AI95-00287-01} A component of an array can be named with an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0096"},"indexed_component"),". A value of an array type can be specified with an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.3#S0113"},"array_aggregate"),". For a one-dimensional array type, a slice of the array can be named; also, string literals are defined if the component type is a character type. "),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Examples (using arrays declared in the examples of subclause 3.6.1): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Filter'First      =   0   Filter'Last       =  31   Filter'Length =  32\n--  Rectangle'Last(1) =  20   Rectangle'Last(2) =  30\n\n")),(0,i.kt)("h2",{id:"363--string-types"},"3.6.3  String Types"),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"A one-dimensional array type whose component type is a character type is called a string type."),(0,i.kt)("p",null,"{AI95-00285-01} ","[There are three predefined string types, String, Wide_String, and Wide_Wide_String, each indexed by values of the predefined subtype Positive; these are declared in the visible part of package Standard:]"," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"[subtype Positive is Integer range 1 .. Integer'Last;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00285-01} type String is array(Positive range &lt&gt) of Character;\ntype Wide_String is array(Positive range &lt&gt) of Wide_Character;\ntype Wide_Wide_String is array(Positive range &lt&gt) of Wide_Wide_Character;\n]\n\n")),(0,i.kt)("p",null,"NOTE 1   String literals (see 2.6 and 4.2) are defined for all string types. The concatenation operator & is predefined for string types, as for all nonlimited one-dimensional array types. The ordering operators ","<",", ","<","=, ",">",", and ",">","= are predefined for string types, as for all one-dimensional discrete array types; these ordering operators correspond to lexicographic order (see 4.5.2)."),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Examples of string objects: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Stars      : String(1 .. 120) := (1 .. 120 =&gt '*' );\nQuestion   : constant String  := \"How many characters?\";\n    -- Question'First = 1, Question'Last = 20\n    -- Question'Length = 20 (the number of characters)\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'Ask_Twice  : String  := Question & Question;    -- constrained to (1..40)\nNinety_Six : constant Roman   := "XCVI";    -- see 3.5.2 and 3.6\n\n')),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"The declaration of Wide_String in Standard hides a use-visible declaration with the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),". In rare cases, this might result in an inconsistency between Ada 83 and Ada 95. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"Because both String and Wide_String are always directly visible, an expression like "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'"a" &lt "bc"\n\n')),(0,i.kt)("p",null,"is now ambiguous, whereas in Ada 83 both string literals could be resolved to type String. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The type Wide_String is new (though it was approved by ARG for Ada 83 compilers as well). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"We define the term string type as a natural analogy to the term character type. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} The declaration of Wide_Wide_String in Standard hides a use-visible declaration with the same ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier"),". In the (very) unlikely event that an Ada 95 program had depended on such a use-visible declaration, and the program remains legal after the substitution of Standard.Wide_Wide_String, the meaning of the program will be different. "),(0,i.kt)("h4",{id:"extensions-to-ada-95-1"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00285-01} The type Wide_Wide_String is new."))}h.isMDXComponent=!0}}]);