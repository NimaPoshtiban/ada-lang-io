"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9573],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(a),h=i,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||r;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1436:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:17},o="Annex C Systems Programming",s={unversionedId:"arm/AA-Annex C",id:"arm/AA-Annex C",title:"Annex C Systems Programming",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-Annex C.md",sourceDirName:"arm",slug:"/arm/AA-Annex C",permalink:"/docs/arm/AA-Annex C",draft:!1,tags:[],version:"current",sidebarPosition:17,frontMatter:{sidebar_position:17},sidebar:"tutorialSidebar",previous:{title:"Annex B Interface to Other Languages",permalink:"/docs/arm/AA-Annex B"},next:{title:"Annex D Real-Time Systems",permalink:"/docs/arm/AA-Annex D"}},l={},d=[{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"C.1  Access to Machine Operations",id:"c1--access-to-machine-operations",level:2},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Documentation Requirements",id:"documentation-requirements",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"C.2  Required Representation Support",id:"c2--required-representation-support",level:2},{value:"Implementation Requirements",id:"implementation-requirements-1",level:4},{value:"C.3  Interrupt Support",id:"c3--interrupt-support",level:2},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements-2",level:4},{value:"Documentation Requirements",id:"documentation-requirements-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice-2",level:4},{value:"C.3.1  Protected Procedure Handlers",id:"c31--protected-procedure-handlers",level:3},{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Metrics",id:"metrics",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Implementation Advice",id:"implementation-advice-3",level:4},{value:"C.3.2  The Package Interrupts",id:"c32--the-package-interrupts",level:3},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements-3",level:4},{value:"Documentation Requirements",id:"documentation-requirements-2",level:4},{value:"Implementation Advice",id:"implementation-advice-4",level:4},{value:"Examples",id:"examples",level:4},{value:"C.4  Preelaboration Requirements",id:"c4--preelaboration-requirements",level:2},{value:"Implementation Requirements",id:"implementation-requirements-4",level:4},{value:"Documentation Requirements",id:"documentation-requirements-3",level:4},{value:"Implementation Advice",id:"implementation-advice-5",level:4},{value:"C.5  Pragma Discard_Names",id:"c5--pragma-discard_names",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Advice",id:"implementation-advice-6",level:4},{value:"C.6  Shared Variable Control",id:"c6--shared-variable-control",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Implementation Requirements",id:"implementation-requirements-5",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"C.7  Task Identification and Attributes",id:"c7--task-identification-and-attributes",level:2},{value:"C.7.1  The Package Task_Identification",id:"c71--the-package-task_identification",level:3},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Documentation Requirements",id:"documentation-requirements-4",level:4},{value:"C.7.2  The Package Task_Attributes",id:"c72--the-package-task_attributes",level:3},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Erroneous Execution",id:"erroneous-execution-2",level:4},{value:"Implementation Requirements",id:"implementation-requirements-6",level:4},{value:"Documentation Requirements",id:"documentation-requirements-5",level:4},{value:"Metrics",id:"metrics-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"Implementation Advice",id:"implementation-advice-7",level:4}],p={toc:d};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"annex-c-systems-programming"},"Annex C Systems Programming"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"[ The Systems Programming Annex specifies additional capabilities provided for low-level programming. These capabilities are also required in many real-time, embedded, distributed, and information systems.]"," "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"This Annex is new to Ada 95. "),(0,i.kt)("h2",{id:"c1--access-to-machine-operations"},"C.1  Access to Machine Operations"),(0,i.kt)("p",null,"[This clause specifies rules regarding access to machine instructions from within an Ada program.]"," "),(0,i.kt)("p",null,"Implementation defined: Support for access to machine instructions."),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall support machine code insertions (see 13.8) or intrinsic subprograms (see 6.3.1) (or both). Implementation-defined attributes shall be provided to allow the use of Ada entities as operands."),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"The machine code or intrinsics support should allow access to all operations normally available to assembly language programmers for the target environment, including privileged instructions, if any. "),(0,i.kt)("p",null,"Ramification: Of course, on a machine with protection, an attempt to execute a privileged instruction in user mode will probably trap. Nonetheless, we want implementations to provide access to them so that Ada can be used to write systems programs that run in privileged mode. "),(0,i.kt)("p",null,"The interfacing pragmas (see Annex B) should support interface to assembler; the default assembler should be associated with the convention identifier Assembler. "),(0,i.kt)("p",null,"If an entity is exported to assembly language, then the implementation should allocate it at an addressable location, and should ensure that it is retained by the linking process, even if not otherwise referenced from the Ada code. The implementation should assume that any call to a machine code or assembler subprogram is allowed to read or update every object that is specified as exported. "),(0,i.kt)("h4",{id:"documentation-requirements"},"Documentation Requirements"),(0,i.kt)("p",null,"The implementation shall document the overhead associated with calling machine-code or intrinsic subprograms, as compared to a fully-inlined call, and to a regular out-of-line call. "),(0,i.kt)("p",null,"The implementation shall document the types of the package System.Machine_Code usable for machine code insertions, and the attributes to be used in machine code insertions for references to Ada entities. "),(0,i.kt)("p",null,"The implementation shall document the subprogram calling conventions associated with the convention identifiers available for use with the interfacing pragmas (Ada and Assembler, at a minimum), including register saving, exception propagation, parameter passing, and function value returning. "),(0,i.kt)("p",null,"For exported and imported subprograms, the implementation shall document the mapping between the Link_Name string, if specified, or the Ada designator, if not, and the external link name used for such a subprogram. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: Implementation-defined aspects of access to machine operations."),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"The implementation should ensure that little or no overhead is associated with calling intrinsic and machine-code subprograms. "),(0,i.kt)("p",null,"It is recommended that intrinsic subprograms be provided for convenient access to any machine operations that provide special capabilities or efficiency and that are not otherwise available through the language constructs. Examples of such instructions include: "),(0,i.kt)("p",null,"Atomic read-modify-write operations - e.g., test and set, compare and swap, decrement and test, enqueue/dequeue."),(0,i.kt)("p",null,"Standard numeric functions - e.g., sin, log."),(0,i.kt)("p",null,"String manipulation operations - e.g., translate and test."),(0,i.kt)("p",null,"Vector operations - e.g., compare vector against thresholds."),(0,i.kt)("p",null,"Direct operations on I/O ports."),(0,i.kt)("h2",{id:"c2--required-representation-support"},"C.2  Required Representation Support"),(0,i.kt)("p",null,"This clause specifies minimal requirements on the implementation's support for representation items and related features. "),(0,i.kt)("h4",{id:"implementation-requirements-1"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall support at least the functionality defined by the recommended levels of support in Section 13. "),(0,i.kt)("h2",{id:"c3--interrupt-support"},"C.3  Interrupt Support"),(0,i.kt)("p",null,"[This clause specifies the language-defined model for hardware interrupts in addition to mechanisms for handling interrupts.]"," "),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"[An interrupt represents a class of events that are detected by the hardware or the system software.]"," Interrupts are said to occur. An occurrence of an interrupt is separable into generation and delivery. Generation of an interrupt is the event in the underlying hardware or system that makes the interrupt available to the program. Delivery is the action that invokes part of the program as response to the interrupt occurrence. Between generation and delivery, the interrupt occurrence ","[(or interrupt)]"," is pending. Some or all interrupts may be blocked. When an interrupt is blocked, all occurrences of that interrupt are prevented from being delivered. Certain interrupts are reserved. The set of reserved interrupts is implementation defined. A reserved interrupt is either an interrupt for which user-defined handlers are not supported, or one which already has an attached handler by some other implementation-defined means. Program units can be connected to nonreserved interrupts. While connected, the program unit is said to be attached to that interrupt. The execution of that program unit, the interrupt handler, is invoked upon delivery of the interrupt occurrence. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: Implementation-defined aspects of interrupts."),(0,i.kt)("p",null,"To be honest: As an obsolescent feature, interrupts may be attached to task entries by an address clause. See J.7.1. "),(0,i.kt)("p",null,"While a handler is attached to an interrupt, it is called once for each delivered occurrence of that interrupt. While the handler executes, the corresponding interrupt is blocked."),(0,i.kt)("p",null,"While an interrupt is blocked, all occurrences of that interrupt are prevented from being delivered. Whether such occurrences remain pending or are lost is implementation defined."),(0,i.kt)("p",null,"Each interrupt has a default treatment which determines the system's response to an occurrence of that interrupt when no user-defined handler is attached. The set of possible default treatments is implementation defined, as is the method (if one exists) for configuring the default treatments for interrupts."),(0,i.kt)("p",null,"An interrupt is delivered to the handler (or default treatment) that is in effect for that interrupt at the time of delivery."),(0,i.kt)("p",null,"An exception propagated from a handler that is invoked by an interrupt has no effect."),(0,i.kt)("p",null,"[If the Ceiling_Locking policy (see D.3) is in effect, the interrupt handler executes with the active priority that is the ceiling priority of the corresponding protected object.]"),(0,i.kt)("h4",{id:"implementation-requirements-2"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall provide a mechanism to determine the minimum stack space that is needed for each interrupt handler and to reserve that space for the execution of the handler. ","[This space should accommodate nested invocations of the handler where the system permits this.]"),(0,i.kt)("p",null,"If the hardware or the underlying system holds pending interrupt occurrences, the implementation shall provide for later delivery of these occurrences to the program."),(0,i.kt)("p",null,"If the Ceiling_Locking policy is not in effect, the implementation shall provide means for the application to specify whether interrupts are to be blocked during protected actions."),(0,i.kt)("h4",{id:"documentation-requirements-1"},"Documentation Requirements"),(0,i.kt)("p",null,"The implementation shall document the following items: "),(0,i.kt)("p",null,"Discussion: This information may be different for different forms of interrupt handlers. "),(0,i.kt)("p",null,"a)For each interrupt, which interrupts are blocked from delivery when a handler attached to that interrupt executes (either as a result of an interrupt delivery or of an ordinary call on a procedure of the corresponding protected object)."),(0,i.kt)("p",null,"b)Any interrupts that cannot be blocked, and the effect of attaching handlers to such interrupts, if this is permitted."),(0,i.kt)("p",null,"c)Which run-time stack an interrupt handler uses when it executes as a result of an interrupt delivery; if this is configurable, what is the mechanism to do so; how to specify how much space to reserve on that stack."),(0,i.kt)("p",null,"d)Any implementation- or hardware-specific activity that happens before a user-defined interrupt handler gets control (e.g., reading device registers, acknowledging devices)."),(0,i.kt)("p",null,"e)Any timing or other limitations imposed on the execution of interrupt handlers."),(0,i.kt)("p",null,"f)The state (blocked/unblocked) of the nonreserved interrupts when the program starts; if some interrupts are unblocked, what is the mechanism a program can use to protect itself before it can attach the corresponding handlers."),(0,i.kt)("p",null,"g)Whether the interrupted task is allowed to resume execution before the interrupt handler returns."),(0,i.kt)("p",null,"h)The treatment of interrupt occurrences that are generated while the interrupt is blocked; i.e., whether one or more occurrences are held for later delivery, or all are lost."),(0,i.kt)("p",null,"i)Whether predefined or implementation-defined exceptions are raised as a result of the occurrence of any interrupt, and the mapping between the machine interrupts (or traps) and the predefined exceptions."),(0,i.kt)("p",null,"j)On a multi-processor, the rules governing the delivery of an interrupt to a particular processor. "),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"If the underlying system or hardware does not allow interrupts to be blocked, then no blocking is required ","[as part of the execution of subprograms of a protected object whose one of its subprograms is an interrupt handler]","."),(0,i.kt)("p",null,"In a multi-processor with more than one interrupt subsystem, it is implementation defined whether (and how) interrupt sources from separate subsystems share the same Interrupt_Id type (see C.3.2). In particular, the meaning of a blocked or pending interrupt may then be applicable to one processor only. "),(0,i.kt)("p",null,"Discussion: This issue is tightly related to the issue of scheduling on a multi-processor. In a sense, if a particular interrupt source is not available to all processors, the system is not truly homogeneous."),(0,i.kt)("p",null,'One way to approach this problem is to assign sub-ranges within Interrupt_Id to each interrupt subsystem, such that "similar" interrupt sources (e.g. a timer) in different subsystems get a distinct id. '),(0,i.kt)("p",null,"Implementations are allowed to impose timing or other limitations on the execution of interrupt handlers. "),(0,i.kt)("p",null,"Reason: These limitations are often necessary to ensure proper behavior of the implementation. "),(0,i.kt)("p",null,"Other forms of handlers are allowed to be supported, in which case, the rules of this subclause should be adhered to."),(0,i.kt)("p",null,"The active priority of the execution of an interrupt handler is allowed to vary from one occurrence of the same interrupt to another."),(0,i.kt)("h4",{id:"implementation-advice-2"},"Implementation Advice"),(0,i.kt)("p",null,"If the Ceiling_Locking policy is not in effect, the implementation should provide means for the application to specify which interrupts are to be blocked during protected actions, if the underlying system allows for a finer-grain control of interrupt blocking. "),(0,i.kt)("p",null,"NOTE 1   The default treatment for an interrupt can be to keep the interrupt pending or to deliver it to an implementation-defined handler. Examples of actions that an implementation-defined handler is allowed to perform include aborting the partition, ignoring (i.e., discarding occurrences of) the interrupt, or queuing one or more occurrences of the interrupt for possible later delivery when a user-defined handler is attached to that interrupt."),(0,i.kt)("p",null,"NOTE 2   It is a bounded error to call Task_Identification.Current_Task (see C.7.1) from an interrupt handler."),(0,i.kt)("p",null,"NOTE 3   The rule that an exception propagated from an interrupt handler has no effect is modeled after the rule about exceptions propagated out of task bodies."),(0,i.kt)("h3",{id:"c31--protected-procedure-handlers"},"C.3.1  Protected Procedure Handlers"),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Interrupt_Handler is as follows: "),(0,i.kt)("p",null,"  pragma Interrupt_Handler(handler_name);"),(0,i.kt)("p",null,"The form of a pragma Attach_Handler is as follows: "),(0,i.kt)("p",null,"  pragma Attach_Handler(handler_name, expression); "),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"For the Interrupt_Handler and Attach_Handler pragmas, the handler_name shall resolve to denote a protected procedure with a parameterless profile."),(0,i.kt)("p",null,"For the Attach_Handler pragma, the expected type for the expression is Interrupts.Interrupt_Id (see C.3.2). "),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"The Attach_Handler pragma is only allowed immediately within the protected_definition where the corresponding subprogram is declared. The corresponding protected_type_declaration or single_protected_declaration shall be a librarylevel declaration."),(0,i.kt)("p",null,"Discussion: In the case of a protected_type_declaration, an object_declaration of an object of that type need not be at library level."),(0,i.kt)("p",null,"The Interrupt_Handler pragma is only allowed immediately within a protected_definition. The corresponding protected_type_declaration shall be a librarylevel declaration. In addition, any object_declaration of such a type shall be a library level declaration. "),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"If the pragma Interrupt_Handler appears in a protected_definition, then the corresponding procedure can be attached dynamically, as a handler, to interrupts (see C.3.2). ","[Such procedures are allowed to be attached to multiple interrupts.]"),(0,i.kt)("p",null,"The expression in the Attach_Handler pragma ","[as evaluated at object creation time]"," specifies an interrupt. As part of the initialization of that object, if the Attach_Handler pragma is specified, the handler procedure is attached to the specified interrupt. A check is made that the corresponding interrupt is not reserved. Program_Error is raised if the check fails, and the existing treatment for the interrupt is not affected."),(0,i.kt)("p",null,"If the Ceiling_Locking policy (see D.3) is in effect then upon the initialization of a protected object that either an Attach_Handler or  Interrupt_Handler pragma applies to one of its procedures, a check is made that the ceiling priority defined in the protected_definition is in the range of System.Interrupt_Priority. If the check fails, Program_Error is raised."),(0,i.kt)("p",null,"When a protected object is finalized, for any of its procedures that are attached to interrupts, the handler is detached. If the handler was attached by a procedure in the Interrupts package or if no user handler was previously attached to the interrupt, the default treatment is restored. Otherwise, ","[that is, if an Attach_Handler pragma was specified]",", the previous handler is restored. "),(0,i.kt)("p",null,"Discussion: Since only library-level protected procedures can be attached as handlers using the Interrupts package, the finalization discussed above occurs only as part of the finalization of all library-level packages in a partition. "),(0,i.kt)("p",null,"When a handler is attached to an interrupt, the interrupt is blocked ","[(subject to the Implementation Permission in C.3)]"," during the execution of every protected action on the protected object containing the handler."),(0,i.kt)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,i.kt)("p",null,"If the Ceiling_Locking policy (see D.3) is in effect and an interrupt is delivered to a handler, and the interrupt hardware priority is higher than the ceiling priority of the corresponding protected object, the execution of the program is erroneous."),(0,i.kt)("h4",{id:"metrics"},"Metrics"),(0,i.kt)("p",null,"The following metric shall be documented by the implementation: "),(0,i.kt)("p",null,"The worst case overhead for an interrupt handler that is a parameterless protected procedure, in clock cycles. This is the execution time not directly attributable to the handler procedure or the interrupted execution. It is estimated as C  (A+B), where A is how long it takes to complete a given sequence of instructions without any interrupt, B is how long it takes to complete a normal call to a given protected procedure, and C is how long it takes to complete the same sequence of instructions when it is interrupted by one execution of the same procedure called via an interrupt. "),(0,i.kt)("p",null,"Implementation Note: The instruction sequence and interrupt handler used to measure interrupt handling overhead should be chosen so as to maximize the execution time cost due to cache misses. For example, if the processor has cache memory and the activity of an interrupt handler could invalidate the contents of cache memory, the handler should be written such that it invalidates all of the cache memory. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"When the pragmas Attach_Handler or Interrupt_Handler apply to a protected procedure, the implementation is allowed to impose implementation-defined restrictions on the corresponding protected_type_declaration and protected_body. "),(0,i.kt)("p",null,"Ramification: The restrictions may be on the constructs that are allowed within them, and on ordinary calls (i.e. not via interrupts) on protected operations in these protected objects. "),(0,i.kt)("p",null,"Implementation defined: "),(0,i.kt)("p",null,"An implementation may use a different mechanism for invoking a protected procedure in response to a hardware interrupt than is used for a call to that protected procedure from a task. "),(0,i.kt)("p",null,"Discussion: This is despite the fact that the priority of an interrupt handler (see D.1) is modeled after a hardware task calling the handler. "),(0,i.kt)("p",null,"Notwithstanding what this subclause says elsewhere, the Attach_Handler and Interrupt_Handler pragmas are allowed to be used for other, implementation defined, forms of interrupt handlers. "),(0,i.kt)("p",null,"Ramification: For example, if an implementation wishes to allow interrupt handlers to have parameters, it is allowed to do so via these pragmas; it need not invent implementation-defined pragmas for the purpose. "),(0,i.kt)("p",null,"Implementation defined: "),(0,i.kt)("h4",{id:"implementation-advice-3"},"Implementation Advice"),(0,i.kt)("p",null,"Whenever possible, the implementation should allow interrupt handlers to be called directly by the hardware. "),(0,i.kt)("p",null,"Whenever practical, the implementation should detect violations of any implementation-defined restrictions before run time. "),(0,i.kt)("p",null,"NOTE 1   The Attach_Handler pragma can provide static attachment of handlers to interrupts if the implementation supports preelaboration of protected objects. (See C.4.)"),(0,i.kt)("p",null,"NOTE 2   The ceiling priority of a protected object that one of its procedures is attached to an interruptshould be at least as high as the highest processor priority at which that interrupt will ever be delivered."),(0,i.kt)("p",null,"NOTE 3   Protected procedures can also be attached dynamically to interrupts via operations declared in the predefined package Interrupts."),(0,i.kt)("p",null,"NOTE 4   An example of a possible implementation-defined restriction is disallowing the use of the standard storage pools within the body of a protected procedure that is an interrupt handler."),(0,i.kt)("h3",{id:"c32--the-package-interrupts"},"C.3.2  The Package Interrupts"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined packages exist: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with System;\npackage Ada.Interruptsis\n   type Interrupt_Id is implementation-defined;\n   type Parameterless_Handler is\n      access protected procedure;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"}," \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Reserved (Interrupt : Interrupt_Id)\n      return Boolean;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Attached (Interrupt : Interrupt_Id)\n      return Boolean;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Current_Handler (Interrupt : Interrupt_Id)\n      return Parameterless_Handler;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Attach_Handler\n      (New_Handler : in Parameterless_Handler;\n       Interrupt   : in Interrupt_Id);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Exchange_Handler\n      (Old_Handler : out Parameterless_Handler;\n       New_Handler : in Parameterless_Handler;\n       Interrupt   : in Interrupt_Id);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Detach_Handler\n      (Interrupt : in Interrupt_Id);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Reference (Interrupt : Interrupt_Id)\n      return System.Address;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Interrupts;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Interrupts.Names is\n   implementation-defined : constant Interrupt_Id :=\n     implementation-defined;\n      . . .\n   implementation-defined : constant Interrupt_Id :=\n     implementation-defined;\nend Ada.Interrupts.Names;\n\n")),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"The Interrupt_Id type is an implementation-defined discrete type used to identify interrupts."),(0,i.kt)("p",null,"The Is_Reserved function returns True if and only if the specified interrupt is reserved."),(0,i.kt)("p",null,"The Is_Attached function returns True if and only if a user-specified interrupt handler is attached to the interrupt."),(0,i.kt)("p",null,"The Current_Handler function returns a value that represents the attached handler of the interrupt. If no user-defined handler is attached to the interrupt, Current_Handler returns a value that designates the default treatment; calling Attach_Handler or Exchange_Handler with this value restores the default treatment."),(0,i.kt)("p",null,"The Attach_Handler procedure attaches the specified handler to the interrupt, overriding any existing treatment (including a user handler) in effect for that interrupt. If New_Handler is null, the default treatment is restored. If New_Handler designates a protected procedure to which the pragma Interrupt_Handler does not apply, Program_Error is raised. In this case, the operation does not modify the existing interrupt treatment."),(0,i.kt)("p",null,"The Exchange_Handler procedure operates in the same manner as Attach_Handler with the addition that the value returned in Old_Handler designates the previous treatment for the specified interrupt. "),(0,i.kt)("p",null,"Ramification: Calling Attach_Handler or Exchange_Handler with this value for New_Handler restores the previous handler."),(0,i.kt)("p",null,"The Detach_Handler procedure restores the default treatment for the specified interrupt."),(0,i.kt)("p",null,"For all operations defined in this package that take a parameter of type Interrupt_Id, with the exception of Is_Reserved and Reference, a check is made that the specified interrupt is not reserved. Program_Error is raised if this check fails."),(0,i.kt)("p",null,"If, by using the Attach_Handler, Detach_Handler, or Exchange_Handler procedures, an attempt is made to detach a handler that was attached statically (using the pragma Attach_Handler), the handler is not detached and Program_Error is raised."),(0,i.kt)("p",null,"The Reference function returns a value of type System.Address that can be used to attach a task entry, via an address clause (see J.7.1) to the interrupt specified by Interrupt. This function raises Program_Error if attaching task entries to interrupts (or to this particular interrupt) is not supported."),(0,i.kt)("h4",{id:"implementation-requirements-3"},"Implementation Requirements"),(0,i.kt)("p",null,"At no time during attachment or exchange of handlers shall the current handler of the corresponding interrupt be undefined."),(0,i.kt)("h4",{id:"documentation-requirements-2"},"Documentation Requirements"),(0,i.kt)("p",null,"If the Ceiling_Locking policy (see D.3) is in effect the implementation shall document the default ceiling priority assigned to a protected object that contains either the Attach_Handler or Interrupt_Handler pragmas, but not the Interrupt_Priority pragma. ","[This default need not be the same for all interrupts.]"," "),(0,i.kt)("p",null,"Documentation Requirement: "),(0,i.kt)("h4",{id:"implementation-advice-4"},"Implementation Advice"),(0,i.kt)("p",null,"If implementation-defined forms of interrupt handler procedures are supported, such as protected procedures with parameters, then for each such form of a handler, a type analogous to Parameterless_Handler should be specified in a child package of Interrupts, with the same operations as in the predefined package Interrupts."),(0,i.kt)("p",null,"NOTE 1   The package Interrupts.Names contains implementation-defined names (and constant values) for the interrupts that are supported by the implementation."),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Example of interrupt handlers: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Device_Priority : constant\n  array (1..5) of System.Interrupt_Priority := ( ... );\nprotected type Device_Interface\n  (Int_Id : Ada.Interrupts.Interrupt_Id) is\n  procedure Handler;\n  pragma Attach_Handler(Handler, Int_Id);\n  ...\n  pragma Interrupt_Priority(Device_Priority(Int_Id));\nend Device_Interface;\n  ...\nDevice_1_Driver : Device_Interface(1);\n  ...\nDevice_5_Driver : Device_Interface(5);\n  ...\n\n")),(0,i.kt)("h2",{id:"c4--preelaboration-requirements"},"C.4  Preelaboration Requirements"),(0,i.kt)("p",null,"[This clause specifies additional implementation and documentation requirements for the Preelaborate pragma (see 10.2.1).]"," "),(0,i.kt)("h4",{id:"implementation-requirements-4"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall not incur any run-time overhead for the elaboration checks of subprograms and protected_bodies declared in preelaborated library units. "),(0,i.kt)("p",null,"The implementation shall not execute any memory write operations after load time for the elaboration of constant objects declared immediately within the declarative region of a preelaborated library package, so long as the subtype and initial expression (or default initial expressions if initialized by default) of the object_declaration satisfy the following restrictions. The meaning of load time is implementation defined. "),(0,i.kt)("p",null,'Discussion: On systems where the image of the partition is initially copied from disk to RAM, or from ROM to RAM, prior to starting execution of the partition, the intention is that "load time" consist of this initial copying step. On other systems, load time and run time might actually be interspersed. '),(0,i.kt)("p",null,"Any subtype_mark denotes a statically constrained subtype, with statically constrained subcomponents, if any;"),(0,i.kt)("p",null,"any constraint is a static constraint;"),(0,i.kt)("p",null,"any allocator is for an access-to-constant type;"),(0,i.kt)("p",null,"any uses of predefined operators appear only within static expressions;"),(0,i.kt)("p",null,"any primaries that are names, other than attribute_references for the Access or Address attributes, appear only within static expressions; "),(0,i.kt)("p",null,"Ramification: This cuts out attribute_references that are not static, except for Access and Address. "),(0,i.kt)("p",null,"any name that is not part of a static expression is an expanded name or direct_name that statically denotes some entity; "),(0,i.kt)("p",null,"Ramification: This cuts out function_calls and type_conversions that are not static, including calls on attribute functions like 'Image and 'Value. "),(0,i.kt)("p",null,"any discrete_choice of an array_aggregate is static;"),(0,i.kt)("p",null,"no language-defined check associated with the elaboration of the object_declaration can fail. "),(0,i.kt)("p",null,"Reason: The intent is that aggregates all of whose scalar subcomponents are static, and all of whose access subcomponents are null, allocators for access-to-constant types, or X'Access, will be supported with no run-time code generated. "),(0,i.kt)("h4",{id:"documentation-requirements-3"},"Documentation Requirements"),(0,i.kt)("p",null,"The implementation shall document any circumstances under which the elaboration of a preelaborated package causes code to be executed at run time. "),(0,i.kt)("p",null,"The implementation shall document whether the method used for initialization of preelaborated variables allows a partition to be restarted without reloading. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: Implementation-defined aspects of preelaboration."),(0,i.kt)("p",null,"Discussion: This covers the issue of the RTS itself being restartable, so that need not be a separate Documentation Requirement. "),(0,i.kt)("h4",{id:"implementation-advice-5"},"Implementation Advice"),(0,i.kt)("p",null,"It is recommended that preelaborated packages be implemented in such a way that there should be little or no code executed at run time for the elaboration of entities not already covered by the Implementation Requirements."),(0,i.kt)("h2",{id:"c5--pragma-discard_names"},"C.5  Pragma Discard_Names"),(0,i.kt)("p",null,"[A pragma Discard_Names may be used to request a reduction in storage used for the names of certain entities.]"," "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"The form of a pragma Discard_Names is as follows: "),(0,i.kt)("p",null,"  pragma Discard_Names[(","[On =",">"," ]"," local_name)];"),(0,i.kt)("p",null,"A pragma Discard_Names is allowed only immediately within a declarative_part, immediately within a package_specification, or as a configuration pragma. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"The local_name (if present) shall denote a nonderived enumeration ","[first]"," subtype, a tagged ","[first]"," subtype, or an exception. The pragma applies to the type or exception. Without a local_name, the pragma applies to all such entities declared after the pragma, within the same declarative region. Alternatively, the pragma can be used as a configuration pragma. If the pragma applies to a type, then it applies also to all descendants of the type."),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"If a local_name is given, then a pragma Discard_Names is a representation pragma."),(0,i.kt)("p",null,"If the pragma applies to an enumeration type, then the semantics of the Wide_Image and Wide_Value attributes are implementation defined for that type","[; the semantics of Image and Value are still defined in terms of Wide_Image and Wide_Value]",". In addition, the semantics of Text_IO.Enumeration_IO are implementation defined. If the pragma applies to a tagged type, then the semantics of the Tags.Expanded_Name function are implementation defined for that type. If the pragma applies to an exception, then the semantics of the Exceptions.Exception_Name function are implementation defined for that exception."),(0,i.kt)("p",null,"Implementation defined: The semantics of pragma Discard_Names."),(0,i.kt)("p",null,"Ramification: The Width attribute is still defined in terms of Image."),(0,i.kt)("p",null,"The semantics of S'Wide_Image and S'Wide_Value are implementation defined for any subtype of an enumeration type to which the pragma applies. (The pragma actually names the first subtype, of course.) "),(0,i.kt)("h4",{id:"implementation-advice-6"},"Implementation Advice"),(0,i.kt)("p",null,"If the pragma applies to an entity, then the implementation should reduce the amount of storage used for storing names associated with that entity. "),(0,i.kt)("p",null,"Implementation Advice: "),(0,i.kt)("p",null,"Reason: A typical implementation of the Image attribute for enumeration types is to store a table containing the names of all the enumeration literals. Pragma Discard_Names allows the implementation to avoid storing such a table without having to prove that the Image attribute is never used (which can be difficult in the presence of separate compilation)."),(0,i.kt)("p",null,"We did not specify the semantics of the Image attribute in the presence of this pragma because different semantics might be desirable in different situations. In some cases, it might make sense to use the Image attribute to print out a useful value that can be used to identify the entity given information in compiler-generated listings. In other cases, it might make sense to get an error at compile time or at run time. In cases where memory is plentiful, the simplest implementation makes sense: ignore the pragma. Implementations that are capable of avoiding the extra storage in cases where the Image attribute is never used might also wish to ignore the pragma."),(0,i.kt)("p",null,"The same applies to the Tags.Expanded_Name and Exceptions.Exception_Name functions. "),(0,i.kt)("h2",{id:"c6--shared-variable-control"},"C.6  Shared Variable Control"),(0,i.kt)("p",null,"[This clause specifies representation pragmas that control the use of shared variables.]"," "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"The form for pragmas Atomic, Volatile, Atomic_Components, and Volatile_Components is as follows: "),(0,i.kt)("p",null,"  pragma Atomic(local_name);"),(0,i.kt)("p",null,"  pragma Volatile(local_name);"),(0,i.kt)("p",null,"  pragma Atomic_Components(array_local_name);"),(0,i.kt)("p",null,"  pragma Volatile_Components(array_local_name);"),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"An atomic type is one to which a pragma Atomic applies. An atomic object (including a component) is one to which a pragma Atomic applies, or a component of an array to which a pragma Atomic_Components applies, or any object of an atomic type. "),(0,i.kt)("p",null,"A volatile type is one to which a pragma Volatile applies. A volatile object (including a component) is one to which a pragma Volatile applies, or a component of an array to which a pragma Volatile_Components applies, or any object of a volatile type. In addition, every atomic type or object is also defined to be volatile. Finally, if an object is volatile, then so are all of its subcomponents ","[(the same does not apply to atomic)]","."),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"The local_name in an Atomic or Volatile pragma shall resolve to denote either an object_declaration, a noninherited component_declaration, or a full_type_declaration. The array_local_name in an Atomic_Components or Volatile_Components pragma shall resolve to denote the declaration of an array type or an array object of an anonymous type. "),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"It is illegal to apply either an Atomic or Atomic_Components pragma to an object or type if the implementation cannot support the indivisible reads and updates required by the pragma (see below)."),(0,i.kt)("p",null,"It is illegal to specify the Size attribute of an atomic object, the Component_Size attribute for an array type with atomic components, or the layout attributes of an atomic component, in a way that prevents the implementation from performing the required indivisible reads and updates."),(0,i.kt)("p",null,"If an atomic object is passed as a parameter, then the type of the formal parameter shall either be atomic or allow pass by copy ","[(that is, not be a nonatomic by-reference type)]",". If an atomic object is used as an actual for a generic formal object of mode in out, then the type of the generic formal object shall be atomic. If the prefix of an attribute_reference for an Access attribute denotes an atomic object ","[(including a component)]",", then the designated type of the resulting access type shall be atomic. If an atomic type is used as an actual for a generic formal derived type, then the ancestor of the formal type shall be atomic or allow pass by copy. Corresponding rules apply to volatile objects and types."),(0,i.kt)("p",null,"If a pragma Volatile, Volatile_Components, Atomic, or Atomic_Components applies to a stand-alone constant object, then a pragma Import shall also apply to it. "),(0,i.kt)("p",null,"Ramification: Hence, no initialization expression is allowed for such a constant. Note that a constant that is atomic or volatile because of its type is allowed. "),(0,i.kt)("p",null,"Reason: Stand-alone constants that are explicitly specified as Atomic or Volatile only make sense if they are being manipulated outside the Ada program. From the Ada perspective the object is read-only. Nevertheless, if imported and atomic or volatile, the implementation should presume it might be altered externally. For an imported stand-alone constant that is not atomic or volatile, the implementation can assume that it will not be altered. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"These pragmas are representation pragmas (see 13.1). "),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"For an atomic object (including an atomic component) all reads and updates of the object as a whole are indivisible."),(0,i.kt)("p",null,"For a volatile object all reads and updates of the object as a whole are performed directly to memory."),(0,i.kt)("p",null,"Implementation Note: This precludes any use of register temporaries, caches, and other similar optimizations for that object. "),(0,i.kt)("p",null,"Two actions are sequential (see 9.10) if each is the read or update of the same atomic object."),(0,i.kt)("p",null,"If a type is atomic or volatile and it is not a by-copy type, then the type is defined to be a by-reference type. If any subcomponent of a type is atomic or volatile, then the type is defined to be a by-reference type."),(0,i.kt)("p",null,"If an actual parameter is atomic or volatile, and the corresponding formal parameter is not, then the parameter is passed by copy. "),(0,i.kt)("p",null,"Implementation Note: Note that in the case where such a parameter is normally passed by reference, a copy of the actual will have to be produced at the call-site, and a pointer to the copy passed to the formal parameter. If the actual is atomic, any copying has to use indivisible read on the way in, and indivisible write on the way out. "),(0,i.kt)("p",null,"Reason: It has to be known at compile time whether an atomic or a volatile parameter is to be passed by copy or by reference. For some types, it is unspecified whether parameters are passed by copy or by reference. The above rules further specify the parameter passing rules involving atomic and volatile types and objects. "),(0,i.kt)("p",null,"Implementation Note: } "),(0,i.kt)("h4",{id:"implementation-requirements-5"},"Implementation Requirements"),(0,i.kt)("p",null,"The external effect of a program (see ) is defined to include each read and update of a volatile or atomic object. The implementation shall not generate any memory reads or updates of atomic or volatile objects other than those specified by the program. "),(0,i.kt)("p",null,'Discussion: The presumption is that volatile or atomic objects might reside in an "active" part of the address space where each read has a potential side effect, and at the very least might deliver a different value.'),(0,i.kt)("p",null,"The rule above and the definition of external effect are intended to prevent (at least) the following incorrect optimizations, where V is a volatile variable: "),(0,i.kt)("p",null,"X:= V; Y:=V; cannot be allowed to be translated as Y:=V; X:=V;"),(0,i.kt)("p",null,"Deleting redundant loads: X:= V; X:= V; shall read the value of V from memory twice."),(0,i.kt)("p",null,"Deleting redundant stores: V:= X; V:= X; shall write into V twice."),(0,i.kt)("p",null,"Extra stores: V:= X+Y; should not translate to something like V:= X; V:= V+Y;"),(0,i.kt)("p",null,"Extra loads: X:= V; Y:= X+Z; X:=X+B; should not translate to something like Y:= V+Z; X:= V+B;"),(0,i.kt)("p",null,"Reordering of loads from volatile variables: X:= V1; Y:= V2; (whether or not V1 = V2) should not translate to Y:= V2; X:= V1;"),(0,i.kt)("p",null,"Reordering of stores to volatile variables: V1:= X; V2:= X; should not translate to V2:=X; V1:= X; "),(0,i.kt)("p",null,"If a pragma Pack applies to a type any of whose subcomponents are atomic, the implementation shall not pack the atomic subcomponents more tightly than that for which it can support indivisible reads and updates. "),(0,i.kt)("p",null,"Implementation Note: A warning might be appropriate if no packing whatsoever can be achieved. "),(0,i.kt)("p",null,'NOTE 1   An imported volatile or atomic constant behaves as a constant (i.e. read-only) with respect to other parts of the Ada program, but can still be modified by an "external source".'),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,'Pragma Atomic replaces Ada 83\'s pragma Shared. The name "Shared" was confusing, because the pragma was not used to mark variables as shared. '),(0,i.kt)("h2",{id:"c7--task-identification-and-attributes"},"C.7  Task Identification and Attributes"),(0,i.kt)("p",null,"[This clause describes operations and attributes that can be used to obtain the identity of a task. In addition, a package that associates user-defined information with a task is defined.]"," "),(0,i.kt)("h3",{id:"c71--the-package-task_identification"},"C.7.1  The Package Task_Identification"),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package Ada.Task_Identification is\n   type Task_Id is private;\n   Null_Task_Id : constant Task_Id;\n   function  "=" (Left, Right : Task_Id) return Boolean;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function  Image                  (T : Task_Id) return String;\n   function  Current_Task     return Task_Id;\n   procedure Abort_Task             (T : in out Task_Id);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function  Is_Terminated          (T : Task_Id) return Boolean;\n   function  Is_Callable            (T : Task_Id) return Boolean;\nprivate\n   ... -- not specified by the language\nend Ada.Task_Identification;\n\n")),(0,i.kt)("h4",{id:"dynamic-semantics-4"},"Dynamic Semantics"),(0,i.kt)("p",null,"A value of the type Task_Id identifies an existent task. The constant Null_Task_Id does not identify any task. Each object of the type Task_Id is default initialized to the value of Null_Task_Id."),(0,i.kt)("p",null,'The function "=" returns True if and only if Left and Right identify the same task or both have the value Null_Task_Id.'),(0,i.kt)("p",null,"The function Image returns an implementation-defined string that identifies T. If T equals Null_Task_Id, Image returns an empty string. "),(0,i.kt)("p",null,"Implementation defined: The result of the Task_Identification.Image attribute."),(0,i.kt)("p",null,"The function Current_Task returns a value that identifies the calling task."),(0,i.kt)("p",null,"The effect of Abort_Task is the same as the abort_statement for the task identified by T. ","[In addition, if T identifies the environment task, the entire partition is aborted, See E.1.]"),(0,i.kt)("p",null,"The functions Is_Terminated and Is_Callable return the value of the corresponding attribute of the task identified by T. "),(0,i.kt)("p",null,"For a prefix T that is of a task type ","[(after any implicit dereference)]",", the following attribute is defined: "),(0,i.kt)("p",null,"T'IdentityYields a value of the type Task_Id that identifies the task denoted by T."),(0,i.kt)("p",null,"For a prefix E that denotes an entry_declaration, the following attribute is defined: "),(0,i.kt)("p",null,"E'CallerYields a value of the type Task_Id that identifies the task whose call is now being serviced. Use of this attribute is allowed only inside an entry_body or accept_statementcorresponding to the entry_declaration denoted by E. "),(0,i.kt)("p",null,"Program_Error is raised if a value of Null_Task_Id is passed as a parameter to Abort_Task, Is_Terminated, and Is_Callable."),(0,i.kt)("p",null,"Abort_Task is a potentially blocking operation (see 9.5.1). "),(0,i.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,i.kt)("p",null,"It is a bounded error to call the Current_Task function from an entry body or an interrupt handler. Program_Error is raised, or an implementation-defined value of the type Task_Id is returned. "),(0,i.kt)("p",null,"Implementation defined: The value of Current_Task when in a protected entry or interrupt handler."),(0,i.kt)("p",null,"Implementation Note: This value could be Null_Task_Id, or the ID of some user task, or that of an internal task created by the implementation. "),(0,i.kt)("h4",{id:"erroneous-execution-1"},"Erroneous Execution"),(0,i.kt)("p",null,"If a value of Task_Id is passed as a parameter to any of the operations declared in this package (or any language-defined child of this package), and the corresponding task object no longer exists, the execution of the program is erroneous. "),(0,i.kt)("h4",{id:"documentation-requirements-4"},"Documentation Requirements"),(0,i.kt)("p",null,"The implementation shall document the effect of calling Current_Task from an entry body or interrupt handler. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: The effect of calling Current_Task from an entry body or interrupt handler."),(0,i.kt)("p",null,"NOTE 1   This package is intended for use in writing user-defined task scheduling packages and constructing server tasks. Current_Task can be used in conjunction with other operations requiring a task as an argument such as Set_Priority (see D.5)."),(0,i.kt)("p",null,"NOTE 2   The function Current_Task and the attribute Caller can return a Task_Id value that identifies the environment task."),(0,i.kt)("h3",{id:"c72--the-package-task_attributes"},"C.7.2  The Package Task_Attributes"),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"The following language-defined generic library package exists: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Task_Identification; use Ada.Task_Identification;\ngeneric\n   type Attribute is private;\n   Initial_Value : in Attribute;\npackage Ada.Task_Attributes is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Attribute_Handle is access all Attribute;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Value(T : Task_Id := Current_Task)\n     return Attribute;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Reference(T : Task_Id := Current_Task)\n     return Attribute_Handle;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Set_Value(Val : in Attribute;\n                       T : in Task_Id := Current_Task);\n   procedure Reinitialize(T : in Task_Id := Current_Task);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end Ada.Task_Attributes;\n\n")),(0,i.kt)("h4",{id:"dynamic-semantics-5"},"Dynamic Semantics"),(0,i.kt)("p",null,"When an instance of Task_Attributes is elaborated in a given active partition, an object of the actual type corresponding to the formal type Attribute is implicitly created for each task (of that partition) that exists and is not yet terminated. This object acts as a user-defined attribute of the task. A task created previously in the partition and not yet terminated has this attribute from that point on. Each task subsequently created in the partition will have this attribute when created. In all these cases, the initial value of the given attribute is Initial_Value."),(0,i.kt)("p",null,"The Value operation returns the value of the corresponding attribute of T."),(0,i.kt)("p",null,"The Reference operation returns an access value that designates the corresponding attribute of T."),(0,i.kt)("p",null,"The Set_Value operation performs any finalization on the old value of the attribute of T and assigns Val to that attribute (see 5.2 and 7.6)."),(0,i.kt)("p",null,"The effect of the Reinitialize operation is the same as Set_Value where the Val parameter is replaced with Initial_Value. "),(0,i.kt)("p",null,"Implementation Note: In most cases, the attribute memory can be reclaimed at this point. "),(0,i.kt)("p",null,"For all the operations declared in this package, Tasking_Error is raised if the task identified by T is terminated. Program_Error is raised if the value of T is Null_Task_Id."),(0,i.kt)("h4",{id:"erroneous-execution-2"},"Erroneous Execution"),(0,i.kt)("p",null,"It is erroneous to dereference the access value returned by a given call on Reference after a subsequent call on Reinitialize for the same task attribute, or after the associated task terminates. "),(0,i.kt)("p",null,"Reason: This allows the storage to be reclaimed for the object associated with an attribute upon Reinitialize or task termination. "),(0,i.kt)("p",null,"If a value of Task_Id is passed as a parameter to any of the operations declared in this package and the corresponding task object no longer exists, the execution of the program is erroneous."),(0,i.kt)("h4",{id:"implementation-requirements-6"},"Implementation Requirements"),(0,i.kt)("p",null,"The implementation shall perform each of the above operations for a given attribute of a given task atomically with respect to any other of the above operations for the same attribute of the same task. "),(0,i.kt)("p",null,"Ramification: Hence, other than by dereferencing an access value returned by Reference, an attribute of a given task can be safely read and updated concurrently by multiple tasks. "),(0,i.kt)("p",null,"When a task terminates, the implementation shall finalize all attributes of the task, and reclaim any other storage associated with the attributes. "),(0,i.kt)("h4",{id:"documentation-requirements-5"},"Documentation Requirements"),(0,i.kt)("p",null,"The implementation shall document the limit on the number of attributes per task, if any, and the limit on the total storage for attribute values per task, if such a limit exists."),(0,i.kt)("p",null,"In addition, if these limits can be configured, the implementation shall document how to configure them. "),(0,i.kt)("p",null,"This paragraph was deleted.Implementation defined: Implementation-defined aspects of Task_Attributes."),(0,i.kt)("h4",{id:"metrics-1"},"Metrics"),(0,i.kt)("p",null,"The implementation shall document the following metrics: A task calling the following subprograms shall execute in a sufficiently high priority as to not be preempted during the measurement period. This period shall start just before issuing the call and end just after the call completes. If the attributes of task T are accessed by the measurement tests, no other task shall access attributes of that task during the measurement period. For all measurements described here, the Attribute type shall be a scalar whose size is equal to the size of the predefined integer size. For each measurement, two cases shall be documented: one where the accessed attributes are of the calling task ","[(that is, the default value for the T parameter is used)]",", and the other, where T identifies another, nonterminated, task."),(0,i.kt)("p",null,"The following calls (to subprograms in the Task_Attributes package) shall be measured: "),(0,i.kt)("p",null,"a call to Value, where the return value is Initial_Value;"),(0,i.kt)("p",null,"a call to Value, where the return value is not equal to Initial_Value;"),(0,i.kt)("p",null,"a call to Reference, where the return value designates a value equal to Initial_Value;"),(0,i.kt)("p",null,"a call to Reference, where the return value designates a value not equal to Initial_Value;"),(0,i.kt)("p",null,"a call to Set_Value where the Val parameter is not equal to Initial_Value and the old attribute value is equal to Initial_Value."),(0,i.kt)("p",null,"a call to Set_Value where the Val parameter is not equal to Initial_Value and the old attribute value is not equal to Initial_Value."),(0,i.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,i.kt)("p",null,"An implementation need not actually create the object corresponding to a task attribute until its value is set to something other than that of Initial_Value, or until Reference is called for the task attribute. Similarly, when the value of the attribute is to be reinitialized to that of Initial_Value, the object may instead be finalized and its storage reclaimed, to be recreated when needed later. While the object does not exist, the function Value may simply return Initial_Value, rather than implicitly creating the object. "),(0,i.kt)("p",null,"Discussion: The effect of this permission can only be observed if the assignment operation for the corresponding type has side effects. "),(0,i.kt)("p",null,"Implementation Note: This permission means that even though every task has every attribute, storage need only be allocated for those attributes that have been Reference'd or set to a value other than that of Initial_Value. "),(0,i.kt)("p",null,"An implementation is allowed to place restrictions on the maximum number of attributes a task may have, the maximum size of each attribute, and the total storage size allocated for all the attributes of a task."),(0,i.kt)("h4",{id:"implementation-advice-7"},"Implementation Advice"),(0,i.kt)("p",null,"Some implementations are targeted to domains in which memory use at run time must be completely deterministic. For such implementations, it is recommended that the storage for task attributes will be pre-allocated statically and not from the heap. This can be accomplished by either placing restrictions on the number and the size of the task's attributes, or by using the pre-allocated storage for the first N attribute objects, and the heap for the others. In the latter case, N should be documented."),(0,i.kt)("p",null,"NOTE 1   An attribute always exists (after instantiation), and has the initial value. It need not occupy memory until the first operation that potentially changes the attribute value. The same holds true after Reinitialize."),(0,i.kt)("p",null,"NOTE 2   The result of the Reference function should be used with care; it is always safe to use that result in the task body whose attribute is being accessed. However, when the result is being used by another task, the programmer must make sure that the task whose attribute is being accessed is not yet terminated. Failing to do so could make the program execution erroneous."),(0,i.kt)("p",null,"NOTE 3   As specified in C.7.1, if the parameter T (in a call on a subprogram of an instance of this package) identifies a nonexistent task, the execution of the program is erroneous."))}c.isMDXComponent=!0}}]);