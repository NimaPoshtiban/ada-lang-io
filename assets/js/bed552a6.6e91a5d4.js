"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9487],{902:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>b,frontMatter:()=>u,metadata:()=>m,toc:()=>f});var a=n(1716),i=Object.defineProperty,r=Object.defineProperties,o=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&d(e,n,t[n]);if(s)for(var n of s(t))p.call(t,n)&&d(e,n,t[n]);return e};const u={title:"Reusability",sidebar_position:8},h=void 0,m={unversionedId:"style-guide/Reusability",id:"style-guide/Reusability",title:"Reusability",description:"Reusability is the extent to which code can be used in different",source:"@site/docs/style-guide/Reusability.mdx",sourceDirName:"style-guide",slug:"/style-guide/Reusability",permalink:"/docs/style-guide/Reusability",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Reusability",sidebar_position:8},sidebar:"styleGuideSidebar",previous:{title:"Portability",permalink:"/docs/style-guide/Portability"},next:{title:"Object-Oriented Features",permalink:"/docs/style-guide/Object-Oriented_Features"}},g={},f=[{value:"Understanding and Clarity",id:"understanding-and-clarity",level:2},{value:"Application-Independent Naming",id:"application-independent-naming",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Abbreviations",id:"abbreviations",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"Generic Formal Parameters",id:"generic-formal-parameters",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Robustness",id:"robustness",level:2},{value:"Named Numbers",id:"named-numbers",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Unconstrained Arrays",id:"unconstrained-arrays",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Minimizing and Documenting Assumptions",id:"minimizing-and-documenting-assumptions",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-1",level:4},{value:"Subtypes in Generic Specifications",id:"subtypes-in-generic-specifications",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-2",level:4},{value:"Overloading in Generic Units",id:"overloading-in-generic-units",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"Hidden Tasks",id:"hidden-tasks",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Exceptions",id:"exceptions",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"notes",id:"notes-3",level:4},{value:"Adaptability",id:"adaptability",level:2},{value:"Complete Functionality",id:"complete-functionality",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"notes",id:"notes-4",level:4},{value:"Generic Units",id:"generic-units",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Formal Private and Limited Private Types",id:"formal-private-and-limited-private-types",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"notes",id:"notes-5",level:4},{value:"Using Generic Units to Encapsulate Algorithms",id:"using-generic-units-to-encapsulate-algorithms",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"Iterators",id:"iterators",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"example",id:"example-13",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"notes",id:"notes-6",level:4},{value:"Decimal Type Output and Information Systems Annex",id:"decimal-type-output-and-information-systems-annex",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-14",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"Implementing Mixins",id:"implementing-mixins",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"example",id:"example-15",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"Independence",id:"independence",level:2},{value:"Subsystem Design",id:"subsystem-design",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"Using Generic Parameters to Reduce Coupling",id:"using-generic-parameters-to-reduce-coupling",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"example",id:"example-16",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"Coupling Due to Pragmas",id:"coupling-due-to-pragmas",level:3},{value:"guideline",id:"guideline-20",level:4},{value:"example",id:"example-17",level:4},{value:"rationale",id:"rationale-20",level:4},{value:"notes",id:"notes-7",level:4},{value:"Part Families",id:"part-families",level:3},{value:"guideline",id:"guideline-21",level:4},{value:"example",id:"example-18",level:4},{value:"rationale",id:"rationale-21",level:4},{value:"notes",id:"notes-8",level:4},{value:"Conditional Compilation",id:"conditional-compilation",level:3},{value:"guideline",id:"guideline-22",level:4},{value:"example",id:"example-19",level:4},{value:"rationale",id:"rationale-22",level:4},{value:"caution",id:"caution",level:4},{value:"Table-Driven Programming",id:"table-driven-programming",level:3},{value:"guideline",id:"guideline-23",level:4},{value:"example",id:"example-20",level:4},{value:"rationale",id:"rationale-23",level:4},{value:"notes",id:"notes-9",level:4},{value:"String Handling",id:"string-handling",level:3},{value:"guideline",id:"guideline-24",level:4},{value:"example",id:"example-21",level:4},{value:"rationale",id:"rationale-24",level:4},{value:"Tagged Type Hierarchies",id:"tagged-type-hierarchies",level:3},{value:"guideline",id:"guideline-25",level:4},{value:"example",id:"example-22",level:4},{value:"rationale",id:"rationale-25",level:4},{value:"Summary",id:"summary",level:2},{value:"understanding and clarity",id:"understanding-and-clarity-1",level:3},{value:"robustness",id:"robustness-1",level:3},{value:"adaptability",id:"adaptability-1",level:3},{value:"independence",id:"independence-1",level:3}],y={toc:f};function b(e){var t,n=e,{components:i}=n,d=((e,t)=>{var n={};for(var a in e)l.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},y),d),r(t,o({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Reusability is the extent to which code can be used in different\napplications with minimal change. As code is reused in a new\napplication, that new application partially inherits the attributes of\nthat code. If the code is maintainable, the application is more\nmaintainable. If it is portable, then the application is more portable.\nSo this chapter's guidelines are most useful when all of the other\nguidelines in this book are also applied. Several guidelines are\ndirected at the issue of maintainability. Maintainable code is easy to\nchange to meet new or changing requirements. Maintainability plays a\nspecial role in reuse. When attempts are made to reuse code, it is often\nnecessary to change it to suit the new application. If the code cannot\nbe changed easily, it is less likely to be reused."),(0,a.kt)("p",null,"There are many issues involved in software reuse: whether to reuse\nparts, how to store and retrieve reusable parts in a library, how to\ncertify parts, how to maximize the economic value of reuse, how to\nprovide incentives to engineers and entire companies to reuse parts\nrather than reinvent them, and so on. This chapter ignores these\nmanagerial, economic, and logistic issues to focus on the single\ntechnical issue of how to write software parts in Ada to increase reuse\npotential. The other issues are just as important but are outside of the\nscope of this book."),(0,a.kt)("p",null,"One of the design goals of Ada was to facilitate the creation and use of\nreusable parts to improve productivity. To this end, Ada provides\nfeatures to develop reusable parts and to adapt them once they are\navailable. Packages, visibility control, and separate compilation\nsupport modularity and information hiding (see guidelines in Sections\n4.1, 4.2, 5.3, and 5.7). This allows the separation of\napplication-specific parts of the code, maximizes the general purpose\nparts suitable for reuse, and allows the isolation of design decisions\nwithin modules, facilitating change. The Ada type system supports\nlocalization of data definitions so that consistent changes are easy to\nmake. The Ada inheritance features support type extension so that data\ndefinitions and interfaces may be customized for an application. Generic\nunits directly support the development of general purpose, adaptable\ncode that can be instantiated to perform specific functions. The Ada 95\nimprovements for object-oriented techniques and abstraction support all\nof the above goals. Using these features carefully and in conformance to\nthe guidelines in this book, produces code that is more likely to be\nreusable."),(0,a.kt)("p",null,"Reusable code is developed in many ways. Code may be scavenged from a\nprevious project. A reusable library of code may be developed from\nscratch for a particularly well-understood domain, such as a math\nlibrary. Reusable code may be developed as an intentional byproduct of a\nspecific application. Reusable code may be developed a certain way\nbecause a design method requires it. These guidelines are intended to\napply in all of these situations."),(0,a.kt)("p",null,"The experienced programmer recognizes that software reuse is much more a\nrequirements and design issue than a coding issue. The guidelines in\nthis section are intended to work within an overall method for\ndeveloping reusable code. This section will not deal with artifacts of\ndesign, testing, etc. Some research into reuse issues related\nspecifically to the Ada language can be found in AIRMICS (1990), Edwards\n(1990), and Wheeler (1992)."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Regardless of development method, experience indicates that reusable\ncode has certain characteristics, and this chapter makes the\nfollowing assumptions:"),(0,a.kt)("li",{parentName:"ul"},"Reusable parts must be understandable. A reusable part should be a\nmodel of clarity. The requirements for commenting reusable parts are\neven more stringent than those for parts specific to a particular\napplication."),(0,a.kt)("li",{parentName:"ul"},"Reusable parts must be of the highest possible quality. They must be\ncorrect, reliable, and robust. An error or weakness in a reusable\npart may have far-reaching consequences, and it is important that\nother programmers can have a high degree of confidence in any parts\noffered for reuse."),(0,a.kt)("li",{parentName:"ul"},"Reusable parts must be adaptable. To maximize its reuse potential, a\nreusable part must be able to adapt to the needs of a wide variety\nof users."),(0,a.kt)("li",{parentName:"ul"},"Reusable parts should be independent. It should be possible to reuse\na single part without also adopting many other parts that are\napparently unrelated.")),(0,a.kt)("p",null,"In addition to these criteria, a reusable part must be easier to reuse\nthan to reinvent, must be efficient, and must be portable. If it takes\nmore effort to reuse a part than to create one from scratch or if the\nreused part is simply not efficient enough, reuse does not occur as\nreadily. For guidelines on portability, see Chapter 7. This chapter\nshould not be read in isolation. In many respects, a well-written,\nreusable component is simply an extreme example of a well-written\ncomponent. All of the guidelines in the previous chapters and in Chapter\n9 apply to reusable components as well as components specific to a\nsingle application. As experience increases with the 1995 revision to\nthe Ada standard, new guidelines may emerge while others may change. The\nguidelines listed here apply specifically to reusable components."),(0,a.kt)("p",null,'Guidelines in this chapter are frequently worded "consider . . ."\nbecause hard and fast rules cannot apply in all situations. The specific\nchoice you can make in a given situation involves design tradeoffs. The\nrationale for these guidelines is intended to give you insight into some\nof these tradeoffs.'),(0,a.kt)("h2",c({},{id:"understanding-and-clarity"}),"Understanding and Clarity"),(0,a.kt)("p",null,"It is particularly important that parts intended for reuse should be\neasy to understand. What the part does, how to use it, what anticipated\nchanges might be made to it in the future, and how it works are facts\nthat must be immediately apparent from inspection of the comments and\nthe code itself. For maximum readability of reusable parts, follow the\nguidelines in Chapter 3, some of which are repeated more strongly below."),(0,a.kt)("h3",c({},{id:"application-independent-naming"}),"Application-Independent Naming"),(0,a.kt)("h4",c({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Select the least restrictive names possible for reusable parts and\ntheir identifiers ."),(0,a.kt)("li",{parentName:"ul"},"Select the generic name to avoid conflicting with the naming\nconventions of instantiations of the generic."),(0,a.kt)("li",{parentName:"ul"},"Use names that indicate the behavioral characteristics of the\nreusable part, as well as its abstraction.")),(0,a.kt)("h4",c({},{id:"example"}),"example"),(0,a.kt)("p",null,"General-purpose stack abstraction:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Item is private;\npackage Bounded_Stack is\n   procedure Push (New_Item    : in     Item);\n   procedure Pop  (Newest_Item :    out Item);\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"Renamed appropriately for use in current application:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Bounded_Stack;\n\n...\n\n   type Tray is ...\n   package Tray_Stack is\n      new Bounded_Stack (Item => Tray);\n")),(0,a.kt)("h4",c({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"Choosing a general or application-independent name for a reusable part\nencourages its wide reuse. When the part is used in a specific context,\nit can be instantiated (if generic) or renamed with a more specific\nname."),(0,a.kt)("p",null,"When there is an obvious choice for the simplest, clearest name for a\nreusable part, it is a good idea to leave that name for use by the\nreuser of the part, choosing a longer, more descriptive name for the\nreusable part. Thus, Bounded_Stack is a better name than Stack for a\ngeneric stack package because it leaves the simpler name Stack available\nto be used by an instantiation."),(0,a.kt)("p",null,"Include indications of the behavioral characteristics (but not\nindications of the implementation) in the name of a reusable part so\nthat multiple parts with the same abstraction (e.g., multiple stack\npackages) but with different restrictions (bounded, unbounded, etc.) can\nbe stored in the same Ada library and used as part of the same Ada\nprogram."),(0,a.kt)("h3",c({},{id:"abbreviations"}),"Abbreviations"),(0,a.kt)("h4",c({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Do not use abbreviations in identifier or unit names.")),(0,a.kt)("h4",c({},{id:"example-1"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Ada.Calendar;\npackage Greenwich_Mean_Time is\n   function Clock return Ada.Calendar.Time;\n   ...\nend Greenwich_Mean_Time;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The following abbreviation may not be clear when used in an application:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Calendar;\nwith Greenwich_Mean_Time;\n...\n   function Get_GMT return Ada.Calendar.Time renames\n          Greenwich_Mean_Time.Clock;\n")),(0,a.kt)("h4",c({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"This is a stronger guideline than Guideline 3.1.4. However well\ncommented, an abbreviation may cause confusion in some future reuse\ncontext. Even universally accepted abbreviations, such as GMT for\nGreenwich Mean Time, can cause problems and should be used only with\ngreat caution."),(0,a.kt)("p",null,"The difference between this guideline and Guideline 3.1.4 involves\nissues of domain. When the domain is well-defined, abbreviations and\nacronyms that are accepted in that domain will clarify the meaning of\nthe application. When that same code is removed from its domain-specific\ncontext, those abbreviations may become meaningless."),(0,a.kt)("p",null,"In the example above, the package, Greenwich_Mean_Time, could be used\nin any application without loss of meaning. But the function Get_GMT\ncould easily be confused with some other acronym in a different domain."),(0,a.kt)("h4",c({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"See Guideline 5.7.2 concerning the proper use of the renames clause. If\na particular application makes extensive use of the\nGreenwich_Mean_Time domain, it may be appropriate to rename the\npackage GMT within that application:"),(0,a.kt)("p",null,"with Greenwich_Mean_Time; ..."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," package GMT renames Greenwich_Mean_Time;")),(0,a.kt)("h3",c({},{id:"generic-formal-parameters"}),"Generic Formal Parameters"),(0,a.kt)("h4",c({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Document the expected behavior of generic formal parameters just as\nyou document any package specification.")),(0,a.kt)("h4",c({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"The following example shows how a very general algorithm can be\ndeveloped but must be clearly documented to be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   -- Index provides access to values in a structure.  For example,\n   -- an array, A.\n   type Index is (<>);\n   type Element is private;\n   type Element_Array is array (Index range <>) of Element;\n   -- The function, Should_Precede, does NOT compare the indexes\n   -- themselves; it compares the elements of the structure.\n   -- The function Should_Precede is provided rather than a \"Less_Than\" function\n   -- because the sort criterion need not be smallest first.\n   with function Should_Precede (Left  : in     Element;\n                                 Right : in     Element)\n     return Boolean;\n   -- This procedure swaps values of the structure (the mode won't\n   -- allow the indexes themselves to be swapped!)\n   with procedure Swap (Index1 : in     Index;\n                        Index2 : in     Index;\n                        A      : in out Element_Array);\n   -- After the call to Quick_Sort, the indexed structure will be\n   -- sorted:\n   --     For all i,j in First..Last :  i<j  =>  A(i) < A(j).\nprocedure Quick_Sort (First : in     Index := Index'First;\n                      Last  : in     Index := Index'Last);\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"The generic capability is one of Ada's strongest features because of its\nformalization. However, not all of the assumptions made about generic\nformal parameters can be expressed directly in Ada. It is important that\nany user of a generic know exactly what that generic needs in order to\nbehave correctly."),(0,a.kt)("p",null,"In a sense, a generic specification is a contract where the instantiator\nmust supply the formal parameters and, in return, receives a working\ninstance of the specification. Both parties are best served when the\ncontract is complete and clear about all assumptions."),(0,a.kt)("h2",c({},{id:"robustness"}),"Robustness"),(0,a.kt)("p",null,"The following guidelines improve the robustness of Ada code. It is easy\nto write code that depends on an assumption that you do not realize that\nyou are making. When such a part is reused in a different environment,\nit can break unexpectedly. The guidelines in this section show some ways\nin which Ada code can be made to automatically conform to its\nenvironment and some ways in which it can be made to check for\nviolations of assumptions. Finally, some guidelines are given to warn\nyou about errors that Ada does not catch as soon as you might like."),(0,a.kt)("h3",c({},{id:"named-numbers"}),"Named Numbers"),(0,a.kt)("h4",c({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use named numbers and static expressions to allow multiple\ndependencies to be linked to a small number of symbols.")),(0,a.kt)("h4",c({},{id:"example-3"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nprocedure Disk_Driver is\n   -- In this procedure, a number of important disk parameters are\n   -- linked.\n   Number_Of_Sectors  : constant :=     4;\n   Number_Of_Tracks   : constant :=   200;\n   Number_Of_Surfaces : constant :=    18;\n   Sector_Capacity    : constant := 4_096;\n   Track_Capacity   : constant := Number_Of_Sectors  * Sector_Capacity;\n   Surface_Capacity : constant := Number_Of_Tracks   * Track_Capacity;\n   Disk_Capacity    : constant := Number_Of_Surfaces * Surface_Capacity;\n   type Sector_Range  is range 1 .. Number_Of_Sectors;\n   type Track_Range   is range 1 .. Number_Of_Tracks;\n   type Surface_Range is range 1 .. Number_Of_Surfaces;\n   type Track_Map   is array (Sector_Range)  of ...;\n   type Surface_Map is array (Track_Range)   of Track_Map;\n   type Disk_Map    is array (Surface_Range) of Surface_Map;\nbegin  -- Disk_Driver\n   ...\nend Disk_Driver;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"To reuse software that uses named numbers and static expressions\nappropriately, just one or a small number of constants need to be reset,\nand all declarations and associated code are changed automatically.\nApart from easing reuse, this reduces the number of opportunities for\nerror and documents the meanings of the types and constants without\nusing error-prone comments."),(0,a.kt)("h3",c({},{id:"unconstrained-arrays"}),"Unconstrained Arrays"),(0,a.kt)("h4",c({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use unconstrained array types for array formal parameters and array\nreturn values."),(0,a.kt)("li",{parentName:"ul"},"Make the size of local variables depend on actual parameter size,\nwhere appropriate.")),(0,a.kt)("h4",c({},{id:"example-4"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ...\n   type Vector is array (Vector_Index range <>) of Element;\n   type Matrix is array\n           (Vector_Index range <>, Vector_Index range <>) of Element;\n   ...\n   ---------------------------------------------------------------------\n   procedure Matrix_Operation (Data : in     Matrix) is\n      Workspace   : Matrix (Data'Range(1), Data'Range(2));\n      Temp_Vector : Vector (Data'First(1) .. 2 * Data'Last(1));\n   ...\n   ---------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"Unconstrained arrays can be declared with their sizes dependent on\nformal parameter sizes. When used as local variables, their sizes change\nautomatically with the supplied actual parameters. This facility can be\nused to assist in the adaptation of a part because necessary size\nchanges in local variables are taken care of automatically."),(0,a.kt)("h3",c({},{id:"minimizing-and-documenting-assumptions"}),"Minimizing and Documenting Assumptions"),(0,a.kt)("h4",c({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the number of assumptions made by a unit."),(0,a.kt)("li",{parentName:"ul"},"For assumptions that cannot be avoided, use subtypes or constraints\nto automatically enforce conformance."),(0,a.kt)("li",{parentName:"ul"},"For assumptions that cannot be automatically enforced by subtypes,\nadd explicit checks to the code."),(0,a.kt)("li",{parentName:"ul"},"Document all assumptions."),(0,a.kt)("li",{parentName:"ul"},"If the code depends upon the implementation of a specific Special\nNeeds Annex for proper operation, document this assumption in the\ncode.")),(0,a.kt)("h4",c({},{id:"example-5"}),"example"),(0,a.kt)("p",null,"The following poorly written function documents but does not check its\nassumption:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   -- Assumption:  BCD value is less than 4 digits.\n   function Binary_To_BCD (Binary_Value : in     Natural)\n     return BCD;\n")),(0,a.kt)("p",null,"The next example enforces conformance with its assumption, making the\nchecking automatic and the comment unnecessary:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype Binary_Values is Natural range 0 .. 9_999;\n   function Binary_To_BCD (Binary_Value : in     Binary_Values)\n     return BCD;\n")),(0,a.kt)("p",null,"The next example explicitly checks and documents its assumption:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ---------------------------------------------------------------------\n   -- Out_Of_Range raised when BCD value exceeds 4  digits.\n   function Binary_To_BCD (Binary_Value : in     Natural)\n     return BCD is\n      Maximum_Representable : constant Natural := 9_999;\n   begin  -- Binary_To_BCD\n      if Binary_Value > Maximum_Representable then\n         raise Out_Of_Range;\n      end if;\n      ...\n   end Binary_To_BCD;\n   ---------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"Any part that is intended to be used again in another program,\nespecially if the other program is likely to be written by other people,\nshould be robust. It should defend itself against misuse by defining its\ninterface to enforce as many assumptions as possible and by adding\nexplicit defensive checks on anything that cannot be enforced by the\ninterface. By documenting dependencies on a Special Needs Annex, you\nwarn the user that he should only reuse the component in a compilation\nenvironment that provides the necessary support."),(0,a.kt)("h4",c({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"You can restrict the ranges of values of the inputs by careful selection\nor construction of the subtypes of the formal parameters. When you do\nso, the compiler-generated checking code may be more efficient than any\nchecks you might write. Indeed, such checking is part of the intent of\nthe strong typing in the language. This presents a challenge, however,\nfor generic units where the user of your code selects the types of the\nparameters. Your code must be constructed to deal with any value of any\nsubtype the user may choose to select for an instantiation."),(0,a.kt)("h3",c({},{id:"subtypes-in-generic-specifications"}),"Subtypes in Generic Specifications"),(0,a.kt)("h4",c({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use first subtypes when declaring generic formal objects of mode in\nout."),(0,a.kt)("li",{parentName:"ul"},"Beware of using subtypes as subtype marks when declaring parameters\nor return values of generic formal subprograms."),(0,a.kt)("li",{parentName:"ul"},"Use attributes rather than literal values.")),(0,a.kt)("h4",c({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"In the following example, it appears that any value supplied for the\ngeneric formal object Object would be constrained to the range 1..10. It\nalso appears that parameters passed at run-time to the Put routine in\nany instantiation and values returned by the Get routine would be\nsimilarly constrained:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype Range_1_10 is Integer range 1 .. 10;\n   ---------------------------------------------------------------------\n   generic\n      Object : in out Range_1_10;\n      with procedure Put (Parameter : in     Range_1_10);\n      with function  Get return Range_1_10;\n   package Input_Output is\n      ...\n   end Input_Output;\n   ---------------------------------------------------------------------\n")),(0,a.kt)("p",null,"However, this is not the case. Given the following legal instantiation:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype Range_15_30 is Integer range 15 .. 30;\n   Constrained_Object : Range_15_30 := 15;\n   procedure Constrained_Put (Parameter : in     Range_15_30);\n   function  Constrained_Get return Range_15_30;\n   package Constrained_Input_Output is\n      new Input_Output (Object => Constrained_Object,\n                        Put    => Constrained_Put,\n                        Get    => Constrained_Get);\n   ...\n")),(0,a.kt)("p",null,"Object, Parameter, and the return value of Get are constrained to the\nrange 15..30. Thus, for example, if the body of the generic package\ncontains an assignment statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Object := 1;\n")),(0,a.kt)("p",null,"Constraint_Error is raised when this instantiation is executed."),(0,a.kt)("h4",c({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,'The language specifies that when constraint checking is performed for\ngeneric formal objects and parameters and return values of generic\nformal subprograms, the constraints of the actual subtype (not the\nformal subtype) are enforced (Ada Reference Manual 1995, \xa7\xa712.4"',">"," and\n12.6).Thus, the subtype specified in a formal in out object parameter\nand the subtypes specified in the profile of a formal subprogram need\nnot match those of the actual object or subprogram."),(0,a.kt)("p",null,"Thus, even with a generic unit that has been instantiated and tested\nmany times and with an instantiation that reported no errors at\ninstantiation time, there can be a run-time error. Because the subtype\nconstraints of the generic formal are ignored, the Ada Reference Manual\n(1995, \xa7\xa712.4 and 12.6) suggests using the name of a base type in such\nplaces to avoid confusion. Even so, you must be careful not to assume\nthe freedom to use any value of the base type because the instantiation\nimposes the subtype constraints of the generic actual parameter. To be\nsafe, always refer to specific values of the type via symbolic\nexpressions containing attributes like 'First, 'Last, 'Pred, and 'Succ\nrather than via literal values."),(0,a.kt)("p",null,"For generics, attributes provide the means to maintain generality. It is\npossible to use literal values, but literals run the risk of violating\nsome constraint. For example, assuming that an array's index starts at 1\nmay cause a problem when the generic is instantiated for a zero-based\narray type."),(0,a.kt)("h4",c({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"Adding a generic formal parameter that defines the subtype of the\ngeneric formal object does not address the ramifications of the\nconstraint checking rule discussed in the above rationale. You can\ninstantiate the generic formal type with any allowable subtype, and you\nare not guaranteed that this subtype is the first subtype:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type Object_Range is range <>;\n   Objects : in out Object_Range;\n   ...\npackage X is\n   ...\nend X;\n")),(0,a.kt)("p",null,"You can instantiate the subtype Object_Range with any Integer subtype,\nfor example, Positive. However, the actual variable Object can be of\nPositive'Base, i.e., Integer and its value are not guaranteed to be\ngreater than 0."),(0,a.kt)("h3",c({},{id:"overloading-in-generic-units"}),"Overloading in Generic Units"),(0,a.kt)("h4",c({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Be careful about overloading the names of subprograms exported by\nthe same generic package.")),(0,a.kt)("h4",c({},{id:"example-7"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Item is limited private;\npackage Input_Output is\n   procedure Put (Value : in     Integer);\n   procedure Put (Value : in     Item);\nend Input_Output;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"If the generic package shown in the example above is instantiated with\nInteger (or any subtype of Integer) as the actual type corresponding to\ngeneric formal Item, then the two Put procedures have identical\ninterfaces, and all calls to Put are ambiguous. Therefore, this package\ncannot be used with type Integer. In such a case, it is better to give\nunambiguous names to all subprograms. See the Ada Reference Manual\n(1995, \xa712.3) for more information."),(0,a.kt)("h3",c({},{id:"hidden-tasks"}),"Hidden Tasks"),(0,a.kt)("h4",c({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Within a specification , document any tasks that would be activated\nby with'ing the specification and by using any part of the\nspecification."),(0,a.kt)("li",{parentName:"ul"},"Document which generic formal parameters are accessed from a task\nhidden inside the generic unit."),(0,a.kt)("li",{parentName:"ul"},"Document any multithreaded components.")),(0,a.kt)("h4",c({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"The effects of tasking become a major factor when reusable code enters\nthe domain of real-time systems. Even though tasks may be used for other\npurposes, their effect on scheduling algorithms is still a concern and\nmust be clearly documented. With the task clearly documented, the\nreal-time programmer can then analyze performance, priorities, and so\nforth to meet timing requirements, or, if necessary, he can modify or\neven redesign the component."),(0,a.kt)("p",null,"Concurrent access to datastructures must be carefully planned to avoid\nerrors, especially for data structures that are not atomic (see Chapter\n6 for details). If a generic unit accesses one of its generic formal\nparameters (reads or writes the value of a generic formal object or\ncalls a generic formal subprogram that reads or writes data) from within\na task contained in the generic unit, then there is the possibility of\nconcurrent access for which the user may not have planned. In such a\ncase, the user should be warned by a comment in the generic\nspecification."),(0,a.kt)("h3",c({},{id:"exceptions"}),"Exceptions"),(0,a.kt)("h4",c({},{id:"guideline-9"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Propagate exceptions out of reusable parts. Handle exceptions within\nreusable parts only when you are certain that the handling is\nappropriate in all circumstances."),(0,a.kt)("li",{parentName:"ul"},"Propagate exceptions raised by generic formal subprograms after\nperforming any cleanup necessary to the correct operation of future\ninvocations of the generic instantiation."),(0,a.kt)("li",{parentName:"ul"},"Leave state variables in a valid state when raising an exception."),(0,a.kt)("li",{parentName:"ul"},"Leave parameters unmodified when raising an exception.")),(0,a.kt)("h4",c({},{id:"example-8"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Number is limited private;\n   with procedure Get (Value :    out Number);\nprocedure Process_Numbers;\n\n------------------------------------------------------------------------\nprocedure Process_Numbers is\n   Local : Number;\n   procedure Perform_Cleanup_Necessary_For_Process_Numbers is separate;\n   ...\nbegin  -- Process_Numbers\n   ...\n   Catch_Exceptions_Generated_By_Get:\n      begin\n         Get (Local);\n      exception\n         when others =>\n            Perform_Cleanup_Necessary_For_Process_Numbers;\n            raise;\n      end Catch_Exceptions_Generated_By_Get;\n   ...\nend Process_Numbers;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-9"}),"rationale"),(0,a.kt)("p",null,"On most occasions, an exception is raised because an undesired event\n(such as floating-point overflow) has occurred. Such events often need\nto be dealt with entirely differently with different uses of a\nparticular software part. It is very difficult to anticipate all the\nways that users of the part may wish to have the exceptions handled.\nPassing the exception out of the part is the safest treatment."),(0,a.kt)("p",null,"In particular, when an exception is raised by a generic formal\nsubprogram, the generic unit is in no position to understand why or to\nknow what corrective action to take. Therefore, such exceptions should\nalways be propagated back to the caller of the generic instantiation.\nHowever, the generic unit must first clean up after itself, restoring\nits internal data structures to a correct state so that future calls may\nbe made to it after the caller has dealt with the current exception. For\nthis reason, all calls to generic formal subprograms should be within\nthe scope of a when others exception handler if the internal state is\nmodified, as shown in the example above."),(0,a.kt)("p",null,"When a reusable part is invoked, the user of the part should be able to\nknow exactly what operation (at the appropriate level of abstraction)\nhas been performed. For this to be possible, a reusable part must always\ndo all or none of its specified function; it must never do half.\nTherefore, any reusable part that terminates early by raising or\npropagating an exception should return to the caller with no effect on\nthe internal or external state. The easiest way to do this is to test\nfor all possible exceptional conditions before making any state changes\n(modifying internal state variables, making calls to other reusable\nparts to modify their states, updating files, etc.). When this is not\npossible, it is best to restore all internal and external states to the\nvalues that were current when the part was invoked before raising or\npropagating the exception. Even when this is not possible, it is\nimportant to document this potentially hazardous situation in the\ncomment header of the specification of the part."),(0,a.kt)("p",null,'A similar problem arises with parameters of mode out or in out when\nexceptions are raised. The Ada language distinguishes between "by-copy"\nand "by-reference" parameter passing. In some cases, "by-copy" is\nrequired; in other cases, "by-reference" is required; and in the\nremaining cases, either mechanism is allowed. The potential problem\narises in those cases where the language does not specify the parameter\npassing mechanism to use. When an exception is raised, the copy-back\ndoes not occur, but for an Ada compiler, which passes parameters by\nreference (in those cases where a choice is allowed), the actual\nparameter has already been updated. When parameters are passed by copy,\nthe update does not occur. To reduce ambiguity, increase portability,\nand avoid situations where some but not all of the actual parameters are\nupdated when an exception is raised, it is best to treat values of out\nand in out parameters like state variables, updating them only after it\nis certain that no exception will be raised. See also Guideline 7.1.8.'),(0,a.kt)("h4",c({},{id:"notes-3"}),"notes"),(0,a.kt)("p",null,"A reusable part could range from a low-level building block (e.g., data\nstructure, sorting algorithm, math function) to a large reusable\nsubsystem. The lower level the building block, the less likely that the\nreusable part will know how to handle exceptions or produce meaningful\nresults. Thus, the low-level parts should propagate exceptions. A large\nreusable subsystem, however, should be able to handle any anticipated\nexceptions independently of the variations across which it is reused."),(0,a.kt)("h2",c({},{id:"adaptability"}),"Adaptability"),(0,a.kt)("p",null,"Reusable parts often need to be changed before they can be used in a\nspecific application. They should be structured so that change is easy\nand as localized as possible. One way of achieving adaptability is to\ncreate general parts with complete functionality, only a subset of which\nmight be needed in a given application. Another way to achieve\nadaptability is to use Ada's generic construct to produce parts that can\nbe appropriately instantiated with different parameters. Both of these\napproaches avoid the error-prone process of adapting a part by changing\nits code but have limitations and can carry some overhead. Anticipated\nchanges, that is, changes that can be reasonably foreseen by the\ndeveloper of the part, should be provided for as far as possible.\nUnanticipated changes can only be accommodated by carefully structuring\na part to be adaptable. Many of the considerations pertaining to\nmaintainability apply. If the code is of high quality, clear, and\nconforms to well-established design principles such as information\nhiding, it is easier to adapt in unforeseen ways."),(0,a.kt)("h3",c({},{id:"complete-functionality"}),"Complete Functionality"),(0,a.kt)("h4",c({},{id:"guideline-10"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide core functionality in a reusable part or set of parts so\nthat the functionality in this abstraction can be meaningfully\nextended by its reusers."),(0,a.kt)("li",{parentName:"ul"},"More specifically, provide initialization and finalization\nprocedures for every data structure that may contain dynamic data."),(0,a.kt)("li",{parentName:"ul"},"For data structures needing initialization and finalization,\nconsider deriving them, when possible, from the types\nAda.Finalization.Controlled or Ada.Finalization.Limited_Controlled.")),(0,a.kt)("h4",c({},{id:"example-9"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Incoming : Queue;\n   ...\n   Set_Initial (Incoming);     -- initialization operation\n   ...\n   if Is_Full (Incoming) then  -- query operation\n      ...\n   end if;\n   ...\n   Clean_Up (Incoming);        -- finalization operation\n")),(0,a.kt)("h4",c({},{id:"rationale-10"}),"rationale"),(0,a.kt)("p",null,"This functionality is particularly important in designing/programming an\nabstraction. You have to balance the completeness of the abstraction\nagainst its extensibility. Completeness ensures that you have configured\nthe abstraction correctly, without built-in assumptions about its\nexecution environment. It also ensures the proper separation of\nfunctions so that they are useful to the current application and, in\nother combinations, to other applications. Extensibility ensures that\nreusers can add functionality by extension, using tagged type\nhierarchies (see Guideline 8.4.8 and Chapter 9) or child library\npackages (see Guidelines 4.1.6, 8.4.1, and 9.4.1)."),(0,a.kt)("p",null,"In designing for reuse, you need to think in terms of clean\nabstractions. If you provide too little functionality and rely on your\nreusers to extend the abstraction, they risk having an abstraction that\nlacks cohesion. This hodgepodge abstraction has inherited many\noperations, not all of which are necessary or work together."),(0,a.kt)("p",null,"When a reusable part can be implemented reasonably using dynamic data,\nthen any application that must control memory can use the initialization\nand finalization routines to guard against memory leakage. Then, if data\nstructures become dynamic, the applications that are sensitive to these\nconcerns can be easily adapted."),(0,a.kt)("p",null,"The predefined types Ada.Finalization.Controlled or\nAda.Finalization.Limited_Controlled provide automatic, user-definable\ninitialization, adjustment, and finalization procedures. When you\ndeclare controlled types and objects, you are guaranteed that the\ncompiler will insert the necessary calls to initialization, adjustment,\nand finalization, making your code less error-prone and more\nmaintainable. When overriding the Initialize and Finalize routines on\nthe controlled types, make sure to call the parent Initialize or\nFinalize."),(0,a.kt)("h4",c({},{id:"notes-4"}),"notes"),(0,a.kt)("p",null,"The example illustrates end condition functions. An abstraction should\nbe automatically initialized before its user gets a chance to damage it.\nWhen that is not possible, it should be supplied with initialization\noperations. In any case, it needs finalization operations. One way to\nsupply the initialization and finalization operations is to derive the\nabstraction from the predefined types Ada.Finalization.Controlled or\nAda.Finalization.Limited_Controlled. Wherever possible, query\noperations should be provided to determine when limits are about to be\nexceeded, so that the user can avoid causing exceptions to be raised."),(0,a.kt)("p",null,'It is also useful to provide reset operations for many objects. To see\nthat a reset and an initiation can be different, consider the analogous\nsituation of a "warm boot" and a "cold boot" on a personal computer.'),(0,a.kt)("p",null,"Even if all of these operations are not appropriate for the abstraction,\nthe exercise of considering them aids in formulating a complete set of\noperations, others of which may be used by another application."),(0,a.kt)("p",null,"Some implementations of the language link all subprograms of a package\ninto the executable file, ignoring whether they are used or not, making\nunused operations a liability (see Guideline 8.4.5). In such cases,\nwhere the overhead is significant, create a copy of the fully functional\npart and comment out the unused operations with an indication that they\nare redundant in this application."),(0,a.kt)("h3",c({},{id:"generic-units"}),"Generic Units"),(0,a.kt)("h4",c({},{id:"guideline-11"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use generic units to avoid code duplication."),(0,a.kt)("li",{parentName:"ul"},"Parameterize generic units for maximum adaptability."),(0,a.kt)("li",{parentName:"ul"},"Reuse common instantiations of generic units, as well as the generic\nunits themselves.")),(0,a.kt)("h4",c({},{id:"rationale-11"}),"rationale"),(0,a.kt)("p",null,"Ada does not allow data types to be passed as actual parameters to\nsubprograms during execution. Such parameters must be specified as\ngeneric formal parameters to a generic unit when it is instantiated.\nTherefore, if you want to write a subprogram for which there is\nvariation from call to call in the data type of objects on which it\noperates, then you must write the subprogram as a generic unit and\ninstantiate it once for each combination of data type parameters. The\ninstantiations of the unit can then be called as regular subprograms."),(0,a.kt)("p",null,"You can pass subprograms as actual parameters either by declaring\naccess-to-subprogram values or generic formal subprogram parameters. See\nGuideline 5.3.4 for a discussion of the tradeoffs."),(0,a.kt)("p",null,"If you find yourself writing two very similar routines differing only in\nthe data type they operate on or the subprograms they call, then it is\nprobably better to write the routine once as a generic unit and\ninstantiate it twice to get the two versions you need. When the need\narises later to modify the two routines, the change only needs to be\nmade in one place. This greatly facilitates maintenance."),(0,a.kt)("p",null,"Once you have made such a choice, consider other aspects of the routine\nthat these two instances may have in common but that are not essential\nto the nature of the routine. Factor these out as generic formal\nparameters. When the need arises later for a third similar routine, it\ncan be automatically produced by a third instantiation if you have\nforeseen all the differences between it and the other two. A\nparameterized generic unit can be very reusable."),(0,a.kt)("p",null,"It may seem that the effort involved in writing generic rather than\nnongeneric units is substantial. However, making units generic is not\nmuch more difficult or time-consuming than making them nongeneric once\nyou become familiar with the generic facilities. It is, for the most\npart, a matter of practice. Also, any effort put into the development of\nthe unit will be recouped when the unit is reused, as it surely will be\nif it is placed in a reuse library with sufficient visibility. Do not\nlimit your thinking about potential reuse to the application you are\nworking on or to other applications with which you are very familiar.\nApplications with which you are not familiar or future applications\nmight be able to reuse your software."),(0,a.kt)("p",null,"After writing a generic unit and placing it in your reuse library, the\nfirst thing you are likely to do is to instantiate it once for your\nparticular needs. At this time, it is a good idea to consider whether\nthere are instantiations that are very likely to be widely used. If so,\nplace each such instantiation in your reuse library so that they can be\nfound and shared by others."),(0,a.kt)("p",null,"See also Guideline 9.3.5."),(0,a.kt)("h3",c({},{id:"formal-private-and-limited-private-types"}),"Formal Private and Limited Private Types"),(0,a.kt)("h4",c({},{id:"guideline-12"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private type for a generic formal type when\nyou do not need assignment on objects of the type inside the generic\nbody."),(0,a.kt)("li",{parentName:"ul"},"Consider using a nonlimited private type for a generic formal type\nwhen you need normal assignment on objects of the type inside the\nbody of the generic."),(0,a.kt)("li",{parentName:"ul"},"Consider using a formal tagged type derived from\nAda.Finalization.Controlled when you need to enforce special\nassignment semantics on objects of the type in the body of the\ngeneric."),(0,a.kt)("li",{parentName:"ul"},"Export the least restrictive type that maintains the integrity of\nthe data and abstraction while allowing alternate implementations."),(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private abstract type for generic formal\ntypes of a generic that extends a formal private tagged type.")),(0,a.kt)("h4",c({},{id:"example-10"}),"example"),(0,a.kt)("p",null,"The first example shows a case of a template providing only a data\nstructure, a case in which assignment is clearly not needed in the body\nof the generic:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element_Type is limited private;\npackage Generic_Doubly_Linked_Lists is\n   type Cell_Type;\n   type List_Type is access all Element_Type;\n   type Cell_Type is\n      record\n         Data     : Element_Type;\n         Next     : List_Type;\n         Previous : List_Type;\n      end record;\nend Generic_Doubly_Linked_Lists;\n")),(0,a.kt)("p",null,"The second example shows a template that composes new operations out of\n(nonassignment) operations passed as generic formal parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type Element_Type is limited private;\n   with procedure Process_Element (X : in out Element_Type);\n   type List_Type is array (Positive range <>) of Element_Type;\nprocedure Process_List (L : in out List_Type);\nprocedure Process_List (L : in out List_Type) is\nbegin -- Process_List\n   for I in L'Range loop\n      Process_Element (L(I));\n   end loop;\nend Process_List;\n------------------------------------------------------------------------\ngeneric\n   type Domain_Type is limited private;\n   type Intermediate_Type is limited private;\n   type Range_Type is limited private;\n   with function Left (X : Intermediate_Type) return Range_Type;\n   with function Right (X : Domain_Type) return Intermediate_Type;\nfunction Generic_Composition (X : Domain_Type) return Range_Type;\n-- the function Left o Right\nfunction Generic_Composition (X : Domain_Type) return Range_Type is\nbegin  -- generic_Composition\n   return Left (Right (X));\nend Generic_Composition;\n")),(0,a.kt)("p",null,"The third example shows how to use Ada's controlled types to provide\nspecial assignment semantics:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Finalization;\ngeneric\n   type Any_Element is new Ada.Finalization.Controlled with private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   type Stack is private;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Any_Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Any_Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n")),(0,a.kt)("h4",c({},{id:"rationale-12"}),"rationale"),(0,a.kt)("p",null,"For a generic component to be usable in as many contexts as possible, it\nshould minimize the assumptions that it makes about its environment and\nshould make explicit any assumptions that are necessary. In Ada, the\nassumptions made by generic units can be stated explicitly by the types\nof the generic formal parameters. A limited private generic formal type\nprevents the generic unit from making any assumptions about the\nstructure of objects of the type or about operations defined for such\nobjects. A private (nonlimited) generic formal type allows the\nassumption that assignment and equality comparison operations are\ndefined for the type. Thus, a limited private data type cannot be\nspecified as the actual parameter for a private generic formal type."),(0,a.kt)("p",null,"In general, you should choose the private or limited private generic\nformal type based on the need for assignment inside a generic. Limited\nprivate types should be used for abstractions that do not need\nassignment, as in the first two examples above. In the third example,\nwhere assignment is needed, a type derived from a controlled type is\nspecified to ensure that the correct assignment semantics will be\navailable. If you need equality in the body of the generic, you may need\nto redefine equality as well to get the correct semantics; you would\nthen need to include a formal generic subprogram parameter for the =\nfunction."),(0,a.kt)("p",null,"The situation is reversed for types exported by a reusable part. For\nexported types, the restrictions specified by limited and limited\nprivate are restrictions on the user of the part, not on the part\nitself. To provide maximum capability to the user of a reusable part,\nexport types with as few restrictions as possible. Apply restrictions as\nnecessary to protect the integrity of the exported data structures and\nthe abstraction for the various implementations envisioned for that\ngeneric."),(0,a.kt)("p",null,"Because they are so restrictive, limited private types are not always\nthe best choice for types exported by a reusable part. In a case where\nit makes sense to allow the user to make copies of and compare data\nobjects, and when the underlying data type does not involve access types\n(so that the entire data structure gets copied or compared), then it is\nbetter to export a (nonlimited) private type. In a case where it makes\nsense to allow the user to make copies of and compare data objects and\nwhen the underlying data type involves access types (so that the entire\ndata structure gets copied or compared), then it is better to export a\ncontrolled type and an (overridden) equality operation. In cases where\nit does not detract from the abstraction to reveal even more about the\ntype, then a nonprivate type (e.g., a numeric, enumerated, record, or\narray type) should be used."),(0,a.kt)("p",null,"One use of generic units is to create a mixin generic (see Guideline\n8.3.8) to extend a tagged type. In this situation, you want to use the\nmost restrictive type as the generic formal type, that is, a formal type\nthat is both limited and abstract. When you instantiate the generic, if\nthe actual type is nonlimited, the type extension will also be\nnonlimited. In the generic package, you must declare the type extension\nas abstract. The instantiator of the generic can then extend the type\nagain to achieve the desired mixin configuration."),(0,a.kt)("h4",c({},{id:"notes-5"}),"notes"),(0,a.kt)("p",null,"The predefined packages, Sequential_IO and Direct_IO, take private\ntypes. This will complicate I/O requirements for limited private types\nand should be considered during design."),(0,a.kt)("p",null,"There are also some cases where you must use a limited private formal\ntype. These cases arise when the formal type has an access discriminant,\nor the formal is used as the parent type in defining a type extension\nthat itself includes a component of a limited type (e.g., task type), or\nthe formal defines a new discriminant part with an access discriminant."),(0,a.kt)("h3",c({},{id:"using-generic-units-to-encapsulate-algorithms"}),"Using Generic Units to Encapsulate Algorithms"),(0,a.kt)("h4",c({},{id:"guideline-13"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use generic units to encapsulate algorithms independently of data\ntype.")),(0,a.kt)("h4",c({},{id:"example-11"}),"example"),(0,a.kt)("p",null,"This is the specification of a generic sort procedure:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   type Data    is array (Positive range <>) of Element;\n   with function Should_Precede (Left  : in     Element;\n                                 Right : in     Element)\n          return Boolean is <>;\n with procedure Swap (Left  : in out Element;\n                        Right : in out Element) is <>;\nprocedure Generic_Sort (Data_To_Sort : in out Data);\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The generic body looks just like a regular procedure body and can make\nfull use of the generic formal parameters in implementing the sort\nalgorithm:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nprocedure Generic_Sort (Data_To_Sort : in out Data) is\nbegin\n   ...\n   for I in Data_To_Sort'Range loop\n      ...\n         ...\n         if Should_Precede (Data_To_Sort(J), Data_To_Sort(I)) then\n            Swap(Data_To_Sort(I), Data_To_Sort(J));\n         end if;\n         ...\n      ...\n   end loop;\n   ...\nend Generic_Sort;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The generic procedure can be instantiated as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   type Integer_Array is array (Positive range <>) of Integer;\n   function Should_Precede (Left  : in     Integer;\n                            Right : in     Integer)\n     return Boolean;\n\n   procedure Swap (Left  : in out Integer;\n                   Right : in out Integer);\n   procedure Sort is\n      new Generic_Sort (Element => Integer,\n                        Data    => Integer_Array);\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype String_80    is String (1 .. 80);\n   type    String_Array is array (Positive range <>) of String_80;\n   function Should_Precede (Left  : in     String_80;\n                            Right : in     String_80)\n     return Boolean;\n\n   procedure Swap (Left  : in out String_80;\n                   Right : in out String_80);\n\n   procedure Sort is\n      new Generic_Sort (Element => String_80,\n                        Data    => String_Array);\n")),(0,a.kt)("p",null,"and called as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Integer_Array_1 : Integer_Array (1 .. 100);\n   ...\n   Sort (Integer_Array_1);\n")),(0,a.kt)("p",null,"or:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   String_Array_1  : String_Array  (1 .. 100);\n   ...\n   Sort (String_Array_1);\n")),(0,a.kt)("h4",c({},{id:"rationale-13"}),"rationale"),(0,a.kt)("p",null,"A sort algorithm can be described independently of the data type being\nsorted. This generic procedure takes the Element data type as a generic\nlimited private type parameter so that it assumes as little as possible\nabout the data type of the objects actually being operated on. It also\ntakes Data as a generic formal parameter so that instantiations can have\nentire arrays passed to them for sorting. Finally, it explicitly\nrequires the two operators that it needs to do the sort: Should_Precede\nand Swap. The sort algorithm is encapsulated without reference to any\ndata type. The generic can be instantiated to sort an array of any data\ntype. 8.3.5 Using Generic Units for Data Abstraction"),(0,a.kt)("h4",c({},{id:"guideline-14"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using abstract data types (not to be confused with Ada's\nabstract types) in preference to abstract data objects."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic units to implement abstract data types\nindependently of their component data type.")),(0,a.kt)("h4",c({},{id:"example-12"}),"example"),(0,a.kt)("p",null,"This example presents a series of different techniques that can be used\nto generate abstract data types and objects. A discussion of the merits\nof each follows in the rationale section below. The first is an abstract\ndata object (ADO), which can be used to encapsulate an abstract state\nmachine. It encapsulates one stack of integers:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Bounded_Stack is\n   subtype Element is Integer;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The second example is an abstract data type (ADT). It differs from the\nADO by exporting the Stack type, which allows the user to declare any\nnumber of stacks of integers. Because multiple stacks may now exist, it\nis necessary to specify a Stack argument on calls to Push and Pop:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Bounded_Stack is\n   subtype Element is Integer;\n   type    Stack   is limited private;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The third example is a parameterless generic abstract data object\n(GADO). It differs from the ADO (the first example) simply by being\ngeneric, so that the user can instantiate it multiple times to obtain\nmultiple stacks of integers:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\npackage Bounded_Stack is\n   subtype Element is Integer;\n   Maximum_Stack_Size : constant := 100;\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The fourth example is a slight variant on the third, still a GADO but\nwith parameters. It differs from the third example by making the data\ntype of the stack a generic parameter so that stacks of data types other\nthan Integer can be created. Also, Maximum_Stack_Size has been made a\ngeneric parameter that defaults to 100 but can be specified by the user,\nrather than a constant defined by the package:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   procedure Push (New_Element : in     Element);\n   procedure Pop  (Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The fifth example is a generic abstract data type (GADT). It differs\nfrom the GADO in the fourth example in the same way that the ADT in the\nsecond example differed from the ADO in the first example; it exports\nthe Stack type, which allows the user to declare any number of stacks:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   type Element is private;\n   Maximum_Stack_Size : in Natural := 100;\npackage Bounded_Stack is\n   type Stack is private;\n   procedure Push (On_Top      : in out Stack;\n                   New_Element : in     Element);\n   procedure Pop  (From_Top    : in out Stack;\n                   Top_Element :    out Element);\n   Overflow  : exception;\n   Underflow : exception;\n   ...\nprivate\n   type Stack_Information;\n   type Stack is access Stack_Information;\nend Bounded_Stack;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-14"}),"rationale"),(0,a.kt)("p",null,"The biggest advantage of an ADT over an ADO (or a GADT over a GADO) is\nthat the user of the package can declare as many objects as desired with\nan ADT. These objects can be declared as standalone variables or as\ncomponents of arrays and records. They can also be passed as parameters.\nNone of this is possible with an ADO, where the single data object is\nencapsulated inside of the package. Furthermore, an ADO provides no more\nprotection of the data structure than an ADT. When a private type is\nexported by the ADT package, as in the example above, then for both the\nADO and ADT, the only legal operations that can modify the data are\nthose defined explicitly by the package (in this case, Push and Pop).\nFor these reasons, an ADT or GADT is almost always preferable to an ADO\nor GADO, respectively."),(0,a.kt)("p",null,"A GADO is similar to an ADT in one way: it allows multiple objects to be\ncreated by the user. With an ADT, multiple objects can be declared using\nthe type defined by the ADT package. With a GADO (even a GADO with no\ngeneric formal parameters, as shown in the third example), the package\ncan be instantiated multiple times to produce multiple objects. However,\nthe similarity ends there. The multiple objects produced by the\ninstantiations suffer from all restrictions described above for ADOs;\nthey cannot be used in arrays or records or passed as parameters.\nFurthermore, the objects are each of a different type, and no operations\nare defined to operate on more than one of them at a time. For example,\nthere cannot be an operation to compare two such objects or to assign\none to another. The multiple objects declared using the type defined by\nan ADT package suffer from no such restrictions; they can be used in\narrays and records and can be passed as parameters. Also, they are all\ndeclared to be of the same type, so that it is possible for the ADT\npackage to provide operations to assign, compare, copy, etc. For these\nreasons, an ADT is almost always preferable to a parameterless GADO."),(0,a.kt)("p",null,"The biggest advantage of a GADT or GADO over an ADT or ADO,\nrespectively, is that the GADT and GADO are generic and can thus be\nparameterized with types, subprograms, and other configuration\ninformation. Thus, as shown above, a single generic package can support\nbounded stacks of any data type and any stack size, while the ADT and\nADO above are restricted to stacks of Integer, no more than 100 in size.\nFor this reason, a GADO or GADT is almost always preferable to an ADO or\nADT."),(0,a.kt)("p",null,"The list of examples above is given in order of increasing power and\nflexibility, starting with an ADO and ending with a GADT. These\nadvantages are not expensive in terms of complexity or development time.\nThe specification of the GADT above is not significantly harder to write\nor understand than the specification of the ADO. The bodies are also\nnearly identical."),(0,a.kt)("p",null,"Compare the body for the simplest version, the ADO:"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"package body Bounded_Stack is"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," type Stack_Slots is array (Natural range <>) of Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"type Stack_Information is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"record"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Slots : Stack_Slots (1 .. Maximum_Stack_Size);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Index : Natural := 0;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end record;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack : Stack_Information;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Push (New_Element : in Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if Stack.Index >= Maximum_Stack_Size then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Overflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Index := Stack.Index + 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Slots(Stack.Index) := New_Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Push;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Pop (Top_Element : out Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if Stack.Index <= 0 then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Underflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element := Stack.Slots(Stack.Index);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Stack.Index := Stack.Index - 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Pop;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"...")),(0,a.kt)("p",null,"end Bounded_Stack;"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"with the body for the most powerful and flexible version, the GADT:"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"package body Bounded_Stack is"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," type Stack_Slots is array (Natural range <>) of Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"type Stack_Information is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"record"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Slots : Stack_Slots (1 .. Maximum_Stack_Size);"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Index : Natural := 0;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end record;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Push (On_Top : in out Stack;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"New_Element : in Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if On_Top.Index >= Maximum_Stack_Size then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Overflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"On_Top.Index := On_Top.Index + 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"On_Top.Slots(On_Top.Index) := New_Element;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Push;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"procedure Pop (From_Top : in out Stack;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element : out Element) is"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"if From_Top.Index <= 0 then"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"raise Underflow;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end if;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"Top_Element := From_Top.Slots(From_Top.Index);")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"}," From_Top.Index := From_Top.Index - 1;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"end Pop;"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"---------------------------------------------------------------------"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"...")),(0,a.kt)("p",null,"end Bounded_Stack;"),(0,a.kt)("hr",null),(0,a.kt)("p",null,"There is only one difference. The ADO declares a local object called\nStack, while the GADT has one additional parameter (called Stack) on\neach of the exported procedures Push and Pop."),(0,a.kt)("h3",c({},{id:"iterators"}),"Iterators"),(0,a.kt)("h4",c({},{id:"guideline-15"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide iterators for traversing complex data structures within\nreusable parts."),(0,a.kt)("li",{parentName:"ul"},"Consider providing both active and passive iterators."),(0,a.kt)("li",{parentName:"ul"},"Protect the iterators from errors due to modification of the data\nstructure during iteration."),(0,a.kt)("li",{parentName:"ul"},"Document the behavior of the iterators when the data structure is\nmodified during traversal.")),(0,a.kt)("h4",c({},{id:"example-13"}),"example"),(0,a.kt)("p",null,'Ada provides several mechanisms for building reusable iterators. The\nfollowing examples discuss the alternatives of "simple" generics, access\ndiscriminants, and type extension. The terms active and passive are used\nto differentiate whether the iteration mechanism (i.e., the way in which\nthe complex data structure is traversed) is exposed or hidden. A passive\niterator hides the traversal (e.g., looping mechanism) and consists of a\nsingle operation, iterate, that is parameterized by the processing you\ndo on each element of the data structure. By contrast, an active\niterator exposes the primitive operations by which you traverse the data\nstructure (Booch 1987).'),(0,a.kt)("p",null,"The first example shows a generic package that defines an abstract list\ndata type, with both active and passive iterators for traversing a list:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'------------------------------------------------------------------------\ngeneric\n   type Element is limited private;\n   ...\npackage Unbounded_List is\n   type List is limited private;\n   procedure Insert (New_Element : in     Element;\n                     Into        : in out List);\n   -- Passive (generic) iterator.\n   generic\n      with procedure Process (Each : in out Element);\n   procedure Iterate (Over : in     List);\n   -- Active iterator\n   type Iterator is limited private;\n\n   procedure Initialize (Index         : in out Iterator;\n                         Existing_List : in     List);\n\n   function  More       (Index         : in     Iterator)\n     return Boolean;\n\n   -- The procedure Get_Next combines an "Advance" and "Current" function\n   procedure Get_Next   (Index           : in out Iterator;\n                         Current_Element :    out Element);\n   ...\nprivate\n   ...\nend Unbounded_List;\n------------------------------------------------------------------------\n')),(0,a.kt)("p",null,"After instantiating the generic package and declaring a list as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Unbounded_List;\nprocedure List_User is\n   type Employee is ...;\n   package Roster is\n      new Unbounded_List (Element => Employee, ...);\n   Employee_List : Roster.List;\n")),(0,a.kt)("p",null,"the passive iterator is instantiated, specifying the name of the routine\nthat should be called for each list element when the iterator is called."),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ---------------------------------------------------------------------\n   procedure Process_Employee (Each : in out Employee) is\n   begin\n      ...\n      -- Perform the required action for EMPLOYEE here.\n   end Process_Employee;\n   ---------------------------------------------------------------------\n   procedure Process_All is\n      new Roster.Iterate (Process => Process_Employee);\n")),(0,a.kt)("p",null,"The passive iterator can then be called as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"begin  -- List_User\n   Process_All (Employee_List);\nend List_User;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"Alternatively, the active iterator can be used without the second\ninstantiation required by the passive iterator:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   Iterator         : Roster.Iterator;\n   Current_Employee : Employee;\n   procedure Process_Employee (Each : in     Employee) is separate;\nbegin  -- List_User\n   Roster.Initialize (Index         => Iterator,\n                      Existing_List => Employee_List);\n\n   while Roster.More (Iterator) loop\n\n      Roster.Get_Next (Index           => Iterator,\n                       Current_Element => Current_Employee);\n\n      Process_Employee (Current_Employee);\n\n   end loop;\nend List_User;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"The second example shows a code excerpt from Rationale (1995, \xa73.7.1) on\nhow to construct iterators using access discriminants:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type Element is private;\npackage Sets is\n   type Set is limited private;\n   ... -- various set operations\n   type Iterator (S : access Set) is limited private;\n   procedure Start (I : Iterator);\n   function Done (I : Iterator) return Boolean;\n   procedure Next (I : in out Iterator);\n   ...  -- other iterator operations\nprivate\n   type Node;\n   type Ptr is access Node;\n   type Node is\n      record\n         E    : Element;\n         Next : Ptr;\n      end record;\n   type Set is new Ptr;\n   type Iterator (S : access Set) is\n      record\n         This : Ptr;\n      end record;\nend Sets;\npackage body Sets is\n   ...  -- bodies of the various set operations\n   procedure Start (I : in out Iterator) is\n   begin\n      I.This := Ptr(I.S.all);\n   end Start;\n   function Done (I : Iterator) return Boolean is\n   begin\n      return I.This = null;\n   end Done;\n   procedure Next (I : in out Iterator) is\n   begin\n      I.This := I.This.Next;\n   end Next;\n   ...\nend Sets;\n")),(0,a.kt)("p",null,"The iterator operations allow you to iterate over the elements of the\nset with the component This of the iterator object accessing the current\nelement. The access discriminant always points to the enclosing set to\nwhich the current element belongs."),(0,a.kt)("p",null,"The third example uses code fragments from Rationale (1995, \xa74.4.4) to\nshow an iterator using type extension and dispatching:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Element is ...\npackage Sets is\n   type Set is limited private;\n   -- various set operations\n   type Iterator is abstract tagged null record;\n   procedure Iterate (S : in Set; IC : in out Iterator'Class);\n   procedure Action (E : in out Element;\n                     I : in out Iterator) is abstract;\nprivate\n   -- definition of Node, Ptr (to Node), and Set\nend Sets;\npackage body Sets is\n   ...\n   procedure Iterate (S : in Set; IC : in out Iterator'Class) is\n      This : Ptr := Ptr (S);\n   begin\n      while This /= null loop\n         Action (This.E, IC);  -- dispatch\n         This := This.Next;\n      end loop;\n   end Iterate;\nend Sets;\n")),(0,a.kt)("p",null,"The general purpose iterator looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"package Sets.Something is\n   procedure Do_Something (S : Set; P : Parameters);\nend Sets.Something;\npackage body Sets.Something is\n   type My_Iterator is new Iterator with\n      record\n         -- components for parameters and workspace\n      end record;\n   procedure Action (E : in out Element;\n                     I : in out My_Iterator) is\n   begin\n      -- do something to element E using data from iterator I\n   end Action;\n   procedure Do_Something (S : Set; P : Parameters) is\n      I : My_Iterator;\n   begin  -- Do_Something\n      ...  -- copy parameters into iterator\n      Iterate (S, I);\n      ... copy any results from iterator back to parameters\n   end Do_Something;\n\nend Sets.Something;\n")),(0,a.kt)("h4",c({},{id:"rationale-15"}),"rationale"),(0,a.kt)("p",null,"Iteration over complex data structures is often required and, if not\nprovided by the part itself, can be difficult to implement without\nviolating information hiding principles."),(0,a.kt)("p",null,"Active and passive iterators each have their advantages, but neither is\nappropriate in all situations. Therefore, it is recommended that both be\nprovided to give the user a choice of which to use in each situation."),(0,a.kt)("p",null,"Passive iterators are simpler and less error-prone than active\niterators, in the same way that the for loop is simpler and less\nerror-prone than the while loop. There are fewer mistakes that the user\ncan make in using a passive iterator. Simply instantiate it with the\nroutine to be executed for each list element, and call the instantiation\nfor the desired list. Active iterators require more care by the user.\nCare must be taken to invoke the iterator operations in the proper\nsequence and to associate the proper iterator variable with the proper\nlist variable. It is possible for a change made to the software during\nmaintenance to introduce an error, perhaps an infinite loop."),(0,a.kt)("p",null,"On the other hand, active iterators are more flexible than passive\niterators. With a passive iterator, it is difficult to perform multiple,\nconcurrent, synchronized iterations. For example, it is much easier to\nuse active iterators to iterate over two sorted lists, merging them into\na third sorted list. Also, for multidimensional data structures, a small\nnumber of active iterator routines may be able to replace a large number\nof passive iterators, each of which implements one combination of the\nactive iterators. Finally, active iterators can be passed as generic\nformal parameters while passive iterators cannot because passive\niterators are themselves generic, and generic units cannot be passed as\nparameters to other generic units."),(0,a.kt)("p",null,'For either type of iterator, semantic questions can arise about what\nhappens when the data structure is modified as it is being iterated.\nWhen writing an iterator, be sure to consider this possibility, and\nindicate with comments the behavior that occurs in such a case. It is\nnot always obvious to the user what to expect. For example, to determine\nthe "closure" of a mathematical "set" with respect to some operation, a\ncommon algorithm is to iterate over the members of the set, generating\nnew elements and adding them to the set. In such a case, it is important\nthat elements added to the set during the iteration be encountered\nsubsequently during the iteration. On the other hand, for other\nalgorithms, it may be important that the iterated set is the same set\nthat existed at the beginning of the iteration. In the case of a\nprioritized list data structure, if the list is iterated in priority\norder, it may be important that elements inserted at lower priority than\nthe current element during iteration not be encountered subsequently\nduring the iteration but that elements inserted at a higher priority\nshould be encountered. In any case, make a conscious decision about how\nthe iterator should operate, and document that behavior in the package\nspecification.'),(0,a.kt)("p",null,"Deletions from the data structure also pose a problem for iterators. It\nis a common mistake for a user to iterate over a data structure,\ndeleting it piece by piece during the iteration. If the iterator is not\nprepared for such a situation, it is possible to end up dereferencing a\nnull pointer or committing a similar error. Such situations can be\nprevented by storing extra information with each data structure, which\nindicates whether it is currently being iterated, and using this\ninformation to disallow any modifications to the data structure during\niteration. When the data structure is declared as a limited private\ntype, as should usually be the case when iterators are involved, the\nonly operations defined on the type are declared explicitly in the\npackage that declares the type, making it possible to add such tests to\nall modification operations."),(0,a.kt)("p",null,"The Rationale (1995, \xa74.4.4) notes that the access discriminant and type\nextension techniques are inversions of each other. In the access\ndiscriminant approach, you have to write out the looping mechanism for\neach action. In the type extension approach, you write one loop and\ndispatch to the desired action. Thus, an iterator that uses the access\ndiscriminant technique would be considered active, while an iterator\nthat uses the type extension technique would be considered passive."),(0,a.kt)("h4",c({},{id:"notes-6"}),"notes"),(0,a.kt)("p",null,"You can use an access to subprogram type as an alternative to generic\ninstantiation, using a nongeneric parameter as a pointer to subprogram.\nYou would then apply the referenced subprogram to every element in a\ncollection ( Rationale 1995, \xa73.7.2). There are drawbacks to this\napproach, however, because you cannot use it to create a general purpose\niterator. Anonymous access to subprogram parameters is not allowed in\nAda; thus, the following fragment is illegal:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"procedure Iterate (C      : Collection;\n                   Action : access procedure (E : in out Element));\n")),(0,a.kt)("p",null,"The formal parameter Action must be of a named access subtype, as in:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Action_Type is access procedure (E : in out Element);\nprocedure Iterate (C      : Collection;\n                   Action : Action_Type);\n")),(0,a.kt)("p",null,"In order for this to work, you must make sure that the action subprogram\nis in scope and not defined internal to another subprogram. If it is\ndefined as a nested procedure, it would be illegal to access it. See the\nRationale (1995, \xa74.4.4) for a more complete example."),(0,a.kt)("p",null,"For further discussion of passive and active iterators, see the\nRationale (1995, \xa73.7.1 and \xa74.4.4), Ross (1989), and Booch (1987)."),(0,a.kt)("h3",c({},{id:"decimal-type-output-and-information-systems-annex"}),"Decimal Type Output and Information Systems Annex"),(0,a.kt)("h4",c({},{id:"guideline-16"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Localize the currency symbol, digits separator, radix mark, and fill\ncharacter in picture output."),(0,a.kt)("li",{parentName:"ul"},"Consider using the ","#"," character in picture layouts so that the\nedited numeric output lengths are invariant across currency symbols\nof different lengths.")),(0,a.kt)("h4",c({},{id:"example-14"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Text_IO.Editing;\npackage Currency is\n\n   type Dollars is delta 0.01 digits 10;\n   type Marks   is delta 0.01 digits 10;\n\n   package Dollar_Output is\n      new Ada.Text_IO.Editing.Decimal_Output\n             (Num                => Dollars,\n              Default_Currency   => \"$\",\n              Default_Fill       => '*',\n              Default_Separator  => ',',\n              Default_Radix_Mark => '.');\n\n   package Mark_Output is\n      new Ada.Text_IO.Editing.Decimal_Output\n             (Num                => Marks,\n              Default_Currency   => \"DM\",\n              Default_Fill       => '*',\n              Default_Separator  => '.',\n              Default_Radix_Mark => ',');\n\nend Currency;\nwith Ada.Text_IO.Editing;\nwith Currency;  use Currency;\nprocedure Test_Picture_Editing is\n\n   DM_Amount     : Marks;\n   Dollar_Amount : Dollars;\n\n   Amount_Picture : constant Ada.Text_IO.Editing.Picture\n      := Ada.Text_IO.Editing.To_Picture (\"##ZZ_ZZZ_ZZ9.99\");\n\nbegin   -- Test_Picture_Editing\n\n   DM_Amount     := 1_234_567.89;\n   Dollar_Amount := 1_234_567.89;\n\n   DM_Output.Put (Item => DM_Amount,\n                  Pic  => Amount_Picture);\n\n   Dollar_Output.Put (Item => Dollar_Amount,\n                      Pic  => Amount_Picture);\n\nend Test_Picture_Editing;\n")),(0,a.kt)("h4",c({},{id:"rationale-16"}),"rationale"),(0,a.kt)("p",null,"Currencies differ in how they are displayed in a report. Currencies use\ndifferent symbols of different lengths (e.g., the American $, the German\nDM, and the Austrian \xd6S). They use different symbols to separate digits.\nThe United States and the United Kingdom use the comma to separate\ngroups of thousands, whereas Continental Europe uses the period. The\nUnited States and the United Kingdom use a period as a decimal point;\nContinental Europe uses the comma. For a program involving financial\ncalculations that is to be reused across countries, you need to take\nthese differences into account. By encapsulating them, you limit the\nimpact of change in adapting the financial package."),(0,a.kt)("h3",c({},{id:"implementing-mixins"}),"Implementing Mixins"),(0,a.kt)("h4",c({},{id:"guideline-17"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Consider using abstract tagged types and generics to define reusable\nunits of functionality that can be "mixed into" core abstractions\n(also known as mixins).')),(0,a.kt)("h4",c({},{id:"example-15"}),"example"),(0,a.kt)("p",null,"Note the use of an abstract tagged type as a generic formal parameter\nand as the exported extended type in the pattern that follows, excerpted\nfrom the Rationale (1995, \xa74.6.2):"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"generic\n   type S is abstract tagged private;\npackage P is\n   type T is abstract new S with private;\n   -- operations on T\nprivate\n   type T is abstract new S with\n      record\n         -- additional components\n      end record;\nend P;\n")),(0,a.kt)("p",null,'The following code shows how the generic might be instantiated to\n"mixin" the desired features in the final type extension. See also\nGuideline 9.5.1 for a related example of code.'),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"-- Assume that packages P1, P2, P3, and P4 are generic packages which take a tagged\n-- type as generic formal type parameter and which export a tagged type T\npackage Q is\n   type My_T is new Basic_T with private;\n   ... -- exported operations\nprivate\n   package Feature_1 is new P1 (Basic_T);\n   package Feature_2 is new P2 (Feature_1.T);\n   package Feature 3 is new P3 (Feature_2.T);\n   package Feature_4 is new P4 (Feature_3.T);\n   -- etc.\n   type My_T is new Feature_4.T with null record;\nend Q;\n")),(0,a.kt)("h4",c({},{id:"rationale-17"}),"rationale"),(0,a.kt)("p",null,"The Rationale (1995, \xa74.6.2) discusses the use of a generic template to\ndefine the properties to be mixed in to your abstraction:"),(0,a.kt)("p",null,"The generic template defines the mixin. The type supplied as generic\nactual parameter determines the parent . . . the body provides the\noperations and the specification exports the extended type."),(0,a.kt)("p",null,"If you have defined a series of generic mixin packages, you would then\nserialize the instantiations. The actual parameter to the next\ninstantiation is the exported tagged type from the previous\ninstantiation. This is shown in the second code segment in the example.\nEach extension is derived from a previous extension, so you have a\nlinearized succession of overriding subprograms. Because they are\nlinearized, you have a derivation order you can use to resolve any\nconflicts."),(0,a.kt)("p",null,"You should encapsulate one extension (and related operations) per\ngeneric package. This provides a better separation of concerns and more\nmaintainable, reusable components."),(0,a.kt)("p",null,"See Guideline 9.5.1 for a full discussion of the use of mixins."),(0,a.kt)("h2",c({},{id:"independence"}),"Independence"),(0,a.kt)("p",null,'A reusable part should be as independent as possible from other reusable\nparts. A potential user is less inclined to reuse a part if that part\nrequires the use of other parts that seem unnecessary. The "extra\nbaggage" of the other parts wastes time and space. A user would like to\nbe able to reuse only that part that is perceived as useful. The concept\nof a "part" is intentionally vague here. A single package does not need\nto be independent of each other package in a reuse library if the\n"parts" from that library that are typically reused are entire\nsubsystems. If the entire subsystem is perceived as providing a useful\nfunction, the entire subsystem is reused. However, the subsystem should\nnot be tightly coupled to all the other subsystems in the reuse library\nso that it is difficult or impossible to reuse the subsystem without\nreusing the entire library. Coupling between reusable parts should only\noccur when it provides a strong benefit perceptible to the user.'),(0,a.kt)("h3",c({},{id:"subsystem-design"}),"Subsystem Design"),(0,a.kt)("h4",c({},{id:"guideline-18"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider structuring subsystems so that operations that are only\nused in a particular context are in different child packages than\noperations used in a different context."),(0,a.kt)("li",{parentName:"ul"},"Consider declaring context-independent functionality in the parent\npackage and context-dependent functionality in child packages.")),(0,a.kt)("h4",c({},{id:"rationale-18"}),"rationale"),(0,a.kt)("p",null,"The generic unit is a basic building block. Generic parameterization can\nbe used to break dependencies between program units so that they can be\nreused separately. However, it is often the case that a set of units,\nparticularly a set of packages, are to be reused together as a\nsubsystem. In this case, the packages can be collected into a hierarchy\nof child packages, with private packages to hide internal details. The\nhierarchy may or may not be generic. Using the child packages allows\nsubsystems to be reused without incorporating too many extraneous\noperations because the unused child packages can be discarded in the new\nenvironment."),(0,a.kt)("p",null,"See also Guidelines 4.1.6 and 8.3.1."),(0,a.kt)("h3",c({},{id:"using-generic-parameters-to-reduce-coupling"}),"Using Generic Parameters to Reduce Coupling"),(0,a.kt)("h4",c({},{id:"guideline-19"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize with clauses on reusable parts, especially on their\nspecifications."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic parameters instead of with statements to\nreduce the number of context clauses on a reusable part."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic formal package parameters to import directly\nall the types and operations defined in an instance of a preexisting\ngeneric.")),(0,a.kt)("h4",c({},{id:"example-16"}),"example"),(0,a.kt)("p",null,"A procedure like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Package_A;\nprocedure Produce_And_Store_A is\n   ...\nbegin  -- Produce_And_Store_A\n   ...\n   Package_A.Produce (...);\n   ...\n   Package_A.Store (...);\n   ...\nend Produce_And_Store_A;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"can be rewritten as a generic unit:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\ngeneric\n   with procedure Produce (...);\n   with procedure Store   (...);\nprocedure Produce_And_Store;\n------------------------------------------------------------------------\nprocedure Produce_And_Store is\n   ...\nbegin  -- Produce_And_Store\n   ...\n   Produce (...);\n   ...\n   Store   (...);\n   ...\nend Produce_And_Store;\n------------------------------------------------------------------------\n")),(0,a.kt)("p",null,"and then instantiated:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\nwith Package_A;\nwith Produce_And_Store;\nprocedure Produce_And_Store_A is\n   new Produce_And_Store (Produce => Package_A.Produce,\n                          Store   => Package_A.Store);\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-19"}),"rationale"),(0,a.kt)("p",null,"Context (with) clauses specify the names of other units upon which this\nunit depends. Such dependencies cannot and should not be entirely\navoided, but it is a good idea to minimize the number of them that occur\nin the specification of a unit. Try to move them to the body, leaving\nthe specification independent of other units so that it is easier to\nunderstand in isolation. Also, organize your reusable parts in such a\nway that the bodies of the units do not contain large numbers of\ndependencies on each other. Partitioning your library into independent\nfunctional areas with no dependencies spanning the boundaries of the\nareas is a good way to start. Finally, reduce dependencies by using\ngeneric formal parameters instead of with statements, as shown in the\nexample above. If the units in a library are too tightly coupled, then\nno single part can be reused without reusing most or all of the library."),(0,a.kt)("p",null,"The first (nongeneric) version of Produce_And_Store_A above is\ndifficult to reuse because it depends on Package_A that may not be\ngeneral purpose or generally available. If the operation\nProduce_And_Store has reuse potential that is reduced by this\ndependency, a generic unit and an instantiation should be produced as\nshown above. The with clause for Package_A has been moved from the\nProduce_And_Store generic procedure, which encapsulates the reusable\nalgorithm to the Produce_And_Store_A instantiation. Instead of naming\nthe package that provides the required operations, the generic unit\nsimply lists the required operations themselves. This increases the\nindependence and reusability of the generic unit."),(0,a.kt)("p",null,"This use of generic formal parameters in place of with clauses also\nallows visibility at a finer granularity. The with clause on the\nnongeneric version of Produce_And_Store_A makes all of the contents\nof Package_A visible to Produce_And_Store_A, while the generic\nparameters on the generic version make only the Produce and Store\noperations available to the generic instantiation."),(0,a.kt)("p",null,'Generic formal packages allow for "safer and simpler composition of\ngeneric abstractions" ( Rationale 1995, \xa712.6). The generic formal\npackage allows you to group a set of related types and their operations\ninto a single unit, avoiding having to list each type and operation as\nan individual generic formal parameter. This technique allows you to\nshow clearly that you are extending the functionality of one generic\nwith another generic, effectively parameterizing one abstraction with\nanother.'),(0,a.kt)("h3",c({},{id:"coupling-due-to-pragmas"}),"Coupling Due to Pragmas"),(0,a.kt)("h4",c({},{id:"guideline-20"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In the specification of a generic library unit, use pragma\nElaborate_Body.")),(0,a.kt)("h4",c({},{id:"example-17"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"---------------------------------------------------------------------------\ngeneric\n   ...\npackage Stack is\n\n   pragma Elaborate_Body (Stack); -- in case the body is not yet elaborated\n\n   ...\nend Stack;\n---------------------------------------------------------------------------\nwith Stack;\npackage My_Stack is\n   new Stack (...);\n---------------------------------------------------------------------------\npackage body Stack is\nbegin\n   ...\nend Stack;\n---------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-20"}),"rationale"),(0,a.kt)("p",null,"The elaboration order of compilation units is only constrained to follow\nthe compilation order. Furthermore, any time you have an instantiation\nas a library unit or an instantiation in a library package, Ada requires\nthat you elaborate the body of the generic being instantiated before\nelaborating the instantiation itself. Because a generic library unit\nbody may be compiled after an instantiation of that generic, the body\nmay not necessarily be elaborated at the time of the instantiation,\ncausing a Program_Error. Using pragma Elaborate_Body avoids this by\nrequiring that the generic unit body be elaborated immediately after the\nspecification, whatever the compilation order."),(0,a.kt)("p",null,"When there is clear requirement for a recursive dependency, you should\nuse pragma Elaborate_Body. This situation arises, for example, when you\nhave a recursive dependency (i.e., package A's body depends on package\nB's specification and package B's body depends on package A's\nspecification)."),(0,a.kt)("h4",c({},{id:"notes-7"}),"notes"),(0,a.kt)("p",null,"Pragma Elaborate_All controls the order of elaboration of one unit with\nrespect to another. This is another way of coupling units and should be\navoided when possible in reusable parts because it restricts the number\nof configurations in which the reusable parts can be combined.\nRecognize, however, that pragma Elaborate_All provides a better\nguarantee of elaboration order because if using this pragma uncovers\nelaboration problems, they will be reported at link time (as opposed to\na run-time execution error)."),(0,a.kt)("p",null,"Any time you call a subprogram (typically a function) during the\nelaboration of a library unit, the body of the subprogram must have been\nelaborated before the library unit. You can ensure this elaboration\nhappens by adding a pragma Elaborate_Body for the unit containing the\nfunction. If, however, that function calls other functions, then it is\nsafer to put a pragma Elaborate_All on the unit containing the\nfunction."),(0,a.kt)("p",null,"For a discussion of the pragmas Pure and Preelaborate, see also the Ada\nReference Manual (1995, \xa710.2.1) and the Rationale (1995, \xa710.3). If you\nuse either pragma Pure or Preelaborate, you will not need the pragma\nElaborate_Body."),(0,a.kt)("p",null,'The idea of a registry is fundamental to many object-oriented\nprogramming frameworks. Because other library units will need to call it\nduring their elaboration, you need to make sure that the registry itself\nis elaborated early. Note that the registry should only depend on the\nroot types of the type hierarchies and that the registry should only\nhold "class-wide" pointers to the objects, not more specific pointers.\nThe root types should not themselves depend on the registry. See Chapter\n9 for a more complete discussion of the use of object-oriented features.'),(0,a.kt)("h3",c({},{id:"part-families"}),"Part Families"),(0,a.kt)("h4",c({},{id:"guideline-21"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Create families of generic or other parts with similar\nspecifications.")),(0,a.kt)("h4",c({},{id:"example-18"}),"example"),(0,a.kt)("p",null,"The Booch parts (Booch 1987) are an example of the application of this\nguideline."),(0,a.kt)("h4",c({},{id:"rationale-21"}),"rationale"),(0,a.kt)("p",null,"Different versions of similar parts (e.g., bounded versus unbounded\nstacks) may be needed for different applications or to change the\nproperties of a given application. Often, the different behaviors\nrequired by these versions cannot be obtained using generic parameters.\nProviding a family of parts with similar specifications makes it easy\nfor the programmer to select the appropriate one for the current\napplication or to substitute a different one if the needs of the\napplication change."),(0,a.kt)("h4",c({},{id:"notes-8"}),"notes"),(0,a.kt)("p",null,"A reusable part that is structured from subparts that are members of\npart families is particularly easy to tailor to the needs of a given\napplication by substitution of family members."),(0,a.kt)("p",null,"Guideline 9.2.4 discusses the use of tagged types in building different\nversions of similar parts (i.e., common interface, multiple\nimplementations)."),(0,a.kt)("h3",c({},{id:"conditional-compilation"}),"Conditional Compilation"),(0,a.kt)("h4",c({},{id:"guideline-22"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Structure reusable code to take advantage of dead code removal by\nthe compiler.")),(0,a.kt)("h4",c({},{id:"example-19"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"------------------------------------------------------------------------\npackage Matrix_Math is\n   ...\n   type Algorithm is (Gaussian, Pivoting, Choleski, Tri_Diagonal);\n   generic\n      Which_Algorithm : in     Algorithm := Gaussian;\n   procedure Invert ( ... );\nend Matrix_Math;\n------------------------------------------------------------------------\npackage body Matrix_Math is\n   ...\n   ---------------------------------------------------------------------\n   procedure Invert ( ... ) is\n      ...\n   begin  -- Invert\n      case Which_Algorithm is\n         when Gaussian     => ... ;\n         when Pivoting     => ... ;\n         when Choleski     => ... ;\n         when Tri_Diagonal => ... ;\n      end case;\n   end Invert;\n   ---------------------------------------------------------------------\nend Matrix_Math;\n------------------------------------------------------------------------\n")),(0,a.kt)("h4",c({},{id:"rationale-22"}),"rationale"),(0,a.kt)("p",null,"Some compilers omit object code corresponding to parts of the program\nthat they detect can never be executed. Constant expressions in\nconditional statements take advantage of this feature where it is\navailable, providing a limited form of conditional compilation. When a\npart is reused in an implementation that does not support this form of\nconditional compilation, this practice produces a clean structure that\nis easy to adapt by deleting or commenting out redundant code where it\ncreates an unacceptable overhead."),(0,a.kt)("p",null,"This feature should be used when other factors prevent the code from\nbeing separated into separate program units. In the above example, it\nwould be preferable to have a different procedure for each algorithm.\nBut the algorithms may differ in slight but complex ways to make\nseparate procedures difficult to maintain."),(0,a.kt)("h4",c({},{id:"caution"}),"caution"),(0,a.kt)("p",null,"Be aware of whether your implementation supports dead code removal, and\nbe prepared to take other steps to eliminate the overhead of redundant\ncode if necessary."),(0,a.kt)("h3",c({},{id:"table-driven-programming"}),"Table-Driven Programming"),(0,a.kt)("h4",c({},{id:"guideline-23"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Write table-driven reusable parts wherever possible and appropriate.")),(0,a.kt)("h4",c({},{id:"example-20"}),"example"),(0,a.kt)("p",null,'The epitome of table-driven reusable software is a parser generation\nsystem. A specification of the form of the input data and of its output,\nalong with some specialization code, is converted to tables that are to\nbe "walked" by preexisting code using predetermined algorithms in the\nparser produced. Other forms of "application generators" work similarly.'),(0,a.kt)("h4",c({},{id:"rationale-23"}),"rationale"),(0,a.kt)("p",null,"Table-driven (sometimes known as data-driven) programs have behavior\nthat depends on data with'ed at compile time or read from a file at\nrun-time. In appropriate circumstances, table-driven programming\nprovides a very powerful way of creating general-purpose, easily\ntailorable, reusable parts."),(0,a.kt)("p",null,"See Guideline 5.3.4 for a short discussion of using access-to-subprogram\ntypes in implementing table-driven programs."),(0,a.kt)("h4",c({},{id:"notes-9"}),"notes"),(0,a.kt)("p",null,"Consider whether differences in the behavior of a general-purpose part\ncould be defined by some data structure at compile- or run-time, and if\nso, structure the part to be table-driven. The approach is most likely\nto be applicable when a part is designed for use in a particular\napplication domain but needs to be specialized for use in a specific\napplication within the domain. Take particular care in commenting the\nstructure of the data needed to drive the part."),(0,a.kt)("p",null,"Table-driven programs are often more efficient and easier to read than\nthe corresponding case or if-elsif-else networks to compute the item\nbeing sought or looked up."),(0,a.kt)("h3",c({},{id:"string-handling"}),"String Handling"),(0,a.kt)("h4",c({},{id:"guideline-24"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use the predefined packages for string handling.")),(0,a.kt)("h4",c({},{id:"example-21"}),"example"),(0,a.kt)("p",null,"Writing code such as the following is no longer necessary in Ada 95:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"function Upper_Case (S : String) return String is\n\n   subtype Lower_Case_Range is Character range 'a'..'z';\n\n   Temp : String := S;\n   Offset : constant := Character'Pos('A') - Character'Pos('a');\n\nbegin\n   for Index in Temp'Range loop\n      if Temp(Index) in Lower_Case_Range then\n         Temp(Index) := Character'Val (Character'Pos(Temp(Index)) + Offset);\n      end if;\n   end loop;\n   return Temp;\nend Upper_Case;\n\nwith Ada.Characters.Latin_1;\nfunction Trim (S : String) return String is\n   Left_Index  : Positive := S'First;\n   Right_Index : Positive := S'Last;\n   Space : constant Character := Ada.Characters.Latin_1.Space;\nbegin\n   while (Left_Index < S'Last) and then (S(Left_Index) = Space) loop\n      Left_Index := Positive'Succ(Left_Index);\n   end loop;\n\n   while (Right_Index > S'First) and then (S(Right_Index) = Space) loop\n      Right_Index := Positive'Pred(Right_Index);\n   end loop;\n\n   return S(Left_Index..Right_Index);\nend Trim;\n")),(0,a.kt)("p",null,"Assuming a variable S of type String, the following expression:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"Upper_Case(Trim(S))\n")),(0,a.kt)("p",null,"can now be replaced by more portable and preexisting language-defined\noperations such as:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Ada.Characters.Handling;  use Ada.Characters.Handling;\nwith Ada.Strings;              use Ada.Strings;\nwith Ada.Strings.Fixed;        use Ada.Strings.Fixed;\n\n...\nTo_Upper (Trim (Source => S, Side => Both))\n")),(0,a.kt)("h4",c({},{id:"rationale-24"}),"rationale"),(0,a.kt)("p",null,"The predefined Ada language environment includes string handling\npackages to encourage portability. They support different categories of\nstrings: fixed length, bounded length, and unbounded length. They also\nsupport subprograms for string construction, concatenation, copying,\nselection, ordering, searching, pattern matching, and string\ntransformation. You no longer need to define your own string handling\npackages."),(0,a.kt)("h3",c({},{id:"tagged-type-hierarchies"}),"Tagged Type Hierarchies"),(0,a.kt)("h4",c({},{id:"guideline-25"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consider using hierarchies of tagged types to promote generalization\nof software for reuse."),(0,a.kt)("li",{parentName:"ul"},"Consider using a tagged type hierarchy to decouple a generalized\nalgorithm from the details of dependency on specific types.")),(0,a.kt)("h4",c({},{id:"example-22"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"with Wage_Info;\npackage Personnel is\n   type Employee is abstract tagged limited private;\n   type Employee_Ptr is access all Employee'Class;\n   ...\n   procedure Compute_Wage (E : Employee) is abstract;\nprivate\n   type Employee is tagged limited record\n      Name  : ...;\n      SSN   : ... ;\n      Rates : Wage_Info.Tax_Info;\n      ...\n   end record;\nend Personnel;\npackage Personnel.Part_Time is\n   type Part_Timer is new Employee with private;\n   ...\n   procedure Compute_Wage (E : Part_Timer);\nprivate\n   ...\nend Personnel.Part_Time;\npackage Personnel.Full_Time is\n   type Full_Timer is new Employee with private;\n   ...\n   procedure Compute_Wage (E : Full_Timer);\nprivate\n   ...\nend Personnel.Full_Time;\n")),(0,a.kt)("p",null,"Given the following array declaration:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"type Employee_List is array (Positive range <>) of Personnel.Employee_Ptr;\n")),(0,a.kt)("p",null,"you can write a procedure that computes the wage of each employee,\nregardless of the different types of employees that you create. The\nEmployee_List consists of an array of pointers to the various kinds of\nemployees, each of which has an individual Compute_Wage procedure. (The\nprimitive Compute_Wage is declared as an abstract procedure and,\ntherefore, must be overridden by all descendants.) You will not need to\nmodify the payroll code as you specialize the kinds of employees:"),(0,a.kt)("pre",null,(0,a.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"procedure Compute_Payroll (Who : Employee_List) is\nbegin -- Compute_Payroll\n   for E in Who'Range loop\n      Compute_Wage (Who(E).all);\n   end loop;\nend Compute_Payroll;\n")),(0,a.kt)("h4",c({},{id:"rationale-25"}),"rationale"),(0,a.kt)("p",null,"The general algorithm can depend polymorphically on objects of the\nclass-wide type of the root tagged type without caring what specialized\ntypes are derived from the root type. The generalized algorithm does not\nneed to be changed if additional types are added to the type hierarchy.\nSee also Guideline 5.4.2. Furthermore, the child package hierarchy then\nmirrors the inheritance hierarchy."),(0,a.kt)("p",null,"A general root tagged type can define the common properties and have\ncommon operations for a hierarchy of more specific types. Software that\ndepends only on this root type will be general, in that it can be used\nwith objects of any of the more specific types. Further, the general\nalgorithms of clients of the root type do not have to be changed as more\nspecific types are added to the type hierarchy. This is a particularly\neffective way to organize object-oriented software for reuse."),(0,a.kt)("p",null,"Separating the hierarchy of derived tagged types into individual\npackages enhances reusability by reducing the number of items in package\ninterfaces. It also allows you to with only the capabilities needed."),(0,a.kt)("p",null,"See also Guidelines 9.2, 9.3.1, 9.3.5, and 9.4.1."),(0,a.kt)("h2",c({},{id:"summary"}),"Summary"),(0,a.kt)("h3",c({},{id:"understanding-and-clarity-1"}),"understanding and clarity"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Select the least restrictive names possible for reusable parts and\ntheir identifiers."),(0,a.kt)("li",{parentName:"ul"},"Select the generic name to avoid conflicting with the naming\nconventions of instantiations of the generic."),(0,a.kt)("li",{parentName:"ul"},"Use names that indicate the behavioral characteristics of the\nreusable part, as well as its abstraction ."),(0,a.kt)("li",{parentName:"ul"},"Do not use abbreviations in identifier or unit names."),(0,a.kt)("li",{parentName:"ul"},"Document the expected behavior of generic formal parameters just as\nyou document any package specification.")),(0,a.kt)("h3",c({},{id:"robustness-1"}),"robustness"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use named numbers and static expressions to allow multiple\ndependencies to be linked to a small number of symbols."),(0,a.kt)("li",{parentName:"ul"},"Use unconstrained array types for array formal parameters and array\nreturn values."),(0,a.kt)("li",{parentName:"ul"},"Make the size of local variables depend on actual parameter size,\nwhere appropriate."),(0,a.kt)("li",{parentName:"ul"},"Minimize the number of assumptions made by a unit."),(0,a.kt)("li",{parentName:"ul"},"For assumptions that cannot be avoided, use subtypes or constraints\nto automatically enforce conformance."),(0,a.kt)("li",{parentName:"ul"},"For assumptions that cannot be automatically enforced by subtypes,\nadd explicit checks to the code."),(0,a.kt)("li",{parentName:"ul"},"Document all assumptions."),(0,a.kt)("li",{parentName:"ul"},"If the code depends upon the implementation of a specific Special\nNeeds Annex for proper operation, document this assumption in the\ncode."),(0,a.kt)("li",{parentName:"ul"},"Use first subtypes when declaring generic formal objects of mode in\nout."),(0,a.kt)("li",{parentName:"ul"},"Beware of using subtypes as subtype marks when declaring parameters\nor return values of generic formal subprograms."),(0,a.kt)("li",{parentName:"ul"},"Use attributes rather than literal values."),(0,a.kt)("li",{parentName:"ul"},"Be careful about overloading the names of subprograms exported by\nthe same generic package."),(0,a.kt)("li",{parentName:"ul"},"Within a specification, document any tasks that would be activated\nby with'ing the specification and by using any part of the\nspecification."),(0,a.kt)("li",{parentName:"ul"},"Document which generic formal parameters are accessed from a task\nhidden inside the generic unit."),(0,a.kt)("li",{parentName:"ul"},"Document any multithreaded components."),(0,a.kt)("li",{parentName:"ul"},"Propagate exceptions out of reusable parts. Handle exceptions within\nreusable parts only when you are certain that the handling is\nappropriate in all circumstances."),(0,a.kt)("li",{parentName:"ul"},"Propagate exceptions raised by generic formal subprograms after\nperforming any cleanup necessary to the correct operation of future\ninvocations of the generic instantiation."),(0,a.kt)("li",{parentName:"ul"},"Leave state variables in a valid state when raising an exception."),(0,a.kt)("li",{parentName:"ul"},"Leave parameters unmodified when raising an exception.")),(0,a.kt)("h3",c({},{id:"adaptability-1"}),"adaptability"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provide core functionality in a reusable part or set of parts so\nthat the functionality in this abstraction can be meaningfully\nextended by its reusers."),(0,a.kt)("li",{parentName:"ul"},"More specifically, provide initialization and finalization\nprocedures for every data structure that may contain dynamic data."),(0,a.kt)("li",{parentName:"ul"},"For data structures needing initialization and finalization,\nconsider deriving them, when possible, from the types\nAda.Finalization.Controlled or Ada.Finalization.Limited_Controlled."),(0,a.kt)("li",{parentName:"ul"},"Use generic units to avoid code duplication."),(0,a.kt)("li",{parentName:"ul"},"Parameterize generic units for maximum adaptability."),(0,a.kt)("li",{parentName:"ul"},"Reuse common instantiations of generic units, as well as the generic\nunits themselves."),(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private type for a generic formal type when\nyou do not need assignment on objects of the type inside the generic\nbody."),(0,a.kt)("li",{parentName:"ul"},"Consider using a nonlimited private type for a generic formal type\nwhen you need normal assignment on objects of the type inside the\nbody of the generic."),(0,a.kt)("li",{parentName:"ul"},"Consider using a formal tagged type derived from\nAda.Finalization.Controlled when you need to enforce special\nassignment semantics on objects of the type in the body of the\ngeneric."),(0,a.kt)("li",{parentName:"ul"},"Export the least restrictive type that maintains the integrity of\nthe data and abstraction while allowing alternate implementations."),(0,a.kt)("li",{parentName:"ul"},"Consider using a limited private abstract type for generic formal\ntypes of a generic that extends a formal private tagged type."),(0,a.kt)("li",{parentName:"ul"},"Use generic units to encapsulate algorithms independently of data\ntype."),(0,a.kt)("li",{parentName:"ul"},"Consider using abstract data types (not to be confused with Ada's\nabstract types) in preference to abstract data objects."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic units to implement abstract data types\nindependently of their component data type."),(0,a.kt)("li",{parentName:"ul"},"Provide iterators for traversing complex data structures within\nreusable parts."),(0,a.kt)("li",{parentName:"ul"},"Consider providing both active and passive iterators."),(0,a.kt)("li",{parentName:"ul"},"Protect the iterators from errors due to modification of the data\nstructure during iteration."),(0,a.kt)("li",{parentName:"ul"},"Document the behavior of the iterators when the data structure is\nmodified during traversal."),(0,a.kt)("li",{parentName:"ul"},"Localize the currency symbol, digits separator, radix mark, and fill\ncharacter in picture output."),(0,a.kt)("li",{parentName:"ul"},"Consider using the ","#"," character in picture layouts so that the\nedited numeric output lengths are invariant across currency symbols\nof different lengths."),(0,a.kt)("li",{parentName:"ul"},'Consider using abstract tagged types and generics to define reusable\nunits of functionality that can be "mixed into" core abstractions\n(also known as mixins).'),(0,a.kt)("li",{parentName:"ul"},"Consider structuring subsystems so that operations that are only\nused in a particular context are in different child packages than\noperations used in a different context."),(0,a.kt)("li",{parentName:"ul"},"Consider declaring context-independent functionality in the parent\npackage and context-dependent functionality in child packages.")),(0,a.kt)("h3",c({},{id:"independence-1"}),"independence"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize with clauses on reusable parts, especially on their\nspecifications."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic parameters instead of with statements to\nreduce the number of context clauses on a reusable part."),(0,a.kt)("li",{parentName:"ul"},"Consider using generic formal package parameters to import directly\nall the types and operations defined in an instance of a preexisting\ngeneric."),(0,a.kt)("li",{parentName:"ul"},"In the specification of a generic library unit, use pragma\nElaborate_Body."),(0,a.kt)("li",{parentName:"ul"},"Create families of generic or other parts with similar\nspecifications."),(0,a.kt)("li",{parentName:"ul"},"Structure reusable code to take advantage of dead code removal by\nthe compiler."),(0,a.kt)("li",{parentName:"ul"},"Write table-driven reusable parts wherever possible and appropriate."),(0,a.kt)("li",{parentName:"ul"},"Use the predefined packages for string handling."),(0,a.kt)("li",{parentName:"ul"},"Consider using hierarchies of tagged types to promote generalization\nof software for reuse."),(0,a.kt)("li",{parentName:"ul"},"Consider using a tagged type hierarchy to decouple a generalized\nalgorithm from the details of dependency on specific types.")),(0,a.kt)("admonition",c({},{type:"note"}),(0,a.kt)("p",{parentName:"admonition"},'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,a.kt)("a",c({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,a.kt)("a",c({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work.")))}b.isMDXComponent=!0}}]);