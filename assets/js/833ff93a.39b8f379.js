"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[2079],{6932:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>k,default:()=>b,frontMatter:()=>h,metadata:()=>f,toc:()=>_});var r=n(1716),a=n(7556),i=n(9464),o=Object.defineProperty,l=Object.defineProperties,s=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,p=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,m=(e,t)=>{for(var n in t||(t={}))c.call(t,n)&&p(e,n,t[n]);if(u)for(var n of u(t))d.call(t,n)&&p(e,n,t[n]);return e};const h={sidebar_position:140},k="B.3 Interfacing with C and C++",f={unversionedId:"arm/AA-B/AA-B.3",id:"arm/AA-B/AA-B.3",title:"B.3 Interfacing with C and C++",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-B/AA-B.3.mdx",sourceDirName:"arm/AA-B",slug:"/arm/AA-B/AA-B.3",permalink:"/docs/arm/AA-B/AA-B.3",draft:!1,tags:[],version:"current",sidebarPosition:140,frontMatter:{sidebar_position:140},sidebar:"referenceManualSidebar",previous:{title:"B.2 The Package Interfaces",permalink:"/docs/arm/AA-B/AA-B.2"},next:{title:"B.4 Interfacing with COBOL",permalink:"/docs/arm/AA-B/AA-B.4"}},y={},_=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"B.3.1  The Package Interfaces.C.Strings",id:"b31--the-package-interfacescstrings",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"B.3.2  The Generic Package Interfaces.C.Pointers",id:"b32--the-generic-package-interfacescpointers",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Erroneous Execution",id:"erroneous-execution-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"B.3.3  Unchecked Union Types",id:"b33--unchecked-union-types",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-2",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4}],g={toc:_};function b(e){var t,n=e,{components:o}=n,p=((e,t)=>{var n={};for(var r in e)c.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&u)for(var r of u(e))t.indexOf(r)<0&&d.call(e,r)&&(n[r]=e[r]);return n})(n,["components"]);return(0,r.kt)("wrapper",(t=m(m({},g),p),l(t,s({components:o,mdxType:"MDXLayout"}))),(0,r.kt)("h1",m({},{id:"b3-interfacing-with-c-and-c"}),"B.3 Interfacing with C and C++"),(0,r.kt)("admonition",m({},{type:"warning"}),(0,r.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.kt)("a",m({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-00376-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,r.kt)("em",null,"AI12-0028-1"),"}"," ",(0,r.kt)("br",null),"The facilities relevant to interfacing with the C language and the corresponding subset of the C++ language are the package Interfaces.C and its children, and support for specifying the Convention aspect with ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s C, C_Pass_By_Copy, and any of the C_Variadic_",(0,r.kt)("em",null,"n")," conventions described below.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00376-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-0262-1"),"}"," ","{",(0,r.kt)("em",null,"AI95-0299-1"),"}"," ",(0,r.kt)("br",null),"The package Interfaces.C contains the basic types, constants, and subprograms that allow an Ada program to pass scalars and strings to C and C++ functions. When this subclause mentions a C entity, the reference also applies to the corresponding entity in C++. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"static-semantics"}),"Static Semantics"),(0,r.kt)("p",null,"The library package Interfaces.C has the following declaration: ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI12-0414-1","}","\n"," package Interfaces.C","\n","   with Pure is","\n","-- Declarations based on C's ","<","limits.h",">","\n","CHAR_BIT  : constant := implementation-defined;  -- typically 8","\n","   SCHAR_MIN : constant := implementation-defined;  -- typically 128","\n","   SCHAR_MAX : constant := implementation-defined;  -- typically 127","\n","   UCHAR_MAX : constant := implementation-defined;  -- typically 255","\n","-- Signed and Unsigned Integers","\n","   type int   is range implementation-defined;","\n","   type short is range implementation-defined;","\n","   type long  is range implementation-defined;","\n","type signed_char is range SCHAR_MIN .. SCHAR_MAX;","\n","   for signed_char'Size use CHAR_BIT;","\n","type unsigned       is mod implementation-defined;","\n","   type unsigned_short is mod implementation-defined;","\n","   type unsigned_long  is mod implementation-defined;","\n","type unsigned_char is mod (UCHAR_MAX+1);","\n","   for unsigned_char'Size use CHAR_BIT;","\n","subtype plain_char is implementation-defined;","\n","type ptrdiff_t is range implementation-defined;","\n","type size_t is mod implementation-defined;","\n","--  ","{","AI12-0411-1","}","\n","    -- Boolean Type","\n","   type C_bool is new Boolean;","\n","-- Floating Point","\n","type C_float     is digits implementation-defined;","\n","type double      is digits implementation-defined;","\n","type long_double is digits implementation-defined;","\n","-- Characters and Strings ","\n","type char is ","<","implementation-defined character type",">",";","\n","{","8652/0060","}"," --  ","{","AI95-00037-01","}","\n","    nul : constant char := implementation-defined;","\n","function To_C   (Item : in Character) return char;","\n","function To_Ada (Item : in char) return Character;","\n","--  ","{","AI05-0229-1","}","\n"," --  ","{","AI05-0269-1","}","\n","    type char_array is array (size_t range ","<",">",") of aliased char","\n","      with Pack;","\n","   for char_array'Component_Size use CHAR_BIT;","\n","function Is_Nul_Terminated (Item : in char_array) return Boolean;","\n","function To_C   (Item       : in String;","\n","                    Append_Nul : in Boolean := True)","\n","      return char_array;","\n","function To_Ada (Item     : in char_array;","\n","                    Trim_Nul : in Boolean := True)","\n","      return String;","\n","procedure To_C (Item       : in  String;","\n","                   Target     : out char_array;","\n","                   Count      : out size_t;","\n","                   Append_Nul : in  Boolean := True);","\n","procedure To_Ada (Item     : in  char_array;","\n","                     Target   : out String;","\n","                     Count    : out Natural;","\n","                     Trim_Nul : in  Boolean := True);","\n","-- Wide Character and Wide String","\n","{","8652/0060","}"," --  ","{","AI95-00037-01","}","\n","    type wchar_t is ","<","implementation-defined character type",">",";","\n","{","8652/0060","}"," --  ","{","AI95-00037-01","}","\n","    wide_nul : constant wchar_t := implementation-defined;","\n","function To_C   (Item : in Wide_Character) return wchar_t;","\n","   function To_Ada (Item : in wchar_t       ) return Wide_Character;","\n","--  ","{","AI05-0229-1","}","\n","    type wchar_array is array (size_t range ","<",">",") of aliased wchar_t","\n","      with Pack;","\n","This paragraph was deleted.--  ","{","AI05-0229-1","}","\n"," ","\n","function Is_Nul_Terminated (Item : in wchar_array) return Boolean;","\n","function To_C   (Item       : in Wide_String;","\n","                    Append_Nul : in Boolean := True)","\n","      return wchar_array;","\n","function To_Ada (Item     : in wchar_array;","\n","                    Trim_Nul : in Boolean := True)","\n","      return Wide_String;","\n","procedure To_C (Item       : in  Wide_String;","\n","                   Target     : out wchar_array;","\n","                   Count      : out size_t;","\n","                   Append_Nul : in  Boolean := True);","\n","procedure To_Ada (Item     : in  wchar_array;","\n","                     Target   : out Wide_String;","\n","                     Count    : out Natural;","\n","                     Trim_Nul : in  Boolean := True);","\n","--  ","{","AI95-00285-01","}","\n","    -- ISO/IEC 10646:2003 compatible types defined by ISO/IEC TR 19769:2004.","\n","--  ","{","AI95-00285-01","}","\n","    type char16_t is ","<","implementation-defined character type",">",";","\n","char16_nul : constant char16_t := implementation-defined;","\n","function To_C (Item : in Wide_Character) return char16_t;","\n","   function To_Ada (Item : in char16_t) return Wide_Character;","\n","--  ","{","AI05-0229-1","}","\n","    type char16_array is array (size_t range ","<",">",") of aliased char16_t","\n","      with Pack;","\n","This paragraph was deleted.--  ","{","AI05-0229-1","}","\n"," ","\n","function Is_Nul_Terminated (Item : in char16_array) return Boolean;","\n","   function To_C (Item       : in Wide_String;","\n","                  Append_Nul : in Boolean := True)","\n","      return char16_array;","\n","function To_Ada (Item     : in char16_array;","\n","                    Trim_Nul : in Boolean := True)","\n","      return Wide_String;","\n","procedure To_C (Item       : in  Wide_String;","\n","                   Target     : out char16_array;","\n","                   Count      : out size_t;","\n","                   Append_Nul : in  Boolean := True);","\n","procedure To_Ada (Item     : in  char16_array;","\n","                     Target   : out Wide_String;","\n","                     Count    : out Natural;","\n","                     Trim_Nul : in  Boolean := True);","\n","--  ","{","AI95-00285-01","}","\n","    type char32_t is ","<","implementation-defined character type",">",";","\n","char32_nul : constant char32_t := implementation-defined;","\n","function To_C (Item : in Wide_Wide_Character) return char32_t;","\n","   function To_Ada (Item : in char32_t) return Wide_Wide_Character;","\n","--  ","{","AI05-0229-1","}","\n","    type char32_array is array (size_t range ","<",">",") of aliased char32_t","\n","      with Pack;","\n","This paragraph was deleted.--  ","{","AI05-0229-1","}","\n"," ","\n","function Is_Nul_Terminated (Item : in char32_array) return Boolean;","\n","   function To_C (Item       : in Wide_Wide_String;","\n","                  Append_Nul : in Boolean := True)","\n","      return char32_array;","\n","function To_Ada (Item     : in char32_array;","\n","                    Trim_Nul : in Boolean := True)","\n","      return Wide_Wide_String;","\n","procedure To_C (Item       : in  Wide_Wide_String;","\n","                   Target     : out char32_array;","\n","                   Count      : out size_t;","\n","                   Append_Nul : in  Boolean := True);","\n","procedure To_Ada (Item     : in  char32_array;","\n","                     Target   : out Wide_Wide_String;","\n","                     Count    : out Natural;","\n","                     Trim_Nul : in  Boolean := True);","\n","Terminator_Error : exception;","\n","end Interfaces.C;","\n"),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The definitions of certain types and constants in Interfaces.C.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Each of the types declared in Interfaces.C is C-compatible.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,r.kt)("em",null,"AI12-0411-1"),"}"," ",(0,r.kt)("br",null),"The types int, short, long, unsigned, ptrdiff_t, size_t, double, char, wchar_t, char16_t, and char32_t correspond respectively to the C types having the same names. The types signed_char, unsigned_short, unsigned_long, unsigned_char, C_bool, C_float, and long_double correspond respectively to the C types signed char, unsigned short, unsigned long, unsigned char, bool,  float, and long double.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The C types wchar_t and char16_t seem to be the same. However, wchar_t has an implementation-defined size, whereas char16_t is guaranteed to be an unsigned type of at least 16 bits. Also, char16_t and char32_t are encouraged to have UTF-16 and UTF-32 representations; that means that they are not directly the same as the Ada types, which most likely don't use any UTF encoding. ",(0,r.kt)("br",null)),(0,r.kt)("p",null,"The type of the subtype plain_char is either signed_char or unsigned_char, depending on the C implementation. ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C   (Item : in Character) return char;","\n","function To_Ada (Item : in char     ) return Character;","\n"),(0,r.kt)("p",null,"The functions To_C and To_Ada map between the Ada type Character and the C type char.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"{",(0,r.kt)("em",null,"8652/0114"),"}"," ","{",(0,r.kt)("em",null,"AI95-00038-01"),"}"," ",(0,r.kt)("br",null),"The To_C and To_Ada functions map between corresponding characters, not necessarily between characters with the same internal representation. Corresponding characters are characters defined by the same enumeration literal, if such exist; otherwise, the correspondence is unspecified.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The following definition is equivalent to the above summary:",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"To_C (Latin_1_Char) = char'Value(Character'Image(Latin_1_Char))",(0,r.kt)("br",null),"provided that char'Value does not raise an exception; otherwise the result is unspecified.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"To_Ada (Native_C_Char) = Character'Value(char'Image(Native_C_Char))",(0,r.kt)("br",null),"provided that Character'Value does not raise an exception; otherwise the result is unspecified. ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Is_Nul_Terminated (Item : in char_array) return Boolean;","\n"),(0,r.kt)("p",null,"The result of Is_Nul_Terminated is True if Item contains nul, and is False otherwise.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C   (Item : in String;     Append_Nul : in Boolean := True)","\n","   return char_array;","\n","\n","function To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True)","\n","   return String;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00258-01"),"}"," ",(0,r.kt)("br",null),"The result of To_C is a char_array value of length Item'Length (if Append_Nul is False) or Item'Length+1 (if Append_Nul is True). The lower bound is 0. For each component Item(I), the corresponding component in the result is To_C applied to Item(I). The value nul is appended if Append_Nul is True. If Append_Nul is False and Item'Length is 0, then To_C propagates Constraint_Error.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"The result of To_Ada is a String whose length is Item'Length (if Trim_Nul is False) or the length of the slice of Item preceding the first nul (if Trim_Nul is True). The lower bound of the result is 1. If Trim_Nul is False, then for each component Item(I) the corresponding component in the result is To_Ada applied to Item(I). If Trim_Nul is True, then for each component Item(I) before the first nul the corresponding component in the result is To_Ada applied to Item(I). The function propagates Terminator_Error if Trim_Nul is True and Item does not contain nul.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure To_C (Item       : in  String;","\n","                Target     : out char_array;","\n","                Count      : out size_t;","\n","                Append_Nul : in  Boolean := True);","\n","\n","procedure To_Ada (Item     : in  char_array;","\n","                  Target   : out String;","\n","                  Count    : out Natural;","\n","                  Trim_Nul : in  Boolean := True);","\n"),(0,r.kt)("p",null,"For procedure To_C, each element of Item is converted (via the To_C function) to a char, which is assigned to the corresponding element of Target. If Append_Nul is True, nul is then assigned to the next element of Target. In either case, Count is set to the number of Target elements assigned. If Target is not long enough, Constraint_Error is propagated.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"For procedure To_Ada, each element of Item (if Trim_Nul is False) or each element of Item preceding the first nul (if Trim_Nul is True) is converted (via the To_Ada function) to a Character, which is assigned to the corresponding element of Target. Count is set to the number of Target elements assigned. If Target is not long enough, Constraint_Error is propagated. If Trim_Nul is True and Item does not contain nul, then Terminator_Error is propagated.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Is_Nul_Terminated (Item : in wchar_array) return Boolean;","\n"),(0,r.kt)("p",null,"The result of Is_Nul_Terminated is True if Item contains wide_nul, and is False otherwise.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C   (Item : in Wide_Character) return wchar_t;","\n","function To_Ada (Item : in wchar_t       ) return Wide_Character;","\n"),(0,r.kt)("p",null,"To_C and To_Ada provide the mappings between the Ada and C wide character types.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C   (Item       : in Wide_String;","\n","                 Append_Nul : in Boolean := True)","\n","   return wchar_array;","\n","\n","function To_Ada (Item     : in wchar_array;","\n","                 Trim_Nul : in Boolean := True)","\n","   return Wide_String;","\n","\n","procedure To_C (Item       : in  Wide_String;","\n","                Target     : out wchar_array;","\n","                Count      : out size_t;","\n","                Append_Nul : in  Boolean := True);","\n","\n","procedure To_Ada (Item     : in  wchar_array;","\n","                  Target   : out Wide_String;","\n","                  Count    : out Natural;","\n","                  Trim_Nul : in  Boolean := True);","\n"),(0,r.kt)("p",null,"The To_C and To_Ada subprograms that convert between Wide_String and wchar_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that wide_nul is used instead of nul.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Is_Nul_Terminated (Item : in char16_array) return Boolean;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"The result of Is_Nul_Terminated is True if Item contains char16_nul, and is False otherwise.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C (Item : in Wide_Character) return char16_t;","\n","function To_Ada (Item : in char16_t ) return Wide_Character;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"To_C and To_Ada provide mappings between the Ada and C 16-bit character types.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C (Item       : in Wide_String;","\n","               Append_Nul : in Boolean := True)","\n","   return char16_array;","\n","\n","function To_Ada (Item     : in char16_array;","\n","                 Trim_Nul : in Boolean := True)","\n","   return Wide_String;","\n","\n","procedure To_C (Item       : in  Wide_String;","\n","                Target     : out char16_array;","\n","                Count      : out size_t;","\n","                Append_Nul : in  Boolean := True);","\n","\n","procedure To_Ada (Item     : in  char16_array;","\n","                  Target   : out Wide_String;","\n","                  Count    : out Natural;","\n","                  Trim_Nul : in  Boolean := True);","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"The To_C and To_Ada subprograms that convert between Wide_String and char16_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that char16_nul is used instead of nul.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Is_Nul_Terminated (Item : in char32_array) return Boolean;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,r.kt)("em",null,"AI12-0437-1"),"}"," ",(0,r.kt)("br",null),"The result of Is_Nul_Terminated is True if Item contains char32_nul, and is False otherwise.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C (Item : in Wide_Wide_Character) return char32_t;","\n","function To_Ada (Item : in char32_t ) return Wide_Wide_Character;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"To_C and To_Ada provide mappings between the Ada and C 32-bit character types.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_C (Item       : in Wide_Wide_String;","\n","               Append_Nul : in Boolean := True)","\n","   return char32_array;","\n","\n","function To_Ada (Item     : in char32_array;","\n","                 Trim_Nul : in Boolean := True)","\n","   return Wide_Wide_String;","\n","\n","procedure To_C (Item       : in  Wide_Wide_String;","\n","                Target     : out char32_array;","\n","                Count      : out size_t;","\n","                Append_Nul : in  Boolean := True);","\n","\n","procedure To_Ada (Item     : in  char32_array;","\n","                  Target   : out Wide_Wide_String;","\n","                  Count    : out Natural;","\n","                  Trim_Nul : in  Boolean := True);","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"The To_C and To_Ada subprograms that convert between Wide_Wide_String and char32_array have analogous effects to the To_C and To_Ada subprograms that convert between String and char_array, except that char32_nul is used instead of nul.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The Interfaces.C package provides an implementation-defined character type, char, designed to model the C run-time character set, and mappings between the types char and Character.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"One application of the C interface package is to compose a C string and pass it to a C function. One way to do this is for the programmer to declare an object that will hold the C array, and then pass this array to the C function. This is realized via the type char_array: ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"type char_array is array (size_t range ","<",">",") of Char;","\n"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The programmer can declare an Ada String, convert it to a char_array, and pass the char_array as actual parameter to the C function that is expecting a char *.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"An alternative approach is for the programmer to obtain a C char pointer from an Ada String (or from a char_array) by invoking an allocation function. The package Interfaces.C.Strings (see below) supplies the needed facilities, including a private type chars_ptr that corresponds to C's char *, and two allocation functions. To avoid storage leakage, a Free procedure releases the storage that was allocated by one of these allocate functions.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"It is typical for a C function that deals with strings to adopt the convention that the string is delimited by a nul char. The C interface packages support this convention. A constant nul of type Char is declared, and the function Value(Chars_Ptr) in Interfaces.C.Strings returns a char_array up to and including the first nul in the array that the chars_ptr points to. The Allocate_Chars function allocates an array that is nul terminated.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Some C functions that deal with strings take an explicit length as a parameter, thus allowing strings to be passed that contain nul as a data element. Other C functions take an explicit length that is an upper bound: the prefix of the string up to the char before nul, or the prefix of the given length, is used by the function, whichever is shorter. The C Interface packages support calling such functions. ",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),"The Convention aspect with ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," C_Pass_By_Copy shall only be specified for a type.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"The eligibility rules in B.1 do not apply to convention C_Pass_By_Copy. Instead, a type T is eligible for convention C_Pass_By_Copy if T is an unchecked union type or if T is a record type that has no discriminants and that only has components with statically constrained subtypes, and each component is C-compatible.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0264-1"),"}"," ",(0,r.kt)("br",null),"If a type is C_Pass_By_Copy-compatible, then it is also C-compatible.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI12-0028-1"),"}"," ",(0,r.kt)("br",null),"The identifiers C_Variadic_0, C_Variadic_1, C_Variadic_2, and so on are ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s. These conventions are said to be ",(0,r.kt)("em",null,"C_Variadic"),". The convention C_Variadic_",(0,r.kt)("em",null,"n")," is the calling convention for a variadic C function taking ",(0,r.kt)("em",null,"n")," fixed parameters and then a variable number of additional parameters. The C_Variadic_",(0,r.kt)("em",null,"n")," convention shall only be specified as the convention aspect for a subprogram, or for an access-to-subprogram type, having at least ",(0,r.kt)("em",null,"n")," parameters. A type is compatible with a C_Variadic convention if and only if the type is C-compatible.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,r.kt)("strong",null,"To be honest: "),"It is implementation defined what the largest ",(0,r.kt)("em",null,"n")," in C_Variadic_",(0,r.kt)("em",null,"n")," is supported. We don't say this because it complicates the wording and it is true for almost any ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," (only Ada is required to be supported by the language, all others need to be documented in order for programmers to know that they are available). ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"implementation-requirements"}),"Implementation Requirements"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),"An implementation shall support specifying aspect Convention with a C ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for a C-eligible type (see B.1). An implementation shall support specifying aspect Convention with a C_Pass_By_Copy ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for a C_Pass_By_Copy-eligible type. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,r.kt)("p",null,"An implementation may provide additional declarations in the C interface packages.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,r.kt)("em",null,"AI12-0444-1"),"}"," ",(0,r.kt)("br",null),"An implementation is not required to support specifying the Convention aspect with ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," C in the following cases:",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI05-0248-1"),"}"," ",(0,r.kt)("br",null),"for a subprogram that has a parameter of an unconstrained array subtype, unless the Import aspect has the value True for the subprogram;",(0,r.kt)("br",null)),(0,r.kt)("li",null,"for a function with an unconstrained array result subtype;",(0,r.kt)("br",null)),(0,r.kt)("li",null,"for an object whose nominal subtype is an unconstrained array subtype. ",(0,r.kt)("br",null))),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ",(0,r.kt)("br",null),"These rules ensure that an implementation never needs to create bounds for an unconstrained array that originates in C (and thus does not have bounds). An implementation can do so if it wishes, of course. Note that these permissions do not extend to passing an unconstrained array as a parameter to a C function; in this case, the bounds can simply be dropped and thus support is required. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"implementation-advice"}),"Implementation Advice"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0060"),"}"," ","{",(0,r.kt)("em",null,"AI95-00037-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ",(0,r.kt)("br",null),"The constants nul, wide_nul, char16_nul, and char32_nul should have a representation of zero. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},(0,r.kt)("strong",null),"The constants nul, wide_nul, char16_nul, and char32_nul in package Interfaces.C should have a representation of zero.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"An implementation should support the following interface correspondences between Ada and C. ",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"An Ada procedure corresponds to a void-returning C function. ",(0,r.kt)("br",null))),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The programmer can also choose an Ada procedure when the C function returns an int that is to be discarded.",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"An Ada function corresponds to a non-void C function.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI12-0135-1"),"}"," ",(0,r.kt)("br",null),"An Ada enumeration type corresponds to a C enumeration type with corresponding enumeration literals having the same internal codes, provided the internal codes fall within the range of the C int type.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"An Ada ",(0,r.kt)("strong",null,"in")," scalar parameter is passed as a scalar argument to a C function.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"An Ada ",(0,r.kt)("strong",null,"in")," parameter of an access-to-object type with designated type T is passed as a t* argument to a C function, where t is the C type corresponding to the Ada type T.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"An Ada ",(0,r.kt)("strong",null,"access")," T parameter, or an Ada ",(0,r.kt)("strong",null,"out")," or ",(0,r.kt)("strong",null,"in out")," parameter of an elementary type T, is passed as a t* argument to a C function, where t is the C type corresponding to the Ada type T. In the case of an elementary ",(0,r.kt)("strong",null,"out")," or ",(0,r.kt)("strong",null,"in out")," parameter, a pointer to a temporary copy is used to preserve by-copy semantics.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-00343-01"),"}"," ",(0,r.kt)("br",null),"An Ada parameter of a (record) type T of convention C_Pass_By_Copy, of mode ",(0,r.kt)("strong",null,"in"),", is passed as a t argument to a C function, where t is the C struct corresponding to the Ada type T.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ","{",(0,r.kt)("em",null,"AI95-00343-01"),"}"," ","{",(0,r.kt)("em",null,"AI12-0219-1"),"}"," ",(0,r.kt)("br",null),"An Ada parameter of a record type T, other than an ",(0,r.kt)("strong",null,"in")," parameter of a type of convention C_Pass_By_Copy, is passed as a t* argument to a C function, with the const modifier if the Ada mode is ",(0,r.kt)("strong",null,"in"),", where t is the C struct corresponding to the Ada type T.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI12-0219-1"),"}"," ",(0,r.kt)("br",null),"An Ada parameter of an array type with component type T is passed as a t* argument to a C function, with the const modifier if the Ada mode is ",(0,r.kt)("strong",null,"in"),", where t is the C type corresponding to the Ada type T.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"An Ada parameter of an access-to-subprogram type is passed as a pointer to a C function whose prototype corresponds to the designated subprogram's specification.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ",(0,r.kt)("br",null),"An Ada parameter of a private type is passed as specified for the full view of the type.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ",(0,r.kt)("br",null),"The rules of correspondence given above for parameters of mode ",(0,r.kt)("strong",null,"in")," also apply to the return object of a function.",(0,r.kt)("br",null))),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00337-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ","{",(0,r.kt)("em",null,"AI12-0184-1"),"}"," ",(0,r.kt)("br",null),"An implementation should provide unsigned_long_long and long_long as 64-bit modular and signed integer types (respectively) in package Interfaces.C if the C implementation supports unsigned long long and long long as 64-bit types.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},(0,r.kt)("strong",null),"If C interfacing is supported, the interface correspondences between Ada and C should be supported.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},(0,r.kt)("strong",null),"If the C implementation supports unsigned long long and long long, unsigned_long_long and long_long should be supported.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 1   Values of type char_array are not implicitly terminated with nul. If a char_array is to be passed as a parameter to an imported C function requiring nul termination, it is the programmer's responsibility to obtain this effect.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 2   To obtain the effect of C's sizeof(item_type), where Item_Type is the corresponding Ada type, evaluate the expression: size_t(Item_Type'Size/CHAR_BIT).",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,r.kt)("em",null,"This paragraph was deleted."),"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 3   ","{",(0,r.kt)("em",null,"AI12-0028-1"),"}"," ",(0,r.kt)("br",null),"A variadic C function can correspond to several Ada subprograms, taking various specific numbers and types of parameters. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"examples"}),"Examples"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI12-0312-1"),"}"," ",(0,r.kt)("em",null,(0,r.kt)("br",null),"Example of using the Interfaces.C package:")," ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"--Calling the C Library Functions strcpy and printf","\n","with Interfaces.C;","\n","procedure Test is","\n","   package C renames Interfaces.C;","\n","   use type C.char_array;","\n","   -- Call ","<","string.h",">","strcpy:","\n","   -- C definition of strcpy:  char *strcpy(char *s1, const char *s2);","\n","   --    This function copies the string pointed to by s2 (including the terminating null character)","\n","   --     into the array pointed to by s1. If copying takes place between objects that overlap,","\n","   --     the behavior is undefined. The strcpy function returns the value of s1.","\n","--  ","{","AI05-0229-1","}","\n","    -- ","\n","   procedure Strcpy (Target : out C.char_array;","\n","                     Source : in  C.char_array)","\n","      with Import =",">"," True, Convention =",">"," C, External_Name =",">",' "strcpy";',"\n","--  ","{","AI05-0229-1","}","\n"," --  ","{","AI12-0312-1","}","\n","    -- Call ","<","sdtio.h",">","printf:","\n","   -- C definition of printf:  int printf ( const char * format, ... );","\n","   --    This function writes the C string pointed by format to the standard output (stdout).","\n","   --     If format includes format specifiers (subsequences beginning with %), the additional","\n","   --     arguments following format are formatted and inserted in the resulting string","\n","   --     replacing their respective specifiers. If the number of arguments does not match","\n","   --     the number of format specifiers, or if the types of the arguments do not match","\n","   --     the corresponding format specifier, the behaviour is undefined. On success, the","\n","   --     printf function returns the total number of characters written to the standard output.","\n","   --     If a writing error occurs, a negative number is returned.","\n","--  ","{","AI12-0312-1","}","\n","    -- ","\n","   procedure Printf (Format : in C.char_array;","\n","                     Param1 : in C.char_array;","\n","                     Param2 : in C.int)","\n","      with Import =",">"," True, Convention =",">"," C_Variadic_1, External_Name =",">",' "printf";',"\n","Chars1 :  C.char_array(1..20);","\n","   Chars2 :  C.char_array(1..20);","\n","begin","\n",'   Chars2(1..6) := "qwert" & C.nul;',"\n","Strcpy(Chars1, Chars2);","\n",'-- Now Chars1(1..6) = "qwert" & C.Nul',"\n","--  ","{","AI12-0312-1","}","\n",'    Printf("The String=%s, Length=%d", Chars1, Chars1\'Length);',"\n","end Test;","\n"),(0,r.kt)("h4",m({},{id:"incompatibilities-with-ada-95"}),"Incompatibilities With Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00285-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0005-1"),"}"," ",(0,r.kt)("br",null),"Types char16_t and char32_t and their related types and operations are added to Interfaces.C. If Interfaces.C is referenced in a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause")),", and an entity ",(0,r.kt)("em",null,"E")," with the same ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," as a new entity in Interfaces.C is defined in a package that is also referenced in a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause")),", the entity ",(0,r.kt)("em",null,"E")," may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0059"),"}"," ","{",(0,r.kt)("em",null,"AI95-00131-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Convention C_Pass_By_Copy is new. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0060"),"}"," ","{",(0,r.kt)("em",null,"AI95-00037-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Clarified the intent for Nul and Wide_Nul.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"Specified that an unchecked union type (see B.3.3) is eligible for convention C_Pass_By_Copy.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00258-01"),"}"," ",(0,r.kt)("br",null),"Specified what happens if the To_C function tries to return a null string.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00337-01"),"}"," ",(0,r.kt)("br",null),"Clarified that the interface correspondences also apply to private types whose full types have the specified characteristics.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00343-01"),"}"," ",(0,r.kt)("br",null),"Clarified that a type must have convention C_Pass_By_Copy in order to be passed by copy (not just a type that could have that convention).",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00376-01"),"}"," ",(0,r.kt)("br",null),"Added wording to make it clear that these facilities can also be used with C++. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"incompatibilities-with-ada-2005"}),"Incompatibilities With Ada 2005"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0002-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null))," Added a definition of correspondences for function results. Also added wording to make it clear that we do not expect the implementation to conjure bounds for unconstrained arrays out of thin air. These changes allow (but don't require) compilers to reject unreasonable uses of array types. Such uses probably didn't work anyway (and probably were rejected, no matter what the language definition said), so little existing code should be impacted. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0411-1"),"}"," ",(0,r.kt)("br",null),"Added type C_bool and (implicitly) the enumeration literals True and False to the Interfaces.C package. Therefore, a use clause conflict is possible; see the introduction of Annex A for more on this topic. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0028-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," The ",(0,r.kt)("em",null,"convention_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s C_Variadic_0, C_Variadic_1, and so on are new. These are classified as a correction as any implementation can add such identifiers and it is important that special conventions be available for variadic functions as typical x64 conventions are different for normal and variadic C functions.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0135-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Defined the correspondence between an Ada enumeration type and a C enumeration type; implementations should support convention C for enumeration types. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0184-1"),"}"," ",(0,r.kt)("br",null),"Added  that types be defined in Interfaces.C corresponding to long long and unsigned long long.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0219-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null))," Added advice that const t* map to Ada ",(0,r.kt)("strong",null,"in")," parameters and vice versa.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI12-0411-1"),"}"," ",(0,r.kt)("br",null),"Added advice about mapping type Boolean. ",(0,r.kt)("br",null)),(0,r.kt)("h2",m({},{id:"b31--the-package-interfacescstrings"}),"B.3.1  The Package Interfaces.C.Strings"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),'The package Interfaces.C.Strings declares types and subprograms allowing an Ada program to allocate, reference, update, and free C-style strings. In particular, the private type chars_ptr corresponds to a common use of "char *" in C programs, and an object of this type can be passed to a subprogram to which ',(0,r.kt)("strong",null,"with")," Import =",">"," True, Convention =",">",' C has been specified, and for which "char *" is the type of the argument of the C function. ',(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"static-semantics-1"}),"Static Semantics"),(0,r.kt)("p",null,"The library package Interfaces.C.Strings has the following declaration: ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI12-0241-1","}","\n"," --  ","{","AI12-0302-1","}","\n"," package Interfaces.C.Strings ","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","type char_array_access is access all char_array;","\n","--  ","{","AI95-00161-01","}","\n"," --  ","{","AI12-0399-1","}","\n","    type chars_ptr is private","\n","      with Preelaborable_Initialization;","\n","--  ","{","AI95-00276-01","}","\n","    type chars_ptr_array is array (size_t range ","<",">",") of aliased chars_ptr;","\n","Null_Ptr : constant chars_ptr;","\n","function To_Chars_Ptr (Item      : in char_array_access;","\n","                          Nul_Check : in Boolean := False)","\n","      return chars_ptr;","\n","function New_Char_Array (Chars   : in char_array) return chars_ptr;","\n","function New_String (Str : in String) return chars_ptr;","\n","procedure Free (Item : in out chars_ptr);","\n","Dereference_Error : exception;","\n","function Value (Item : in chars_ptr) return char_array;","\n","function Value (Item : in chars_ptr; Length : in size_t)","\n","      return char_array;","\n","function Value (Item : in chars_ptr) return String;","\n","function Value (Item : in chars_ptr; Length : in size_t)","\n","      return String;","\n","function Strlen (Item : in chars_ptr) return size_t;","\n","procedure Update (Item   : in chars_ptr;","\n","                     Offset : in size_t;","\n","                     Chars  : in char_array;","\n","                     Check  : in Boolean := True);","\n","procedure Update (Item   : in chars_ptr;","\n","                     Offset : in size_t;","\n","                     Str    : in String;","\n","                     Check  : in Boolean := True);","\n","Update_Error : exception;","\n","private","\n","   ... -- not specified by the language","\n","end Interfaces.C.Strings;","\n"),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The string manipulation types and subprograms appear in a child of Interfaces.C versus being there directly, since it is useful to have Interfaces.C specified as ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Pure.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Differently named functions New_String and New_Char_Array are declared, since if there were a single overloaded function a call with a string literal as actual parameter would be ambiguous. ",(0,r.kt)("br",null)),(0,r.kt)("p",null,'The type chars_ptr is C-compatible and corresponds to the use of C\'s "char *" for a pointer to the first char in a char array terminated by nul. When an object of type chars_ptr is declared, its value is by default set to Null_Ptr, unless the object is imported (see B.1). ',(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),'The type char_array_access is not necessarily C-compatible, since an object of this type may carry "dope" information. The programmer should convert from char_array_access to chars_ptr for objects imported from, exported to, or passed to C.',(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function To_Chars_Ptr (Item      : in char_array_access;","\n","                       Nul_Check : in Boolean := False)","\n","   return chars_ptr;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0061"),"}"," ","{",(0,r.kt)("em",null,"AI95-00140-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0264-1"),"}"," ",(0,r.kt)("br",null),"If Item is ",(0,r.kt)("strong",null,"null"),", then To_Chars_Ptr returns Null_Ptr. If Item is not ",(0,r.kt)("strong",null,"null"),", Nul_Check is True, and Item.",(0,r.kt)("strong",null,"all")," does not contain nul, then the function propagates Terminator_Error; otherwise, To_Chars_Ptr performs a pointer conversion with no allocation of memory.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function New_Char_Array (Chars   : in char_array) return chars_ptr;","\n"),(0,r.kt)("p",null,"This function returns a pointer to an allocated object initialized to Chars(Chars'First .. Index) & nul, where ",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Index = Chars'Last if Chars does not contain nul, or",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Index is the smallest size_t value I such that Chars(I+1) = nul. ",(0,r.kt)("br",null))),(0,r.kt)("p",null,"Storage_Error is propagated if the allocation fails.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function New_String (Str : in String) return chars_ptr;","\n"),(0,r.kt)("p",null,"This function is equivalent to New_Char_Array(To_C(Str)).",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Free (Item : in out chars_ptr);","\n"),(0,r.kt)("p",null,"If Item is Null_Ptr, then Free has no effect. Otherwise, Free releases the storage occupied by Value(Item), and resets Item to Null_Ptr.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value (Item : in chars_ptr) return char_array;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI05-0264-1"),"}"," ",(0,r.kt)("br",null),"If Item = Null_Ptr, then Value propagates Dereference_Error. Otherwise, Value returns the prefix of the array of chars pointed to by Item, up to and including the first nul. The lower bound of the result is 0. If Item does not point to a nul-terminated string, then execution of Value is erroneous.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value (Item : in chars_ptr; Length : in size_t)","\n","   return char_array;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0062"),"}"," ","{",(0,r.kt)("em",null,"AI95-00139-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0264-1"),"}"," ",(0,r.kt)("br",null),"If Item = Null_Ptr, then Value propagates Dereference_Error. Otherwise, Value returns the shorter of two arrays, either the first Length chars pointed to by Item, or Value(Item). The lower bound of the result is 0. If Length is 0, then Value propagates Constraint_Error. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"Value(New_Char_Array(Chars)) = Chars if Chars does not contain nul; else Value(New_Char_Array( Chars)) is the prefix of Chars up to and including the first nul. ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value (Item : in chars_ptr) return String;","\n"),(0,r.kt)("p",null,"Equivalent to To_Ada(Value(Item), Trim_Nul=",">","True).",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value (Item : in chars_ptr; Length : in size_t)","\n","   return String;","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0063"),"}"," ","{",(0,r.kt)("em",null,"AI95-00177-01"),"}"," ",(0,r.kt)("br",null),"Equivalent to To_Ada(Value(Item, Length) & nul, Trim_Nul=",">","True).",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Strlen (Item : in chars_ptr) return size_t;","\n"),(0,r.kt)("p",null,"Returns ",(0,r.kt)("em",null,"Val"),"'Length1 where ",(0,r.kt)("em",null,"Val")," = Value(Item); propagates Dereference_Error if Item = Null_Ptr. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"Strlen returns the number of chars in the array pointed to by Item, up to and including the char immediately before the first nul.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Strlen has the same possibility for erroneous execution as Value, in cases where the string has not been nul-terminated.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Strlen has the effect of C's strlen function. ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Update (Item   : in chars_ptr;","\n","                  Offset : in size_t;","\n","                  Chars  : in char_array;","\n","                  Check  : Boolean := True);","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"8652/0064"),"}"," ","{",(0,r.kt)("em",null,"AI95-00039-01"),"}"," ",(0,r.kt)("br",null),"If Item = Null_Ptr, then Update propagates Dereference_Error. Otherwise, this procedure updates the value pointed to by Item, starting at position Offset, using Chars as the data to be copied into the array. Overwriting the nul terminator, and skipping with the Offset past the nul terminator, are both prevented if Check is True, as follows: ",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Let N = Strlen(Item). If Check is True, then: ",(0,r.kt)("br",null))),(0,r.kt)("ul",null,(0,r.kt)("li",null,"If Offset+Chars'Length",">","N, propagate Update_Error.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Otherwise, overwrite the data in the array pointed to by Item, starting at the char at position Offset, with the data in Chars. ",(0,r.kt)("br",null))),(0,r.kt)("ul",null,(0,r.kt)("li",null,"If Check is False, then processing is as above, but with no check that Offset+Chars'Length",">","N. ",(0,r.kt)("br",null))),(0,r.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,r.kt)("strong",null),'If Chars contains nul, Update\'s effect may be to "shorten" the pointed-to char array.',(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Update (Item   : in chars_ptr;","\n","                  Offset : in size_t;","\n","                  Str    : in String;","\n","                  Check  : in Boolean := True);","\n"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00242-01"),"}"," ",(0,r.kt)("br",null),"Equivalent to Update(Item, Offset, To_C(Str, Append_Nul =",">"," False), Check). ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"{",(0,r.kt)("em",null,"AI95-00242-01"),"}"," ",(0,r.kt)("br",null),"To truncate the Item to the length of Str, use Update(Item, Offset, To_C(Str), Check) instead of Update(Item, Offset, Str, Check). Note that when truncating Item, Item must be longer than Str. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"erroneous-execution"}),"Erroneous Execution"),(0,r.kt)("p",null,"Execution of any of the following is erroneous if the Item parameter is not null_ptr and Item does not point to a nul-terminated array of chars. ",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"a Value function not taking a Length parameter,",(0,r.kt)("br",null)),(0,r.kt)("li",null,"the Free procedure,",(0,r.kt)("br",null)),(0,r.kt)("li",null,"the Strlen function. ",(0,r.kt)("br",null))),(0,r.kt)("p",null,"Execution of Free(X) is also erroneous if the chars_ptr X was not returned by New_Char_Array or New_String.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Reading or updating a freed char_array is erroneous.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Execution of Update is erroneous if Check is False and a call with Check equal to True would have propagated Update_Error. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE   ","{",(0,r.kt)("em",null,"AI12-0440-1"),"}"," ",(0,r.kt)("br",null),'New_Char_Array and New_String can be implemented either through the allocation function from the C environment ("malloc") or through Ada dynamic memory allocation ("new"). The key points are ',(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI12-0440-1"),"}"," ",(0,r.kt)("br",null),'the returned value (a chars_ptr) is represented as a C "char *" so that it can be passed to C functions;',(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI12-0442-1"),"}"," ",(0,r.kt)("br",null),"the allocated object can be freed by the programmer via a call of Free, rather than by calling a C function. ",(0,r.kt)("br",null))),(0,r.kt)("h4",m({},{id:"inconsistencies-with-ada-95"}),"Inconsistencies With Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00242-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Amendment ")," Update for a String parameter is now defined to not add a nul character. It did add a nul in Ada 95. This means that programs that used this behavior of Update to truncate a string will no longer work (the string will not be truncated). This change makes Update for a string consistent with Update for a char_array (no implicit nul is added to the end of a char_array). ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"extensions-to-ada-95-1"}),"Extensions to Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00161-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Amendment ")," Added ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Preelaborable_Initialization to type chars_ptr, so that it can be used in preelaborated units.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00276-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Amendment ")," The components of chars_ptr_array are aliased so that it can be used to instantiate Interfaces.C.Pointers (that is its intended purpose, which is otherwise mysterious as it has no operations). ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"wording-changes-from-ada-95-1"}),"Wording Changes from Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0061"),"}"," ","{",(0,r.kt)("em",null,"AI95-00140-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Fixed the missing semantics of To_Char_Ptr when Nul_Check is False.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0062"),"}"," ","{",(0,r.kt)("em",null,"AI95-00139-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Fixed the missing semantics of Value when the Length is 0.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0063"),"}"," ","{",(0,r.kt)("em",null,"AI95-00177-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Corrected the definition of Value to avoid raising Terminator_Error.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"8652/0064"),"}"," ","{",(0,r.kt)("em",null,"AI95-00039-01"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null),"Corrigendum:")," Fixed the missing semantics of Update when Item is Null_Ptr. ",(0,r.kt)("br",null)),(0,r.kt)("h2",m({},{id:"b32--the-generic-package-interfacescpointers"}),"B.3.2  The Generic Package Interfaces.C.Pointers"),(0,r.kt)("p",null,'The generic package Interfaces.C.Pointers allows the Ada programmer to perform C-style operations on pointers. It includes an access type Pointer, Value functions that dereference a Pointer and deliver the designated array, several pointer arithmetic operations, and "copy" procedures that copy the contents of a source pointer into the array designated by a destination pointer. As in C, it treats an object Ptr of type Pointer as a pointer to the first element of an array, so that for example, adding 1 to Ptr yields a pointer to the second element of the array.',(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI12-0445-1"),"}"," ",(0,r.kt)("br",null),"The generic allows two styles of usage: one in which the array is terminated by a special terminator element; and another in which the programmer keeps track of the length. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"static-semantics-2"}),"Static Semantics"),(0,r.kt)("p",null,"The generic library package Interfaces.C.Pointers has the following declaration: ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI12-0241-1","}","\n"," --  ","{","AI12-0302-1","}","\n"," generic","\n","   type Index is (","<",">",");","\n","   type Element is private;","\n","   type Element_Array is array (Index range ","<",">",") of aliased Element;","\n","   Default_Terminator : Element;","\n","package Interfaces.C.Pointers ","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n","type Pointer is access all Element;","\n","function Value(Ref        : in Pointer;","\n","                  Terminator : in Element := Default_Terminator)","\n","      return Element_Array;","\n","function Value(Ref    : in Pointer;","\n","                  Length : in ptrdiff_t)","\n","      return Element_Array;","\n","Pointer_Error : exception;","\n","-- C-style Pointer arithmetic","\n","--  ","{","AI05-0229-1","}","\n",'    function "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer',"\n","      with Convention =",">"," Intrinsic;","\n",'   function "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer',"\n","      with Convention =",">"," Intrinsic;","\n",'   function "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer',"\n","      with Convention =",">"," Intrinsic;","\n",'   function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff_t',"\n","      with Convention =",">"," Intrinsic;","\n","--  ","{","AI05-0229-1","}","\n","    procedure Increment (Ref : in out Pointer)","\n","      with Convention =",">"," Intrinsic;","\n","   procedure Decrement (Ref : in out Pointer)","\n","      with Convention =",">"," Intrinsic;","\n","This paragraph was deleted.--  ","{","AI05-0229-1","}","\n"," ","\n","function Virtual_Length (Ref        : in Pointer;","\n","                            Terminator : in Element := Default_Terminator)","\n","      return ptrdiff_t;","\n","procedure Copy_Terminated_Array","\n","      (Source     : in Pointer;","\n","       Target     : in Pointer;","\n","       Limit      : in ptrdiff_t := ptrdiff_t'Last;","\n","       Terminator : in Element :=  Default_Terminator);","\n","procedure Copy_Array (Source  : in Pointer;","\n","                         Target  : in Pointer;","\n","                         Length  : in ptrdiff_t);","\n","end Interfaces.C.Pointers;","\n"),(0,r.kt)("p",null,'The type Pointer is C-compatible and corresponds to one use of C\'s "Element *". An object of type Pointer is interpreted as a pointer to the initial Element in an Element_Array. Two styles are supported: ',(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Explicit termination of an array value with Default_Terminator (a special terminator value);",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Programmer-managed length, with Default_Terminator treated simply as a data element. ",(0,r.kt)("br",null))),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value(Ref        : in Pointer;","\n","               Terminator : in Element := Default_Terminator)","\n","   return Element_Array;","\n"),(0,r.kt)("p",null,"This function returns an Element_Array whose value is the array pointed to by Ref, up to and including the first Terminator; the lower bound of the array is Index'First. Interfaces.C.Strings.Dereference_Error is propagated if Ref is ",(0,r.kt)("strong",null,"null"),".",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Value(Ref    : in Pointer;","\n","               Length : in ptrdiff_t)","\n","   return Element_Array;","\n"),(0,r.kt)("p",null,"This function returns an Element_Array comprising the first Length elements pointed to by Ref. The exception Interfaces.C.Strings.Dereference_Error is propagated if Ref is ",(0,r.kt)("strong",null,"null"),". ",(0,r.kt)("br",null)),(0,r.kt)("p",null,'The "+" and "" functions perform arithmetic on Pointer values, based on the Size of the array elements. In each of these functions, Pointer_Error is propagated if a Pointer parameter is ',(0,r.kt)("strong",null,"null"),". ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Increment (Ref : in out Pointer);","\n"),(0,r.kt)("p",null,"Equivalent to Ref := Ref+1.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Decrement (Ref : in out Pointer);","\n"),(0,r.kt)("p",null,"Equivalent to Ref := Ref1.",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"function Virtual_Length (Ref        : in Pointer;","\n","                         Terminator : in Element := Default_Terminator)","\n","   return ptrdiff_t;","\n"),(0,r.kt)("p",null,"Returns the number of Elements, up to the one just before the first Terminator, in Value(Ref, Terminator).",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Copy_Terminated_Array","\n","   (Source     : in Pointer;","\n","    Target     : in Pointer;","\n","    Limit      : in ptrdiff_t := ptrdiff_t'Last;","\n","    Terminator : in Element := Default_Terminator);","\n"),(0,r.kt)("p",null,"This procedure copies Value(Source, Terminator) into the array pointed to by Target; it stops either after Terminator has been copied, or the number of elements copied is Limit, whichever occurs first. Dereference_Error is propagated if either Source or Target is ",(0,r.kt)("strong",null,"null"),". ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"It is the programmer's responsibility to ensure that elements are not copied beyond the logical length of the target array. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"The implementation has to take care to check the Limit first. ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"procedure Copy_Array (Source  : in Pointer;","\n","                      Target  : in Pointer;","\n","                      Length  : in ptrdiff_t);","\n"),(0,r.kt)("p",null,"This procedure copies the first Length elements from the array pointed to by Source, into the array pointed to by Target. Dereference_Error is propagated if either Source or Target is ",(0,r.kt)("strong",null,"null"),". ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"erroneous-execution-1"}),"Erroneous Execution"),(0,r.kt)("p",null,"It is erroneous to dereference a Pointer that does not designate an aliased Element. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),'Such a Pointer could arise via "+", "", Increment, or Decrement.',(0,r.kt)("br",null)),(0,r.kt)("p",null,"Execution of Value(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element_Array terminated by Terminator.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Execution of Value(Ref, Length) is erroneous if Ref does not designate an aliased Element in an Element_Array containing at least Length Elements between the designated Element and the end of the array, inclusive.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does not designate an aliased Element in an Element_Array terminated by Terminator.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is erroneous in either of the following situations: ",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Execution of both Value(Source, Terminator) and Value(Source, Limit) are erroneous, or",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Copying writes past the end of the array containing the Element designated by Target. ",(0,r.kt)("br",null))),(0,r.kt)("p",null,"Execution of Copy_Array(Source, Target, Length) is erroneous if either Value(Source, Length) is erroneous, or copying writes past the end of the array containing the Element designated by Target. ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE   To compose a Pointer from an Element_Array, use 'Access on the first element. For example (assuming appropriate instantiations): ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"Some_Array   : Element_Array(0..5) ;","\n","Some_Pointer : Pointer := Some_Array(0)'Access;","\n"),(0,r.kt)("h4",m({},{id:"examples-1"}),"Examples"),(0,r.kt)("p",null,(0,r.kt)("em",null,"Example of Interfaces.C.Pointers:")," ",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"with Interfaces.C.Pointers;","\n","with Interfaces.C.Strings;","\n","procedure Test_Pointers is","\n","   package C renames Interfaces.C;","\n","   package Char_Ptrs is","\n","      new C.Pointers (Index              =",">"," C.size_t,","\n","                      Element            =",">"," C.char,","\n","                      Element_Array      =",">"," C.char_array,","\n","                      Default_Terminator =",">"," C.nul);","\n","use type Char_Ptrs.Pointer;","\n","   subtype Char_Star is Char_Ptrs.Pointer;","\n","procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is","\n","      Target_Temp_Ptr : Char_Star := Target_Ptr;","\n","      Source_Temp_Ptr : Char_Star := Source_Ptr;","\n","      Element : C.char;","\n","   begin","\n","      if Target_Temp_Ptr = null or Source_Temp_Ptr = null then","\n","         raise C.Strings.Dereference_Error;","\n","      end if;","\n","{","8652/0065","}"," --  ","{","AI95-00142-01","}","\n","       loop","\n","         Element             := Source_Temp_Ptr.all;","\n","         Target_Temp_Ptr.all := Element;","\n",'         exit when C."="(Element, C.nul);',"\n","         Char_Ptrs.Increment(Target_Temp_Ptr);","\n","         Char_Ptrs.Increment(Source_Temp_Ptr);","\n","      end loop;","\n","   end Strcpy;","\n","begin","\n","   ...","\n","end Test_Pointers;","\n"),(0,r.kt)("h2",m({},{id:"b33--unchecked-union-types"}),"B.3.3  Unchecked Union Types"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,r.kt)("em",null,"AI05-0269-1"),"}"," ",(0,r.kt)("br",null),"[Specifying aspect Unchecked_Union to have the value True defines an interface correspondence between a given discriminated type and some C union. The aspect requires that the associated type shall be given a representation that allocates no space for its discriminant(s).] ",(0,r.kt)("br",null)),(0,r.kt)("p",null,(0,r.kt)("em",null,'Paragraphs 2 through 3 were moved to Annex J, "Obsolescent Features".')," ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"static-semantics-3"}),"Static Semantics"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),"For a discriminated record type having a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.8#S0071"},"variant_part")),", the following language-defined representation aspect may be specified:",(0,r.kt)("br",null)),(0,r.kt)("dt",null,(0,r.kt)("br",null),"Unchecked_Union"),(0,r.kt)("dl",null,(0,r.kt)("dd",null,"The type of aspect Unchecked_Union is Boolean. If directly specified, the ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," shall be a static expression. If not specified (including by inheritance), the aspect is False.",(0,r.kt)("br",null))),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,r.kt)("strong",null,"Aspect Description for "),(0,r.kt)("strong",null,"Unchecked_Union: "),"Type is used to interface to a C union type.",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"legality-rules"}),"Legality Rules"),(0,r.kt)("p",null,(0,r.kt)("em",null,"Paragraphs 4 and 5 were deleted.")," ",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),"A type for which aspect Unchecked_Union is True is called an ",(0,r.kt)("em",null,"unchecked union type"),". A subtype of an unchecked union type is defined to be an ",(0,r.kt)("em",null,"unchecked union subtype"),". An object of an unchecked union type is defined to be an ",(0,r.kt)("em",null,"unchecked union object"),".",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"All component subtypes of an unchecked union type shall be C-compatible.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"If a component subtype of an unchecked union type is subject to a per-object constraint, then the component subtype shall be an unchecked union subtype.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0026-1"),"}"," ","{",(0,r.kt)("em",null,"AI12-0174-1"),"}"," ",(0,r.kt)("br",null),"Any name that denotes a discriminant of an object of an unchecked union type shall occur within the declarative region of the type or as the ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," of an ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),", and shall not occur within a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-13/AA-13.5#S0352"},"record_representation_clause")),".",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ","{",(0,r.kt)("em",null,"AI05-0026-1"),"}"," ",(0,r.kt)("br",null),"The type of a component declared in a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.8#S0071"},"variant_part"))," of an unchecked union type shall not need finalization. In addition to the places where Legality Rules normally apply (see 12.3), this rule also applies in the private part of an instance of a generic unit. For an unchecked union type declared within the body of a generic unit, or within the body of any of its descendant library units, no part of the type of a component declared in a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.8#S0071"},"variant_part"))," of the unchecked union type shall be of a formal private type or formal private extension declared within the formal part of the generic unit.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"{",(0,r.kt)("em",null,"AI05-0026-1"),"}"," ",(0,r.kt)("br",null),'The last part is a classic assume-the-worst rule that avoids dependence on the actuals in a generic body. We did not include this in the definition of "needs finalization" as it has a bad interaction with the use of that term for the No_Nested_Finalization restriction. ',(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"The completion of an incomplete or private type declaration having a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part"))," shall not be an unchecked union type.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"An unchecked union subtype shall only be passed as a generic actual parameter if the corresponding formal type has no known discriminants or is an unchecked union type.",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"This includes formal private types without a ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part")),", formal derived types that do not inherit any discriminants (formal derived types do not have ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.7#S0061"},"known_discriminant_part")),"s), and formal derived types that are unchecked union types. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"static-semantics-4"}),"Static Semantics"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"An unchecked union type is eligible for convention C.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"All objects of an unchecked union type have the same size.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"Discriminants of objects of an unchecked union type are of size zero.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"Any check which would require reading a discriminant of an unchecked union object is suppressed (see 11.5). These checks include:",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"The check performed when addressing a variant component (i.e., a component that was declared in a variant part) of an unchecked union object that the object has this component (see 4.1.3).",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Any checks associated with a type or subtype conversion of a value of an unchecked union type (see 4.6). This includes, for example, the check associated with the implicit subtype conversion of an assignment statement.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"The subtype membership check associated with the evaluation of a qualified expression (see 4.7) or an uninitialized allocator (see 4.8). ",(0,r.kt)("br",null))),(0,r.kt)(i.Z,{type:"aarm",aarm:"discussion",title:"Discussion: ",mdxType:"Admonition"},(0,r.kt)("strong",null),"If a suppressed check would have failed, execution is erroneous (see 11.5). An implementation is always allowed to make a suppressed check if it can somehow determine the discriminant value. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"A view of an unchecked union object (including a type conversion or function call) has ",(0,r.kt)("em",null,"inferable discriminants")," if it has a constrained nominal subtype, unless the object is a component of an enclosing unchecked union object that is subject to a per-object constraint and the enclosing object lacks inferable discriminants.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"An expression of an unchecked union type has inferable discriminants if it is either a name of an object with inferable discriminants or a qualified expression whose ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," denotes a constrained subtype.",(0,r.kt)("br",null)),(0,r.kt)("p",null,"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"Program_Error is raised in the following cases:",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",null,"Evaluation of the predefined equality operator for an unchecked union type if either of the operands lacks inferable discriminants.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Evaluation of the predefined equality operator for a type which has a subcomponent of an unchecked union type whose nominal subtype is unconstrained.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"{",(0,r.kt)("em",null,"AI12-0162-1"),"}"," ",(0,r.kt)("br",null),"Evaluation of an individual membership test if the ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark"))," (if any) denotes a constrained unchecked union subtype and the ",(0,r.kt)("em",null,"tested_"),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-4/AA-4.4#S0138"},"simple_expression"))," lacks inferable discriminants.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Conversion from a derived unchecked union type to an unconstrained non-unchecked-union type if the operand of the conversion lacks inferable discriminants.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Execution of the default implementation of the Write or Read attribute of an unchecked union type.",(0,r.kt)("br",null)),(0,r.kt)("li",null,"Execution of the default implementation of the Output or Input attribute of an unchecked union type if the type lacks default discriminant values. ",(0,r.kt)("br",null))),(0,r.kt)("p",null,(0,r.kt)("em",null,"Paragraph 29 was deleted.")," ",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE   ","{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),"The use of an unchecked union to obtain the effect of an unchecked conversion results in erroneous execution (see 11.5). Execution of the following example is erroneous even if Float'Size = Integer'Size:",(0,r.kt)("br",null)),(0,r.kt)(a.Z,{mdxType:"CodeBlock"},"--  ","{","AI05-0229-1","}","\n"," type T (Flag : Boolean := False) is","\n","   record","\n","       case Flag is","\n","           when False =",">","\n","               F1 : Float := 0.0;","\n","           when True =",">","\n","               F2 : Integer := 0;","\n","       end case;","\n","    end record","\n","    with Unchecked_Union;","\n","X : T;","\n","Y : Integer := X.F2; -- erroneous","\n"),(0,r.kt)("h4",m({},{id:"extensions-to-ada-95-2"}),"Extensions to Ada 95"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI95-00216-01"),"}"," ",(0,r.kt)("br",null),(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"Pragma"))," Unchecked_Union is new. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"incompatibilities-with-ada-2005-1"}),"Incompatibilities With Ada 2005"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0026-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null))," The use of discriminants on Unchecked_Union types is now illegal in ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-13/AA-13.5#S0352"},"record_representation_clause")),"s, as it makes no sense to specify a position for something that is not supposed to exist. It is very unlikely that this change will have any impact on existing code. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,r.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0229-1"),"}"," ",(0,r.kt)("br",null),"Aspect Unchecked_Union is new; ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Unchecked_Union is now obsolescent. ",(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0026-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null)),' Revised the rules to use the "needs finalization" definition, and eliminated generic contract issues. ',(0,r.kt)("br",null)),(0,r.kt)("h4",m({},{id:"wording-changes-from-ada-2012-1"}),"Wording Changes from Ada 2012"),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0162-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null))," Adjusted the wording to reflect that membership tests can have more than one expression or ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-3/AA-3.2#S0028"},"subtype_mark")),".",(0,r.kt)("br",null)),(0,r.kt)(i.Z,{type:"aarm",aarm:"correction",title:"Correction:",mdxType:"Admonition"},"{",(0,r.kt)("em",null,"AI05-0174-1"),"}"," ",(0,r.kt)("strong",null,(0,r.kt)("br",null))," Adjusted the wording to allow named aggregates of an unchecked union type; it is clearly madness to allow positional record components in an ",(0,r.kt)("code",null,(0,r.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate"))," but not named component associations. ",(0,r.kt)("br",null)))}b.isMDXComponent=!0}}]);