"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6945],{3034:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>f,contentTitle:()=>k,default:()=>b,frontMatter:()=>m,metadata:()=>A,toc:()=>y});var n=a(1716),o=a(7556),l=a(3183),i=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,h=(e,t,a)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,p=(e,t)=>{for(var a in t||(t={}))u.call(t,a)&&h(e,a,t[a]);if(c)for(var a of c(t))d.call(t,a)&&h(e,a,t[a]);return e};const m={sidebar_position:52},k="6.4 Subprogram Calls",A={unversionedId:"arm/AA-6/AA-6.4",id:"arm/AA-6/AA-6.4",title:"6.4 Subprogram Calls",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-6/AA-6.4.mdx",sourceDirName:"arm/AA-6",slug:"/arm/AA-6/AA-6.4",permalink:"/docs/arm/AA-6/AA-6.4",draft:!1,tags:[],version:"current",sidebarPosition:52,frontMatter:{sidebar_position:52},sidebar:"referenceManualSidebar",previous:{title:"6.3 Subprogram Bodies",permalink:"/docs/arm/AA-6/AA-6.3"},next:{title:"6.5 Return Statements",permalink:"/docs/arm/AA-6/AA-6.5"}},f={},y=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"6.4.1  Parameter Associations",id:"641--parameter-associations",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4}],g={toc:y};function b(e){var t,a=e,{components:i}=a,h=((e,t)=>{var a={};for(var n in e)u.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&c)for(var n of c(e))t.indexOf(n)<0&&d.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=p(p({},g),h),r(t,s({components:i,mdxType:"MDXLayout"}))),(0,n.kt)("h1",p({},{id:"64-subprogram-calls"}),"6.4 Subprogram Calls"),(0,n.kt)("admonition",p({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",p({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"A ",(0,n.kt)("em",null,"subprogram call")," is either a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0217"},"procedure_call_statement"))," or a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"; [it invokes the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),". The call specifies the association of the actual parameters, if any, with formal parameters of the subprogram.] "),(0,n.kt)("h4",p({},{id:"syntax"}),"Syntax"),(0,n.kt)("p",null,(0,n.kt)("code",null,"procedure_call_statement"),(0,n.kt)("a",{id:"S0217"}),(0,n.kt)("code",null," ::= "),"    ",(0,n.kt)("em",null,"procedure_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),";  | ",(0,n.kt)("em",null,"procedure_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part")),";"),(0,n.kt)("p",null,(0,n.kt)("code",null,"function_call"),(0,n.kt)("a",{id:"S0218"}),(0,n.kt)("code",null," ::= "),"    ",(0,n.kt)("em",null,"function_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"  | ",(0,n.kt)("em",null,"function_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part"))),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI05-0005-1"),"}"," For the purpose of non-syntax rules, infix operator calls are considered ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"s. See 6.6. ")),(0,n.kt)("p",null,(0,n.kt)("code",null,"actual_parameter_part"),(0,n.kt)("a",{id:"S0219"}),(0,n.kt)("code",null," ::= "),"    (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," ","{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association")),"}",")"),(0,n.kt)("p",null,(0,n.kt)("code",null,"parameter_association"),(0,n.kt)("a",{id:"S0220"}),(0,n.kt)("code",null," ::= "),"   [",(0,n.kt)("em",null,"formal_parameter_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0221"},"explicit_actual_parameter"))),(0,n.kt)("p",null,(0,n.kt)("code",null,"explicit_actual_parameter"),(0,n.kt)("a",{id:"S0221"}),(0,n.kt)("code",null," ::= "),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," | ",(0,n.kt)("em",null,"variable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0416-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," is ",(0,n.kt)("em",null,"named")," or ",(0,n.kt)("em",null,"positional")," according to whether or not the ",(0,n.kt)("em",null,"formal_parameter_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," is specified. For the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association")),"s of a single ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.5#S0188"},"iterator_actual_parameter_part")),", any positional associations shall precede any named associations. Named associations are not allowed if the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," in a subprogram call is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),". "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This means that the formal parameter names used in describing predefined attributes are to aid presentation of their semantics, but are not intended for use in actual calls. ")),(0,n.kt)("h4",p({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00310-01"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," given in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0217"},"procedure_call_statement"))," shall resolve to denote a callable entity that is a procedure, or an entry renamed as (viewed as) a procedure. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," given in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," shall resolve to denote a callable entity that is a function. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," shall not resolve to denote an abstract subprogram unless it is also a dispatching subprogram. [When there is an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," can be an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," of an access-to-subprogram value.] "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI95-00310-01"),"}"," This rule is talking about dispatching operations (which is a static concept) and not about dispatching calls (which is a dynamic concept). ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The function can be an operator, enumeration literal, attribute that is a function, etc. ")),(0,n.kt)("p",null,"A subprogram call shall contain at most one association for each formal parameter. Each formal parameter without an association shall have a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," (in the profile of the view denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"). [This rule is an overloading rule (see 8.6).] "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Proof: "),"{",(0,n.kt)("em",null,"AI05-0240-1"),"}"," All Name Resolution Rules are overloading rules, see 8.6. ")),(0,n.kt)("h4",p({},{id:"static-semantics"}),"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00407-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0416-1"),"}"," If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a subprogram call denotes a prefixed view (see 4.1.3), the subprogram call is equivalent to a call on the underlying subprogram, with the first actual parameter being provided by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the prefixed view (or the Access attribute of this ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," if the first formal parameter is an access parameter), and the remaining actual parameters given by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part")),", if any. "),(0,n.kt)("h4",p({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00345-01"),"}"," For the execution of a subprogram call, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the call is evaluated, and each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," is evaluated (see 6.4.1). If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is used, an implicit ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," is assumed for this rule. These evaluations are done in an arbitrary order. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body"))," is then executed, or a call on an entry or protected subprogram is performed (see 3.9.2). Finally, if the subprogram completes normally, then after it is left, any necessary assigning back of formal to actual parameters occurs (see 6.4.1)."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"The implicit association for a default is only for this run-time rule. At compile time, the visibility rules are applied to the default at the place where it occurs, not at the place of a call. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),'If the subprogram is inherited, see 3.4, "Derived Types and Classes".')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'If the subprogram is protected, see 9.5.1, "Protected Subprograms and Protected Actions".')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'If the subprogram is really a renaming of an entry, see 9.5.3, "Entry Calls".')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00345-01"),"}",' If the subprogram is implemented by an entry or protected subprogram, it will be treated as a dispatching call to the corresponding entry (see 9.5.3, "Entry Calls") or protected subprogram (see 9.5.1, "Protected Subprograms and Protected Actions").')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00348-01"),"}"," Normally, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),' that is executed by the above rule is the one for the subprogram being called. For an enumeration literal, implicitly declared (but noninherited) subprogram, null procedure, or an attribute that is a subprogram, an implicit body is assumed. For a dispatching call, 3.9.2, "Dispatching Operations of Tagged Types" defines which ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body"))," is executed. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00318-02"),"}"," The exception Program_Error is raised at the point of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," if the function completes normally without executing a return statement. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"We are committing to raising the exception at the point of call, for uniformity - see AI83-00152. This happens after the function is left, of course.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note that there is no name for suppressing this check, since the check imposes no time overhead and minimal space overhead (since it can usually be statically eliminated as dead code). ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00231-01"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," denotes a constant, as defined in 6.5; the nominal subtype of the constant is given by the nominal subtype of the function result. "),(0,n.kt)("h4",p({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of procedure calls:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Traverse_Tree;                                               --  see 6.1","\n","Print_Header(128, Title, True);                              --  see 6.1","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Switch(From =",">"," X, To =",">"," Next);                               --  see 6.1","\n","Print_Header(128, Header =",">"," Title, Center =",">"," True);          --  see 6.1","\n","Print_Header(Header =",">"," Title, Center =",">"," True, Pages =",">"," 128); --  see 6.1","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of function calls:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Dot_Product(U, V)   --  see 6.1 and 6.3","\n","Clock               --  see 9.6","\n","F.all               --  presuming F is of an access-to-subprogram type - see 3.10","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of procedures with default expressions:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"procedure Activate(Process : in Process_Name;","\n","                   After   : in Process_Name := No_Process;","\n","                   Wait    : in Duration := 0.0;","\n","                   Prior   : in Boolean := False);","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"{","AI05-0299-1","}"," procedure Pair(Left, Right : in Person_Name := new Person(M));   --  see 3.10.1","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of their calls:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Activate(X);","\n","Activate(X, After =",">"," Y);","\n","Activate(X, Wait =",">"," 60.0, Prior =",">"," True);","\n","Activate(X, Y, 10.0, False);","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"{","AI05-0299-1","}"," Pair;","\n","Pair(Left =",">"," new Person(F), Right =",">"," new Person(M));","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"NOTE 1   If a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is used for two or more parameters in a multiple ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is evaluated once for each omitted parameter. Hence in the above examples, the two calls of Pair are equivalent. ")),(0,n.kt)("h4",p({},{id:"examples-1"}),"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of overloaded subprograms:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"procedure Put(X : in Integer);","\n","procedure Put(X : in String);","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"procedure Set(Tint   : in Color);","\n","procedure Set(Signal : in Light);","\n"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of their calls:")," "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Put(28);","\n",'Put("no possible ambiguity here");',"\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Set(Tint   =",">"," Red);","\n","Set(Signal =",">"," Red);","\n","Set(Color'(Red));","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"{","AI12-0440-1","}"," --  Set(Red) would be ambiguous since Red can","\n","--  denote a value either of type Color or of type Light","\n"),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'We have gotten rid of parameters "of the form of a type conversion" (see RM83-6.4.1(3)). The new view semantics of ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion")),"s allows us to use normal ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion")),"s instead.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"We have moved wording about run-time semantics of parameter associations to 6.4.1.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"We have moved wording about raising Program_Error for a function that falls off the end to here from RM83-6.5. ")),(0,n.kt)("h4",p({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00310-01"),"}"," Nondispatching abstract operations are no longer considered when resolving a subprogram call. That makes it possible to use ",(0,n.kt)("strong",null,"abstract"),' to "undefine" a predefined operation for an untagged type. That\'s especially helpful when defining custom arithmetic packages. ')),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00231-01"),"}"," Changed the definition of the nominal subtype of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call"))," to use the nominal subtype wording of 6.1, to take into account ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),"s and access result types.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00345-01"),"}",' Added wording to clarify that the meaning of a call on a subprogram "implemented by" an entry or protected operation is defined by 3.9.2.')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00407-01"),"}"," Defined the meaning of a call on a prefixed view of a subprogram (see 4.1.3). ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0416-1"),"}"," Moved the equivalence definition for a prefixed view to Static Semantics, in order that it is clear Legality Rules that apply to calls and the parameters of calls apply to prefixed views (including the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"). ")),(0,n.kt)("h2",p({},{id:"641--parameter-associations"}),"6.4.1  Parameter Associations"),(0,n.kt)("p",null,"[ A parameter association defines the association between an actual parameter and a formal parameter.] "),(0,n.kt)("h4",p({},{id:"language-design-principles"}),"Language Design Principles"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The parameter passing rules for ",(0,n.kt)("strong",null,"out"),' parameters are designed to ensure that the parts of a type that have implicit initial values (see 3.3.1) don\'t become "de-initialized" by being passed as an ',(0,n.kt)("strong",null,"out")," parameter.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0142-4"),"}"," For explicitly aliased parameters of functions, we will ensure at the call site that a part of the parameter can be returned as part of the function result without creating a dangling pointer. We do this with accessibility checks at the call site that all actual objects of explicitly aliased parameters live at least as long as the function result; then we can allow them to be returned as access discriminants or anonymous access results, as those have the master of the function result. ")),(0,n.kt)("h4",p({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0118-1"),"}"," The ",(0,n.kt)("em",null,"formal_parameter_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," of a named ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," shall resolve to denote a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," of the view being called; this is the formal parameter of the association. The formal parameter for a positional ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," is the parameter with the corresponding position in the formal part of the view being called."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI05-0118-1"),"}",' For positional parameters, the "corresponding position" is calculated after any transformation of prefixed views. ')),(0,n.kt)("p",null,"The ",(0,n.kt)("em",null,"actual parameter")," is either the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0221"},"explicit_actual_parameter"))," given in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," for a given formal parameter, or the corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," if no ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," is given for the formal parameter. The expected type for an actual parameter is the type of the corresponding formal parameter. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"The corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is the one of the corresponding formal parameter in the profile of the view denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the call. ")),(0,n.kt)("p",null,"If the mode is ",(0,n.kt)("strong",null,"in"),", the actual is interpreted as an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"; otherwise, the actual is interpreted only as a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", if possible. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"AI12-0005-1"),"}"," This formally resolves the ambiguity present in the syntax rule for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0221"},"explicit_actual_parameter")),". This matters as an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," that is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is evaluated and represents a value while a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," by itself can be an object; if the mode is not ",(0,n.kt)("strong",null,"in"),", we want the parameter to interpreted as an object. Note that we don't actually require that the actual be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," if the mode is not ",(0,n.kt)("strong",null,"in"),"; we do that below.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0005-1"),"}",' This wording uses "interpreted as" rather than "shall be" so that this rule is not used to resolve overloading; it is solely about evaluation as described above. We definitely do not want to allow oddities like the presence of parentheses requiring the selection of an ',(0,n.kt)("strong",null,"in")," formal parameter as opposed to an otherwise matching ",(0,n.kt)("strong",null,"in out")," parameter. ")),(0,n.kt)("h4",p({},{id:"legality-rules"}),"Legality Rules"),(0,n.kt)("p",null,"If the mode is ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out"),", the actual shall be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a variable. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI12-0005-1"),"}",' We no longer need "or a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion"))," whose argument is the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),' of a variable", because a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion"))," is now a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", and a view conversion of a variable is a variable while any other conversion (which should not be legal here) is a constant. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"The requirement that the actual be a (variable) ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is not an overload resolution rule, since we don't want the difference between ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," to be used to resolve overloading. For example: ")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"procedure Print(X : in Integer; Y : in Boolean := True);","\n","procedure Print(Z : in out Integer);","\n",". . .","\n","Print(3); -- Ambiguous!","\n","  ","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The above call to Print is ambiguous even though the call is not compatible with the second Print which requires an actual that is a (variable) ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),' ("3" is an ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", not a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"). This requirement is a legality rule, so overload resolution fails before it is considered, meaning that the call is ambiguous. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0074-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0159-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0377-1"),"}"," If the mode is ",(0,n.kt)("strong",null,"out"),", the actual parameter is a view conversion, and the type of the formal parameter is a scalar type, then "),(0,n.kt)("p",null,"neither the target type nor the operand type has the Default_Value aspect specified; or"),(0,n.kt)("p",null,"both the target type and the operand type shall have the Default_Value aspect specified, and there shall exist a type (other than a root numeric type) that is an ancestor of both the target type and the operand type. "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0074-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0159-1"),"}"," In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"These rules are needed in order to ensure that a well-defined parameter value is passed. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0102-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0142-4"),"}"," If the formal parameter is an explicitly aliased parameter, the type of the actual parameter shall be tagged or the actual parameter shall be an aliased view of an object. Further, if the formal parameter subtype ",(0,n.kt)("em",null,"F")," is untagged:"),(0,n.kt)("p",null,"the subtype ",(0,n.kt)("em",null,"F")," shall statically match the nominal subtype of the actual object; or"),(0,n.kt)("p",null,"the subtype ",(0,n.kt)("em",null,"F")," shall be unconstrained, discriminated in its full view, and unconstrained in any partial view. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Tagged objects (and tagged ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),"s for ",(0,n.kt)("strong",null,"in")," parameters) do not need to be aliased. This matches the behavior of unaliased formal parameters of tagged types, which allow 'Access to be taken of the formal parameter regardless of the form of the actual parameter. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"We need the subtype check on untagged actual parameters so that the requirements of 'Access are not lost. 'Access makes its checks against the nominal subtype of its prefix, and parameter passing can change that subtype. But we don't want this parameter passing to change the objects that would be allowed as the prefix of 'Access. This is particularly important for arrays, where we don't want to require any additional implementation burden. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI12-0095-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0005-1"),"}"," We assume the worst in a generic body regarding whether a formal subtype has a constrained partial view; specifically, in a generic body a discriminated subtype is considered to have a constrained partial view if it is a descendant of an untagged generic formal private or derived type (see 12.5.1 for the formal definition of this rule). ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0095-1"),"}"," In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0142-4"),"}"," ","{",(0,n.kt)("em",null,"AI05-0234-1"),"}"," In a function call, the accessibility level of the actual object for each explicitly aliased parameter shall not be statically deeper than the accessibility level of the master of the call (see 3.10.2)."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"Since explicitly aliased parameters are either tagged or required to be objects, there is always an object (possibly anonymous) to talk about. This is discussing the static accessibility level of the actual object; it does not depend on any runtime information (for instance when the actual object is a formal parameter of another subprogram, it does not depend on the actual parameter of that other subprogram). ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"AI12-0095-1"),"}"," This accessibility check (and its dynamic cousin as well) can only fail if the master of the function call (which is defined in the Heart of Darkness, or 3.10.2 if you prefer) is different than the master directly enclosing the call. The most likely place where this will occur is in the initializer of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.8#S0164"},"allocator")),"; in almost all other cases this check will always pass. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," Two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are ",(0,n.kt)("em",null,"known to denote the same object")," if:"),(0,n.kt)("p",null,"both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s statically denote the same stand-alone object or parameter; or"),(0,n.kt)("p",null,"both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),"s, their ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es are known to denote the same object, and their ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),"s denote the same component; or"),(0,n.kt)("p",null,"both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are dereferences (implicit or explicit) and the dereferenced ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are known to denote the same object; or"),(0,n.kt)("p",null,"both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"s, their ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es are known to denote the same object, and each of the pairs of corresponding index values are either both static expressions with the same static value or both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s that are known to denote the same object; or"),(0,n.kt)("p",null,"both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),"s, their ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es are known to denote the same object, and the two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),"s have statically matching index constraints; or"),(0,n.kt)("p",null,"one of the two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s statically denotes a renaming declaration whose renamed ",(0,n.kt)("em",null,"object_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is known to denote the same object as the other, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of any dereference within the renamed ",(0,n.kt)("em",null,"object_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is not a variable, and any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," within the renamed ",(0,n.kt)("em",null,"object_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," contains no references to variables nor calls on nonstatic functions. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"This exposes known renamings of slices, indexing, and so on to this definition. In particular, if we have ")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"C : Character renames S(1);","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"then C and S(1) are known to denote the same object.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"We need the requirement that no variables occur in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es of dereferences and in (index) ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s of the renamed object in order to avoid problems from later changes to those parts of renamed names. Consider:")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"type Ref is access Some_Type;","\n","   Ptr : Ref := new Some_Type'(...);","\n","   X : Some_Type renames Ptr.all;","\n","begin","\n","   Ptr := new Some_Type'(...);","\n","   P (Func_With_Out_Params (Ptr.all), X);","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"X and Ptr.",(0,n.kt)("strong",null,"all")," should not be known to denote the same object, since they denote different allocated objects (and this is not an unreasonable thing to do). ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"The exclusion of variables from renamed object_names is not enough to prevent altering the value of the name or expression by another access path. For instance, both ",(0,n.kt)("strong",null,"in"),' parameters passed by reference and access-to-constant values can designate variables. For the intended use of "known to be the same object", this is OK; the modification via another access path is very tricky and it is OK to reject code that would be buggy except for the tricky code. Assuming Element is an elementary type, consider the following example: ')),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Global : Tagged_Type;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"procedure Foo (Param : in Tagged_Type := Global) is","\n","   X : Element renames Some_Global_Array (Param.C);","\n","begin","\n","   Global.C := Global.C + 1;","\n","   Swap (X, Some_Global_Array (Param.C));","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The rules will flag the call of procedure Swap as illegal, since X and Some_Global_Array (Parameter.C) are known to denote the same object (even though they will actually represent different objects if Param = Global). But this is only incorrect if the parameter actually is Global and not some other value; the error could exist for some calls. So this flagging seems harmless.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Similar examples can be constructed using stand-alone composite constants with controlled or immutably limited components, and (as previously noted) with dereferences of access-to-constant values. Even when these examples flag a call incorrectly, that call depends on very tricky code (modifying the value of a constant); the code is likely to confuse future maintainers as well and thus we do not mind rejecting it. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"Whether or not ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"es are known to denote the same object is determined statically. If the name contains some dynamic portion other than a dereference, ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),', it is not "known to denote the same object".')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"These rules make no attempt to handle slices of objects that are known to be the same when the slices have dynamic bounds (other than the trivial case of bounds being defined by the same subtype), even when the bounds could be proven to be the same, as it is just too complex to get right and these rules are intended to be conservative. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'"Known to denote the same object" is intended to be an equivalence relationship, that is, it is reflexive, symmetric, and transitive. We believe this follows from the rules. For instance, given the following declarations: ')),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"S   : String(1..10);","\n","ONE : constant Natural := 1;","\n","R   : Character renames S(1);","\n"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"the names R and S(1) are known to denote the same object by the sixth bullet, and S(1) and S(ONE) are known to denote the same object by the fourth bullet, so using the sixth bullet on R and S(ONE), we simply have to test S(1) vs. S(ONE), which we already know denote the same object. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," Two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are ",(0,n.kt)("em",null,"known to refer to the same object")," if "),(0,n.kt)("p",null,"The two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are known to denote the same object; or"),(0,n.kt)("p",null,"One of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," and its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is known to refer to the same object as the other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"; or"),(0,n.kt)("p",null,"One of the two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s statically denotes a renaming declaration whose renamed ",(0,n.kt)("em",null,"object_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is known to refer to the same object as the other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"This ensures that names Prefix.Comp and Prefix are known to refer to the same object for the purposes of the rules below. This intentionally does not include dereferences; we only want to worry about accesses to the same object, and a dereference changes the object in question. (There is nothing shared between an access value and the object it designates.) ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," If a call ",(0,n.kt)("em",null,"C")," has two or more parameters of mode ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," that are of an elementary type, then the call is legal only if:"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0216-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0324-1"),"}"," For each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," ",(0,n.kt)("em",null,"N")," denoting an object of an elementary type that is passed as a parameter of mode ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," to the call ",(0,n.kt)("em",null,"C"),", there is no other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," among the other parameters of mode ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," to ",(0,n.kt)("em",null,"C")," that is known to denote the same object."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"This means ",(0,n.kt)("em",null,"visibly")," an elementary type; it does not include partial views of elementary types (partial views are always composite). That's necessary to avoid having Legality Rules depend on the contents of the private part. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," If a construct ",(0,n.kt)("em",null,"C")," has two or more direct constituents that are ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s whose evaluation may occur in an arbitrary order, at least one of which contains a function call with an ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," parameter, then the construct is legal only if:"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'All of the places where the language allows an arbitrary order can be found by looking in the index under "arbitrary order, allowed". Note that this listing includes places that don\'t involve ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s (such as checks or finalization). ")),(0,n.kt)("p",null,"For each name ",(0,n.kt)("em",null,"N")," that is passed as a parameter of mode ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," to some inner function call ",(0,n.kt)("em",null,"C2")," (not including the construct ",(0,n.kt)("em",null,"C")," itself), there is no other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," anywhere within a direct constituent of the construct ",(0,n.kt)("em",null,"C")," other than the one containing ",(0,n.kt)("em",null,"C2"),", that is known to refer to the same object. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This requirement cannot fail for a procedure or entry call alone; there must be at least one function with an ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," parameter called as part of a parameter expression of the call in order for it to fail. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"These rules prevent obvious cases of dependence on the order of evaluation of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s. Such dependence is usually a bug, and in any case, is not portable to another implementation (or even another optimization setting).")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"In the case that the top-level construct C is a call, these rules do not require checks for most ",(0,n.kt)("strong",null,"in out")," parameters, as the rules about evaluation of calls prevent problems. Similarly, we do not need checks for short circuit operations or other operations with a defined order of evaluation. The rules about arbitrary order (see ) allow evaluating parameters and writing parameters back in an arbitrary order, but not interleaving of evaluating parameters of one call with writing parameters back from another - that would not correspond to any allowed sequential order. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," For the purposes of checking this rule:"),(0,n.kt)("p",null,"For an array ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),", an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," associated with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.8#S0073"},"discrete_choice_list"))," that has two or more discrete choices, or that has a nonstatic range, is considered as two or more separate occurrences of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),";"),(0,n.kt)("p",null,"For a record ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),":"),(0,n.kt)("p",null,"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0109"},"record_component_association"))," is considered to occur once for each associated component; and"),(0,n.kt)("p",null,"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," for each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0109"},"record_component_association"))," with ","<",">"," for which the associated component has a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," is considered part of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.3#S0106"},"aggregate")),"; "),(0,n.kt)("p",null,"For a call, any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," evaluated as part of the call is considered part of the call. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"We do not check expressions that are evaluated only because of a component initialized by default in an aggregate (via ","<",">","). ")),(0,n.kt)("h4",p({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,n.kt)("p",null,"For the evaluation of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association")),": "),(0,n.kt)("p",null,"The actual parameter is first evaluated."),(0,n.kt)("p",null,"For an access parameter, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," is elaborated, which creates the anonymous access type."),(0,n.kt)("p",null,"For a parameter [(of any mode)] that is passed by reference (see 6.2), a view conversion of the actual parameter to the nominal subtype of the formal parameter is evaluated, and the formal parameter denotes that conversion. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"We are always allowing sliding, even for [",(0,n.kt)("strong",null,"in"),"] ",(0,n.kt)("strong",null,"out")," by-reference parameters. ")),(0,n.kt)("p",null,"For an ",(0,n.kt)("strong",null,"in")," or ",(0,n.kt)("strong",null,"in out")," parameter that is passed by copy (see 6.2), the formal parameter object is created, and the value of the actual parameter is converted to the nominal subtype of the formal parameter and assigned to the formal. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The conversion mentioned here is a value conversion. ")),(0,n.kt)("p",null,"For an ",(0,n.kt)("strong",null,"out")," parameter that is passed by copy, the formal parameter object is created, and: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0153-3"),"}"," ","{",(0,n.kt)("em",null,"AI05-0196-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0378-1"),"}"," For an access type, the formal parameter is initialized from the value of the actual, without checking whether the value satisfies any constraints, predicates, or null exclusions, but including any[ dynamic] accessibility checks associated with a conversion to the type of the formal parameter."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),'This preserves the Language Design Principle that an object of an access type is always initialized with a "reasonable" value. ')),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"AI12-0378-1"),"}"," The permission to pass ",(0,n.kt)("strong",null,"null")," (see below) can be used in any case where an accessibility check could fail, rather than making a check. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0153-3"),"}"," ","{",(0,n.kt)("em",null,"AI05-0228-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0074-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0159-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0377-1"),"}"," For a scalar type that has the Default_Value aspect specified, the formal parameter is initialized from the value of the actual, without checking that the value satisfies any constraint or any predicate."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"This preserves the Language Design Principle that all objects of a type with an implicit initial value are initialized. This is important so that a programmer can guarantee that all objects of a scalar type have a valid value with a carefully chosen Default_Value. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation Note: "),"This rule means that ",(0,n.kt)("strong",null,"out")," parameters of a subtype ",(0,n.kt)("em",null,"T")," with a specified Default_Value need to be large enough to support any possible value of the base type of ",(0,n.kt)("em",null,"T"),". In contrast, a type that does not have a Default_Value only need support the size of the subtype (since no values are passed in). ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0333-1"),"}"," For a composite type with discriminants or that has implicit initial values for any subcomponents (see 3.3.1), the behavior is as for an ",(0,n.kt)("strong",null,"in out")," parameter passed by copy[, except that no predicate check is performed]. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),'This ensures that no part of an object of such a type can become "de-initialized" by being part of an ',(0,n.kt)("strong",null,"out")," parameter. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This includes an array type whose component type is an access type, and a record type with a component that has a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression")),", among other things. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Proof: "),"{",(0,n.kt)("em",null,"AI12-0333-1"),"}"," No predicate check follows from the definition of subtype conversion in 4.6. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0439-1"),"}"," For any other type, the formal parameter is uninitialized. If composite, a view conversion of the actual parameter to the nominal subtype of the formal is evaluated [(which can raise Constraint_Error)], and the actual subtype of the formal is that of the view conversion. If elementary, the actual subtype of the formal is given by its nominal subtype. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"AI05-0228-1"),"}"," This case covers scalar types that do not have Default_Value specified, and composite types whose subcomponent's subtypes do not have any implicit initial values. The view conversion for composite types ensures that if the lengths don't match between an actual and a formal array parameter, the Constraint_Error is raised before the call, rather than after. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0377-1"),"}"," Furthermore, if the type is a scalar type, and the actual parameter is a view conversion, then Program_Error is raised if either the target or the operand type has the Default_Value aspect specified, unless they both have the Default_Value aspect specified, and there is a type (other than a root numeric type) that is an ancestor of both the target type and the operand type."),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"This can only occur in the body of an instance of a generic unit. Legality Rules will catch all other cases. Implementations that macro-expand generics can always detect this case when the enclosing instance body is expanded. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0142-4"),"}"," ","{",(0,n.kt)("em",null,"AI05-0234-1"),"}"," In a function call, for each explicitly aliased parameter, a check is made that the accessibility level of the master of the actual object is not deeper than that of the  master of the call (see 3.10.2). "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"If the actual object to a call ",(0,n.kt)("em",null,"C")," is a formal parameter of some function call ",(0,n.kt)("em",null,"F"),", no dynamic check against the master of the actual parameter of ",(0,n.kt)("em",null,"F")," is necessary. Any case which could fail the dynamic check is already statically illegal (either at the call site of ",(0,n.kt)("em",null,"F"),", or at the call site ",(0,n.kt)("em",null,"C"),"). This is important, as it would require nasty distributed overhead to accurately know the dynamic accessibility of a formal parameter (all tagged and explicitly aliased parameters would have to carry accessibility levels). ")),(0,n.kt)("p",null,"A formal parameter of mode ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," with discriminants is constrained if either its nominal subtype or the actual parameter is constrained."),(0,n.kt)("p",null,"After normal completion and leaving of a subprogram, for each ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," parameter that is passed by copy, the value of the formal parameter is converted to the subtype of the variable given as the actual parameter and assigned to it. These conversions and assignments occur in an arbitrary order. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The conversions mentioned above during parameter passing might raise Constraint_Error - (see 4.6). ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"If any conversion or assignment as part of parameter passing propagates an exception, the exception is raised at the place of the subprogram call; that is, it cannot be handled inside the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),". ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Proof: "),"Since these checks happen before or after executing the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),", the execution of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body"))," does not dynamically enclose them, so it can't handle the exceptions. ")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"The variable we're talking about is the one denoted by the ",(0,n.kt)("em",null,"variable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," given as the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0221"},"explicit_actual_parameter")),". If this ",(0,n.kt)("em",null,"variable_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion")),", then the rules in 4.6 for assigning to a view conversion apply. That is, if X is of subtype S1, and the actual is S2(X), the above-mentioned conversion will convert to S2, and the one mentioned in 4.6 will convert to S1. ")),(0,n.kt)("h4",p({},{id:"erroneous-execution"}),"Erroneous Execution"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0008-1"),"}"," If the nominal subtype of a formal parameter with discriminants is constrained or indefinite, and the parameter is passed by reference, then the execution of the call is erroneous if the value of any discriminant of the actual is changed while the formal parameter exists (that is, before leaving the corresponding callable construct). "),(0,n.kt)("h4",p({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0378-1"),"}"," If the actual parameter in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.4#S0220"},"parameter_association"))," with mode ",(0,n.kt)("strong",null,"out")," is a view conversion between two access types that do not share a common ancestor type, the implementation may pass in the null value of the type of the formal parameter instead of the value of the actual parameter. It is implementation-defined under what circumstances the implementation passes in the null value. "),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation defined: "),"The circumstances in which the implementation passes in the null value for a view conversion of an access type used as an ",(0,n.kt)("strong",null,"out")," parameter.")),(0,n.kt)("h4",p({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"In Ada 95, a program can rely on the fact that passing an object as an ",(0,n.kt)("strong",null,"out"),' parameter does not "de-initialize" any parts of the object whose subtypes have implicit initial values. (This generalizes the RM83 rule that required copy-in for parts that were discriminants or of an access type.) ')),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-83-1"}),"Wording Changes from Ada 83"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," We have eliminated the subclause on Default Parameters, as it is subsumed by earlier subclauses. ")),(0,n.kt)("h4",p({},{id:"inconsistencies-with-ada-2005"}),"Inconsistencies With Ada 2005"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0196-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Clarified that ",(0,n.kt)("strong",null,"out")," parameters of an access type are not checked for null exclusions when they are passed in (which is similar to the behavior for constraints). This was unspecified in Ada 2005, so a program which depends on the behavior of an implementation which does check the exclusion may malfunction. But a program depending on an exception being raised is unlikely. ")),(0,n.kt)("h4",p({},{id:"incompatibilities-with-ada-2005"}),"Incompatibilities With Ada 2005"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," Additional rules have been added to make illegal passing the same elementary object to more than one ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," parameters of the same call. In this case, the result in the object could depend on the compiler version, optimization settings, and potentially the phase of the moon, so this check will mostly reject programs that are nonportable and could fail with any change. Even when the result is expected to be the same in both parameters, the code is unnecessarily tricky. Programs which fail this new check should be rare and are easily fixed by adding a temporary object. ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0008-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," A missing rule was added to cover cases that were missed in Ada 95 and Ada 2005; specifically, that an ",(0,n.kt)("strong",null,"in")," parameter passed by reference might have its discriminants changed via another path. Such cases are erroneous as requiring compilers to detect such errors would be expensive, and requiring such cases to work would be a major change of the user model (",(0,n.kt)("strong",null,"in")," parameters with discriminants could no longer be assumed constant). This is not an inconsistency, as compilers are not required to change any current behavior.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0102-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Moved implicit conversion Legality Rule to 8.6.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0118-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Added a definition for positional parameters, as this is missing from Ada 95 and later.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0142-4"),"}"," Rules have been added defining the legality and dynamic checks needed for explicitly aliased parameters (see 6.1).")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0144-2"),"}"," Additional rules have been added such that passing an object to an ",(0,n.kt)("strong",null,"in out")," or ",(0,n.kt)("strong",null,"out")," parameter of a function is illegal if it is used elsewhere in a construct which allows evaluation in an arbitrary order. Such calls are not portable (since the results may depend on the evaluation order), and the results could even vary because of optimization settings and the like. Thus they've been banned. ")),(0,n.kt)("h4",p({},{id:"inconsistencies-with-ada-2012"}),"Inconsistencies With Ada 2012"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0378-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Added a permission to pass ",(0,n.kt)("strong",null,"null")," so that value passed into an ",(0,n.kt)("strong",null,"out")," parameter for access types is well-defined in the case of a view conversion. ",(0,n.kt)("strong",null,"Null")," may be passed for any view conversion between unrelated access types; this is important for conversions that may have problematic accessibility or tags. If the permission is used and the ",(0,n.kt)("strong",null,"out")," parameter is read before it is written (perhaps to read a bound or discriminant), Constraint_Error may be raised by Ada 2022 when it would not have been in Ada 2012. Additionally, if the called subprogram does not write the ",(0,n.kt)("strong",null,"out")," parameter at all, the actual object will be overwritten with ",(0,n.kt)("strong",null,"null")," (and possibly raise Constraint_Error if the object is null excluding), while the object would be unchanged in Ada 2012. Such cases are thought to be rare, as most ",(0,n.kt)("strong",null,"out")," parameters of access types are overwritten before being read. In addition, at least one widely-used Ada compiler already passes ",(0,n.kt)("strong",null,"null")," in these cases. ")),(0,n.kt)("h4",p({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0074-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0159-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0377-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0378-1"),"}"," ",(0,n.kt)("strong",null,"Corrigendum:")," Added rules to ensure that the value passed into an ",(0,n.kt)("strong",null,"out")," parameter for scalar types is well-defined in the case of a view conversion. The new rules can be incompatible. View conversions from/to an unrelated type with the Default_Value aspect specified are unlikely to occur in existing code, as the aspect is new in Ada 2012. Declaring and passing a temporary rather than a view conversion will eliminate the problem.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0095-1"),"}"," ",(0,n.kt)("strong",null,"Corrigendum:")," Because of a rule added in 12.5.1, the checks for the passing of an object to an explicitly aliased parameter in a generic body were strengthened to use an assume the worst rule. This case is rather unlikely as a formal private or derived type with discriminants is required along with an explicitly aliased parameter whose type doesn't statically match the formal type. Such a program is very unlikely, especially as explicitly aliased parameters are a new Ada 2012 feature. ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-2012-1"}),"Wording Changes from Ada 2012"),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0216-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," The ",(0,n.kt)("strong",null,"in out")," parameter rule only applies to actual parameters of elementary types. While this allows additional programs (and thus could be considered an extension), it is unlikely to change anything in a real program (it could only matter in a call with 4 or more parameters, and then only if two composite parameters have matching actuals). Thus we document it as a wording change.")),(0,n.kt)(l.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0333-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Predicate checks are not made for inbound ",(0,n.kt)("strong",null,"out")," parameters. The actual rule change that has this effect is found in 4.6 and is documented there. ")))}b.isMDXComponent=!0}}]);