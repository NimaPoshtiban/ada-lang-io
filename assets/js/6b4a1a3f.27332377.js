"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6438],{6160:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>f,default:()=>b,frontMatter:()=>p,metadata:()=>m,toc:()=>y});var a=n(1716),i=n(7556),o=n(3183),l=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,A=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,h=(e,t)=>{for(var n in t||(t={}))c.call(t,n)&&A(e,n,t[n]);if(d)for(var n of d(t))u.call(t,n)&&A(e,n,t[n]);return e};const p={sidebar_position:29},f="4.1 Names",m={unversionedId:"arm/AA-4/AA-4.1",id:"arm/AA-4/AA-4.1",title:"4.1 Names",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-4/AA-4.1.mdx",sourceDirName:"arm/AA-4",slug:"/arm/AA-4/AA-4.1",permalink:"/docs/arm/AA-4/AA-4.1",draft:!1,tags:[],version:"current",sidebarPosition:29,frontMatter:{sidebar_position:29},sidebar:"tutorialSidebar",previous:{title:"4 Names and Expressions",permalink:"/docs/arm/AA-4/"},next:{title:"4.2 Literals",permalink:"/docs/arm/AA-4/AA-4.2"}},k={},y=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"4.1.1  Indexed Components",id:"411--indexed-components",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"4.1.2  Slices",id:"412--slices",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"4.1.3  Selected Components",id:"413--selected-components",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"4.1.4  Attributes",id:"414--attributes",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4},{value:"4.1.5  User-Defined References",id:"415--user-defined-references",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Syntax",id:"syntax-5",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-5",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-1",level:4},{value:"4.1.6  User-Defined Indexing",id:"416--user-defined-indexing",level:2},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Syntax",id:"syntax-6",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-6",level:4},{value:"Examples",id:"examples-6",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-2",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-2",level:4}],g={toc:y};function b(e){var t,n=e,{components:l}=n,A=((e,t)=>{var n={};for(var a in e)c.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&d)for(var a of d(e))t.indexOf(a)<0&&u.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=h(h({},g),A),r(t,s({components:l,mdxType:"MDXLayout"}))),(0,a.kt)("h1",h({},{id:"41-names"}),"4.1 Names"),(0,a.kt)("admonition",h({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,a.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"[",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"Name")),"s can denote declared entities, whether declared explicitly or implicitly (see 3.1). ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"Name")),"s can also denote objects or subprograms designated by access values; the results of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion")),"s or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"s; subcomponents and slices of objects and values; protected subprograms, single entries, entry families, and entries in families of entries. Finally, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s can denote attributes of any of the foregoing.] "),(0,a.kt)("h4",h({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0003-1"),"}"," ","{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI12-0125-3"),"}"," ",(0,a.kt)("code",null,"name"),(0,a.kt)("a",{id:"S0091"}),(0,a.kt)("code",null," ::= "),"     ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0094"},"explicit_dereference")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference")),"\t| ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing")),"   | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0174"},"target_name"))),(0,a.kt)("p",null,(0,a.kt)("code",null,"direct_name"),(0,a.kt)("a",{id:"S0092"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal"))," is no longer a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name")),". ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"s are usable even when the corresponding enumeration type declaration is not visible. See 4.2. ")),(0,a.kt)("p",null,(0,a.kt)("code",null,"prefix"),(0,a.kt)("a",{id:"S0093"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))),(0,a.kt)("p",null,(0,a.kt)("code",null,"explicit_dereference"),(0,a.kt)("a",{id:"S0094"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),".",(0,a.kt)("strong",null,"all")),(0,a.kt)("p",null,(0,a.kt)("code",null,"implicit_dereference"),(0,a.kt)("a",{id:"S0095"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0004-1"),"}"," [Certain forms of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," (",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"s, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),"s, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),"s, and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),"s) include a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," that is either itself a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes some related entity, or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," of an access value that designates some related entity.] "),(0,a.kt)("h4",h({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in a ",(0,a.kt)("em",null,"dereference")," (either an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0094"},"explicit_dereference")),") is expected to be of any access type. "),(0,a.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," If the type of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in a dereference is some access-to-object type ",(0,a.kt)("em",null,"T"),", then the dereference denotes a view of an object, the ",(0,a.kt)("em",null,"nominal subtype")," of the view being the designated subtype of ",(0,a.kt)("em",null,"T"),". If the designated subtype has unconstrained discriminants, the (actual) subtype of the view is constrained by the values of the discriminants of the designated object, except when there is a partial view of the type of the designated subtype that does not have discriminants, in which case the dereference is not constrained by its discriminant values. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"If the value of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is the result of an access type conversion, the dereference denotes a view created as part of the conversion. The nominal subtype of the view is not necessarily the same as that used to create the designated object. See 4.6. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"We sometimes refer to the nominal subtype of a particular kind of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," rather than the nominal subtype of the view denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," (presuming the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes a view of an object). These two uses of nominal subtype are intended to mean the same thing. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," The last sentence was not present in Ada 95; it is necessary in Ada 2005 because general access types can designate unconstrained objects, which was not possible in Ada 95. Thus, the rules that had this effect in Ada 95 (the object being constrained by its initial value) don't work in Ada 2005 and we have to say this explicitly.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}",' The "except" part of the last sentence prevents privacy "breaking", so that if a private type has discriminants only in the full view, they don\'t interfere with freely interassigning values between objects of the type, even when the objects live in the heap. ')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Implementation Note: "),"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," Since we don't depend on whether the designated object is constrained, it is not necessary to include a constrained bit in every object that could be designated by a general access type. ")),(0,a.kt)("p",null,"If the type of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in a dereference is some access-to-subprogram type ",(0,a.kt)("em",null,"S"),", then the dereference denotes a view of a subprogram, the ",(0,a.kt)("em",null,"profile")," of the view being the designated profile of ",(0,a.kt)("em",null,"S"),". "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"This means that the formal parameter names and default expressions to be used in a call whose ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is a dereference are those of the designated profile, which need not be the same as those of the subprogram designated by the access value, since 'Access requires only subtype conformance, not full conformance. ")),(0,a.kt)("h4",h({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00415-01"),"}"," The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," determines the entity denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". This evaluation has no other effect for a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"."),(0,a.kt)("p",null,"[The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," includes the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),".] The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," consists of the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference")),". The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes the entity denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference")),"."),(0,a.kt)("p",null,"The evaluation of a dereference consists of the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," and the determination of the object or subprogram that is designated by the value of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". A check is made that the value of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is not the null access value. Constraint_Error is raised if this check fails. The dereference denotes the object or subprogram designated by the value of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". "),(0,a.kt)("h4",h({},{id:"examples"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of direct names:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Pi \t-- the direct name of a number \t(see 3.3.2)","\n","Limit \t-- the direct name of a constant \t(see 3.3.1)","\n","Count \t-- the direct name of a scalar variable \t(see 3.3.1)","\n","Board \t-- the direct name of an array variable \t(see 3.6.1)","\n","Matrix \t-- the direct name of a type \t(see 3.6)","\n","Random \t-- the direct name of a function \t(see 6.1)","\n","Error \t-- the direct name of an exception \t(see 11.1)","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of dereferences:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Next_Car.all\t--  explicit dereference denoting the object designated by","\n","               \t--  the access variable Next_Car (see 3.10.1)","\n","Next_Car.Owner \t--  selected component with implicit dereference;","\n","               \t--  same as Next_Car.all.Owner","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'Type conversions and function calls are now considered names that denote the result of the operation. In the case of a type conversion used as an actual parameter or that is of a tagged type, the type conversion is considered a variable if the operand is a variable. This simplifies the description of "parameters of the form of a type conversion" as well as better supporting an important OOP paradigm that requires the combination of a conversion from a class-wide type to some specific type followed immediately by component selection. Function calls are considered names so that a type conversion of a function call and the function call itself are treated equivalently in the grammar. A function call is considered the name of a constant, and can be used anywhere such a name is permitted. See 6.5.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Type conversions of a tagged type are permitted anywhere their operand is permitted. That is, if the operand is a variable, then the type conversion can appear on the left-hand side of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0173"},"assignment_statement")),". If the operand is an object, then the type conversion can appear in an object renaming or as a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". See 4.6. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," Everything of the general syntactic form ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"(...) is now syntactically a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". In any realistic parser, this would be a necessity since distinguishing among the various ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"(...) constructs inevitably requires name resolution. In cases where the construct yields a value rather than an object, the name denotes a value rather than an object. Names already denote values in Ada 83 with named numbers, components of the result of a function call, etc. This is partly just a wording change, and partly an extension of functionality (see Extensions heading above).")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," is new. It is used in places where direct visibility is required. It's kind of like Ada 83's ",(0,a.kt)("code",null,"simple_name"),", but ",(0,a.kt)("code",null,"simple_name")," applied to both direct visibility and visibility by selection, and furthermore, it didn't work right for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),"s. The syntax rule for ",(0,a.kt)("code",null,"simple_name")," is removed, since its use is covered by a combination of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),". The syntactic categories ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," are similar; it's mainly the visibility rules that distinguish the two. The introduction of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," requires the insertion of one new explicit textual rule: to forbid ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.1#S0172"},"statement_identifier")),"s from being ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),'s. This is the only case where the explicit rule is needed, because this is the only case where the declaration of the entity is implicit. For example, there is no need to syntactically forbid (say) "X: "Rem";", because it is impossible to declare a type whose name is an ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," in the first place.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The syntax rules for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0094"},"explicit_dereference"))," and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," are new; this makes other rules simpler, since dereferencing an access value has substantially different semantics from ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),"s. We also use ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," instead of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0094"},"explicit_dereference"))," rule since that seems clearer. Note that these rules rely on the fact that function calls are now names, so we don't need to use prefix to allow functions calls in front of .",(0,a.kt)("strong",null,"all"),". ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"Actually, it would be reasonable to allow any ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0141"},"primary"))," in front of .",(0,a.kt)("strong",null,"all"),", since only the value is needed, but that would be a bit radical. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We no longer use the term ",(0,a.kt)("em",null,"appropriate for a type")," since we now describe the semantics of a prefix in terms of implicit dereference. ")),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0003-1"),"}"," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," is now a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denoting a constant view; this allows them to be used as a prefix and to be renamed as an object. They are often used to remove ambiguity from function calls, and there may be no other way to do that. Interestingly, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.7#S0163"},"qualified_expression"))," is already legal in these contexts, so this change mainly reduces clutter by eliminating an otherwise unneeded ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.6#S0162"},"type_conversion"))," from some expressions. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0008-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added a missing rule so that most dereferences are assumed constrained (without determining whether the designated object is). This is just confirming the Ada 95 rules; Ada 2005 failed to ensure that this property was unchanged.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," Added ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," as types of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"; these are documented as extensions in the appropriate subclauses. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0125-3"),"}"," Added a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0174"},"target_name"))," (see 5.2.1) to the syntax of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),". ")),(0,a.kt)("h2",h({},{id:"411--indexed-components"}),"4.1.1  Indexed Components"),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," denotes either a component of an array or an entry in a family of entries. ]"),(0,a.kt)("h4",h({},{id:"syntax-1"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"indexed_component"),(0,a.kt)("a",{id:"S0096"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"(",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," ","{",", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"}",")"),(0,a.kt)("h4",h({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," with a given number of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s shall resolve to denote an array (after any implicit dereference) with the corresponding number of index positions, or shall resolve to denote an entry family of a task or protected object (in which case there shall be only one ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),")."),(0,a.kt)("p",null,"The expected type for each ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is the corresponding index type."),(0,a.kt)("h4",h({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)("p",null,"When the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes an array, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," denotes the component of the array with the specified index value(s). The nominal subtype of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," is the component subtype of the array type. "),(0,a.kt)("p",null,"When the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes an entry family, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component"))," denotes the individual entry of the entry family with the specified index value."),(0,a.kt)("h4",h({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,a.kt)("p",null,"For the evaluation of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),", the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"s are evaluated in an arbitrary order. The value of each ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," is converted to the corresponding index type. A check is made that each index value belongs to the corresponding index range of the array or entry family denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". Constraint_Error is raised if this check fails."),(0,a.kt)("h4",h({},{id:"examples-1"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of indexed components:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"My_Schedule(Sat)     --  a component of a one-dimensional array \t(see 3.6.1)","\n"," Page(10)             --  a component of a one-dimensional array \t(see 3.6)","\n"," Board(M, J + 1)      --  a component of a two-dimensional array \t(see 3.6.1)","\n"," Page(10)(20)         --  a component of a component \t(see 3.6)","\n"," Request(Medium)      --  an entry in a family of entries \t(see 9.1)","\n"," Next_Frame(L)(M, N)  --  a component of a function call \t(see 6.1)","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   ",(0,a.kt)("em",null,"Notes on the examples:")," Distinct notations are used for components of multidimensional arrays (such as Board) and arrays of arrays (such as Page). The components of an array of arrays are arrays and can therefore be indexed. Thus Page(10)(20) denotes the 20th component of Page(10). In the last example Next_Frame(L) is a function call returning an access value that designates a two-dimensional array.")),(0,a.kt)("h2",h({},{id:"412--slices"}),"4.1.2  Slices"),(0,a.kt)("p",null,"[ A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," denotes a one-dimensional array formed by a sequence of consecutive components of a one-dimensional array. A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," of a variable is a variable; a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," of a constant is a constant;] a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," of a value is a value. "),(0,a.kt)("h4",h({},{id:"syntax-2"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"slice"),(0,a.kt)("a",{id:"S0097"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"(",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range")),")"),(0,a.kt)("h4",h({},{id:"name-resolution-rules-2"}),"Name Resolution Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," shall resolve to denote a one-dimensional array (after any implicit dereference)."),(0,a.kt)("p",null,"The expected type for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," is the index type of the array type. "),(0,a.kt)("h4",h({},{id:"static-semantics-2"}),"Static Semantics"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," denotes a one-dimensional array formed by the sequence of consecutive components of the array denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),", corresponding to the range of values of the index given by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range")),"."),(0,a.kt)("p",null,"The type of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," is that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". Its bounds are those defined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range")),"."),(0,a.kt)("h4",h({},{id:"dynamic-semantics-2"}),"Dynamic Semantics"),(0,a.kt)("p",null,"For the evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice")),", the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range"))," are evaluated in an arbitrary order. If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," is not a ",(0,a.kt)("em",null,"null slice")," (a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," where the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range"))," is a null range), then a check is made that the bounds of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0058"},"discrete_range"))," belong to the index range of the array denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". Constraint_Error is raised if this check fails."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," is not permitted as the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an Access ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),", even if the components or the array as a whole are aliased. See 3.10.2. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),'Slices are not aliased, by 3.10, "Access Types". ')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This is to ease implementation of general-access-to-array. If slices were aliased, implementations would need to store array dope with the access values, which is not always desirable given access-to-incomplete types completed in a package body. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   For a one-dimensional array A, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0097"},"slice"))," A(N .. N) denotes an array that has only one component; its type is the type of A. On the other hand, A(N) denotes a component of the array A and has the corresponding component type. ")),(0,a.kt)("h4",h({},{id:"examples-2"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of slices:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Stars(1 .. 15)        --  a slice of 15 characters \t(see 3.6.3)","\n","  Page(10 .. 10 + Size) --  a slice of 1 + Size components \t(see 3.6)","\n","  Page(L)(A .. B)       --  a slice of the array Page(L) \t(see 3.6)","\n","  Stars(1 .. 0)         --  a null slice \t(see 3.6.3)","\n","  My_Schedule(Weekday)  --  bounds given by subtype \t(see 3.6.1 and 3.5.1)","\n","  Stars(5 .. 15)(K)     --  same as Stars(K) \t(see 3.6.3)","\n","                        --  provided that K is in 5 .. 15","\n"),(0,a.kt)("h2",h({},{id:"413--selected-components"}),"4.1.3  Selected Components"),(0,a.kt)("p",null,"[",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"Selected_component")),"s are used to denote components (including discriminants), entries, entry families, and protected subprograms; they are also used as expanded names as described below. ]"),(0,a.kt)("h4",h({},{id:"syntax-3"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"selected_component"),(0,a.kt)("a",{id:"S0098"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," . ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))),(0,a.kt)("p",null,(0,a.kt)("code",null,"selector_name"),(0,a.kt)("a",{id:"S0099"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal"))," | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))),(0,a.kt)("h4",h({},{id:"name-resolution-rules-3"}),"Name Resolution Rules"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," is called an ",(0,a.kt)("em",null,"expanded name")," if, according to the visibility rules, at least one possible interpretation of its ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes a package or an enclosing named construct (directly, not through a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0243"},"generic_renaming_declaration")),"). "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"See AI83-00187. ")),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," that is not an expanded name shall resolve to denote one of the following: "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," denotes an enclosing named construct, then the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," is interpreted only as an expanded name, even if the named construct is a function that could be called without parameters. ")),(0,a.kt)("p",null,"A component [(including a discriminant)]:"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," shall resolve to denote an object or value of some non-array composite type (after any implicit dereference). The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," shall resolve to denote a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0062"},"discriminant_specification"))," of the type, or, unless the type is a protected type, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.8#S0070"},"component_declaration"))," of the type. The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," denotes the corresponding component of the object or value. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI05-0005-1"),"}"," The components of a protected object cannot be named except by an expanded name, even from within the corresponding protected body. The protected body cannot reference the private components of some arbitrary object of the protected type; the protected body may reference components of the current instance only (by an expanded name or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name")),"). ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"Only the discriminants and components visible at the place of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," can be selected, since a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," can only denote declarations that are visible (see 8.3). ")),(0,a.kt)("p",null,"A single entry, an entry family, or a protected subprogram:"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," shall resolve to denote an object or value of some task or protected type (after any implicit dereference). The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," shall resolve to denote an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," occurring (implicitly or explicitly) within the visible part of that type. The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," denotes the corresponding entry, entry family, or protected subprogram. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),'This explicitly says "visible part" because even though the body has visibility on the private part, it cannot call the private operations of some arbitrary object of the task or protected type, only those of the current instance (and expanded name notation has to be used for that). ')),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00252-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00407-01"),"}"," A view of a subprogram whose first formal parameter is of a tagged type or is an access parameter whose designated type is tagged:"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00252-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00407-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0090-1"),"}"," The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," (after any implicit dereference) shall resolve to denote an object or value of a specific tagged type ",(0,a.kt)("em",null,"T")," or class-wide type ",(0,a.kt)("em",null,"T"),"'Class. The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," shall resolve to denote a view of a subprogram declared immediately within the declarative region in which an ancestor of the type ",(0,a.kt)("em",null,"T")," is declared. The first formal parameter of the subprogram shall be of type ",(0,a.kt)("em",null,"T"),", or a class-wide type that covers ",(0,a.kt)("em",null,"T"),", or an access parameter designating one of these types. The designator of the subprogram shall not be the same as that of a component of the tagged type visible at the point of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),". The subprogram shall not be an implicitly declared primitive operation of type ",(0,a.kt)("em",null,"T")," that overrides an inherited subprogram implemented by an entry or protected subprogram visible at the point of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),". The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," denotes a view of this subprogram that omits the first formal parameter. This view is called a ",(0,a.kt)("em",null,"prefixed view")," of the subprogram, and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," (after any implicit dereference) is called the ",(0,a.kt)("em",null,"prefix")," of the prefixed view. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI05-0090-1"),"}"," The part of the rule that excludes a primitive overriding subprogram as a selector applies only to the wrapper subprogram that is implicitly declared to override a subprogram inherited from a synchronized interface that is implemented by an operation of a task or protected type (see 9.1 and 9.4). We don't want calls that use a prefixed view to be ambiguous between the wrapper subprogram and the implementing entry or protected operation. Note that it is illegal to declare an explicit primitive that has a prefixed view that is homographic with one of the type's operations, so in normal cases it isn't possible to have an ambiguity in a prefix call. However, a class-wide operation of an ancestor type that is declared in the same declaration list with the ancestor type is also considered, and that can still make a call ambiguous. ")),(0,a.kt)("p",null,"An expanded name shall resolve to denote a declaration that occurs immediately within a named declarative region, as follows: "),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," shall resolve to denote either a package [(including the current instance of a generic package, or a rename of a package)], or an enclosing named construct."),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," shall resolve to denote a declaration that occurs immediately within the declarative region of the package or enclosing construct [(the declaration shall be visible at the place of the expanded name - see 8.3)]. The expanded name denotes that declaration. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"Hence, a library unit or subunit can use an expanded name to refer to the declarations within the private part of its parent unit, as well as to other children that have been mentioned in ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause")),"s. ")),(0,a.kt)("p",null,"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," does not denote a package, then it shall be a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or an expanded name, and it shall resolve to denote a program unit (other than a package), the current instance of a type, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.6#S0191"},"block_statement")),", a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),", or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," (in the case of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", no family index is allowed); the expanded name shall occur within the declarative region of this construct. Further, if this construct is a callable construct and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes more than one such enclosing callable construct, then the expanded name is ambiguous, independently of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),"."),(0,a.kt)("h4",h({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00252-01"),"}"," ","{",(0,a.kt)("em",null,"AI95-00407-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0427-1"),"}"," For a prefixed view of a subprogram whose first formal parameter is an access parameter, the prefix shall be legal as the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," with ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," Access appearing as the first actual parameter in a call on the unprefixed view of the subprogram."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," This rule prevents, for instance, using a nonaliased prefix in such a prefixed view. It also prevents using discriminant-dependent components as the prefix of such a prefixed view if those components would not be allowed to be renamed. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00407-01"),"}"," For a subprogram whose first parameter is of mode ",(0,a.kt)("strong",null,"in out")," or ",(0,a.kt)("strong",null,"out"),", or of an anonymous access-to-variable type, the prefix of any prefixed view shall denote a variable."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"We want calls through a prefixed view and through a normal view to have the same legality. Thus, the implicit 'Access in this new notation needs the same legality check that an explicit 'Access would have. Similarly, we need to prohibit the object from being constant if the first parameter of the subprogram is ",(0,a.kt)("strong",null,"in out"),", because that is (obviously) prohibited for passing a normal parameter. ")),(0,a.kt)("h4",h({},{id:"dynamic-semantics-3"}),"Dynamic Semantics"),(0,a.kt)("p",null,"The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," includes the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"."),(0,a.kt)("p",null,"For a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," that denotes a component of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.8#S0072"},"variant")),", a check is made that the values of the discriminants are such that the value or object denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," has this component. The exception Constraint_Error is raised if this check fails."),(0,a.kt)("h4",h({},{id:"examples-3"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of selected components:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00252-01","}"," ","{","AI95-00407-01","}"," ","{","AI12-0178","}","   Tomorrow.Month     --  a record component \t(see 3.8)","\n","  Next_Car.Owner     --  a record component \t(see 3.10.1)","\n","  Next_Car.Owner.Age --  a record component \t(see 3.10.1)","\n","                     --  the previous two lines involve implicit dereferences","\n","  Writer.Unit        --  a record component (a discriminant) \t(see 3.8.1)","\n","  Min_Cell(H).Value  --  a record component of the result \t(see 6.1)","\n","                     --  of the function call Min_Cell(H)","\n","  Cashier.Append     --  a prefixed view of a procedure \t(see 3.9.4)","\n","  Control.Seize      --  an entry of a protected object \t(see 9.4)","\n","  Pool(K).Write      --  an entry of the task Pool(K) \t(see 9.1)","\n"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of expanded names:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},'Key_Manager."',"<",'"      --  an operator of the visible part of a package \t(see 7.3.1)',"\n","  Dot_Product.Sum      --  a variable declared in a function body \t(see 6.1)","\n","  Buffer.Pool          --  a variable declared in a protected unit \t(see 9.11)","\n","  Buffer.Read          --  an entry of a protected unit \t(see 9.11)","\n","  Swap.Temp            --  a variable declared in a block statement \t(see 5.6)","\n","  Standard.Boolean     --  the name of a predefined type \t(see A.1)","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-83-1"}),"Extensions to Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We now allow an expanded name to use a prefix that denotes a rename of a package, even if the selector is for an entity local to the body or private part of the package, so long as the entity is visible at the place of the reference. This eliminates a preexisting anomaly where references in a package body may refer to declarations of its visible part but not those of its private part or body when the prefix is a rename of the package. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83-1"}),"Wording Changes from Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),' is new. It is used in places where visibility, but not necessarily direct visibility, is required. See 4.1, "Names" for more information.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The description of dereferencing an access type has been moved to 4.1, "Names"; ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),".",(0,a.kt)("strong",null,"all")," is no longer considered a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),".")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The rules have been restated to be consistent with our new terminology, to accommodate class-wide types, etc. ")),(0,a.kt)("h4",h({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00252-01"),"}"," The prefixed view notation for tagged objects is new. This provides a similar notation to that used in other popular languages, and also reduces the need for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause")),'s. This is sometimes known as "distinguished receiver notation". ')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Given the following definitions for a tagged type T: ")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"procedure Do_Something (Obj : in out T; Count : in Natural);","\n","procedure Do_Something_Else (Obj : access T; Flag : in Boolean);","\n","My_Object : aliased T;","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"the following calls are equivalent: ")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Do_Something (My_Object, Count =",">"," 10);","\n","My_Object.Do_Something (Count =",">"," 10);","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"as are the following calls: ")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Do_Something_Else (My_Object'Access, Flag =",">"," True);","\n","My_Object.Do_Something_Else (Flag =",">"," True);","\n"),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2005-1"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0090-1"),"}"," ",(0,a.kt)("strong",null,"Correction:"),' Corrected the definition of a prefixed view to ignore the implicit subprograms declared for "implemented by" entries and protected subprograms. ')),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added a rule to ensure that all reasons that the prefix of an Access attribute can be illegal are covered by the rule for the implicit Access attribute of a prefixed view. If the object is a subcomponent that depends on discriminants or fails a static accessibility check, Ada 2012 would have allowed the prefix while Ada 2022 would not. This violated the principle that a prefixed view and a normal call have the same semantics; practically, the code may not have worked anyway if a compiler implemented generalized indexing by code expansion into the canonical form. Thus, such code wasn't practically portable. ")),(0,a.kt)("h2",h({},{id:"414--attributes"}),"4.1.4  Attributes"),(0,a.kt)("p",null,"[An ",(0,a.kt)("em",null,"attribute")," is a characteristic of an entity that can be queried via an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference")),".] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Glossary entry: "),"An attribute is a characteristic or property of an entity that can be queried, and in some cases specified.")),(0,a.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[T],Term=[attribute], Def=[a characteristic or property of an entity that can be queried, and in some cases specified] "),(0,a.kt)("h4",h({},{id:"syntax-4"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0262-1"),"}"," ",(0,a.kt)("code",null,"attribute_reference"),(0,a.kt)("a",{id:"S0100"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"'",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator")),"  | ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference"))),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0004-1"),"}"," ",(0,a.kt)("code",null,"attribute_designator"),(0,a.kt)("a",{id:"S0101"}),(0,a.kt)("code",null," ::= "),"    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"[(",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),")]  | Access | Delta | Digits | Mod"),(0,a.kt)("p",null,(0,a.kt)("code",null,"range_attribute_reference"),(0,a.kt)("a",{id:"S0102"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),"'",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0103"},"range_attribute_designator"))),(0,a.kt)("p",null,(0,a.kt)("code",null,"range_attribute_designator"),(0,a.kt)("a",{id:"S0103"}),(0,a.kt)("code",null," ::= "),"Range[(",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),")]"),(0,a.kt)("h4",h({},{id:"name-resolution-rules-4"}),"Name Resolution Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0242-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0262-1"),"}"," In an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," that is not a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference")),", if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," is for an attribute defined for (at least some) objects of an access type, then the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is never interpreted as an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference")),"; otherwise (and for all ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference")),"s and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference")),"s), if there is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," and the type of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is of an access type, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is interpreted as an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference")),". Similarly, if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," is for an attribute defined for (at least some) functions, then the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is never interpreted as a parameterless ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"; otherwise (and for all ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference")),"s and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference")),"s), if there is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," consists of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes a function, it is interpreted as a parameterless ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0218"},"function_call")),"."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"The first part of this rule is essentially a \"preference\" against implicit dereference, so that it is possible to ask for, say, 'Size of an access object, without automatically getting the size of the object designated by the access object. This rule applies to 'Access, 'Unchecked_Access, 'Size, and 'Address, and any other attributes that are defined for at least some access objects.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The second part of this rule implies that, for a parameterless function F, F'Address is the address of F, whereas F'Size is the size of the anonymous constant returned by F.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We normally talk in terms of expected type or profile for name resolution rules, but we don't do this for attributes because certain attributes are legal independent of the type or the profile of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),".")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," Other than the rules given above, the Name Resolution Rules for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of each attribute are defined as Name Resolution Rules for that attribute. If no such rules are defined, then no context at all should be used when resolving the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". In particular, any knowledge about the kind of entities required must not be used for resolution unless that is required by Name Resolution Rules. This matters in obscure cases; for instance, given the following declarations: ")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"function Get_It return Integer is ... -- (1)","\n","  function Get_It return Some_Record_Type is ... -- (2)","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"the following ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," cannot be resolved and is illegal: ")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"if Get_It'Valid then","\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0005-1"),"}"," even though the Valid attribute is only defined for objects of scalar types, and thus cannot be applied to the result of function (2). That information cannot be used to resolve the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". The same would be true if (2) had been a procedure; even though the procedure does not denote an object, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," is still illegal. ")),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", if any, in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0103"},"range_attribute_designator"))," is expected to be of any integer type. "),(0,a.kt)("h4",h({},{id:"legality-rules-1"}),"Legality Rules"),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),", if any, in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0103"},"range_attribute_designator"))," shall be static. "),(0,a.kt)("h4",h({},{id:"static-semantics-3"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0006-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0032-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0159-1"),"}"," An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," denotes a value, an object, a subprogram, or some other kind of program entity. Unless explicitly specified otherwise, for an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," that denotes a value or an object, if its type is scalar, then its nominal subtype is the base subtype of the type; if its type is tagged, its nominal subtype is the first subtype of the type; otherwise, its nominal subtype is a subtype of the type without any constraint, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),", or predicate. Similarly, unless explicitly specified otherwise, for an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," that denotes a function, when its result type is scalar, its result subtype is the base subtype of the type, when its result type is tagged, the result subtype is the first subtype of the type, and when the result type is some other type, the result subtype is a subtype of the type without any constraint, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0083"},"null_exclusion")),", or predicate. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"The attributes defined by the language are summarized in K.2. Implementations can define additional attributes. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"{",(0,a.kt)("em",null,"AI05-0006-1"),"}"," The nominal subtype is primarily a concern when an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),", or a call on an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),", is used as the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of a case statement, due to the full coverage requirement based on the nominal subtype. For nondiscrete cases, we define the nominal subtype mainly for completeness. Implementations may specify otherwise for implementation-defined attribute functions.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The rule is written to match the meaning of the italicized ",(0,a.kt)("em",null,"T")," in the definition of attributes such as Input; see 4.5.1. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"{",(0,a.kt)("em",null,"AI05-0006-1"),"}"," We don't worry about the fact that \"base subtype\" is not explicitly defined for the universal types. Since it is not possible to constrain a universal numeric type, all subtypes are unconstrained, and hence can be considered base subtypes. The wording above could be altered to bypass this issue, but it doesn't seem necessary, since universal integer is handled specially in the rules for case expression full coverage, and we don't allow user-defined functions for attribute functions whose result type is universal. ")),(0,a.kt)("p",null,"[A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference"))," X'Range(N) is equivalent to the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.5#S0037"},"range"))," X'First(N) .. X'Last(N), except that the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is only evaluated once. Similarly, X'Range is equivalent to X'First .. X'Last, except that the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is only evaluated once.]"),(0,a.kt)("h4",h({},{id:"dynamic-semantics-4"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0262-1"),"}"," The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," that is not a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference"))," consists of the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),".[ The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference"))," is defined in 4.5.10.] "),(0,a.kt)("h4",h({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0015"),"}"," ","{",(0,a.kt)("em",null,"AI95-00093-01"),"}"," ","{",(0,a.kt)("em",null,"AI12-0362-2"),"}"," An implementation may provide implementation-defined attributes; the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for such an implementation-defined attribute shall differ from those of the language-defined attributes. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Implementation defined: "),"Implementation-defined attributes.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"They cannot be reserved words because reserved words are not legal identifiers.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The semantics of implementation-defined attributes, and any associated rules, are, of course, implementation defined. For example, the implementation defines whether a given implementation-defined attribute can be used in a static expression. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0362-2"),"}"," An implementation may extend the definition of a language-defined attribute by accepting uses of that attribute that would otherwise be illegal in the following cases: "),(0,a.kt)("p",null,"in order to support compatibility with a previous edition of of this Reference Manual; or"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"{",(0,a.kt)("em",null,"8652/0015"),"}"," ","{",(0,a.kt)("em",null,"AI95-00093-01"),"}"," Implementations are allowed to support the Small attribute for floating types, as this was defined in Ada 83, even though the name would conflict with a language-defined attribute. ")),(0,a.kt)("p",null,"in the case of a language-defined attribute whose ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is required by this document to be a floating point subtype, an implementation may accept an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," whose ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is a fixed point subtype[; the semantics of such an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," are implementation defined.] "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   Attributes are defined throughout this document, and are summarized in K.2.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 2   ","{",(0,a.kt)("em",null,"AI95-00235"),"}"," In general, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," (or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference")),") has to be resolved without using any context. However, in the case of the Access attribute, the expected type for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," has to be a single access type, and the resolution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," can use the fact that the type of the object or the profile of the callable entity denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," has to match the designated type or be type conformant with the designated profile of the access type. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Proof: "),"{",(0,a.kt)("em",null,"AI95-00235"),"}",' In the general case, there is no "expected type" for the ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),'. In the special case of \'Access, there is an "expected type" or "expected profile" for the ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),". ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"'Access is a special case, because without it, it would be very difficult to take 'Access of an overloaded subprogram. ")),(0,a.kt)("h4",h({},{id:"examples-4"}),"Examples"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of attributes:")," "),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"Color'First        -- minimum value of the enumeration type Color \t(see 3.5.1)","\n","Rainbow'Base'First -- same as Color'First \t(see 3.5.1)","\n","Real'Digits        -- precision of the type Real \t(see 3.5.7)","\n","Board'Last(2)      -- upper bound of the second dimension of Board \t(see 3.6.1)","\n","Board'Range(1)     -- index range of the first dimension of Board \t(see 3.6.1)","\n","Pool(K)'Terminated -- True if task Pool(K) is terminated \t(see 9.1)","\n","Date'Size          -- number of bits for records of type Date \t(see 3.8)","\n","Message'Address    -- address of the record variable Message \t(see 3.7.1)","\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-83-2"}),"Extensions to Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We now uniformly treat X'Range as X'First..X'Last, allowing its use with scalar subtypes.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We allow any integer type in the ",(0,a.kt)("em",null,"static_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of an attribute designator, not just a value of ",(0,a.kt)("em",null,"universal_integer"),". The preference rules ensure upward compatibility. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-83-2"}),"Wording Changes from Ada 83"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We use the syntactic category ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),' rather than simply "attribute" to avoid confusing the name of something with the thing itself.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"The syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," now uses ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," instead of ",(0,a.kt)("code",null,"simple_name"),", because attribute ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s are not required to follow the normal visibility rules.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We now separate ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," from ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0102"},"range_attribute_reference")),", and enumerate the reserved words that are legal attribute or range attribute designators. We do this because ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," no longer includes reserved words.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'The Ada 95 name resolution rules are a bit more explicit than in Ada 83. The Ada 83 rule said that the "meaning of the prefix of an attribute must be determinable independently of the attribute designator and independently of the fact that it is the prefix of an attribute".  That isn\'t quite right since the meaning even in Ada 83 embodies whether or not the prefix is interpreted as a parameterless function call, and in Ada 95, it also embodies whether or not the prefix is interpreted as an implicit_dereference. So the attribute designator does make a difference - just not much.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Note however that if the attribute designator is Access, it makes a big difference in the interpretation of the prefix (see 3.10.2). ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0015"),"}"," ","{",(0,a.kt)("em",null,"AI95-00093-01"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," The wording was changed to allow implementations to continue to implement the Ada 83 Small attribute. This was always intended to be allowed.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00235-01"),"}"," The note about resolving prefixes of attributes was updated to reflect that the prefix of an Access attribute now has an expected type (see 3.10.2). ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2005-2"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0006-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Defined the nominal subtype of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," to close a minor language hole. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2012-1"}),"Wording Changes from Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0032-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Allowed overriding the nominal subtype of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," for an object; that is used elsewhere in this standard.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0159-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Added wording so it is clear that predicates don't apply to the result of an attribute.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0242-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0262-1"),"}"," Added ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0158"},"reduction_attribute_reference"))," and cleaned up the rules here to avoid trampling the definition of those in 4.5.10.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0362-2"),"}"," Added a permission to support fixed point versions of float attributes, such as the rounding attributes found in A.5.3. ")),(0,a.kt)("h2",h({},{id:"415--user-defined-references"}),"4.1.5  User-Defined References"),(0,a.kt)("h4",h({},{id:"static-semantics-4"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," Given a discriminated type ",(0,a.kt)("em",null,"T"),", the following type-related operational aspect may be specified:"),(0,a.kt)("p",null,"Implicit_DereferenceThis aspect is specified by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes an access discriminant declared for the type ",(0,a.kt)("em",null,"T"),"."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Implicit_Dereference: "),"Mechanism for user-defined implicit .",(0,a.kt)("strong",null,"all"),".")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," A (view of a) type with a specified Implicit_Dereference aspect is a ",(0,a.kt)("em",null,"reference type"),". A ",(0,a.kt)("em",null,"reference object")," is an object of a reference type. The discriminant named by the Implicit_Dereference aspect is the ",(0,a.kt)("em",null,"reference discriminant")," of the reference type or reference object. [A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that identifies a reference object, and denotes the object or subprogram designated by the reference discriminant of the reference object.]"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Glossary entry: "),'A reference type is one that has user-defined behavior for ".',(0,a.kt)("strong",null,"all"),'", defined by the Implicit_Dereference aspect.')),(0,a.kt)("p",null,'Version=[5],Kind=(AddedNormal),Group=[T],Term=[reference type], Def=[a type that has user-defined behavior for ".all", defined by the Implicit_Dereference aspect] '),(0,a.kt)("h4",h({},{id:"syntax-5"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ",(0,a.kt)("code",null,"generalized_reference"),(0,a.kt)("a",{id:"S0104"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("em",null,"reference_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))),(0,a.kt)("h4",h({},{id:"name-resolution-rules-5"}),"Name Resolution Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0269-1"),"}"," The expected type for the ",(0,a.kt)("em",null,"reference_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," is any reference type. "),(0,a.kt)("h4",h({},{id:"static-semantics-5"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0138-1"),"}"," The Implicit_Dereference aspect is nonoverridable (see 13.1.1)."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This ensures that all descendants of a reference type have the same reference discriminant. This prevents generic contract problems with formal derived types. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," denotes a view equivalent to that of a dereference of the reference discriminant of the reference object."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI12-0203-1"),"}"," Given a reference type ",(0,a.kt)("em",null,"T"),", the Implicit_Dereference aspect is inherited by descendants of type ",(0,a.kt)("em",null,"T")," if not overridden [(which is only permitted if confirming)]. If a descendant type constrains the value of the reference discriminant of ",(0,a.kt)("em",null,"T")," by a new discriminant, that new discriminant is the reference discriminant of the descendant. [If the descendant type constrains the value of the reference discriminant of ",(0,a.kt)("em",null,"T")," by an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," other than the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a new discriminant, a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," that identifies an object of the descendant type denotes the object or subprogram designated by the value of this constraining expression.]"),(0,a.kt)("h4",h({},{id:"dynamic-semantics-5"}),"Dynamic Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," The evaluation of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," consists of the evaluation of the ",(0,a.kt)("em",null,"reference_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," and a determination of the object or subprogram designated by the reference discriminant of the named reference object. A check is made that the value of the reference discriminant is not the null access value. Constraint_Error is raised if this check fails. The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," denotes the object or subprogram designated by the value of the reference discriminant of the named reference object."),(0,a.kt)("h4",h({},{id:"examples-5"}),"Examples"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0429-1"),"}"," ",(0,a.kt)("em",null,"Examples of the specification and use of generalized references:")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," type Barrel is tagged ...  -- holds objects of type Element","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0139-2","}"," ","{","AI05-0299-1","}"," type Ref_Element(Data : access Element) is limited private","\n","   with Implicit_Dereference =",">"," Data;","\n",'      -- This Ref_Element type is a "reference" type.',"\n",'      -- "Data" is its reference discriminant.',"\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0139-2","}"," ","{","AI05-0268-1","}"," function Find (B : aliased in out Barrel; Key : String) return Ref_Element;","\n","   -- Returns a reference to an element of a barrel.","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," ","{","AI05-0299-1","}"," B: aliased Barrel;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0139-2","}"," ...","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0139-2","}"," ","{","AI05-0268-1","}",' Find (B, "grape") := Element\'(...);  -- Assign through a reference.',"\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0139-2","}"," ","{","AI05-0268-1","}"," -- This is equivalent to:","\n",'Find (B, "grape").Data.all := Element\'(...);',"\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," The aspect Implicit_Dereference and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0104"},"generalized_reference"))," are new. ")),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2012-1"}),"Incompatibilities With Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0138-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Defined Implicit_Dereference to be nonoveridable, which makes redefinitions and hiding of the aspect illegal. It's possible that some program could violate one of these new restrictions, but this is not very likely as reference types are not likely to be used in a hierarchy. ")),(0,a.kt)("h2",h({},{id:"416--user-defined-indexing"}),"4.1.6  User-Defined Indexing"),(0,a.kt)("h4",h({},{id:"static-semantics-6"}),"Static Semantics"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," Given a tagged type ",(0,a.kt)("em",null,"T"),", the following type-related, operational aspects may be specified:"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0428-1"),"}"," Constant_IndexingThis aspect shall be specified by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes one or more functions declared immediately within the same declaration list in which ",(0,a.kt)("em",null,"T"),", or the declaration completed by ",(0,a.kt)("em",null,"T"),", is declared. All such functions shall have at least two parameters, the first of which is of type ",(0,a.kt)("em",null,"T")," or ",(0,a.kt)("em",null,"T"),"'Class, or is an access-to-constant parameter with designated type ",(0,a.kt)("em",null,"T")," or ",(0,a.kt)("em",null,"T"),"'Class."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Constant_Indexing: "),"Defines function(s) to implement user-defined ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"s.")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0428-1"),"}"," Variable_IndexingThis aspect shall be specified by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes one or more functions declared immediately within the same declaration list in which ",(0,a.kt)("em",null,"T"),", or the declaration completed by ",(0,a.kt)("em",null,"T"),", is declared. All such functions shall have at least two parameters, the first of which is of type ",(0,a.kt)("em",null,"T")," or ",(0,a.kt)("em",null,"T"),"'Class, or is an access parameter with designated type ",(0,a.kt)("em",null,"T")," or ",(0,a.kt)("em",null,"T"),"'Class. All such functions shall have a return type that is a reference type (see 4.1.5), whose reference discriminant is of an access-to-variable type. "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"We require these functions to return a reference type so that the object returned from the function can act like a variable. We need no similar rule for Constant_Indexing, since all functions return constant objects. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Variable_Indexing: "),"Defines function(s) to implement user-defined ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),"s.")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0104-1"),"}"," These aspects are inherited by descendants of ",(0,a.kt)("em",null,"T")," (including the class-wide type ",(0,a.kt)("em",null,"T"),"'Class)."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"Indexing can be provided for multiple index types by overloading routines with different parameter profiles. For instance, the map containers provide indexing on both cursors and keys by providing pairs of overloaded routines to the Constant_Indexing and Variable_Indexing aspects. ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0292-1"),"}"," An ",(0,a.kt)("em",null,"indexable container type")," is (a view of) a tagged type with at least one of the aspects Constant_Indexing or Variable_Indexing specified. An ",(0,a.kt)("em",null,"indexable container object")," is an object of an indexable container type. [A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," that denotes the result of calling a function named by a Constant_Indexing or Variable_Indexing aspect.]"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Glossary entry: "),"An indexable container type is one that has user-defined behavior for indexing, via the Constant_Indexing or Variable_Indexing aspects.")),(0,a.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[T],Term=[indexable container type], Def=[a type that has user-defined behavior for indexing, via the Constant_Indexing or Variable_Indexing aspects]"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0138-1"),"}"," The Constant_Indexing and Variable_Indexing aspects are nonoverridable (see 13.1.1). "),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"{",(0,a.kt)("em",null,"AI12-0160-1"),"}"," This (and the following Legality Rules) ensures that all descendants of an indexable container type have aspects with the same properties. This prevents generic contract problems with formal derived types.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0104-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0138-1"),"}"," A nonoverridable aspect allows the replacement of the implementation of an indexing function and the addition of a new indexing function for a derived type, but not the removal of an indexing function. This is necessary so that indexing can be used on objects of T'Class. So long as the tag of O is that of its nominal subtype, we do not want T'Class(O)(I) to mean something different than O(I). Thus we cannot allow a change in the function identified. As T'Class(O)(I) expands into a dispatching call, we need to ensure that there is a body for each such function -- but it is OK for that body to be changed from the original body (that's just normal dispatching). ")),(0,a.kt)("h4",h({},{id:"legality-rules-2"}),"Legality Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0160-1"),"}"," If an ancestor of a type ",(0,a.kt)("em",null,"T")," is an indexable container type, then any explicit specification of the Constant_Indexing or Variable_Indexing aspects shall be confirming; that is, the specified ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," shall match the inherited aspect (see 13.1.1). "),(0,a.kt)("p",null,(0,a.kt)("em",null,"Paragraphs 7 through 8 were deleted.")," "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0160-1"),"}"," In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit."),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is illegal if the equivalent prefixed view (see below) is illegal. "),(0,a.kt)("h4",h({},{id:"syntax-6"}),"Syntax"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0292-1"),"}"," ",(0,a.kt)("code",null,"generalized_indexing"),(0,a.kt)("a",{id:"S0105"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part"))),(0,a.kt)("h4",h({},{id:"name-resolution-rules-6"}),"Name Resolution Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0292-1"),"}"," The expected type for the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is any indexable container type."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," can be an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0095"},"implicit_dereference"))," (see 4.1), so an access-to-",(0,a.kt)("em",null,"indexable_container_object")," can be the prefix (English meaning!) of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing")),". ")),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," ","{",(0,a.kt)("em",null,"AI05-0292-1"),"}"," If the Constant_Indexing aspect is specified for the type of the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing")),", then the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is interpreted as a ",(0,a.kt)("em",null,"constant indexing")," under the following circumstances:"),(0,a.kt)("p",null,"when the Variable_Indexing aspect is not specified for the type of the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix")),";"),(0,a.kt)("p",null,"when the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes a constant;"),(0,a.kt)("p",null,"when the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is used within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0141"},"primary"))," where a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denoting a constant is permitted."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"This means it is not interpreted as a constant indexing for the ",(0,a.kt)("em",null,"variable_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in the LHS of an assignment (not inside a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0141"},"primary")),"), nor for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," used for an ",(0,a.kt)("strong",null,"out")," or ",(0,a.kt)("strong",null,"in out")," parameter (not allowed to be a constant), nor for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," in an object renaming (not inside a primary), unless there is no Variable_Indexing aspect defined. ")),(0,a.kt)("p",null,"Otherwise, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is interpreted as a ",(0,a.kt)("em",null,"variable indexing"),"."),(0,a.kt)("p",null,"When a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is interpreted as a constant (or variable) indexing, it is equivalent to a call on a prefixed view of one of the functions named by the Constant_Indexing (or Variable_Indexing) aspect of the type of the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," with the given ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part")),", and with the ",(0,a.kt)("em",null,"indexable_container_object_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," as the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the prefixed view."),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"In other words, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," is equivalent to:")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"indexable_container_object_",(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"),".Indexing ",(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part"),"\n"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0005-1"),"}"," where Indexing is the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," specified for the Constant_Indexing or Variable_Indexing aspect. This equivalence is then resolved in the normal way; the aspect specifies a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", it does not denote declarations. ")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 1   ","{",(0,a.kt)("em",null,"AI12-0104-1"),"}"," The Constant_Indexing and Variable_Indexing aspects cannot be redefined when inherited for a derived type, but the functions that they denote can be modified by overriding or overloading. ")),(0,a.kt)("h4",h({},{id:"examples-6"}),"Examples"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0429-1"),"}"," ",(0,a.kt)("em",null,"Examples of the specification and use of generalized indexing:")),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," ","{","AI05-0292-1","}"," type Indexed_Barrel is tagged ...","\n","  with Variable_Indexing =",">"," Find;","\n","  -- Indexed_Barrel is an indexable container type,","\n","  -- Find is the generalized indexing operation.","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," function Find (B : aliased in out Indexed_Barrel; Key : String) return Ref_Element;","\n","   -- Return a reference to an element of a barrel (see 4.1.5).","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," IB: aliased Indexed_Barrel;","\n"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI05-0268-1","}"," -- All of the following calls are then equivalent:","\n",'Find (IB,"pear").Data.all := Element\'(...); -- Traditional call',"\n",'IB.Find ("pear").Data.all := Element\'(...); -- Call of prefixed view',"\n",'IB.Find ("pear")          := Element\'(...); -- Implicit dereference (see 4.1.5)',"\n",'IB      ("pear")          := Element\'(...); -- Implicit indexing and dereference',"\n",'IB      ("pear").Data.all := Element\'(...); -- Implicit indexing only',"\n"),(0,a.kt)("h4",h({},{id:"extensions-to-ada-2005-2"}),"Extensions to Ada 2005"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0139-2"),"}"," Aspects Constant_Indexing and Variable_Indexing, and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0105"},"generalized_indexing"))," syntax are new. ")),(0,a.kt)("h4",h({},{id:"incompatibilities-with-ada-2012-2"}),"Incompatibilities With Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0160-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Prevented a derived type from specifying Constant_Indexing if the ancestor specified Variable_Indexing (and vice versa). This is necessary to preserve the intent that for an object Obj whose tag is that of its nominal subtype, T'Class(Obj)(I) always has the same meaning as Obj(I). Situations like this should be rare in practice; most types will either define both aspects or neither.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0204-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Added a rule that a generalized indexing is illegal if the equivalent prefixed view would be illegal. If the prefixed view would be illegal for any reason, Ada 2012 would have allowed the generalized indexing while Ada 2022 does not. This violated the principle that a generalized indexing and the equivalent prefixed view have the same semantics; practically, the code may not have worked anyway if a compiler implemented generalized indexing by code expansion into the canonical form. Thus, such code wasn't practically portable. ")),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2012-2"}),"Wording Changes from Ada 2012"),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0104-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:"),' Converted confusing and unnecessary normative wording about "overriding an aspect" into a note.')),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0138-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Defined Constant_Indexing and Variable_Indexing to be nonoveridable. This is merely a new description for Legality Rules which already applied to these aspects.")),(0,a.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0428-1"),"}"," ",(0,a.kt)("strong",null,"Correction:")," Allowed the completion of a private type to use declarations from either the visible part or the private part. ")))}b.isMDXComponent=!0}}]);