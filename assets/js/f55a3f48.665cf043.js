"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9633],{8647:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>g,contentTitle:()=>p,default:()=>v,frontMatter:()=>m,metadata:()=>h,toc:()=>f});var t=a(1716),i=Object.defineProperty,r=Object.defineProperties,l=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,u=(e,n,a)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[n]=a,c=(e,n)=>{for(var a in n||(n={}))s.call(n,a)&&u(e,a,n[a]);if(o)for(var a of o(n))d.call(n,a)&&u(e,a,n[a]);return e};const m={title:"Improving Performance",sidebar_position:10},p=void 0,h={unversionedId:"style-guide/Improving_Performance",id:"style-guide/Improving_Performance",title:"Improving Performance",description:"In many ways, performance is at odds with maintainability and",source:"@site/docs/style-guide/Improving_Performance.mdx",sourceDirName:"style-guide",slug:"/style-guide/Improving_Performance",permalink:"/docs/style-guide/Improving_Performance",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Improving Performance",sidebar_position:10},sidebar:"styleGuideSidebar",previous:{title:"Object-Oriented Features",permalink:"/docs/style-guide/Object-Oriented_Features"},next:{title:"Portable Dining Philosophers Example",permalink:"/docs/style-guide/Portable_Dining_Philosophers_Example"}},g={},f=[{value:"Performance Issues",id:"performance-issues",level:2},{value:"Performance Measurement",id:"performance-measurement",level:2},{value:"Program Structure",id:"program-structure",level:2},{value:"Blocks",id:"blocks",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Data Structures",id:"data-structures",level:2},{value:"Dynamic Arrays",id:"dynamic-arrays",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Zero-Based Arrays",id:"zero-based-arrays",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Unconstrained Records",id:"unconstrained-records",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"Records and Arrays",id:"records-and-arrays",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Record and Array Aggregates",id:"record-and-array-aggregates",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"Algorithms",id:"algorithms",level:2},{value:"Mod and rem Operators",id:"mod-and-rem-operators",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"Short-Circuit Operators",id:"short-circuit-operators",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"Case Statement Versus elsif",id:"case-statement-versus-elsif",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Checking for Constraint Errors",id:"checking-for-constraint-errors",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"Order of Array Processing",id:"order-of-array-processing",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"Assigning Alternatives",id:"assigning-alternatives",level:3},{value:"guideline",id:"guideline-11",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-11",level:4},{value:"Packed Boolean Array Shifts",id:"packed-boolean-array-shifts",level:3},{value:"guideline",id:"guideline-12",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-12",level:4},{value:"Subprogram Dispatching",id:"subprogram-dispatching",level:3},{value:"guideline",id:"guideline-13",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-13",level:4},{value:"notes",id:"notes-1",level:4},{value:"Types",id:"types",level:2},{value:"Aggregates for Type Extensions",id:"aggregates-for-type-extensions",level:3},{value:"guideline",id:"guideline-14",level:4},{value:"example",id:"example-11",level:4},{value:"rationale",id:"rationale-14",level:4},{value:"Protected Types",id:"protected-types",level:3},{value:"guideline",id:"guideline-15",level:4},{value:"example",id:"example-12",level:4},{value:"rationale",id:"rationale-15",level:4},{value:"Bit Operations on Modular Types",id:"bit-operations-on-modular-types",level:3},{value:"guideline",id:"guideline-16",level:4},{value:"example",id:"example-13",level:4},{value:"rationale",id:"rationale-16",level:4},{value:"Bounded Strings",id:"bounded-strings",level:3},{value:"guideline",id:"guideline-17",level:4},{value:"rationale",id:"rationale-17",level:4},{value:"String Handling Subprograms",id:"string-handling-subprograms",level:3},{value:"guideline",id:"guideline-18",level:4},{value:"rationale",id:"rationale-18",level:4},{value:"Constraint Checking",id:"constraint-checking",level:3},{value:"guideline",id:"guideline-19",level:4},{value:"example",id:"example-14",level:4},{value:"rationale",id:"rationale-19",level:4},{value:"Real-Time System Annex",id:"real-time-system-annex",level:3},{value:"guideline",id:"guideline-20",level:4},{value:"rationale",id:"rationale-20",level:4},{value:"Pragmas",id:"pragmas",level:2},{value:"Pragma Inline",id:"pragma-inline",level:3},{value:"guideline",id:"guideline-21",level:4},{value:"example",id:"example-15",level:4},{value:"rationale",id:"rationale-21",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Pragma Restrictions",id:"pragma-restrictions",level:3},{value:"guideline",id:"guideline-22",level:4},{value:"rationale",id:"rationale-22",level:4},{value:"Pragma Preelaborate",id:"pragma-preelaborate",level:3},{value:"guideline",id:"guideline-23",level:4},{value:"rationale",id:"rationale-23",level:4},{value:"Pragma Pure",id:"pragma-pure",level:3},{value:"guideline",id:"guideline-24",level:4},{value:"rationale",id:"rationale-24",level:4},{value:"Pragma Discard_Names",id:"pragma-discard_names",level:3},{value:"guideline",id:"guideline-25",level:4},{value:"rationale",id:"rationale-25",level:4},{value:"Pragma Suppress",id:"pragma-suppress",level:3},{value:"guideline",id:"guideline-26",level:4},{value:"rationale",id:"rationale-26",level:4},{value:"Pragma Reviewable",id:"pragma-reviewable",level:3},{value:"guideline",id:"guideline-27",level:4},{value:"rationale",id:"rationale-27",level:4},{value:"Summary",id:"summary",level:2},{value:"program structure",id:"program-structure-1",level:4},{value:"data structures",id:"data-structures-1",level:3},{value:"algorithms",id:"algorithms-1",level:3},{value:"types",id:"types-1",level:3},{value:"pragmas",id:"pragmas-1",level:3}],k={toc:f};function v(e){var n,a=e,{components:i}=a,u=((e,n)=>{var a={};for(var t in e)s.call(e,t)&&n.indexOf(t)<0&&(a[t]=e[t]);if(null!=e&&o)for(var t of o(e))n.indexOf(t)<0&&d.call(e,t)&&(a[t]=e[t]);return a})(a,["components"]);return(0,t.kt)("wrapper",(n=c(c({},k),u),r(n,l({components:i,mdxType:"MDXLayout"}))),(0,t.kt)("p",null,"In many ways, performance is at odds with maintainability and\nportability. To achieve improved speed or memory usage, the most clear\nalgorithm sometimes gives way to confusing code. To exploit special\npurpose hardware or operating system services, non-portable\nimplementation dependencies are introduced. When concerned about\nperformance, you must decide how well each algorithm meets its\nperformance and maintainability goals. Use the guidelines in this\nchapter with care; they may be hazardous to your software."),(0,t.kt)("p",null,"The best way to build a system that satisfies its performance\nrequirements is through good design. You should not assume that speeding\nup your code will result in a visible increase in system execution. In\nmost applications, the overall throughput of the system is not defined\nby the execution speed of the code but by the interaction between\nconcurrent processes and the response time of the system peripherals."),(0,t.kt)("p",null,'Most of the guidelines in this chapter read "... when measured\nperformance indicates." "Indicates" means that you have determined that\nthe benefit in increased performance to your application in your\nenvironment outweighs the negative side effects on understandability,\nmaintainability, and portability of the resulting code. Many of the\nguideline examples show the alternatives that you will need to measure\nin order to determine if the guideline is indicated.'),(0,t.kt)("h2",c({},{id:"performance-issues"}),"Performance Issues"),(0,t.kt)("p",null,"Performance has at least four aspects: execution speed, code size,\ncompilation speed, and linking speed. Although all four are important,\nmost people think of execution speed when performance is mentioned, and\nmost of the guidelines in this chapter focus on execution speed."),(0,t.kt)("p",null,'Performance is influenced by many factors, including the compilation\nsoftware, hardware, system load, and coding style. While only coding\nstyle is typically under the control of the programmer, the other\nfactors have so much influence that it is impossible to make flat\nstatements such as "case statements are more efficient than if-then-else\nstructures." When performance is critical, you cannot assume that a\ncoding style that proves more efficient on one system will also be more\nefficient on another. Decisions made for the sake of performance must be\nmade on the basis of testing the alternatives on the actual system on\nwhich the application will be fielded.'),(0,t.kt)("h2",c({},{id:"performance-measurement"}),"Performance Measurement"),(0,t.kt)("p",null,"While most well-known tools for measuring performance are stand-alone\nprograms that concentrate on execution speed, there is a comprehensive\ntool that covers all four aspects of performance. The Ada Compiler\nEvaluation System (ACES) is the result of merging two earlier products:\nthe United States Department of Defense's Ada Compiler Evaluation\nCapability and the United Kingdom Ministry of Defence's Ada Evaluation\nSystem. It offers a comprehensive set of nearly 2,000 performance tests\nalong with automated setup, test management, and analysis software. This\nsystem reports (and statistically analyzes) compilation time, linking\ntime, execution time, and code size. The analysis tools make comparisons\namong multiple compilation-execution systems and also provide\ncomparisons of the run-time performance of tests using different coding\nstyles to achieve similar purposes."),(0,t.kt)("p",null,"Performance Issues Working Group (PIWG) suite. The Quick-Look facility\nis advertised as being easy to download, install, and execute in less\nthan a day, while providing information that is as useful as that\ngenerated by the PIWG suite. In addition, sw-eng.falls-church.va.us,\ndirectory /public/AdaIC/testing/aces. For World Wide Web access, use the\nfollowing uniform resource locator (URL):\n",(0,t.kt)("a",c({parentName:"p"},{href:"http://sw-eng.falls-church.va.us/AdaIC/testing/aces/"}),"http://sw-eng.falls-church.va.us/AdaIC/testing/aces/"),"."),(0,t.kt)("p",null,"While measuring performance may seem to be a relatively straightforward\nmatter, there are significant issues that must be addressed by any\nperson or toolset planning to do such measurement. For detailed\ninformation, see the following sources: ACES (1995a, 1995b, 1995c);\nClapp, Mudge, and Roy (1990); Goforth, Collard, and Marquardt (1990);\nKnight (1990); Newport (1995); and Weidermann (1990)."),(0,t.kt)("h2",c({},{id:"program-structure"}),"Program Structure"),(0,t.kt)("h3",c({},{id:"blocks"}),"Blocks"),(0,t.kt)("h4",c({},{id:"guideline"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use blocks (see Guideline 5.6.9) to introduce late initialization\nwhen measured performance indicates.")),(0,t.kt)("h4",c({},{id:"example"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ...\n   Initial : Matrix;\n\nbegin  -- Find_Solution\n\n   Initialize_Solution_Matrix:\n      for Row in Initial'Range(1) loop\n         for Col in Initial'Range(2) loop\n            Initial (Row, Col) := Get_Value (Row, Col);\n         end loop;\n      end loop Initialize_Solution_Matrix;\n\n   Converge_To_The_Solution:\n      declare\n\n         Solution       : Matrix           := Identity;\n         Min_Iterations : constant Natural := ...;\n\n      begin  -- Converge_To_The_Solution\n         for Iterations in 1 .. Min_Iterations loop\n            Converge (Solution, Initial);\n         end loop;\n\n      end Converge_To_The_Solution;\n\n   ...\nend Find_Solution;\n")),(0,t.kt)("h4",c({},{id:"rationale"}),"rationale"),(0,t.kt)("p",null,"Late initialization allows a compiler more choices in register usage\noptimization. Depending on the circumstance, this may introduce a\nsignificant performance improvement."),(0,t.kt)("p",null,"Some compilers incur a performance penalty when declarative blocks are\nintroduced. Careful analysis and timing tests by the programmer may\nidentify those declarative blocks that should be removed."),(0,t.kt)("h4",c({},{id:"notes"}),"notes"),(0,t.kt)("p",null,"It is difficult to accurately predict through code inspections which\ndeclarative blocks improve performance and which degrade performance.\nHowever, with these general guidelines and a familiarity with the\nparticular implementation, performance can be improved."),(0,t.kt)("h2",c({},{id:"data-structures"}),"Data Structures"),(0,t.kt)("h3",c({},{id:"dynamic-arrays"}),"Dynamic Arrays"),(0,t.kt)("h4",c({},{id:"guideline-1"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use constrained arrays when measured performance indicates.")),(0,t.kt)("h4",c({},{id:"rationale-1"}),"rationale"),(0,t.kt)("p",null,"If array bounds are not known until run-time, then calculations of these\nbounds may affect run-time performance. Using named constants or static\nexpressions as array bounds may provide better performance than using\nvariables or nonstatic expressions. Thus, if the values of Lower and\nUpper are not determined until run-time, then:"),(0,t.kt)("p",null,"... is array (Lower .. Upper) of ..."),(0,t.kt)("p",null,"may cause address and offset calculations to be delayed until run-time,\nintroducing a performance penalty. See NASA (1992) for a detailed\ndiscussion of the tradeoffs and alternatives."),(0,t.kt)("h3",c({},{id:"zero-based-arrays"}),"Zero-Based Arrays"),(0,t.kt)("h4",c({},{id:"guideline-2"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use zero-based indexing for arrays when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"rationale-2"}),"rationale"),(0,t.kt)("p",null,"For some compilers, offset calculations for an array whose lower bound\nis 0 (either the integer zero or the first value of an enumeration type)\nare simplified. For other compilers, optimization is more likely if the\nlower bound is 1."),(0,t.kt)("h3",c({},{id:"unconstrained-records"}),"Unconstrained Records"),(0,t.kt)("h4",c({},{id:"guideline-3"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use fixed-size components for records when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"example-1"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"subtype Line_Range   is Integer range 0 .. Max_Lines;\nsubtype Length_Range is Integer range 0 .. Max_Length;\n\n-- Note that Max_Lines and Max_Length need to be static\ntype Paragraph_Body is array (Line_Range range <>, Length_Range range <>) of Character;\n\ntype Paragraph (Lines : Line_Range := 0; Line_Length : Length_Range := 0) is\n   record\n      Text : Paragraph_Body (1 .. Lines, 1 .. Line_Length);\n   end record;\n")),(0,t.kt)("h4",c({},{id:"rationale-3"}),"rationale"),(0,t.kt)("p",null,"Determine the size and speed impact of unconstrained records having\ncomponents depending on discriminants. Some compilers will allocate the\nmaximum possible size to each object of the type; others will use\npointers to the dependent components, incurring a possible heap\nperformance penalty. Consider the possibility of using fixed-size\ncomponents."),(0,t.kt)("h3",c({},{id:"records-and-arrays"}),"Records and Arrays"),(0,t.kt)("h4",c({},{id:"guideline-4"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Define arrays of records as parallel arrays when measured\nperformance indicates.")),(0,t.kt)("h4",c({},{id:"example-2"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"    -- Array of records\n    Process (Student (Index).Name, Student (Index).Grade);\n    -- Record of arrays\n    Process (Student.Name (Index), Student.Grade (Index));\n    -- Parallel arrays\n    Process (Name (Index), Grade (Index));\n")),(0,t.kt)("h4",c({},{id:"rationale-4"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of structuring data as arrays of records, records\ncontaining arrays, or parallel arrays. Some implementations of Ada will\nshow significant performance differences among these examples."),(0,t.kt)("h3",c({},{id:"record-and-array-aggregates"}),"Record and Array Aggregates"),(0,t.kt)("h4",c({},{id:"guideline-5"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use a sequence of assignments for an aggregation when measured\nperformance indicates.")),(0,t.kt)("h4",c({},{id:"rationale-5"}),"rationale"),(0,t.kt)("p",null,'Determine the impact of using an aggregate versus a sequence of\nassignments. Using an aggregate generally requires the use of a\ntemporary variable. If the aggregate is "static" (i.e., its size and\ncomponents are known at compile- or link-time, allowing link-time\nallocation and initialization), then it will generally be more efficient\nthan a sequence of assignments. If the aggregate is "dynamic," then a\nseries of assignments may be more efficient because no temporary\nvariable is needed.'),(0,t.kt)("p",null,"See Guideline 5.6.10 for a discussion of aggregates from the point of\nview of readability and maintainability."),(0,t.kt)("p",null,"See Guideline 10.6.1 for a discussion of extension aggregates."),(0,t.kt)("h2",c({},{id:"algorithms"}),"Algorithms"),(0,t.kt)("h3",c({},{id:"mod-and-rem-operators"}),"Mod and rem Operators"),(0,t.kt)("h4",c({},{id:"guideline-6"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use incremental schemes instead of mod and rem when measured\nperformance indicates.")),(0,t.kt)("h4",c({},{id:"example-3"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   -- Using mod\n   for I in 0 .. N loop\n      Update (Arr (I mod Modulus));\n   end loop;\n\n   -- Avoiding mod\n   J := 0;\n   for I in 0 .. N loop\n      Update (Arr (J));\n      J := J + 1;\n      if J = Modulus then\n         J := 0;\n      end if;\n   end loop;\n")),(0,t.kt)("h4",c({},{id:"rationale-6"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of using the mod and rem operators. One of the\nabove styles may be significantly more efficient than the other."),(0,t.kt)("h3",c({},{id:"short-circuit-operators"}),"Short-Circuit Operators"),(0,t.kt)("h4",c({},{id:"guideline-7"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use the short-circuit control form when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"example-4"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   -- Nested "if"\n   if Last >= Target_Length then\n      if Buffer (1 .. Target_Length) = Target then\n         ...\n      end if;\n   end if;\n\n   -- "and then"\n   if Last >= Target_Length and then Buffer (1 .. Target_Length) = Target then\n      ...\n   end if;\n')),(0,t.kt)("h4",c({},{id:"rationale-7"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of using nested if statements versus using the ",(0,t.kt)("inlineCode",{parentName:"p"},"and\nthen")," or ",(0,t.kt)("inlineCode",{parentName:"p"},"or else")," operator. One of the above may be significantly more\nefficient than the other."),(0,t.kt)("h3",c({},{id:"case-statement-versus-elsif"}),"Case Statement Versus elsif"),(0,t.kt)("h4",c({},{id:"guideline-8"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use the case statement when measured performance indicates.")),(0,t.kt)("h4",c({},{id:"example-5"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   subtype Small_Int is Integer range 1 .. 5;\n   Switch : Small_Int;\n   ...\n   -- Case statement\n   case Switch is\n      when 1 => ...\n      when 2 => ...\n      when 3 => ...\n      when 4 => ...\n      when 5 => ...\n   end case;\n\n   -- "elsif construct"\n   if Switch = 1 then\n      ...\n   elsif Switch = 2 then\n      ...\n   elsif Switch = 3 then\n      ...\n   elsif Switch = 4 then\n      ...\n   elsif Switch = 5 then\n      ...\n   end if;\n')),(0,t.kt)("h4",c({},{id:"rationale-8"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of using case statements versus the elsif\nconstruct. If the case statement is implemented using a small jump\ntable, then it may be significantly more efficient than the if .. then\n.. elsif construct."),(0,t.kt)("p",null,"See also Guideline 8.4.6 for a discussion of the table-driven\nprogramming alternative."),(0,t.kt)("h3",c({},{id:"checking-for-constraint-errors"}),"Checking for Constraint Errors"),(0,t.kt)("h4",c({},{id:"guideline-9"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use hard-coded constraint checking when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"example-6"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype Small_Int is Positive range Lower .. Upper;\n   Var : Small_Int;\n   ...\n\n   -- Using exception handler\n   Double:\n      begin\n         Var := 2 * Var;\n      exception\n         when Constraint_Error =>\n            ...\n      end Double;\n\n      -- Using hard-coded check\n      if Var > Upper / 2 then\n         ...\n      else\n         Var := 2 * Var;\n      end if;\n")),(0,t.kt)("h4",c({},{id:"rationale-9"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of using exception handlers to detect constraint\nerrors. If the exception handling mechanism is slow, then hard-coded\nchecking may be more efficient."),(0,t.kt)("h3",c({},{id:"order-of-array-processing"}),"Order of Array Processing"),(0,t.kt)("h4",c({},{id:"guideline-10"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use column-first processing of two-dimensional arrays when measured\nperformance indicates.")),(0,t.kt)("h4",c({},{id:"example-7"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"    type Table_Type is array (Row_Min .. Row_Max, Col_Min .. Col_Max) of ...\n    Table : Table_Type;\n    ...\n    -- Row-order processing\n    for Row in Row_Min .. Row_Max loop\n       for Col in Col_Min .. Col_Max loop\n          -- Process Table (Row, Col)\n       end loop;\n    end loop;\n    -- Column-order processing\n    for Col in Col_Min .. Col_Max loop\n       for Row in Row_Min .. Row_Max loop\n          -- Process Table (Row, Col)\n       end loop;\n    end loop;\n")),(0,t.kt)("h4",c({},{id:"rationale-10"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of processing two-dimensional arrays in row-major\norder versus column-major order. While most Ada compilers are likely to\nuse row-major order, it is not a requirement. In the presence of good\noptimization, there may be no significant difference in the above\nexamples. Using static array bounds is also likely to be significant\nhere. See Guidelines 10.4.1 and 10.4.2."),(0,t.kt)("h3",c({},{id:"assigning-alternatives"}),"Assigning Alternatives"),(0,t.kt)("h4",c({},{id:"guideline-11"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use overwriting for conditional assignment when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"example-8"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   -- Using "if .. else"\n   if Condition then\n      Var := One_Value;\n   else\n      Var := Other_Value;\n   end if;\n   -- Using overwriting\n   Var := Other_Value;\n   if Condition then\n      Var := One_Value;\n   end if;\n')),(0,t.kt)("h4",c({},{id:"rationale-11"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of styles of assigning alternative values. The\nexamples illustrate two common methods of doing this; for many systems,\nthe performance difference is significant."),(0,t.kt)("h3",c({},{id:"packed-boolean-array-shifts"}),"Packed Boolean Array Shifts"),(0,t.kt)("h4",c({},{id:"guideline-12"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"When measured performance indicates, perform packed Boolean array\nshift operations by using slice assignments rather than repeated\nbit-wise assignment.")),(0,t.kt)("h4",c({},{id:"example-9"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   subtype Word_Range is Integer range 0 .. 15;\n   type Flag_Word is array (Word_Range) of Boolean;\n   pragma Pack (Flag_Word);\n   Word : Flag_Word;\n   ...\n\n   -- Loop to shift by one bit\n   for Index in 0 .. 14 loop\n      Word (Index) := Word (Index + 1);\n   end loop;\n   Word (15) := False;\n\n   -- Use slice assignment to shift by one bit\n   Word (0 .. 14) := Word (1 .. 15);\n   Word (15) := False;\n")),(0,t.kt)("h4",c({},{id:"rationale-12"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of slice manipulation when shifting packed Boolean\narrays. For Ada 83 implementations using packed Boolean arrays, shift\noperations may be much faster when slice assignments are used as opposed\nto for loop moving one component at a time. For Ada 95 implementations,\nconsider using modular types instead (see Guideline 10.6.3)."),(0,t.kt)("h3",c({},{id:"subprogram-dispatching"}),"Subprogram Dispatching"),(0,t.kt)("h4",c({},{id:"guideline-13"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use static subprogram dispatching when measured performance\nindicates.")),(0,t.kt)("h4",c({},{id:"example-10"}),"example"),(0,t.kt)("p",null,'The term "static dispatching" in this example refers to the use of\nif/elsif sequences to explicitly determine which subprograms to call\nbased on certain conditions:'),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'    -- (1) Dispatching where tag is not known at compile time\n    --     (See ACES V2.0 test "a9_ob_class_wide_dynamic_01")\n    -- Object_Type is a tagged type\n    -- The_Pointer designates Object_Type\'Class;\n    -- Subclass1_Pointer designates Subclass1 (derived from Object_Type)\n    -- Subclass2_Pointer designates Subclass2 (derived from Subclass1)\n    -- Subclass3_Pointer designates Subclass3 (derived from Subclass2)\n    Random_Value := Simple_Random; -- Call to a random number generator\n    if Random_Value < 1.0/3.0 then\n       The_Pointer := Subclass1_Pointer;\n    elsif Random_Value > 2.0/3.0 then\n       The_Pointer := Subclass2_Pointer;\n    else\n       The_Pointer := Subclass3_Pointer;\n    end if;\n    Process (The_Pointer.all);  -- Tag is unknown\n    -- (2) Tag is determinable at compile time (static dispatching)\n    --     (See ACES V2.0, test "a9_ob_class_wide_static_01")\n    -- Object_Type is a tagged type\n    -- The_Pointer designates Object_Type\'Class;\n    -- Subclass1_Pointer designates Subclass1 (derived from Object_Type)\n    -- Subclass2_Pointer designates Subclass2 (derived from Subclass1)\n    -- Subclass3_Pointer designates Subclass3 (derived from Subclass2)\n    Random_Value := Simple_Random; -- Call to a random number generator\n    if Random_Value < 1.0/3.0 then\n       Process (Subclass1_Pointer.all);\n    elsif Random_Value > 2.0/3.0 then\n       Process (Subclass2_Pointer.all);\n    else\n       Process (Subclass3_Pointer.all);\n    end if;\n    -- (3) No tagged types are involved (no dispatching)\n    --     (See ACES V2.0, test "ap_ob_class_wide_01")\n    -- Object_type is a discriminated type with variants; possible\n    -- discriminant values are Subclass1, Subclass2, and Subclass3\n    -- All the pointers designate values of Object_Type\n    -- Subclass1_Pointer := new Object_Type (Subclass1);\n    -- Subclass2_Pointer := new Object_Type (Subclass2);\n    -- Subclass3_Pointer := new Object_Type (Subclass3);\n    -- There is only one "Process" procedure (operating on Object_Type)\n    Random_Value := Simple_Random; -- Call to a random number generator\n    if Random_Value < 1.0/3.0 then\n       Process (Subclass1_Pointer.all);\n    elsif Random_Value > 2.0/3.0 then\n       Process (Subclass2_Pointer.all);\n    else\n       Process (Subclass3_Pointer.all);\n    end if;\n')),(0,t.kt)("h4",c({},{id:"rationale-13"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of dynamic and static subprogram dispatching. The\ncompiler may generate much more efficient code for one form of\ndispatching than the other."),(0,t.kt)("h4",c({},{id:"notes-1"}),"notes"),(0,t.kt)("p",null,"Dynamic dispatching will almost certainly be more efficient than an\nexplicit if . . . elsif sequence. However, you should be aware of any\noptimizing decisions made by a compiler that might affect this\nsituation."),(0,t.kt)("h2",c({},{id:"types"}),"Types"),(0,t.kt)("h3",c({},{id:"aggregates-for-type-extensions"}),"Aggregates for Type Extensions"),(0,t.kt)("h4",c({},{id:"guideline-14"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use only simple aggregates when measured performance indicates.")),(0,t.kt)("h4",c({},{id:"example-11"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   type Parent is tagged\n      record\n         C1 : Float;\n         C2 : Float;\n      end record;\n\n   type Extension is new Parent with\n      record\n         C3 : Float;\n         C4 : Float;\n      end record;\n\n   Parent_Var : Parent := (C1 => Float_Var1, C2 => Float_Var2);\n   Exten_Var  : Extension;\n   ...\n   -- Simple aggregate\n   -- (See ACES V2.0, test "a9_ob_simp_aggregate_02")\n   Exten_Var := (C1 => Float_Var1, C2 => Float_Var2,\n                 C3 => Float_Var3, C4 => Float_Var4);\n   -- Extension aggregate\n   -- (See ACES V2.0, test "a9_ob_ext_aggregate_02")\n   Exten_Var := (Parent_Var with C3 => Float_Var3, C4 => Float_Var4);\n')),(0,t.kt)("h4",c({},{id:"rationale-14"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of using extension aggregates. There may be a\nsignificant performance difference between evaluation of simple\naggregates and evaluation of extension aggregates."),(0,t.kt)("h3",c({},{id:"protected-types"}),"Protected Types"),(0,t.kt)("h4",c({},{id:"guideline-15"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"For mutual exclusion, when measured performance indicates, use\nprotected types as an alternative to tasking rendezvous."),(0,t.kt)("li",{parentName:"ul"},"To implement an interrupt handler, when performance measurement\nindicates, use a protected procedure.")),(0,t.kt)("h4",c({},{id:"example-12"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   -- (1) Using protected objects\n   --     (See ACES V2.0, test "a9_pt_prot_access_02")\n   protected Object is\n      function Read return Float;\n      procedure Write (Value : in Float);\n   private\n      Data : Float;\n   end Object;\n   protected body Object is\n      function Read return Float is\n      begin\n         return Data;\n      end Read;\n      procedure Write (Value : in Float) is\n      begin\n         Data := Value;\n      end Write;\n   end Object;\n   task type Modify is\n   end Modify;\n   type Mod_Bunch is array (1 .. 5) of Modify;\n   task body Modify is\n      ...\n   begin -- Modify\n      for I in 1 .. 200 loop\n         The_Value := Object.Read;\n         Object.Write (The_Value - 0.125);\n         if The_Value < -1.0E7 then\n            The_Value := 1.0;\n         end if;\n      end loop;\n   end Modify;\n   ...\n   -- Block statement to be timed\n   declare\n      Contending_Tasks : array (1 .. 5) of Modify;\n   begin\n      null;  -- 5 tasks contend for access to protected data\n   end;\n   ------------------------------------------------------------------------------\n   -- (2) Using monitor task\n   --     (See ACES V2.0, test "tk_rz_entry_access_02")\n   Task Object is\n      entry Write (Value : in     Float);\n      entry Read  (Value :    out Float);\n   end Object;\n   task body Object is\n      Data : Float;\n   begin -- Object\n      loop\n         select\n            accept Write (Value : in     Float) do\n               Data := Value;\n            end Write;\n         or\n            accept Read  (Value :    out Float) do\n               Value := Data;\n            end Read;\n         or\n            terminate;\n         end select;\n      end loop;\n   end Object;\n   -- Task type Modify declared as above\n   -- Block statement to be timed as above\n')),(0,t.kt)("h4",c({},{id:"rationale-15"}),"rationale"),(0,t.kt)("p",null,"Protected objects are meant to be much faster than tasks used for the\nsame purpose (see Guideline 6.1.1). Determine the impact of using\nprotected objects to provide access safely to encapsulated data in a\nconcurrent program."),(0,t.kt)("h3",c({},{id:"bit-operations-on-modular-types"}),"Bit Operations on Modular Types"),(0,t.kt)("h4",c({},{id:"guideline-16"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use modular types rather than packed Boolean arrays when measured\nperformance indicates.")),(0,t.kt)("h4",c({},{id:"example-13"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),'   -- (1) Packed Boolean arrays\n   --     (See ACES V2.0, test "dr_ba_bool_arrays_11")\n\n   type Set is array (0 .. 15) of Boolean;\n   pragma Pack (Set);\n\n   S1     : Set;\n   S2     : Set;\n   Empty  : Set := (Set\'Range => False);\n   Result : Boolean;\n\n   ...\n\n   -- Is S1 a subset of S2?\n   Result := ((S1 and not S2) = Empty);\n\n   ---------------------------------------------------------------------\n\n   -- (2) Modular types\n   --     (See ACES V2.0, test "a9_ms_modular_oper_02")\n\n   type Set is mod 16;\n\n   S1     : Set;\n   S2     : Set;\n   Empty  : Set := 0;\n   Result : Boolean;\n\n   ...\n\n   -- Is S1 a subset of S2?\n   Result := ((S1 and not S2) = Empty);\n')),(0,t.kt)("h4",c({},{id:"rationale-16"}),"rationale"),(0,t.kt)("p",null,"Determine the impact of performing bit-wise operations on modular types.\nThe performance of these operations may be significantly different from\nsimilar operations on packed Boolean arrays. See also Guideline 10.5.7."),(0,t.kt)("h3",c({},{id:"bounded-strings"}),"Bounded Strings"),(0,t.kt)("h4",c({},{id:"guideline-17"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use the predefined bounded strings when predictable performance is\nan issue and measured performance indicates.")),(0,t.kt)("h4",c({},{id:"rationale-17"}),"rationale"),(0,t.kt)("p",null,"The unbounded strings may be allocated on the heap. If bounded strings\nare not allocated on the heap, then they may provide better performance.\nDetermine the impact of using the string type declared in instantiations\nof Ada.Strings.Bounded.Generic","_","Bounded","_","Length versus the type declared\nin Ada.Strings.Unbounded."),(0,t.kt)("p",null,"The predefined Ada 95 language environment defines packages that support\nboth bounded and unbounded strings. Using bounded strings may avoid the\nunpredictable duration of delays associated with using heap storage."),(0,t.kt)("h3",c({},{id:"string-handling-subprograms"}),"String Handling Subprograms"),(0,t.kt)("h4",c({},{id:"guideline-18"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use the procedural form of the string handling subprograms when\nmeasured performance indicates.")),(0,t.kt)("h4",c({},{id:"rationale-18"}),"rationale"),(0,t.kt)("p",null,"Determine the relative performance cost of functions and procedures\nhaving the same name and functionality in Ada.Strings.Fixed,\nAda.Strings.Bounded, Ada.Strings.Unbounded and the corresponding child\npackages whose names include Wide."),(0,t.kt)("p",null,"While functional notation typically leads to clearer code, it may cause\nthe compiler to generate additional copying operations."),(0,t.kt)("h3",c({},{id:"constraint-checking"}),"Constraint Checking"),(0,t.kt)("h4",c({},{id:"guideline-19"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use strong typing with carefully selected constraints to reduce\nrun-time constraint checking when measured performance indicates.")),(0,t.kt)("h4",c({},{id:"example-14"}),"example"),(0,t.kt)("p",null,"In this example, two potential constraint checks are eliminated. If the\nfunction Get","_","Response returns String, then the initialization of the\nvariable Input would require constraint checking. If the variable Last\nis type Positive, then the assignment inside the loop would require\nconstraint checking:"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"   ...\n   subtype Name_Index is Positive range 1 .. 32;\n   subtype Name       is String (Name_Index);\n   ...\n   function Get_Response return Name is separate;\n   ...\nbegin\n   ...\n   Find_Last_Period:\n      declare\n         -- No Constraint Checking needed for initialization\n         Input       : constant Name       := Get_Response;\n         Last_Period :          Name_Index := 1;\n      begin  -- Find_Last_Period\n         for I in Input'Range loop\n            if Input(I) = '.' then\n               -- No Constraint Checking needed in  this `tight' loop\n               Last_Period := I;\n            end if;\n         end loop;\n         ...\n      end Find_Last_Period;\n")),(0,t.kt)("h4",c({},{id:"rationale-19"}),"rationale"),(0,t.kt)("p",null,"Because run-time constraint checking is associated with slow\nperformance, it is not intuitive that the addition of constrained\nsubtypes could actually improve performance. However, the need for\nconstraint checking appears in many places regardless of the use of\nconstrained subtypes. Even assignments to variables that use the\npredefined subtypes may need constraint checks. By consistently using\nconstrained subtypes, many of the unnecessary run-time checking can be\neliminated. Instead, the checking is usually moved to less frequently\nexecuted code involved in system input. In the example, the function\nGet","_","Response may need to check the length of a user-supplied string and\nraise an exception."),(0,t.kt)("p",null,'Some compilers can do additional optimizations based on the information\nprovided by constrained subtypes. For example, although an unconstrained\narray does not have a fixed size, it has a maximum size that can be\ndetermined from the range of its index. Performance can be improved by\nlimiting this maximum size to a "reasonable" number. Refer to the\ndiscussion on unconstrained arrays found in NASA (1992).'),(0,t.kt)("h3",c({},{id:"real-time-system-annex"}),"Real-Time System Annex"),(0,t.kt)("h4",c({},{id:"guideline-20"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"For cases where both rendezvous and protected types are inefficient,\nconsider the use of the Real-Time Systems Annex (Ada Reference\nManual 1995, Annex D).")),(0,t.kt)("h4",c({},{id:"rationale-20"}),"rationale"),(0,t.kt)("p",null,"The packages Ada.Synchronous","_","Task","_","Control and\nAda.Asynchronous","_","Task","_","Control have been defined to provide an\nalternative to tasking and protected types for use in applications where\na minimal run-time is desired (Ada Reference Manual 1995, Annex D)."),(0,t.kt)("h2",c({},{id:"pragmas"}),"Pragmas"),(0,t.kt)("h3",c({},{id:"pragma-inline"}),"Pragma Inline"),(0,t.kt)("h4",c({},{id:"guideline-21"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"When measured performance indicates, use pragma Inline when calling\noverhead is a significant portion of the routine's execution time.")),(0,t.kt)("h4",c({},{id:"example-15"}),"example"),(0,t.kt)("pre",null,(0,t.kt)("code",c({parentName:"pre"},{className:"language-ada"}),"procedure Assign (Variable : in out Integer;\n                  Value    : in     Integer);\npragma Inline (Assign);\n...\nprocedure Assign (Variable : in out Integer;\n                  Value    : in     Integer) is\nbegin\n   Variable := Value;\nend Assign;\n")),(0,t.kt)("h4",c({},{id:"rationale-21"}),"rationale"),(0,t.kt)("p",null,"If calling overhead is a significant portion of a subprogram's execution\ntime, then using pragma Inline may reduce execution time."),(0,t.kt)("p",null,"Procedure and function invocations include overhead that is unnecessary\nwhen the code involved is very small. These small routines are usually\nwritten to maintain the implementation hiding characteristics of a\npackage. They may also simply pass their parameters unchanged to another\nroutine. When one of these routines appears in some code that needs to\nrun faster, either the implementation-hiding principle needs to be\nviolated or a pragma Inline can be introduced."),(0,t.kt)("p",null,"The use of pragma Inline does have its disadvantages. It can create\ncompilation dependencies on the body; that is, when the specification\nuses a pragma Inline, both the specification and corresponding body may\nneed to be compiled before the specification can be used. As updates are\nmade to the code, a routine may become more complex (larger) and the\ncontinued use of a pragma Inline may no longer be justified."),(0,t.kt)("h4",c({},{id:"exceptions"}),"exceptions"),(0,t.kt)("p",null,"Although it is rare, inlining code may increase code size, which can\nlead to slower performance caused by additional paging. A pragma Inline\nmay actually thwart a compiler's attempt to use some other optimization\ntechnique, such as register optimization."),(0,t.kt)("p",null,"When a compiler is already doing a good job of selecting routines to be\ninlined, the pragma may accomplish little, if any, improvement in\nexecution speed."),(0,t.kt)("h3",c({},{id:"pragma-restrictions"}),"Pragma Restrictions"),(0,t.kt)("h4",c({},{id:"guideline-22"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Restrictions to express the user's intent to abide by\ncertain restrictions.")),(0,t.kt)("h4",c({},{id:"rationale-22"}),"rationale"),(0,t.kt)("p",null,"This may facilitate the construction of simpler run-time environments\n(Ada Reference Manual 1995, \xa7\xa713.12, D.7, and H.4)."),(0,t.kt)("h3",c({},{id:"pragma-preelaborate"}),"Pragma Preelaborate"),(0,t.kt)("h4",c({},{id:"guideline-23"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Preelaborate where allowed.")),(0,t.kt)("h4",c({},{id:"rationale-23"}),"rationale"),(0,t.kt)("p",null,"This may reduce memory write operations after load time (Ada Reference\nManual 1995, \xa7\xa710.2.1 and C.4)."),(0,t.kt)("h3",c({},{id:"pragma-pure"}),"Pragma Pure"),(0,t.kt)("h4",c({},{id:"guideline-24"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Pure where allowed.")),(0,t.kt)("h4",c({},{id:"rationale-24"}),"rationale"),(0,t.kt)("p",null,"This may permit the compiler to omit calls on library-level subprograms\nof the library unit if the results are not needed after the call (Ada\nReference Manual 1995, \xa710.2.1)."),(0,t.kt)("h3",c({},{id:"pragma-discard_names"}),"Pragma Discard","_","Names"),(0,t.kt)("h4",c({},{id:"guideline-25"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Discard","_","Names when the names are not needed by the\napplication and data space is at a premium.")),(0,t.kt)("h4",c({},{id:"rationale-25"}),"rationale"),(0,t.kt)("p",null,"This may reduce the memory needed to store names of Ada entities, where\nno operation uses those names (Ada Reference Manual 1995, \xa7C.5)."),(0,t.kt)("h3",c({},{id:"pragma-suppress"}),"Pragma Suppress"),(0,t.kt)("h4",c({},{id:"guideline-26"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Suppress where necessary to achieve performance\nrequirements.")),(0,t.kt)("h4",c({},{id:"rationale-26"}),"rationale"),(0,t.kt)("p",null,"See Guideline 5.9.5."),(0,t.kt)("h3",c({},{id:"pragma-reviewable"}),"Pragma Reviewable"),(0,t.kt)("h4",c({},{id:"guideline-27"}),"guideline"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use pragma Reviewable to aid in the analysis of the generated code.")),(0,t.kt)("h4",c({},{id:"rationale-27"}),"rationale"),(0,t.kt)("p",null,"See the Ada Reference Manual (1995, Annex H)."),(0,t.kt)("h2",c({},{id:"summary"}),"Summary"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use the guidelines in this chapter with care; they may be hazardous\nto your software.")),(0,t.kt)("h4",c({},{id:"program-structure-1"}),"program structure"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use blocks to introduce late initialization when measured\nperformance indicates .")),(0,t.kt)("h3",c({},{id:"data-structures-1"}),"data structures"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use constrained arrays when measured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use zero-based indexing for arrays when measured performance\nindicates."),(0,t.kt)("li",{parentName:"ul"},"Use fixed-size components for records when measured performance\nindicates."),(0,t.kt)("li",{parentName:"ul"},"Define arrays of records as parallel arrays when measured\nperformance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use a sequence of assignments for an aggregation when measured\nperformance indicates.")),(0,t.kt)("h3",c({},{id:"algorithms-1"}),"algorithms"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use incremental schemes instead of mod and rem when measured\nperformance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use the short-circuit control form when measured performance\nindicates."),(0,t.kt)("li",{parentName:"ul"},"Use the case statement when measured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use hard-coded constraint checking when measured performance\nindicates."),(0,t.kt)("li",{parentName:"ul"},"Use column-first processing of two-dimensional arrays when measured\nperformance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use overwriting for conditional assignment when measured performance\nindicates."),(0,t.kt)("li",{parentName:"ul"},"When measured performance indicates, perform packed Boolean array\nshift operations by using slice assignments rather than repeated\nbit-wise assignment."),(0,t.kt)("li",{parentName:"ul"},"Use static subprogram dispatching when measured performance\nindicates.\\<")),(0,t.kt)("h3",c({},{id:"types-1"}),"types"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Use only simple aggregates when measured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"For mutual exclusion, when measured performance indicates, use\nprotected types as an alternative to tasking rendezvous."),(0,t.kt)("li",{parentName:"ul"},"To implement an interrupt handler, when measured performance\nindicates, use a protected procedure."),(0,t.kt)("li",{parentName:"ul"},"Use modular types rather than packed Boolean arrays when measured\nperformance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use the predefined bounded strings when predictable performance is\nan issue and measured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use the procedural form of the string handling subprograms when\nmeasured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"Use strong typing with carefully selected constraints to reduce\nrun-time constraint checking when measured performance indicates."),(0,t.kt)("li",{parentName:"ul"},"For cases where both rendezvous and protected types are inefficient,\nconsider the use of the Real-Time Systems Annex (Ada Reference\nManual 1995, Annex D).")),(0,t.kt)("h3",c({},{id:"pragmas-1"}),"pragmas"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"When measured performance indicates, use pragma Inline when calling\noverhead is a significant portion of the routine's execution time."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Restrictions to express the user's intent to abide by\ncertain restrictions."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Preelaborate where allowed."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Pure where allowed."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Discard","_","Names when the names are not needed by the\napplication and data space is at a premium."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Suppress where necessary to achieve performance\nrequirements."),(0,t.kt)("li",{parentName:"ul"},"Use pragma Reviewable to aid in the analysis of the generated code.\n:::note")),(0,t.kt)("p",null,'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,t.kt)("a",c({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,t.kt)("a",c({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply.  Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work."),(0,t.kt)("p",null,":::"))}v.isMDXComponent=!0}}]);