"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[810],{677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>A,contentTitle:()=>k,default:()=>y,frontMatter:()=>h,metadata:()=>f,toc:()=>b});var a=n(1716),o=n(9464),r=Object.defineProperty,i=Object.defineProperties,l=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,c=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,m=(e,t)=>{for(var n in t||(t={}))u.call(t,n)&&c(e,n,t[n]);if(s)for(var n of s(t))d.call(t,n)&&c(e,n,t[n]);return e};const h={sidebar_position:79},k="9.8 Abort of a Task - Abort of a Sequence of Statements",f={unversionedId:"arm/AA-9/AA-9.8",id:"arm/AA-9/AA-9.8",title:"9.8 Abort of a Task - Abort of a Sequence of Statements",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-9/AA-9.8.mdx",sourceDirName:"arm/AA-9",slug:"/arm/AA-9/AA-9.8",permalink:"/docs/arm/AA-9/AA-9.8",draft:!1,tags:[],version:"current",sidebarPosition:79,frontMatter:{sidebar_position:79},sidebar:"referenceManualSidebar",previous:{title:"9.7 Select Statements",permalink:"/docs/arm/AA-9/AA-9.7"},next:{title:"9.9 Task and Entry Attributes",permalink:"/docs/arm/AA-9/AA-9.9"}},A={},b=[{value:"Syntax",id:"syntax",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],p={toc:b};function y(e){var t,n=e,{components:r}=n,c=((e,t)=>{var n={};for(var a in e)u.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=m(m({},p),c),i(t,l({components:r,mdxType:"MDXLayout"}))),(0,a.kt)("h1",m({},{id:"98-abort-of-a-task---abort-of-a-sequence-of-statements"}),"9.8 Abort of a Task - Abort of a Sequence of Statements"),(0,a.kt)("admonition",m({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.kt)("a",m({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," causes one or more tasks to become abnormal, thus preventing any further interaction with such tasks. The completion of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0282"},"triggering_statement"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," causes a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," to be aborted.] ",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("code",null,"abort_statement"),(0,a.kt)("a",{id:"S0284"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"abort")," ",(0,a.kt)("em",null,"task_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," ","{",", ",(0,a.kt)("em",null,"task_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"}",";",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0444-1"),"}"," ",(0,a.kt)("br",null),"Each ",(0,a.kt)("em",null,"task_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is expected to be of any task type[; each can be of a different task type.]",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)("p",null,"For the execution of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),", the given ",(0,a.kt)("em",null,"task_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"s are evaluated in an arbitrary order. Each named task is then ",(0,a.kt)("em",null,"aborted"),", which consists of making the task ",(0,a.kt)("em",null,"abnormal")," and aborting the execution of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body")),", unless it is already completed. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"{",(0,a.kt)("em",null,"AI95-00114-01"),"}"," ",(0,a.kt)("br",null),"Note that aborting those tasks is not defined to be an abort-deferred operation. Therefore, if one of the named tasks is the task executing the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),", or if the task executing the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," depends on one of the named tasks, then it is possible for the execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),' to be aborted, thus leaving some of the tasks unaborted. This allows the implementation to use either a sequence of calls to an "abort task" run-time system primitive, or a single call to an "abort list of tasks" run-time system primitive. ',(0,a.kt)("br",null)),(0,a.kt)("p",null,"When the execution of a construct is ",(0,a.kt)("em",null,"aborted")," (including that of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body"))," or of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),"), the execution of every construct included within the aborted execution is also aborted, except for executions included within the execution of an ",(0,a.kt)("em",null,"abort-deferred")," operation; the execution of an abort-deferred operation continues to completion without being affected by the abort; the following are the abort-deferred operations: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"a protected action;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"waiting for an entry call to complete (after having initiated the attempt to cancel it - see below);",(0,a.kt)("br",null)),(0,a.kt)("li",null,"waiting for the termination of dependent tasks;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the execution of an Initialize procedure as the last step of the default initialization of a controlled object;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the execution of a Finalize procedure as part of the finalization of a controlled object;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"an assignment operation to an object with a controlled part. ",(0,a.kt)("br",null))),(0,a.kt)("p",null,"[The last three of these are discussed further in 7.6.] ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Deferring abort during Initialize and finalization allows, for example, the result of an allocator performed in an Initialize operation to be assigned into an access object without being interrupted in the middle, which would cause storage leaks. For an object with several controlled parts, each individual Initialize is abort-deferred. Note that there is generally no semantic difference between making each Finalize abort-deferred, versus making a group of them abort-deferred, because if the task gets aborted, the first thing it will do is complete any remaining finalizations. Individual objects are finalized prior to an assignment operation (if nonlimited controlled) and as part of Unchecked_Deallocation. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'Abort is deferred during the entire assignment operation to an object with a controlled part, even if only some subcomponents are controlled. Note that this says "assignment operation", not "',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.2#S0173"},"assignment_statement")),'". Explicit calls to Initialize, Finalize, or Adjust are not abort-deferred. ',(0,a.kt)("br",null)),(0,a.kt)("p",null,"When a master is aborted, all tasks that depend on that master are aborted.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"The order in which tasks become abnormal as the result of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," or the abort of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," is not specified by the language.",(0,a.kt)("br",null)),(0,a.kt)("p",null,"If the execution of an entry call is aborted, an immediate attempt is made to cancel the entry call (see 9.5.3). If the execution of a construct is aborted at a time when the execution is blocked, other than for an entry call, at a point that is outside the execution of an abort-deferred operation, then the execution of the construct completes immediately. For an abort due to an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),", these immediate effects occur before the execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," completes. Other than for these immediate cases, the execution of a construct that is aborted does not necessarily complete before the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," completes. However, the execution of the aborted construct completes no later than its next ",(0,a.kt)("em",null,"abort completion point")," (if any) that occurs outside of an abort-deferred operation; the following are abort completion points for an execution: ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"the point where the execution initiates the activation of another task;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the end of the activation of a task;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0119-1"),"}"," ",(0,a.kt)("br",null),"a point within a parallel construct where a new logical thread of control is created;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"{",(0,a.kt)("em",null,"AI12-0119-1"),"}"," ",(0,a.kt)("br",null),"the end of a parallel construct;",(0,a.kt)("br",null)),(0,a.kt)("li",null,"the start or end of the execution of an entry call, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.6#S0266"},"delay_statement")),", or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),"; ",(0,a.kt)("br",null))),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Although the abort completion point doesn't occur until the end of the entry call or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.6#S0266"},"delay_statement")),", these operations might be cut short because an abort attempts to cancel them. ",(0,a.kt)("br",null)),(0,a.kt)("ul",null,(0,a.kt)("li",null,"the start of the execution of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),", or of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),". ",(0,a.kt)("br",null))),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The start of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler"))," is considered an abort completion point simply because it is easy for an implementation to check at such points. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Implementations may of course check for abort more often than at each abort completion point; ideally, a fully preemptive implementation of abort will be provided. If preemptive abort is not supported in a given environment, then supporting the checking for abort as part of subprogram calls and loop iterations might be a useful option. ",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"bounded-run-time-errors"}),"Bounded (Run-Time) Errors"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0264-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0445-1"),"}"," ",(0,a.kt)("br",null),"An attempt to execute an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," as part of the execution of an abort-deferred operation is a bounded error. Similarly, an attempt to create a task that depends on a master that is included entirely within the execution of an abort-deferred operation is a bounded error. In both cases, Program_Error is raised if the error is detected by the implementation; otherwise, the operations proceed as they would outside an abort-deferred operation, except that an abort of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0283"},"abortable_part"))," or the created task does not necessarily have an effect. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," relies on an abort of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0283"},"abortable_part"))," to effect the asynchronous transfer of control. For an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," within an abort-deferred operation, the abort might have no effect.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"Creating a task dependent on a master included within an abort-deferred operation is considered an error, because such tasks could be aborted while the abort-deferred operation was still progressing, undermining the purpose of abort-deferral. Alternatively, we could say that such tasks are abort-deferred for their entire execution, but that seems too easy to abuse. Note that task creation is already a bounded error in protected actions, so this additional rule only applies to local task creation as part of Initialize, Finalize, or Adjust. ",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"erroneous-execution"}),"Erroneous Execution"),(0,a.kt)("p",null,"If an assignment operation completes prematurely due to an abort, the assignment is said to be ",(0,a.kt)("em",null,"disrupted"),"; the target of the assignment or its parts can become abnormal, and certain subsequent uses of the object can be erroneous, as explained in 13.9.1. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 1   ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," ",(0,a.kt)("br",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement"))," is best used only in situations requiring unconditional termination.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"NOTE 2   A task is allowed to abort any task it can name, including itself.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},'NOTE 3   Additional requirements associated with abort are given in D.6, "Preemptive Abort". ',(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"This subclause has been rewritten to accommodate the concept of aborting the execution of a construct, rather than just of a task. ",(0,a.kt)("br",null)),(0,a.kt)("h4",m({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0119-1"),"}"," ",(0,a.kt)("br",null),"Added points within parallel constructs to the list of abort completion points. ",(0,a.kt)("br",null)))}y.isMDXComponent=!0}}]);