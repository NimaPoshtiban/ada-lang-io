"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3087],{32297:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=a(58168),t=(a(96540),a(15680));const o={title:"5.1 Optional Parts of the Syntax"},l=void 0,s={unversionedId:"style-guide/s5/01",id:"style-guide/s5/01",title:"5.1 Optional Parts of the Syntax",description:"Parts of the Ada syntax, while optional, can enhance the readability of",source:"@site/docs/style-guide/s5/01.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/01",permalink:"/docs/style-guide/s5/01",draft:!1,tags:[],version:"current",frontMatter:{title:"5.1 Optional Parts of the Syntax"},sidebar:"styleGuideSidebar",previous:{title:"5. Programming Practices",permalink:"/docs/style-guide/s5/"},next:{title:"5.2 Parameter Lists",permalink:"/docs/style-guide/s5/02"}},r={},d=[{value:"Loop Names",id:"loop-names",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Block Names",id:"block-names",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"Exit Statements",id:"exit-statements",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Naming End Statements",id:"naming-end-statements",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4}],u={toc:d},g="wrapper";function p(e){let{components:n,...a}=e;return(0,t.yg)(g,(0,i.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("p",null,"Parts of the Ada syntax, while optional, can enhance the readability of\nthe code. The guidelines given below concern use of some of these\noptional features."),(0,t.yg)("h3",{id:"loop-names"},"Loop Names"),(0,t.yg)("h4",{id:"guideline"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Associate names with loops when they are nested (Booch 1986, 1987)."),(0,t.yg)("li",{parentName:"ul"},"Associate names with any loop that contains an ",(0,t.yg)("inlineCode",{parentName:"li"},"exit"),"statement.")),(0,t.yg)("h4",{id:"example"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},"Process_Each_Page:\n   loop\n      Process_All_The_Lines_On_This_Page:\n         loop\n            ...\n            exit Process_All_The_Lines_On_This_Page when Line_Number = Max_Lines_On_Page;\n            ...\n            Look_For_Sentinel_Value:\n               loop\n                  ...\n                  exit Look_For_Sentinel_Value when Current_Symbol = Sentinel;\n                  ...\n               end loop Look_For_Sentinel_Value;\n            ...\n         end loop Process_All_The_Lines_On_This_Page;\n      ...\n      exit Process_Each_Page when Page_Number = Maximum_Pages;\n      ...\n   end loop Process_Each_Page;\n")),(0,t.yg)("h4",{id:"rationale"},"rationale"),(0,t.yg)("p",null,"When you associate a name with a loop, you must include that name with\nthe associated end for that loop (Ada Reference Manual 1995). This helps\nreaders find the associated end for any given loop. This is especially\ntrue if loops are broken over screen or page boundaries. The choice of a\ngood name for the loop documents its purpose, reducing the need for\nexplanatory comments. If a name for a loop is very difficult to choose,\nthis could indicate a need for more thought about the algorithm."),(0,t.yg)("p",null,"Regularly naming loops helps you follow Guideline 5.1.3. Even in the\nface of code changes, for example, adding an outer or inner loop, the\n",(0,t.yg)("inlineCode",{parentName:"p"},"exit")," statement does not become ambiguous."),(0,t.yg)("p",null,"It can be difficult to think up a name for every loop; therefore, the\nguideline specifies nested loops. The benefits in readability and second\nthought outweigh the inconvenience of naming the loops."),(0,t.yg)("h3",{id:"block-names"},"Block Names"),(0,t.yg)("h4",{id:"guideline-1"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Associate names with blocks when they are nested.")),(0,t.yg)("h4",{id:"example-1"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},"Trip:\n   declare\n      ...\n   begin  -- Trip\n      Arrive_At_Airport:\n         declare\n            ...\n         begin  -- Arrive_At_Airport\n            Rent_Car;\n            Claim_Baggage;\n            Reserve_Hotel;\n            ...\n         end Arrive_At_Airport;\n      Visit_Customer:\n         declare\n            ...\n         begin  -- Visit_Customer\n            -- again a set of activities...\n            ...\n         end Visit_Customer;\n      Departure_Preparation:\n         declare\n            ...\n         begin  -- Departure_Preparation\n            Return_Car;\n            Check_Baggage;\n            Wait_For_Flight;\n            ...\n         end Departure_Preparation;\n      Board_Return_Flight;\n   end Trip;\n")),(0,t.yg)("h4",{id:"rationale-1"},"rationale"),(0,t.yg)("p",null,"When there is a nested block structure, it can be difficult to determine\nwhich ",(0,t.yg)("inlineCode",{parentName:"p"},"end")," corresponds to which block. Naming blocks alleviates this\nconfusion. The choice of a good name for the block documents its\npurpose, reducing the need for explanatory comments. If a name for the\nblock is very difficult to choose, this could indicate a need for more\nthought about the algorithm."),(0,t.yg)("p",null,"This guideline is also useful if nested blocks are broken over a screen\nor page boundary."),(0,t.yg)("p",null,"It can be difficult to think up a name for each block; therefore, the\nguideline specifies nested blocks. The benefits in readability and\nsecond thought outweigh the inconvenience of naming the blocks."),(0,t.yg)("h3",{id:"exit-statements"},"Exit Statements"),(0,t.yg)("h4",{id:"guideline-2"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Use loop names on all ",(0,t.yg)("inlineCode",{parentName:"li"},"exit")," statements from nested loops.")),(0,t.yg)("h4",{id:"example-2"},"example"),(0,t.yg)("p",null,"See the example in 5.1.1 ."),(0,t.yg)("h4",{id:"rationale-2"},"rationale"),(0,t.yg)("p",null,"An ",(0,t.yg)("inlineCode",{parentName:"p"},"exit"),"statement is an implicit ",(0,t.yg)("inlineCode",{parentName:"p"},"goto"),". It should specify its source\nexplicitly. When there is a nested loop structure and an ",(0,t.yg)("inlineCode",{parentName:"p"},"exit"),"statement\nis used, it can be difficult to determine which loop is being exited.\nAlso, future changes that may introduce a nested loop are likely to\nintroduce an error, with the ",(0,t.yg)("inlineCode",{parentName:"p"},"exit")," accidentally exiting from the wrong\nloop. Naming loops and their exits alleviates this confusion. This\nguideline is also useful if nested loops are broken over a screen or\npage boundary."),(0,t.yg)("h3",{id:"naming-end-statements"},"Naming End Statements"),(0,t.yg)("h4",{id:"guideline-3"},"guideline"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Include the defining program unit name at the end of a package\nspecification and body."),(0,t.yg)("li",{parentName:"ul"},"Include the defining identifier at the end of a task specification\nand body."),(0,t.yg)("li",{parentName:"ul"},"Include the entry identifier at the end of an ",(0,t.yg)("inlineCode",{parentName:"li"},"accept"),"statement."),(0,t.yg)("li",{parentName:"ul"},"Include the designator at the end of a subprogram body."),(0,t.yg)("li",{parentName:"ul"},"Include the defining identifier at the end of a protected unit\ndeclaration.")),(0,t.yg)("h4",{id:"example-3"},"example"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-ada"},"------------------------------------------------------------------------\npackage Autopilot is\n   function Is_Engaged return Boolean;\n   procedure Engage;\n   procedure Disengage;\nend Autopilot;\n------------------------------------------------------------------------\npackage body Autopilot is\n   ...\n   ---------------------------------------------------------------------\n   task Course_Monitor is\n      entry Reset (Engage : in     Boolean);\n   end Course_Monitor;\n   ---------------------------------------------------------------------\n   function Is_Engaged return Boolean is\n   ...\n   end Is_Engaged;\n   ---------------------------------------------------------------------\n   procedure Engage is\n   ...\n   end Engage;\n   ---------------------------------------------------------------------\n   procedure Disengage is\n   ...\n   end Disengage;\n   ---------------------------------------------------------------------\n   task body Course_Monitor is\n   ...\n         accept Reset (Engage : in     Boolean) do\n            ...\n         end Reset;\n   ...\n   end Course_Monitor;\n   ---------------------------------------------------------------------\nend Autopilot;\n------------------------------------------------------------------------\n")),(0,t.yg)("h4",{id:"rationale-3"},"rationale"),(0,t.yg)("p",null,"Repeating names on the end of these compound statements ensures\nconsistency throughout the code. In addition, the named ",(0,t.yg)("inlineCode",{parentName:"p"},"end")," provides a\nreference for the reader if the unit spans a page or screen boundary or\nif it contains a nested unit."))}p.isMDXComponent=!0}}]);