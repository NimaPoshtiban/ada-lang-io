"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[7014],{1716:(e,a,t)=>{t.d(a,{Zo:()=>h,kt:()=>C});var r=t(6687);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var s=r.createContext({}),l=function(e){var a=r.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):c(c({},a),e)),t},h=function(e){var a=l(e.components);return r.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},u=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),u=l(t),C=n,p=u["".concat(s,".").concat(C)]||u[C]||d[C]||i;return t?r.createElement(p,c(c({ref:a},h),{},{components:t})):r.createElement(p,c({ref:a},h))}));function C(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var i=t.length,c=new Array(i);c[0]=u;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,c[1]=o;for(var l=2;l<i;l++)c[l]=t[l];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},6840:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(9440),n=(t(6687),t(1716));const i={sidebar_position:120},c="A.3  Character Handling",o={unversionedId:"arm/AA-A.3",id:"arm/AA-A.3",title:"A.3  Character Handling",description:"{AI05-0243-1} {AI05-0299-1} This subclause presents the packages related to character processing: an empty declared pure package Characters and child packages Characters.Handling and Characters.Latin1. The package Characters.Handling provides classification and conversion functions for Character data, and some simple functions for dealing with WideCharacter and WideWideCharacter data. The child package Characters.Latin_1 declares a set of constants initialized to values of type Character.",source:"@site/docs/arm/AA-A.3.md",sourceDirName:"arm",slug:"/arm/AA-A.3",permalink:"/docs/arm/AA-A.3",draft:!1,tags:[],version:"current",sidebarPosition:120,frontMatter:{sidebar_position:120},sidebar:"tutorialSidebar",previous:{title:"A.2  The Package Ada",permalink:"/docs/arm/AA-A.2"},next:{title:"A.4  String Handling",permalink:"/docs/arm/AA-A.4"}},s={},l=[{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"A.3.1  The Packages Characters, Wide_Characters, and Wide_Wide_Characters",id:"a31--the-packages-characters-wide_characters-and-wide_wide_characters",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"A.3.2  The Package Characters.Handling",id:"a32--the-package-charactershandling",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"A.3.3  The Package Characters.Latin_1",id:"a33--the-package-characterslatin_1",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"A.3.4  The Package Characters.Conversions",id:"a34--the-package-charactersconversions",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-2",level:4},{value:"A.3.5  The Package Wide_Characters.Handling",id:"a35--the-package-wide_charactershandling",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-1",level:4},{value:"A.3.6  The Package Wide_Wide_Characters.Handling",id:"a36--the-package-wide_wide_charactershandling",level:2},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4}],h={toc:l};function d(e){let{components:a,...t}=e;return(0,n.kt)("wrapper",(0,r.Z)({},h,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"a3--character-handling"},"A.3  Character Handling"),(0,n.kt)("p",null,"{AI95-00285-01} {AI05-0243-1} {AI05-0299-1} This subclause presents the packages related to character processing: an empty declared pure package Characters and child packages Characters.Handling and Characters.Latin_1. The package Characters.Handling provides classification and conversion functions for Character data, and some simple functions for dealing with Wide_Character and Wide_Wide_Character data. The child package Characters.Latin_1 declares a set of constants initialized to values of type Character. "),(0,n.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,n.kt)("p",null,"{AI05-0299-1} This subclause is new to Ada 95. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,n.kt)("p",null,"{AI95-00285-01} Included Wide_Wide_Character in this description; the individual changes are documented as extensions as needed. "),(0,n.kt)("h2",{id:"a31--the-packages-characters-wide_characters-and-wide_wide_characters"},"A.3.1  The Packages Characters, Wide_Characters, and Wide_Wide_Characters"),(0,n.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,n.kt)("p",null,"The library package Characters has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Characters\n   with Pure is\nend Ada.Characters;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} The library package Wide_Characters has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Wide_Characters\n   with Pure is\nend Ada.Wide_Characters;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} The library package Wide_Wide_Characters has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Wide_Wide_Characters\n   with Pure is\nend Ada.Wide_Wide_Characters;\n\n")),(0,n.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,n.kt)("p",null,"{AI95-00395-01} {AI05-0185-1} If an implementation chooses to provide implementation-defined operations on Wide_Character or Wide_String (such as collating and sorting, etc.) it should do so by providing child units of Wide_Characters. Similarly if it chooses to provide implementation-defined operations on Wide_Wide_Character or Wide_Wide_String it should do so by providing child units of Wide_Wide_Characters. "),(0,n.kt)("p",null,"Implementation Advice: Implementation-defined operations on Wide_Character, Wide_String, Wide_Wide_Character, and Wide_Wide_String should be child units of Wide_Characters or Wide_Wide_Characters."),(0,n.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,n.kt)("p",null,"{AI95-00395-01} The packages Wide_Characters and Wide_Wide_Characters are new. "),(0,n.kt)("h2",{id:"a32--the-package-charactershandling"},"A.3.2  The Package Characters.Handling"),(0,n.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,n.kt)("p",null,"The library package Characters.Handling has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00362-01} {AI95-00395-01} {AI12-0414-1} with Ada.Characters.Conversions;\npackage Ada.Characters.Handling\n  with Pure is\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"--Character classification functions\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI05-0185-1} {AI12-0004-1}   function Is_Control           (Item : in Character) return Boolean;\n  function Is_Graphic           (Item : in Character) return Boolean;\n  function Is_Letter            (Item : in Character) return Boolean;\n  function Is_Lower             (Item : in Character) return Boolean;\n  function Is_Upper             (Item : in Character) return Boolean;\n  function Is_Basic             (Item : in Character) return Boolean;\n  function Is_Digit             (Item : in Character) return Boolean;\n  function Is_Decimal_Digit     (Item : in Character) return Boolean\n                     renames Is_Digit;\n  function Is_Hexadecimal_Digit (Item : in Character) return Boolean;\n  function Is_Alphanumeric      (Item : in Character) return Boolean;\n  function Is_Special           (Item : in Character) return Boolean;\n  function Is_Line_Terminator   (Item : in Character) return Boolean;\n  function Is_Mark              (Item : in Character) return Boolean;\n  function Is_Other_Format      (Item : in Character) return Boolean;\n  function Is_Punctuation_Connector (Item : in Character) return Boolean;\n  function Is_Space             (Item : in Character) return Boolean;\n  function Is_NFKC              (Item : in Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"--Conversion functions for Character and String\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  function To_Lower (Item : in Character) return Character;\n  function To_Upper (Item : in Character) return Character;\n  function To_Basic (Item : in Character) return Character;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  function To_Lower (Item : in String) return String;\n  function To_Upper (Item : in String) return String;\n  function To_Basic (Item : in String) return String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"--Classifications of and conversions between Character and ISO 646\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  subtype ISO_646 is\n    Character range Character'Val(0) .. Character'Val(127);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  function Is_ISO_646 (Item : in Character) return Boolean;\n  function Is_ISO_646 (Item : in String)    return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  function To_ISO_646 (Item       : in Character;\n                       Substitute : in ISO_646 := ' ')\n    return ISO_646;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"  function To_ISO_646 (Item       : in String;\n                       Substitute : in ISO_646 := ' ')\n    return String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00285-01} {AI95-00395-01} -- The functions Is_Character, Is_String, To_Character, To_String, To_Wide_Character,\n-- and To_Wide_String are obsolescent; see J.14.\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"Paragraphs 14 through 18 were deleted.\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"end Ada.Characters.Handling;\n\n")),(0,n.kt)("p",null,"Discussion: {AI95-00395-01} The ",(0,n.kt)("a",{parentName:"p",href:"./AA-10.1#S0294"},"with_clause")," for Ada.Characters.Conversions is needed for the definition of the obsolescent functions (see J.14). It would be odd to put this clause into J.14 as it was not present in Ada 95, and ",(0,n.kt)("a",{parentName:"p",href:"./AA-10.1#S0294"},"with_clause"),"s are semantically neutral to clients anyway. "),(0,n.kt)("p",null,"In the description below for each function that returns a Boolean result, the effect is described in terms of the conditions under which the value True is returned. If these conditions are not met, then the function returns False."),(0,n.kt)("p",null,"Each of the following classification functions has a formal Character parameter, Item, and returns a Boolean result. "),(0,n.kt)("p",null,"Is_Control True if Item is a control character. A control character is a character whose position is in one of the ranges 0..31 or 127..159."),(0,n.kt)("p",null,"Is_Graphic True if Item is a graphic character. A graphic character is a character whose position is in one of the ranges 32..126 or 160..255."),(0,n.kt)("p",null,"Is_Letter True if Item is a letter. A letter is a character that is in one of the ranges 'A'..'Z' or 'a'..'z', or whose position is in one of the ranges 192..214, 216..246, or 248..255."),(0,n.kt)("p",null,"Is_Lower True if Item is a lower-case letter. A lower-case letter is a character that is in the range 'a'..'z', or whose position is in one of the ranges 223..246 or 248..255."),(0,n.kt)("p",null,"Is_UpperTrue if Item is an upper-case letter. An upper-case letter is a character that is in the range 'A'..'Z' or whose position is in one of the ranges 192..214 or 216.. 222."),(0,n.kt)("p",null,"Is_Basic True if Item is a basic letter. A basic letter is a character that is in one of the ranges 'A'..'Z' and 'a'..'z', or that is one of the following: '\ufffd', '\ufffd', '\ufffd', '\ufffd', '\ufffd', '\ufffd', or '\ufffd'."),(0,n.kt)("p",null,"Is_Digit True if Item is a decimal digit. A decimal digit is a character in the range '0'..'9'."),(0,n.kt)("p",null,"Is_Decimal_Digit A renaming of Is_Digit."),(0,n.kt)("p",null,"Is_Hexadecimal_Digit True if Item is a hexadecimal digit. A hexadecimal digit is a character that is either a decimal digit or that is in one of the ranges 'A' .. 'F' or 'a' .. 'f'."),(0,n.kt)("p",null,"Is_Alphanumeric True if Item is an alphanumeric character. An alphanumeric character is a character that is either a letter or a decimal digit."),(0,n.kt)("p",null,"Is_Special True if Item is a special graphic character. A special graphic character is a graphic character that is not alphanumeric."),(0,n.kt)("p",null,"{AI05-0185-1} Is_Line_TerminatorTrue if Item is a character with position 10 .. 13 (Line_Feed, Line_Tabulation, Form_Feed, Carriage_Return) or 133 (Next_Line)."),(0,n.kt)("p",null,"{AI05-0185-1} Is_MarkNever True (no value of type Character has categories Mark, Non-Spacing or Mark, Spacing Combining)."),(0,n.kt)("p",null,"{AI05-0185-1} Is_Other_FormatTrue if Item is a character with position 173 (Soft_Hyphen)."),(0,n.kt)("p",null,"{AI05-0185-1} Is",(0,n.kt)("em",{parentName:"p"},"Punctuation_ConnectorTrue if Item is a character with position 95 ('"),"', known as Low_Line or Underscore)."),(0,n.kt)("p",null,"{AI05-0185-1} Is_SpaceTrue if Item is a character with position 32 (' ') or 160 (No_Break_Space)."),(0,n.kt)("p",null,"{AI12-0004-1} {AI12-0263-1} {AI12-0439-1} Is_NFKCTrue if Item can be present in a string normalized to Normalization Form KC (as defined by Clause 21 of ISO/IEC 10646:2017); this includes all characters except those with positions 160, 168, 170, 175, 178, 179, 180, 181, 184, 185, 186, 188, 189, and 190. "),(0,n.kt)("p",null,"Each of the names To_Lower, To_Upper, and To_Basic refers to two functions: one that converts from Character to Character, and the other that converts from String to String. The result of each Character-to-Character function is described below, in terms of the conversion applied to Item, its formal Character parameter. The result of each  String-to-String conversion is obtained by applying to each element of the function's String parameter the corresponding Character-to-Character conversion; the result is the null String if the value of the formal parameter is the null String. The lower bound of the result String is 1. "),(0,n.kt)("p",null,"To_LowerReturns the corresponding lower-case value for Item if Is_Upper(Item), and returns Item otherwise."),(0,n.kt)("p",null,"To_UpperReturns the corresponding upper-case value for Item if Is_Lower(Item) and Item has an upper-case form, and returns Item otherwise. The lower case letters '\ufffd' and '\ufffd' do not have upper case forms."),(0,n.kt)("p",null,"To_BasicReturns the letter corresponding to Item but with no diacritical mark, if Item is a letter but not a basic letter; returns Item otherwise. "),(0,n.kt)("p",null,"The following set of functions test for membership in the ISO 646 character range, or convert between ISO 646 and Character. "),(0,n.kt)("p",null,"Is_ISO_646The function whose formal parameter, Item, is of type Character returns True if Item is in the subtype ISO_646."),(0,n.kt)("p",null,"Is_ISO_646The function whose formal parameter, Item, is of type String returns True if Is_ISO_646(Item(I)) is True for each I in Item'Range."),(0,n.kt)("p",null,"To_ISO_646The function whose first formal parameter, Item, is of type Character returns Item if Is_ISO_646(Item), and returns the Substitute ISO_646 character otherwise."),(0,n.kt)("p",null,"To_ISO_646The function whose first formal parameter, Item, is of type String returns the String whose Range is 1..Item'Length and each of whose elements is given by To_ISO_646 of the corresponding element in Item. "),(0,n.kt)("p",null,"Paragraphs 42 through 49 were deleted. "),(0,n.kt)("p",null,"NOTE 1   A basic letter is a letter without a diacritical mark."),(0,n.kt)("p",null,"NOTE 2   Except for the hexadecimal digits, basic letters, and ISO_646 characters, the categories identified in the classification functions form a strict hierarchy: "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Control characters")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Graphic characters"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Alphanumeric characters"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Letters"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Upper-case letters")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Lower-case letters")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Decimal digits")))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Special graphic characters"))))),(0,n.kt)("p",null,"Ramification: Thus each Character value is either a control character or a graphic character but not both; each graphic character is either an alphanumeric or special graphic but not both; each alphanumeric is either a letter or decimal digit but not both; each letter is either upper case or lower case but not both."),(0,n.kt)("p",null,"NOTE 3   {AI05-0114-1} There are certain characters which are defined to be lower case letters by ISO 10646 and are therefore allowed in identifiers, but are not considered lower case letters by Ada.Characters.Handling."),(0,n.kt)("p",null,"Reason: {AI12-0263-1} This is to maintain runtime compatibility with the Ada 95 definitions of these functions. We don't list the exact characters involved because they're likely to change in future character set standards; the list for ISO 10646:2017 can be found in AI05-0114-1. "),(0,n.kt)("p",null,"Ramification: No version of Characters.Handling is intended to do portable (Ada-version independent) manipulation of Ada identifiers. The classification given by Wide_Characters.Handling will be correct for the current implementation for Ada 2012 identifiers, but it might not be correct for a different implementation or version of Ada. "),(0,n.kt)("h4",{id:"extensions-to-ada-95-1"},"Extensions to Ada 95"),(0,n.kt)("p",null,"{AI95-00362-01} Characters.Handling is now Pure, so it can be used in pure units. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,n.kt)("p",null,"{AI05-0185-1} Added additional classification routines so that Characters.Handling has all of the routines available in Wide_Characters.Handling. If Characters.Handling is referenced in a ",(0,n.kt)("a",{parentName:"p",href:"./AA-8.4#S0235"},"use_clause"),", and an entity E with a ",(0,n.kt)("a",{parentName:"p",href:"./AA-3.1#S0022"},"defining_identifier")," that is the same as one of the new functions is defined in a package that is also referenced in a ",(0,n.kt)("a",{parentName:"p",href:"./AA-8.4#S0235"},"use_clause"),", the entity E may no longer be use-visible, resulting in errors. This should be rare and is easily fixed if it does occur. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,n.kt)("p",null,"{AI95-00285-01} {AI95-00395-01} The conversion functions are made obsolescent; a more complete set is available in Characters.Conversions - see A.3.4."),(0,n.kt)("p",null,"{AI95-00285-01} {AI05-0248-1} We no longer talk about localized character sets; these are a nonstandard mode, which is none of our business. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{AI05-0114-1} Correction: Added a note to clarify that these functions don't have any relationship to the characters allowed in identifiers. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-2012"},"Incompatibilities With Ada 2012"),(0,n.kt)("p",null,"{AI12-0004-1} Added an additional classification routine Is_NFKC. Therefore, a use clause conflict is possible; see the introduction of Annex A for more on this topic. "),(0,n.kt)("h2",{id:"a33--the-package-characterslatin_1"},"A.3.3  The Package Characters.Latin_1"),(0,n.kt)("p",null,"The package Characters.Latin_1 declares constants for characters in ISO 8859-1. "),(0,n.kt)("p",null,"Reason: The constants for the ISO 646 characters could have been declared as renamings of objects declared in package ASCII, as opposed to explicit constants. The main reason for explicit constants was for consistency of style with the upper-half constants, and to avoid emphasizing the package ASCII."),(0,n.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,n.kt)("p",null,"The library package Characters.Latin_1 has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Characters.Latin_1\n    with Pure is\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Control characters:\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    NUL                  : constant Character := Character'Val(0);\n    SOH                  : constant Character := Character'Val(1);\n    STX                  : constant Character := Character'Val(2);\n    ETX                  : constant Character := Character'Val(3);\n    EOT                  : constant Character := Character'Val(4);\n    ENQ                  : constant Character := Character'Val(5);\n    ACK                  : constant Character := Character'Val(6);\n    BEL                  : constant Character := Character'Val(7);\n    BS                   : constant Character := Character'Val(8);\n    HT                   : constant Character := Character'Val(9);\n    LF                   : constant Character := Character'Val(10);\n    VT                   : constant Character := Character'Val(11);\n    FF                   : constant Character := Character'Val(12);\n    CR                   : constant Character := Character'Val(13);\n    SO                   : constant Character := Character'Val(14);\n    SI                   : constant Character := Character'Val(15);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    DLE                  : constant Character := Character'Val(16);\n    DC1                  : constant Character := Character'Val(17);\n    DC2                  : constant Character := Character'Val(18);\n    DC3                  : constant Character := Character'Val(19);\n    DC4                  : constant Character := Character'Val(20);\n    NAK                  : constant Character := Character'Val(21);\n    SYN                  : constant Character := Character'Val(22);\n    ETB                  : constant Character := Character'Val(23);\n    CAN                  : constant Character := Character'Val(24);\n    EM                   : constant Character := Character'Val(25);\n    SUB                  : constant Character := Character'Val(26);\n    ESC                  : constant Character := Character'Val(27);\n    FS                   : constant Character := Character'Val(28);\n    GS                   : constant Character := Character'Val(29);\n    RS                   : constant Character := Character'Val(30);\n    US                   : constant Character := Character'Val(31);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- ISO 646 graphic characters:\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    Space                : constant Character := ' ';  -- Character'Val(32)\n    Exclamation          : constant Character := '!';  -- Character'Val(33)\n    Quotation            : constant Character := '\"';  -- Character'Val(34)\n    Number_Sign          : constant Character := '#';  -- Character'Val(35)\n    Dollar_Sign          : constant Character := '$';  -- Character'Val(36)\n    Percent_Sign         : constant Character := '%';  -- Character'Val(37)\n    Ampersand            : constant Character := '&';  -- Character'Val(38)\n    Apostrophe           : constant Character := ''';  -- Character'Val(39)\n    Left_Parenthesis     : constant Character := '(';  -- Character'Val(40)\n    Right_Parenthesis    : constant Character := ')';  -- Character'Val(41)\n    Asterisk             : constant Character := '*';  -- Character'Val(42)\n    Plus_Sign            : constant Character := '+';  -- Character'Val(43)\n    Comma                : constant Character := ',';  -- Character'Val(44)\n    Hyphen               : constant Character := '-';  -- Character'Val(45)\n    Minus_Sign           : Character renames Hyphen;\n    Full_Stop            : constant Character := '.';  -- Character'Val(46)\n    Solidus              : constant Character := '/';  -- Character'Val(47)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    -- Decimal digits '0' though '9' are at positions 48 through 57\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    Colon                : constant Character := ':';  -- Character'Val(58)\n    Semicolon            : constant Character := ';';  -- Character'Val(59)\n    Less_Than_Sign       : constant Character := '&lt';  -- Character'Val(60)\n    Equals_Sign          : constant Character := '=';  -- Character'Val(61)\n    Greater_Than_Sign    : constant Character := '&gt';  -- Character'Val(62)\n    Question             : constant Character := '?';  -- Character'Val(63)\n    Commercial_At        : constant Character := '@';  -- Character'Val(64)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    -- Letters 'A' through 'Z' are at positions 65 through 90\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    Left_Square_Bracket  : constant Character := '[';  -- Character'Val(91)\n    Reverse_Solidus      : constant Character := '\\';  -- Character'Val(92)\n    Right_Square_Bracket : constant Character := ']';  -- Character'Val(93)\n    Circumflex           : constant Character := '^';  -- Character'Val(94)\n    Low_Line             : constant Character := '_';  -- Character'Val(95)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    Grave                : constant Character := '`';  -- Character'Val(96)\n    LC_A                 : constant Character := 'a';  -- Character'Val(97)\n    LC_B                 : constant Character := 'b';  -- Character'Val(98)\n    LC_C                 : constant Character := 'c';  -- Character'Val(99)\n    LC_D                 : constant Character := 'd';  -- Character'Val(100)\n    LC_E                 : constant Character := 'e';  -- Character'Val(101)\n    LC_F                 : constant Character := 'f';  -- Character'Val(102)\n    LC_G                 : constant Character := 'g';  -- Character'Val(103)\n    LC_H                 : constant Character := 'h';  -- Character'Val(104)\n    LC_I                 : constant Character := 'i';  -- Character'Val(105)\n    LC_J                 : constant Character := 'j';  -- Character'Val(106)\n    LC_K                 : constant Character := 'k';  -- Character'Val(107)\n    LC_L                 : constant Character := 'l';  -- Character'Val(108)\n    LC_M                 : constant Character := 'm';  -- Character'Val(109)\n    LC_N                 : constant Character := 'n';  -- Character'Val(110)\n    LC_O                 : constant Character := 'o';  -- Character'Val(111)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    LC_P                 : constant Character := 'p';  -- Character'Val(112)\n    LC_Q                 : constant Character := 'q';  -- Character'Val(113)\n    LC_R                 : constant Character := 'r';  -- Character'Val(114)\n    LC_S                 : constant Character := 's';  -- Character'Val(115)\n    LC_T                 : constant Character := 't';  -- Character'Val(116)\n    LC_U                 : constant Character := 'u';  -- Character'Val(117)\n    LC_V                 : constant Character := 'v';  -- Character'Val(118)\n    LC_W                 : constant Character := 'w';  -- Character'Val(119)\n    LC_X                 : constant Character := 'x';  -- Character'Val(120)\n    LC_Y                 : constant Character := 'y';  -- Character'Val(121)\n    LC_Z                 : constant Character := 'z';  -- Character'Val(122)\n    Left_Curly_Bracket   : constant Character := '{';  -- Character'Val(123)\n    Vertical_Line        : constant Character := '|';  -- Character'Val(124)\n    Right_Curly_Bracket  : constant Character := '}';  -- Character'Val(125)\n    Tilde                : constant Character := '~';  -- Character'Val(126)\n    DEL                  : constant Character := Character'Val(127);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- ISO 6429 control characters:\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    IS4                  : Character renames FS;\n    IS3                  : Character renames GS;\n    IS2                  : Character renames RS;\n    IS1                  : Character renames US;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    Reserved_128         : constant Character := Character'Val(128);\n    Reserved_129         : constant Character := Character'Val(129);\n    BPH                  : constant Character := Character'Val(130);\n    NBH                  : constant Character := Character'Val(131);\n    Reserved_132         : constant Character := Character'Val(132);\n    NEL                  : constant Character := Character'Val(133);\n    SSA                  : constant Character := Character'Val(134);\n    ESA                  : constant Character := Character'Val(135);\n    HTS                  : constant Character := Character'Val(136);\n    HTJ                  : constant Character := Character'Val(137);\n    VTS                  : constant Character := Character'Val(138);\n    PLD                  : constant Character := Character'Val(139);\n    PLU                  : constant Character := Character'Val(140);\n    RI                   : constant Character := Character'Val(141);\n    SS2                  : constant Character := Character'Val(142);\n    SS3                  : constant Character := Character'Val(143);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    DCS                  : constant Character := Character'Val(144);\n    PU1                  : constant Character := Character'Val(145);\n    PU2                  : constant Character := Character'Val(146);\n    STS                  : constant Character := Character'Val(147);\n    CCH                  : constant Character := Character'Val(148);\n    MW                   : constant Character := Character'Val(149);\n    SPA                  : constant Character := Character'Val(150);\n    EPA                  : constant Character := Character'Val(151);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"    SOS                  : constant Character := Character'Val(152);\n    Reserved_153         : constant Character := Character'Val(153);\n    SCI                  : constant Character := Character'Val(154);\n    CSI                  : constant Character := Character'Val(155);\n    ST                   : constant Character := Character'Val(156);\n    OSC                  : constant Character := Character'Val(157);\n    PM                   : constant Character := Character'Val(158);\n    APC                  : constant Character := Character'Val(159);\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Other graphic characters:\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI05-0181-1} -- Character positions 160 (16#A0#) .. 175 (16#AF#):\n    No_Break_Space             : constant Character := ' '; --Character'Val(160)\n    NBSP                       : Character renames No_Break_Space;\n    Inverted_Exclamation       : constant Character := '\ufffd'; --Character'Val(161)\n    Cent_Sign                  : constant Character := '\ufffd'; --Character'Val(162)\n    Pound_Sign                 : constant Character := '\ufffd'; --Character'Val(163)\n    Currency_Sign              : constant Character := '\ufffd'; --Character'Val(164)\n    Yen_Sign                   : constant Character := '\ufffd'; --Character'Val(165)\n    Broken_Bar                 : constant Character := '\ufffd'; --Character'Val(166)\n    Section_Sign               : constant Character := '\ufffd'; --Character'Val(167)\n    Diaeresis                  : constant Character := '\ufffd'; --Character'Val(168)\n    Copyright_Sign             : constant Character := '\ufffd'; --Character'Val(169)\n    Feminine_Ordinal_Indicator : constant Character := '\ufffd'; --Character'Val(170)\n    Left_Angle_Quotation       : constant Character := '\ufffd'; --Character'Val(171)\n    Not_Sign                   : constant Character := '\ufffd'; --Character'Val(172)\n    Soft_Hyphen                : constant Character := Character'Val(173);\n    Registered_Trade_Mark_Sign : constant Character := '\ufffd'; --Character'Val(174)\n    Macron                     : constant Character := '\ufffd'; --Character'Val(175)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Character positions 176 (16#B0#) .. 191 (16#BF#):\n    Degree_Sign                : constant Character := '\ufffd'; --Character'Val(176)\n    Ring_Above                 : Character renames Degree_Sign;\n    Plus_Minus_Sign            : constant Character := '\ufffd'; --Character'Val(177)\n    Superscript_Two            : constant Character := '\ufffd'; --Character'Val(178)\n    Superscript_Three          : constant Character := '\ufffd'; --Character'Val(179)\n    Acute                      : constant Character := '\ufffd'; --Character'Val(180)\n    Micro_Sign                 : constant Character := '\ufffd'; --Character'Val(181)\n    Pilcrow_Sign               : constant Character := '\ufffd'; --Character'Val(182)\n    Paragraph_Sign             : Character renames Pilcrow_Sign;\n    Middle_Dot                 : constant Character := '\ufffd'; --Character'Val(183)\n    Cedilla                    : constant Character := '\ufffd'; --Character'Val(184)\n    Superscript_One            : constant Character := '\ufffd'; --Character'Val(185)\n    Masculine_Ordinal_Indicator: constant Character := '\ufffd'; --Character'Val(186)\n    Right_Angle_Quotation      : constant Character := '\ufffd'; --Character'Val(187)\n    Fraction_One_Quarter       : constant Character := '\ufffd'; --Character'Val(188)\n    Fraction_One_Half          : constant Character := '\ufffd'; --Character'Val(189)\n    Fraction_Three_Quarters    : constant Character := '\ufffd'; --Character'Val(190)\n    Inverted_Question          : constant Character := '\ufffd'; --Character'Val(191)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Character positions 192 (16#C0#) .. 207 (16#CF#):\n    UC_A_Grave                 : constant Character := '\ufffd'; --Character'Val(192)\n    UC_A_Acute                 : constant Character := '\ufffd'; --Character'Val(193)\n    UC_A_Circumflex            : constant Character := '\ufffd'; --Character'Val(194)\n    UC_A_Tilde                 : constant Character := '\ufffd'; --Character'Val(195)\n    UC_A_Diaeresis             : constant Character := '\ufffd'; --Character'Val(196)\n    UC_A_Ring                  : constant Character := '\ufffd'; --Character'Val(197)\n    UC_AE_Diphthong            : constant Character := '\ufffd'; --Character'Val(198)\n    UC_C_Cedilla               : constant Character := '\ufffd'; --Character'Val(199)\n    UC_E_Grave                 : constant Character := '\ufffd'; --Character'Val(200)\n    UC_E_Acute                 : constant Character := '\ufffd'; --Character'Val(201)\n    UC_E_Circumflex            : constant Character := '\ufffd'; --Character'Val(202)\n    UC_E_Diaeresis             : constant Character := '\ufffd'; --Character'Val(203)\n    UC_I_Grave                 : constant Character := '\ufffd'; --Character'Val(204)\n    UC_I_Acute                 : constant Character := '\ufffd'; --Character'Val(205)\n    UC_I_Circumflex            : constant Character := '\ufffd'; --Character'Val(206)\n    UC_I_Diaeresis             : constant Character := '\ufffd'; --Character'Val(207)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Character positions 208 (16#D0#) .. 223 (16#DF#):\n    UC_Icelandic_Eth           : constant Character := '\ufffd'; --Character'Val(208)\n    UC_N_Tilde                 : constant Character := '\ufffd'; --Character'Val(209)\n    UC_O_Grave                 : constant Character := '\ufffd'; --Character'Val(210)\n    UC_O_Acute                 : constant Character := '\ufffd'; --Character'Val(211)\n    UC_O_Circumflex            : constant Character := '\ufffd'; --Character'Val(212)\n    UC_O_Tilde                 : constant Character := '\ufffd'; --Character'Val(213)\n    UC_O_Diaeresis             : constant Character := '\ufffd'; --Character'Val(214)\n    Multiplication_Sign        : constant Character := '\ufffd'; --Character'Val(215)\n    UC_O_Oblique_Stroke        : constant Character := '\ufffd'; --Character'Val(216)\n    UC_U_Grave                 : constant Character := '\ufffd'; --Character'Val(217)\n    UC_U_Acute                 : constant Character := '\ufffd'; --Character'Val(218)\n    UC_U_Circumflex            : constant Character := '\ufffd'; --Character'Val(219)\n    UC_U_Diaeresis             : constant Character := '\ufffd'; --Character'Val(220)\n    UC_Y_Acute                 : constant Character := '\ufffd'; --Character'Val(221)\n    UC_Icelandic_Thorn         : constant Character := '\ufffd'; --Character'Val(222)\n    LC_German_Sharp_S          : constant Character := '\ufffd'; --Character'Val(223)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Character positions 224 (16#E0#) .. 239 (16#EF#):\n    LC_A_Grave                 : constant Character := '\ufffd'; --Character'Val(224)\n    LC_A_Acute                 : constant Character := '\ufffd'; --Character'Val(225)\n    LC_A_Circumflex            : constant Character := '\ufffd'; --Character'Val(226)\n    LC_A_Tilde                 : constant Character := '\ufffd'; --Character'Val(227)\n    LC_A_Diaeresis             : constant Character := '\ufffd'; --Character'Val(228)\n    LC_A_Ring                  : constant Character := '\ufffd'; --Character'Val(229)\n    LC_AE_Diphthong            : constant Character := '\ufffd'; --Character'Val(230)\n    LC_C_Cedilla               : constant Character := '\ufffd'; --Character'Val(231)\n    LC_E_Grave                 : constant Character := '\ufffd'; --Character'Val(232)\n    LC_E_Acute                 : constant Character := '\ufffd'; --Character'Val(233)\n    LC_E_Circumflex            : constant Character := '\ufffd'; --Character'Val(234)\n    LC_E_Diaeresis             : constant Character := '\ufffd'; --Character'Val(235)\n    LC_I_Grave                 : constant Character := '\ufffd'; --Character'Val(236)\n    LC_I_Acute                 : constant Character := '\ufffd'; --Character'Val(237)\n    LC_I_Circumflex            : constant Character := '\ufffd'; --Character'Val(238)\n    LC_I_Diaeresis             : constant Character := '\ufffd'; --Character'Val(239)\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"-- Character positions 240 (16#F0#) .. 255 (16#FF#):\n    LC_Icelandic_Eth           : constant Character := '\ufffd'; --Character'Val(240)\n    LC_N_Tilde                 : constant Character := '\ufffd'; --Character'Val(241)\n    LC_O_Grave                 : constant Character := '\ufffd'; --Character'Val(242)\n    LC_O_Acute                 : constant Character := '\ufffd'; --Character'Val(243)\n    LC_O_Circumflex            : constant Character := '\ufffd'; --Character'Val(244)\n    LC_O_Tilde                 : constant Character := '\ufffd'; --Character'Val(245)\n    LC_O_Diaeresis             : constant Character := '\ufffd'; --Character'Val(246)\n    Division_Sign              : constant Character := '\ufffd'; --Character'Val(247)\n    LC_O_Oblique_Stroke        : constant Character := '\ufffd'; --Character'Val(248)\n    LC_U_Grave                 : constant Character := '\ufffd'; --Character'Val(249)\n    LC_U_Acute                 : constant Character := '\ufffd'; --Character'Val(250)\n    LC_U_Circumflex            : constant Character := '\ufffd'; --Character'Val(251)\n    LC_U_Diaeresis             : constant Character := '\ufffd'; --Character'Val(252)\n    LC_Y_Acute                 : constant Character := '\ufffd'; --Character'Val(253)\n    LC_Icelandic_Thorn         : constant Character := '\ufffd'; --Character'Val(254)\n    LC_Y_Diaeresis             : constant Character := '\ufffd'; --Character'Val(255)\nend Ada.Characters.Latin_1;\n\n")),(0,n.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,n.kt)("p",null,"An implementation may provide additional packages as children of Ada.Characters, to declare names for the symbols of the local character set or other character sets. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-1"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{AI05-0181-1} Correction: Soft_Hyphen is not a graphic character, and thus a character literal for it is illegal. So we have to use the position value. This makes no semantic change to users of the constant. "),(0,n.kt)("h2",{id:"a34--the-package-charactersconversions"},"A.3.4  The Package Characters.Conversions"),(0,n.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,n.kt)("p",null,"{AI95-00395-01} The library package Characters.Conversions has the following declaration: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0414-1} package Ada.Characters.Conversions\n   with Pure is\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Character (Item : in Wide_Character)      return Boolean;\n   function Is_String    (Item : in Wide_String)         return Boolean;\n   function Is_Character (Item : in Wide_Wide_Character) return Boolean;\n   function Is_String    (Item : in Wide_Wide_String)    return Boolean;\n   function Is_Wide_Character (Item : in Wide_Wide_Character)\n      return Boolean;\n   function Is_Wide_String    (Item : in Wide_Wide_String)\n      return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function To_Wide_Character (Item : in Character) return Wide_Character;\n   function To_Wide_String    (Item : in String)    return Wide_String;\n   function To_Wide_Wide_Character (Item : in Character)\n      return Wide_Wide_Character;\n   function To_Wide_Wide_String    (Item : in String)\n      return Wide_Wide_String;\n   function To_Wide_Wide_Character (Item : in Wide_Character)\n      return Wide_Wide_Character;\n   function To_Wide_Wide_String    (Item : in Wide_String)\n      return Wide_Wide_String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function To_Character (Item       : in Wide_Character;\n                         Substitute : in Character := ' ')\n      return Character;\n   function To_String    (Item       : in Wide_String;\n                          Substitute : in Character := ' ')\n      return String;\n   function To_Character (Item :       in Wide_Wide_Character;\n                          Substitute : in Character := ' ')\n      return Character;\n   function To_String    (Item :       in Wide_Wide_String;\n                          Substitute : in Character := ' ')\n      return String;\n   function To_Wide_Character (Item :       in Wide_Wide_Character;\n                               Substitute : in Wide_Character := ' ')\n      return Wide_Character;\n   function To_Wide_String    (Item :       in Wide_Wide_String;\n                               Substitute : in Wide_Character := ' ')\n      return Wide_String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"end Ada.Characters.Conversions;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} The functions in package Characters.Conversions test Wide_Wide_Character or Wide_Character values for membership in Wide_Character or Character, or convert between corresponding characters of Wide_Wide_Character, Wide_Character, and Character."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Character (Item : in Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns True if Wide_Character'Pos(Item) ","<","= Character'Pos(Character'Last)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Character (Item : in Wide_Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns True if Wide_Wide_Character'Pos(Item) ","<","= Character'Pos(Character'Last)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Wide_Character (Item : in Wide_Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns True if Wide_Wide_Character'Pos(Item) ","<","= Wide_Character'Pos(Wide_Character'Last)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_String (Item : in Wide_String)      return Boolean;\nfunction Is_String (Item : in Wide_Wide_String) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns True if Is_Character(Item(I)) is True for each I in Item'Range."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Wide_String (Item : in Wide_Wide_String) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns True if Is_Wide_Character(Item(I)) is True for each I in Item'Range."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Character (Item :       in Wide_Character;\n                       Substitute : in Character := ' ') return Character;\nfunction To_Character (Item :       in Wide_Wide_Character;\n                       Substitute : in Character := ' ') return Character;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Character corresponding to Item if Is_Character(Item), and returns the Substitute Character otherwise."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_Character (Item : in Character) return Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_Character X such that Character'Pos(Item) = Wide_Character'Pos (X)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_Character (Item :       in Wide_Wide_Character;\n                            Substitute : in Wide_Character := ' ')\n   return Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_Character corresponding to Item if Is_Wide_Character(Item), and returns the Substitute Wide_Character otherwise."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_Wide_Character (Item : in Character)\n   return Wide_Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_Wide_Character X such that Character'Pos(Item) = Wide_Wide_Character'Pos (X)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_Wide_Character (Item : in Wide_Character)\n   return Wide_Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_Wide_Character X such that Wide_Character'Pos(Item) = Wide_Wide_Character'Pos (X)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_String (Item :       in Wide_String;\n                    Substitute : in Character := ' ') return String;\nfunction To_String (Item :       in Wide_Wide_String;\n                    Substitute : in Character := ' ') return String;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the String whose range is 1..Item'Length and each of whose elements is given by To_Character of the corresponding element in Item."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_String (Item : in String) return Wide_String;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_String whose range is 1..Item'Length and each of whose elements is given by To_Wide_Character of the corresponding element in Item."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_String (Item :       in Wide_Wide_String;\n                         Substitute : in Wide_Character := ' ')\n   return Wide_String;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_String whose range is 1..Item'Length and each of whose elements is given by To_Wide_Character of the corresponding element in Item with the given Substitute Wide_Character."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Wide_Wide_String (Item : in String) return Wide_Wide_String;\nfunction To_Wide_Wide_String (Item : in Wide_String)\n   return Wide_Wide_String;\n\n")),(0,n.kt)("p",null,"{AI95-00395-01} Returns the Wide_Wide_String whose range is 1..Item'Length and each of whose elements is given by To_Wide_Wide_Character of the corresponding element in Item."),(0,n.kt)("h4",{id:"extensions-to-ada-95-2"},"Extensions to Ada 95"),(0,n.kt)("p",null,"{AI95-00395-01} The package Characters.Conversions is new, replacing functions previously found in Characters.Handling. "),(0,n.kt)("h2",{id:"a35--the-package-wide_charactershandling"},"A.3.5  The Package Wide_Characters.Handling"),(0,n.kt)("p",null,"{AI05-0185-1} The package Wide_Characters.Handling provides operations for classifying Wide_Characters and case folding for Wide_Characters. "),(0,n.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,n.kt)("p",null,"{AI05-0185-1} The library package Wide_Characters.Handling has the following declaration:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI05-0185-1} {AI05-0266-1} {AI12-0414-1} package Ada.Wide_Characters.Handling\n   with Pure is\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI05-0266-1}    function Character_Set_Version return String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Control (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Letter (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Lower (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Upper (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0260-1}    function Is_Basic (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Digit (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Decimal_Digit (Item : Wide_Character) return Boolean\n      renames Is_Digit;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Alphanumeric (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Special (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Line_Terminator (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Mark (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Other_Format (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Space (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0004-1}    function Is_NFKC (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Is_Graphic (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function To_Lower (Item : Wide_Character) return Wide_Character;\n   function To_Upper (Item : Wide_Character) return Wide_Character;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0260-1}    function To_Basic (Item : Wide_Character) return Wide_Character;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function To_Lower (Item : Wide_String) return Wide_String;\n   function To_Upper (Item : Wide_String) return Wide_String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0260-1}    function To_Basic (Item : Wide_String) return Wide_String;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"end Ada.Wide_Characters.Handling;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} The subprograms defined in Wide_Characters.Handling are locale independent."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Character_Set_Version return String;\n\n")),(0,n.kt)("p",null,"{AI05-0266-1} Returns an implementation-defined identifier that identifies the version of the character set standard that is used for categorizing characters by the implementation."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Control (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as other_control; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Letter (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as letter_uppercase, letter_lowercase, letter_titlecase, letter_modifier, letter_other, or number_letter; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Lower (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as letter_lowercase; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Upper (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as letter_uppercase; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Basic (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI12-0260-1} Returns True if the Wide_Character designated by Item has no Decomposition Mapping in the code charts of ISO/IEC 10646:2017; otherwise returns False."),(0,n.kt)("p",null,"Implementation Note: Decomposition Mapping is defined in Clause 33 of ISO/IEC 10646:2017. Machine-readable (and normative!) versions of this can be found as Character Decomposition Mapping, described in file ",(0,n.kt)("a",{parentName:"p",href:"http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"},"http://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt"),", field 5 (which is the 6th item, Unicode counts from zero). "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Digit (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as number_decimal; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as number_decimal, or is in the range 'A' .. 'F' or 'a' .. 'f'; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Alphanumeric (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as letter_uppercase, letter_lowercase, letter_titlecase, letter_modifier, letter_other, number_letter, or number_decimal; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Special (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as graphic_character, but not categorized as letter_uppercase, letter_lowercase, letter_titlecase, letter_modifier, letter_other, number_letter, or number_decimal; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Line_Terminator (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as separator_line or separator_paragraph, or if Item is a conventional line terminator character (Line_Feed, Line_Tabulation, Form_Feed, Carriage_Return, Next_Line); otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Mark (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as mark_non_spacing or mark_spacing_combining; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Other_Format (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as other_format; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as punctuation_connector; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Space (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as separator_space; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_NFKC (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI12-0004-1} {AI12-0263-1} {AI12-0439-1} Returns True if the Wide_Character designated by Item can be present in a string normalized to Normalization Form KC (as defined by Clause 21 of ISO/IEC 10646:2017), otherwise returns False."),(0,n.kt)("p",null,"Reason: Wide_Characters for which this function returns False are not allowed in identifiers (see 2.3) even if they are categorized as letters or digits. "),(0,n.kt)("p",null,"Implementation Note: This function returns False if the Unicode property NFKC Quick Check (NFKC_QC in the files) has the value No. See the Implementation Notes in 2.3 for the source of this property. "),(0,n.kt)("p",null,"Discussion: A string for which Is_NFKC is true for every character may still not be in Normalization Form KC, as Is_NFKC returns true for characters that are dependent on characters around them as to whether they are removed by normalization. Ada does not provide a full normalization operation (it is complex and expensive). "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function Is_Graphic (Item : Wide_Character) return Boolean;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns True if the Wide_Character designated by Item is categorized as graphic_character; otherwise returns False."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Lower (Item : Wide_Character) return Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} {AI05-0266-1} {AI05-0299-1} {AI12-0263-1} Returns the Simple Lowercase Mapping as defined by documents referenced in Clause 2 of ISO/IEC 10646:2017 of the Wide_Character designated by Item. If the Simple Lowercase Mapping does not exist for the Wide_Character designated by Item, then the value of Item is returned."),(0,n.kt)("p",null,'Discussion: {AI12-0263-1} The "documents referenced" means Unicode, Chapter 4 (specifically, section 4.2 - Case). The case mappings come from Unicode as ISO/IEC 10646:2017 does not include complete case mappings. See the Implementation Notes in subclause  for machine-readable versions of both Uppercase and Lowercase mappings. '),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Lower (Item : Wide_String) return Wide_String;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns the result of applying the To_Lower conversion to each Wide_Character element of the Wide_String designated by Item. The result is the null Wide_String if the value of the formal parameter is the null Wide_String. The lower bound of the result Wide_String is 1."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Upper (Item : Wide_Character) return Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} {AI05-0266-1} {AI05-0299-1} {AI12-0263-1} Returns the Simple Uppercase Mapping as defined by documents referenced in Clause 2 of ISO/IEC 10646:2017 of the Wide_Character designated by Item. If the Simple Uppercase Mapping does not exist for the Wide_Character designated by Item, then the value of Item is returned."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Upper (Item : Wide_String) return Wide_String;\n\n")),(0,n.kt)("p",null,"{AI05-0185-1} Returns the result of applying the To_Upper conversion to each Wide_Character element of the Wide_String designated by Item. The result is the null Wide_String if the value of the formal parameter is the null Wide_String. The lower bound of the result Wide_String is 1."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Basic (Item : Wide_Character) return Wide_Character;\n\n")),(0,n.kt)("p",null,"{AI12-0260-1} Returns the Wide_Character whose code point is given by the first value of its Decomposition Mapping in the code charts of ISO/IEC 10646:2017 if any; returns Item otherwise."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"function To_Basic (Item : Wide_String) return Wide_String;\n\n")),(0,n.kt)("p",null,"{AI12-0260-1} Returns the result of applying the To_Basic conversion to each Wide_Character element of the Wide_String designated by Item. The result is the null Wide_String if the value of the formal parameter is the null Wide_String. The lower bound of the result Wide_String is 1."),(0,n.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,n.kt)("p",null,'{AI05-0266-1} The string returned by Character_Set_Version should include either "10646:" or "Unicode".'),(0,n.kt)("p",null,'Implementation Advice: The string returned by Wide_Characters.Handling.Character_Set_Version should include either "10646:" or "Unicode".'),(0,n.kt)("p",null,'Discussion: {AI12-0263-1} The intent is that the returned string include the year for 10646 (as in "10646:2017"), and the version number for Unicode (as in "Unicode 10.0"). We don\'t try to specify that further so we don\'t need to decide how to represent Corrigenda for 10646, nor which of these is preferred. (Giving a Unicode version is more accurate, as the case folding and mapping rules always come from a Unicode version ',"[10646 just tells one to look at Unicode to get those]",", and the character classifications ought to be the same for equivalent versions, but we don't want to talk about non-ISO standards in an ISO standard.) "),(0,n.kt)("p",null,"NOTE 1   {AI05-0266-1} {AI12-0440-1} The results returned by these functions can depend on which particular version of the 10646 standard is supported by the implementation (see 2.1)."),(0,n.kt)("p",null,'NOTE 2   {AI05-0286-1} The case insensitive equality comparison routines provided in A.4.10, "String Comparison" are also available for wide strings (see A.4.7). '),(0,n.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,n.kt)("p",null,"{AI05-0185-1} {AI05-0266-1} The package Wide_Characters.Handling is new. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-2012-1"},"Incompatibilities With Ada 2012"),(0,n.kt)("p",null,"{AI12-0004-1} {AI12-0260-1} Added additional classification routines Is_Basic and Is_NFKC, and additional conversion routine To_Basic. Therefore, a use clause conflict is possible; see the introduction of Annex A for more on this topic. "),(0,n.kt)("h2",{id:"a36--the-package-wide_wide_charactershandling"},"A.3.6  The Package Wide_Wide_Characters.Handling"),(0,n.kt)("p",null,"{AI05-0185-1} The package Wide_Wide_Characters.Handling has the same contents as Wide_Characters.Handling except that each occurrence of Wide_Character is replaced by Wide_Wide_Character, and each occurrence of Wide_String is replaced by Wide_Wide_String. "),(0,n.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,n.kt)("p",null,"{AI05-0185-1} The package Wide_Wide_Characters.Handling is new."))}d.isMDXComponent=!0}}]);