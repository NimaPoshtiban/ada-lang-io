"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9167],{65635:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>g,contentTitle:()=>h,default:()=>y,frontMatter:()=>p,metadata:()=>m,toc:()=>f});var a=t(91716),i=Object.defineProperty,s=Object.defineProperties,r=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,c=(e,n,t)=>n in e?i(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,u=(e,n)=>{for(var t in n||(n={}))l.call(n,t)&&c(e,t,n[t]);if(o)for(var t of o(n))d.call(n,t)&&c(e,t,n[t]);return e};const p={title:"7.5 Representation Clauses And Implementation-Dependent Features"},h=void 0,m={unversionedId:"style-guide/s7/05",id:"style-guide/s7/05",title:"7.5 Representation Clauses And Implementation-Dependent Features",description:"Ada provides many implementation-dependent features that permit greater",source:"@site/docs/style-guide/s7/05.mdx",sourceDirName:"style-guide/s7",slug:"/style-guide/s7/05",permalink:"/docs/style-guide/s7/05",draft:!1,tags:[],version:"current",frontMatter:{title:"7.5 Representation Clauses And Implementation-Dependent Features"},sidebar:"styleGuideSidebar",previous:{title:"7.4 Exceptions",permalink:"/docs/style-guide/s7/04"},next:{title:"7.6 Input/Output",permalink:"/docs/style-guide/s7/06"}},g={},f=[{value:"Representation Clauses",id:"representation-clauses",level:3},{value:"guideline",id:"guideline",level:4},{value:"rationale",id:"rationale",level:4},{value:"notes",id:"notes",level:4},{value:"Package System",id:"package-system",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes-1",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Machine Code Inserts",id:"machine-code-inserts",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Interfacing to Foreign Languages",id:"interfacing-to-foreign-languages",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Implementation-Specific Pragmas and Attributes",id:"implementation-specific-pragmas-and-attributes",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Unchecked Deallocation",id:"unchecked-deallocation",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"notes",id:"notes-2",level:4},{value:"exceptions",id:"exceptions-3",level:4},{value:"Unchecked Access",id:"unchecked-access",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"Unchecked Conversion",id:"unchecked-conversion",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"exceptions",id:"exceptions-4",level:4},{value:"Run-Time Dependencies",id:"run-time-dependencies",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"exceptions",id:"exceptions-5",level:4}],v={toc:f};function y(e){var n,t=e,{components:i}=t,c=((e,n)=>{var t={};for(var a in e)l.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(null!=e&&o)for(var a of o(e))n.indexOf(a)<0&&d.call(e,a)&&(t[a]=e[a]);return t})(t,["components"]);return(0,a.kt)("wrapper",(n=u(u({},v),c),s(n,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"Ada provides many implementation-dependent features that permit greater\ncontrol over and interaction with the underlying hardware architecture\nthan is normally provided by a high-order language. These mechanisms are\nintended to assist in systems programming and real-time programming to\nobtain greater efficiency (e.g., specific size and layout of variables\nthrough representation clauses) and direct hardware interaction (e.g.,\ninterrupt entries) without having to resort to assembly level\nprogramming. Given the objectives for these features, it is not\nsurprising that you must usually pay a significant price in portability\nto use them. In general, where portability is the main objective, do not\nuse these features. When you must use these features, encapsulate them\nin packages that are well-commented as interfacing to the particular\ntarget environment. This section identifies the various features and\ntheir recommended use with respect to portability."),(0,a.kt)("h3",u({},{id:"representation-clauses"}),"Representation Clauses"),(0,a.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use algorithms that do not depend on the representation of the data\nand, therefore, do not need representation clauses."),(0,a.kt)("li",{parentName:"ul"},"Consider using representation clauses when accessing or defining\ninterface data or when a specific representation is needed to\nimplement a design."),(0,a.kt)("li",{parentName:"ul"},"Do not assume that sharing source files between programs guarantees\nthe same representation of data types in those files.")),(0,a.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"In many cases, it is easy to use representation clauses to implement an\nalgorithm, even when it is not necessary. There is also a tendency to\ndocument the original programmer's assumptions about the representation\nfor future reference. But there is no guarantee that another\nimplementation will support the representation chosen. Unnecessary\nrepresentation clauses also confuse porting or maintenance efforts,\nwhich must assume that the programmer depends on the documented\nrepresentation."),(0,a.kt)("p",null,"Interfaces to external systems and devices are the most common\nsituations where a representation clause is needed. Uses of pragma\nImport and address clauses should be evaluated during design and porting\nto determine whether a representation clause is needed."),(0,a.kt)("p",null,"Without representation clauses, the language does not require two\ncompilations of an unchanged file to result in the same data\nrepresentation. Things that can change the representation between\ncompilations include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A change in a file earlier in the compilation order"),(0,a.kt)("li",{parentName:"ul"},"A change in the optimization strategy or level"),(0,a.kt)("li",{parentName:"ul"},"A change in versions of the compiler"),(0,a.kt)("li",{parentName:"ul"},"A change in actual compilers"),(0,a.kt)("li",{parentName:"ul"},"A change in the availability of system resources")),(0,a.kt)("p",null,"Therefore, two independently linked programs or partitions should only\nshare data that has their representations explicitly controlled."),(0,a.kt)("h4",u({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"During a porting effort, all representation clauses can be evaluated as\neither design artifacts or specifications for accessing interface data\nthat might change with a new implementation."),(0,a.kt)("h3",u({},{id:"package-system"}),"Package System"),(0,a.kt)("h4",u({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid using package System constants except in attempting to\ngeneralize other machine-dependent constructs.")),(0,a.kt)("h4",u({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"Because the values in this package are implementation-provided,\nunexpected effects can result from their use."),(0,a.kt)("h4",u({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"If you must guarantee that physical record layouts will remain the same\nbetween implementations, you can express record fields by their first\nand last bit positions as shown in the Ada Reference Manual (1995,\n\xa713.5.1). Static expressions and named numbers should be used to let\nthe compiler compute the endpoints of each range in terms of earlier\nfields. In this case, greater portability can be achieved by using\nSystem.Storage_Unit to let the compiler compute the value of the named\nnumber. However, this method might not work for all values of\nSystem.Storage_Unit."),(0,a.kt)("h4",u({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"Do use package System constants to parameterize other\nimplementation-dependent features (see Pappas (1985, \xa713.7.1)."),(0,a.kt)("h3",u({},{id:"machine-code-inserts"}),"Machine Code Inserts"),(0,a.kt)("h4",u({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid machine code inserts.")),(0,a.kt)("h4",u({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995, Annex C) suggests that the package that\nimplements machine code inserts is optional. Additionally, it is not\nstandardized so that machine code inserts are most likely not portable.\nIn fact, it is possible that two different vendors' syntax will differ\nfor an identical target, and differences in lower-level details, such as\nregister conventions, will hinder portability."),(0,a.kt)("h4",u({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"If machine code inserts must be used to meet another project\nrequirement, recognize and document the portability decreasing effects."),(0,a.kt)("p",null,"In the declarative region of the body of the routine where machine code\ninserts are being used, insert comments explaining what functions\ninserts provide and (especially) why the inserts are necessary. Comment\nthe necessity of using machine code inserts by delineating what went\nwrong with attempts to use other higher level constructs."),(0,a.kt)("h3",u({},{id:"interfacing-to-foreign-languages"}),"Interfacing to Foreign Languages"),(0,a.kt)("h4",u({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use the package Interfaces and its language-defined child packages\nrather than implementation-specific mechanisms."),(0,a.kt)("li",{parentName:"ul"},'Consider using pragma Import rather than access-to-subprogram types\nfor interfacing to subprograms in other languages. (Preferably using\nthe "External_Name =',">",'" argument.)'),(0,a.kt)("li",{parentName:"ul"},"Isolate all subprograms employing pragmas Import, Export, and\nConvention to implementation-specific (interface) package bodies.")),(0,a.kt)("h4",u({},{id:"example"}),"example"),(0,a.kt)("p",null,"This example shows how to interface with the following cube root\nfunction written in C:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-c"}),"double cbrt (double x);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ada"}),'package Math_Utilities is\n\n   Argument_Error : exception;\n\n   function Cube_Root (X : Float) return Float;\n\n   ...\n\nend Math_Utilities;\n\n------------------------------------------------------------------------------\nwith Interfaces.C;\npackage body Math_Utilities is\n\n   function Cube_Root (X : Float) return Float is\n\n      function C_Cbrt (X : Interfaces.C.Double) return Interfaces.C.Double;\n      pragma Import (Convention    => C,\n                     Entity        => C_Cbrt,\n                     External_Name => "cbrt");\n\n   begin\n      if X < 0.0 then\n         raise Argument_Error;\n      else\n         return Float (C_Cbrt (Interfaces.C.Double (X)));\n      end if;\n   end Cube_Root;\n\n   ...\n\nend Math_Utilities;\n')),(0,a.kt)("h4",u({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"For static interfacing to subprograms in other languages, the pragma\nImport provides a better solution than access to subprograms because no\nindirection is required. The pragma Interface (Ada Reference Manual 1983) has been replaced by pragmas Import, Export, and Convention. Annex\nB of the Rationale (1995) discusses how to use these pragmas in\nconjunction with the access-to-subprogram types in interfacing to other\nlanguages."),(0,a.kt)("p",null,'Note especially the distinction between the "External_Name =',">",'" and\n"Link_Name =',">",'" parameters to pragma Import which are frequently\nconfused. External_Name specifies the procedure name as it appears in\nthe source code of the other language (such as C or Fortran). Link_Name\nspecifies the name used by the linker. Typically, only one of these\nparameters is specified, and generally External_Name is the preferred\nchoice for portability.'),(0,a.kt)("p",null,"Access to subprogram types is useful for implementing callbacks in a\nseparate subsystem, such as the X Window system."),(0,a.kt)("p",null,"The problems with interfacing to foreign languages are complex. These\nproblems include pragma syntax differences, conventions for\nlinking/binding Ada to other languages, and mapping Ada variables to\nforeign language variables. By hiding these dependencies within\ninterface packages, the amount of code modification can be reduced."),(0,a.kt)("h4",u({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("p",null,"It is often necessary to interact with other languages, if only an\nassembly language, to reach certain hardware features. In these cases,\nclearly comment the requirements and limitations of the interface and\npragma Import, Export, and Conventions usage."),(0,a.kt)("h3",u({},{id:"implementation-specific-pragmas-and-attributes"}),"Implementation-Specific Pragmas and Attributes"),(0,a.kt)("h4",u({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid pragmas and attributes added by the compiler implementor.")),(0,a.kt)("h4",u({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"The Ada Reference Manual (1995) permits an implementor to add pragmas\nand attributes to exploit a particular hardware architecture or software\nenvironment. These are obviously even more implementation-specific and\ntherefore less portable than an implementor's interpretations of the\npredefined pragmas and attributes. However, the Ada Reference Manual\n(1995) defines a set of annexes that have a uniform and consistent\napproach to certain specialized needs, namely, real-time systems,\ndistributed systems, information systems, numerics, interfacing to\nforeign languages, and safety and security. You should always prefer the\nfacilities defined in the annexes to any vendor-defined pragmas and\nattributes."),(0,a.kt)("h3",u({},{id:"unchecked-deallocation"}),"Unchecked Deallocation"),(0,a.kt)("h4",u({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Deallocation (see Guideline\n5.9.2).")),(0,a.kt)("h4",u({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"The unchecked storage deallocation mechanism is one method for\noverriding the default time at which allocated storage is reclaimed. The\nearliest default time is when an object is no longer accessible, for\nexample, when control leaves the scope where an access type was declared\n(the exact point after this time is implementation-dependent). Any\nunchecked deallocation of storage performed prior to this may result in\nan erroneous Ada program if an attempt is made to access the object."),(0,a.kt)("p",null,"This guideline is stronger than Guideline 5.9.2 because of the extreme\ndependence on the implementation of Ada.Unchecked_Deallocation. Using\nit could cause considerable difficulty with portability."),(0,a.kt)("h4",u({},{id:"notes-2"}),"notes"),(0,a.kt)("p",null,"Ada.Unchecked_Deallocation is a supported feature in all Ada\nimplementations. The portability issue arises in that unchecked storage\ndeallocations might cause varying results in different implementations."),(0,a.kt)("h4",u({},{id:"exceptions-3"}),"exceptions"),(0,a.kt)("p",null,"Using unchecked deallocation of storage can be beneficial in local\ncontrol of highly iterative or recursive algorithms where available\nstorage may be exceeded."),(0,a.kt)("h3",u({},{id:"unchecked-access"}),"Unchecked Access"),(0,a.kt)("h4",u({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on the attribute Unchecked_Access (see Guideline\n5.9.2).")),(0,a.kt)("h4",u({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,"Access values are subject to accessibility restrictions. Using the\nattribute Unchecked_Access prevents these rules from being checked, and\nthe programmer runs the risk of having dangling references."),(0,a.kt)("h3",u({},{id:"unchecked-conversion"}),"Unchecked Conversion"),(0,a.kt)("h4",u({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid dependence on Ada.Unchecked_Conversion (see Guideline 5.9.1).")),(0,a.kt)("h4",u({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"The unchecked type conversion mechanism is, in effect, a means of\nbypassing the strong typing facilities in Ada. An implementation is free\nto limit the types that may be matched and the results that occur when\nobject sizes differ."),(0,a.kt)("h4",u({},{id:"exceptions-4"}),"exceptions"),(0,a.kt)("p",null,"Unchecked type conversion is useful in implementation-dependent parts of\nAda programs where lack of portability is isolated and where low-level\nprogramming and foreign language interfacing are the objectives."),(0,a.kt)("p",null,"If an enumeration representation clause is used, unchecked type\nconversion is the only language-provided way to retrieve the internal\ninteger code of an enumeration value."),(0,a.kt)("h3",u({},{id:"run-time-dependencies"}),"Run-Time Dependencies"),(0,a.kt)("h4",u({},{id:"guideline-8"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Avoid the direct invocation of or implicit dependence upon an\nunderlying host operating system or Ada run-time support system,\nexcept where the interface is explicitly defined in the language\n(e.g., Annex C or D of the Ada Reference Manual ","[","1995","]",")."),(0,a.kt)("li",{parentName:"ul"},"Use standard bindings and the package Ada.Command_Line when you\nneed to invoke the underlying run-time support system."),(0,a.kt)("li",{parentName:"ul"},"Use features defined in the Annexes rather than vendor-defined\nfeatures.")),(0,a.kt)("h4",u({},{id:"rationale-8"}),"rationale"),(0,a.kt)("p",null,"Features of an implementation not specified in the Ada Reference Manual\n(1995) will usually differ between implementations. Specific\nimplementation-dependent features are not likely to be provided in other\nimplementations. In addition to the mandatory predefined language\nenvironment, the annexes define various packages, attributes, and\npragmas to standardize implementation-dependent features for several\nspecialized domains. You enhance portability when you use the features\ndeclared in the packages in the Annexes because you can port your\nprogram to other vendor environments that implement the same Annexes you\nhave used. Even if a majority of vendors eventually provide similar\nfeatures, they are unlikely to have identical formulations. Indeed,\ndifferent vendors may use the same formulation for (semantically)\nentirely different features."),(0,a.kt)("p",null,"When coding, try to avoid depending on the underlying operating system.\nConsider the consequences of including system calls in a program on a\nhost development system. If these calls are not flagged for removal and\nreplacement, the program could go through development and testing only\nto be unusable when moved to a target environment that lacks the\nfacilities provided by those system calls on the host."),(0,a.kt)("p",null,"Guideline 7.1.5 discusses the use of the package Ada.Command_Line. If\nan Ada environment implements a standard binding to operating system\nservices, such as POSIX/Ada, and you write POSIX-compliant calls, your\nprogram should be portable across more systems."),(0,a.kt)("h4",u({},{id:"exceptions-5"}),"exceptions"),(0,a.kt)("p",null,"In real-time, embedded systems, making calls to low-level support system\nfacilities may often be unavoidable. Isolating the uses of these\nfacilities may be too difficult. Comment them as you would machine code\ninserts (see Guideline 7.6.3); they are, in a sense, instructions for\nthe virtual machine provided by the support system. When isolating the\nuses of these features, provide an interface for the rest of your\nprogram to use, which can be ported through replacement of the\ninterface's implementation."))}y.isMDXComponent=!0}}]);