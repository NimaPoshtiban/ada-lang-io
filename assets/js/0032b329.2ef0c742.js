"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5794],{2144:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var l=a(9440),n=(a(6687),a(1716)),r=a(2526);const i={sidebar_position:205},o="J.15  Aspect-related Pragmas",s={unversionedId:"arm/AA-J.15",id:"arm/AA-J.15",title:"J.15  Aspect-related Pragmas",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-J.15.mdx",sourceDirName:"arm",slug:"/arm/AA-J.15",permalink:"/docs/arm/AA-J.15",draft:!1,tags:[],version:"current",sidebarPosition:205,frontMatter:{sidebar_position:205},sidebar:"tutorialSidebar",previous:{title:"J.14  Character and Wide_Character Conversion Functions",permalink:"/docs/arm/AA-J.14"},next:{title:"Annex K Language-Defined Aspects and Attributes",permalink:"/docs/arm/AA-K"}},u={},d=[{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"J.15.1  Pragma Inline",id:"j151--pragma-inline",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"J.15.2  Pragma No_Return",id:"j152--pragma-no_return",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4},{value:"J.15.3  Pragma Pack",id:"j153--pragma-pack",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-3",level:4},{value:"J.15.4  Pragma Storage_Size",id:"j154--pragma-storage_size",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-4",level:4},{value:"J.15.5  Interfacing Pragmas",id:"j155--interfacing-pragmas",level:2},{value:"Syntax",id:"syntax-4",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-5",level:4},{value:"J.15.6  Pragma Unchecked_Union",id:"j156--pragma-unchecked_union",level:2},{value:"Syntax",id:"syntax-5",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-6",level:4},{value:"J.15.7  Pragmas Interrupt_Handler and Attach_Handler",id:"j157--pragmas-interrupt_handler-and-attach_handler",level:2},{value:"Syntax",id:"syntax-6",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-3",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-7",level:4},{value:"J.15.8  Shared Variable Pragmas",id:"j158--shared-variable-pragmas",level:2},{value:"Syntax",id:"syntax-7",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-8",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-8",level:4},{value:"J.15.9  Pragma CPU",id:"j159--pragma-cpu",level:2},{value:"Syntax",id:"syntax-8",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-5",level:4},{value:"Legality Rules",id:"legality-rules-8",level:4},{value:"Static Semantics",id:"static-semantics-9",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"J.15.10  Pragma Dispatching_Domain",id:"j1510--pragma-dispatching_domain",level:2},{value:"Syntax",id:"syntax-9",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-6",level:4},{value:"Legality Rules",id:"legality-rules-9",level:4},{value:"Static Semantics",id:"static-semantics-10",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"J.15.11  Pragmas Priority and Interrupt_Priority",id:"j1511--pragmas-priority-and-interrupt_priority",level:2},{value:"Syntax",id:"syntax-10",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-7",level:4},{value:"Legality Rules",id:"legality-rules-10",level:4},{value:"Static Semantics",id:"static-semantics-11",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-9",level:4},{value:"J.15.12  Pragma Relative_Deadline",id:"j1512--pragma-relative_deadline",level:2},{value:"Syntax",id:"syntax-11",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-8",level:4},{value:"Legality Rules",id:"legality-rules-11",level:4},{value:"Static Semantics",id:"static-semantics-12",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-10",level:4},{value:"J.15.13  Pragma Asynchronous",id:"j1513--pragma-asynchronous",level:2},{value:"Syntax",id:"syntax-12",level:4},{value:"Static Semantics",id:"static-semantics-13",level:4},{value:"Legality Rules",id:"legality-rules-12",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-11",level:4},{value:"J.15.14  Elaboration Control Pragmas",id:"j1514--elaboration-control-pragmas",level:2},{value:"Syntax",id:"syntax-13",level:4},{value:"Static Semantics",id:"static-semantics-14",level:4},{value:"Legality Rules",id:"legality-rules-13",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-2",level:4},{value:"J.15.15  Distribution Pragmas",id:"j1515--distribution-pragmas",level:2},{value:"Syntax",id:"syntax-14",level:4},{value:"Static Semantics",id:"static-semantics-15",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-3",level:4}],h={toc:d};function m(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,l.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"j15--aspect-related-pragmas"},"J.15  Aspect-related Pragmas"),(0,n.kt)("admonition",{type:"warning"},(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," Pragmas can be used as an alternative to aspect_specifications to specify certain aspects. "),(0,n.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," Certain ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are defined to be ",(0,n.kt)("em",null,"program unit pragmas"),". A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," given as the argument of a program unit pragma shall resolve to denote the declarations or renamings of one or more program units that occur immediately within the declarative region or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0285"},"compilation"))," in which the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," immediately occurs, or it shall resolve to denote the declaration of the immediately enclosing program unit (if any); the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," applies to the denoted program unit(s). If there are no ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),"s given as arguments, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," applies to the immediately enclosing program unit. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The fact that this is a Name Resolution Rule means that the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," will not apply to declarations from outer declarative regions. "),(0,n.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A program unit pragma shall appear in one of these places: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," At the place of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0286"},"compilation_unit")),", in which case the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," shall immediately follow in the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0285"},"compilation"))," (except for other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s) a ",(0,n.kt)("code",null,"[library_unit_declaration](./AA-10.1#S0288)")," that is a ",(0,n.kt)("code",null,"[subprogram_declaration](./AA-6.1#S0195)"),", ",(0,n.kt)("code",null,"[generic_subprogram_declaration](./AA-12.1#S0311)"),", or ",(0,n.kt)("code",null,"[generic_instantiation](./AA-12.3#S0315)"),", and the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," shall have an argument that is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," denoting that declaration. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," has to denote the immediately preceding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0288"},"library_unit_declaration")),". "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0033"),"}"," ","{",(0,n.kt)("em",null,"AI95-00136-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," Immediately within the visible part of a program unit and before any nested declaration (but not within a generic formal part), in which case the argument, if any, shall be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name"))," that denotes the immediately enclosing program unit declaration. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The argument is optional in this case. "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," At the place of a declaration other than the first, of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," or program unit declaration, in which case the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," shall have an argument, which shall be a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name"))," that denotes one or more of the following (and nothing else): a ",(0,n.kt)("code",null,"[subprogram_declaration](./AA-6.1#S0195)"),", a ",(0,n.kt)("code",null,"[generic_subprogram_declaration](./AA-12.1#S0311)"),", or a ",(0,n.kt)("code",null,"[generic_instantiation](./AA-12.3#S0315)"),", of the same ",(0,n.kt)("code",null,"[declarative_part](./AA-3.11#S0086)")," or program unit declaration. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"If you want to denote a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," that is not a completion, or a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-7.1#S0229"},"package_declaration")),", for example, you have to put the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," inside. "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0132-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," Certain program unit pragmas are defined to be ",(0,n.kt)("em",null,"library unit pragmas"),". If a library unit pragma applies to a program unit, the program unit shall be a library unit. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This, together with the rules for program unit pragmas above, implies that if a library unit pragma applies to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.1#S0195"},"subprogram_declaration"))," (and similar things), it has to appear immediately after the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0286"},"compilation_unit")),", whereas if the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," applies to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-7.1#S0229"},"package_declaration")),", a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," that is not a completion (and similar things), it has to appear inside, as the first ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0087"},"declarative_item")),". "),(0,n.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0034"),"}"," ","{",(0,n.kt)("em",null,"AI95-00041-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A library unit pragma that applies to a generic unit does not apply to its instances, unless a specific rule for the pragma specifies the contrary. "),(0,n.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0034"),"}"," ","{",(0,n.kt)("em",null,"AI95-00041-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," When applied to a generic unit, a program unit pragma that is not a library unit pragma should apply to each instance of the generic unit for which there is not an overriding pragma applied directly to the instance. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation Advice: "),"When applied to a generic unit, a program unit pragma that is not a library unit pragma should apply to each instance of the generic unit for which there is not an overriding pragma applied directly to the instance."),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Many existing pragmas have been converted into aspects; the pragmas have moved here."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0132-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," A library unit pragma must apply directly to a library unit, even if no name is given in the pragma. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}",' The terms "program unit pragma" and "library unit pragma" were moved here as all of the ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s that use these terms are now in this annex. "),(0,n.kt)("h2",{id:"j151--pragma-inline"},"J.15.1  Pragma Inline"),(0,n.kt)("h4",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Inline, which is a program unit pragma (see 10.1.5), is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Inline (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),"{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),"}","); "),(0,n.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," shall apply to one or more callable entities or generic subprograms. "),(0,n.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma"))," Inline specifies that the Inline aspect (see 6.3.2) for each entity denoted by each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," given in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," has the value True."),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Note that inline expansion is desired no matter what ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," is used in the call. This allows one to request inlining for only one of several overloaded subprograms as follows:"),(0,n.kt)(r.Z,{mdxType:"CodeBlock"},"package IO is","\n","   procedure Put(X : in Integer);","\n","   procedure Put(X : in String);","\n","   procedure Put(X : in Character);","\n","private","\n","   procedure Character_Put(X : in Character) renames Put;","\n","   pragma Inline(Character_Put);","\n","end IO;","\n"),(0,n.kt)(r.Z,{mdxType:"CodeBlock"},"with IO; use IO;","\n","procedure Main is","\n","   I : Integer;","\n","   C : Character;","\n","begin","\n","   ...","\n","   Put(C); -- Inline expansion is desired.","\n","   Put(I); -- Inline expansion is NOT desired.","\n","end Main;","\n"),(0,n.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," An implementation may allow a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Inline that has an argument which is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name"))," denoting a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," of the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"."),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"This is allowed for Ada 83 compatibility. This is only a permission as this usage was considered obsolescent even for Ada 95. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"We only need to allow this in ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"s, because a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0089"},"body"))," is only allowed in another ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0089"},"body")),", and these all have ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),"s. "),(0,n.kt)("p",null,"NOTE 1   ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0440-1"),"}"," The name in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Inline can denote more than one entity in the case of overloading. Such a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," applies to all of the denoted entities. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00309-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A pragma Inline cannot refer to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," outside of that body. The pragma can be given inside of the subprogram body. Ada 2005 adds an Implementation Permission to allow this usage for compatibility (and Ada 95 implementations also can use this permission), but implementations do not have to allow such ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s. "),(0,n.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Inline is allowed inside a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," if there is no corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.1#S0195"},"subprogram_declaration")),". This is for uniformity with other program unit pragmas. "),(0,n.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00309-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ",(0,n.kt)("strong",null,"Amendment Correction:")," Implementations are allowed to let ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma"))," Inline apply to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),". "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-1"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Inline was moved here from 6.3.2; aspect Inline lives there now. "),(0,n.kt)("h2",{id:"j152--pragma-no_return"},"J.15.2  Pragma No_Return"),(0,n.kt)("h4",{id:"syntax-1"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," No_Return, which is a representation pragma (see 13.1), is as follows: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0269-1"),"}","   ",(0,n.kt)("strong",null,"pragma")," No_Return (",(0,n.kt)("em",null,"subprogram_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"{",", ",(0,n.kt)("em",null,"subprogram_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"}","); "),(0,n.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0269-1"),"}"," Each ",(0,n.kt)("em",null,"subprogram_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," shall denote one or more subprograms or generic subprograms. [The ",(0,n.kt)("em",null,"subprogram_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," shall not denote a null procedure nor an instance of a generic unit.] "),(0,n.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0269-1"),"}"," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma"))," No_Return specifies that the No_Return aspect (see 6.5.1) for each subprogram denoted by each ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," given in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," has the value True. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-2"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma No_Return was moved here from 6.5.1; aspect No_Return lives there now. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2012-1"},"Wording Changes from Ada 2012"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0269-1"),"}"," This subclause is new. Pragma No_Return was moved here from 6.5.1; aspect No_Return lives there now. "),(0,n.kt)("h2",{id:"j153--pragma-pack"},"J.15.3  Pragma Pack"),(0,n.kt)("h4",{id:"syntax-2"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Pack, which is a representation pragma (see 13.1), is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Pack (",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"); "),(0,n.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Pack shall denote a composite subtype. "),(0,n.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma"))," Pack specifies that the Pack aspect (see 13.2) for the type denoted by ",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," has the value True. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-3"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Pack was moved here from 13.2; aspect Pack lives there now. "),(0,n.kt)("h2",{id:"j154--pragma-storage_size"},"J.15.4  Pragma Storage_Size"),(0,n.kt)("h4",{id:"syntax-3"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Storage_Size is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Storage_Size (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Storage_Size is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),". "),(0,n.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Storage_Size is expected to be of any integer type. "),(0,n.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Storage_Size sets the Storage_Size aspect (see 13.3) of the type defined by the immediately enclosing ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition"))," to the value of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),". "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-4"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Storage_Size was moved here from 13.3; aspect Storage_Size lives there now. "),(0,n.kt)("h2",{id:"j155--interfacing-pragmas"},"J.15.5  Interfacing Pragmas"),(0,n.kt)("h4",{id:"syntax-4"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," An ",(0,n.kt)("em",null,"interfacing pragma")," is a representation pragma that is one of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s Import, Export, or Convention. Their forms are as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Import(     [Convention =",">","] ",(0,n.kt)("em",null,"convention_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier")),", [Entity =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"  [, [External_Name =",">","] ",(0,n.kt)("em",null,"external_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"]  [, [Link_Name =",">","] ",(0,n.kt)("em",null,"link_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"]);"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Export(     [Convention =",">","] ",(0,n.kt)("em",null,"convention_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier")),", [Entity =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"  [, [External_Name =",">","] ",(0,n.kt)("em",null,"external_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"]  [, [Link_Name =",">","] ",(0,n.kt)("em",null,"link_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"]);"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Convention([Convention =",">","] ",(0,n.kt)("em",null,"convention_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier")),",[Entity =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s Import and Export, the argument for Link_Name shall not be given without the ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier"))," unless the argument for External_Name is given. "),(0,n.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}","  The expected type for an ",(0,n.kt)("em",null,"external_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," and a ",(0,n.kt)("em",null,"link_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," in an interfacing pragma is String. "),(0,n.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("em",null,"convention_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier"))," of an interfacing pragma shall be the name of a convention (see B.1)."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import shall be the completion of a declaration. Notwithstanding any rule to the contrary, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import may serve as the completion of any kind of (explicit) declaration if supported by an implementation for that kind of declaration. If a completion is a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import, then it shall appear in the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-7.1#S0230"},"package_specification")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition"))," as the declaration. For a library unit, it shall appear in the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0285"},"compilation")),", before any subsequent ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0286"},"compilation_unit")),"s other than ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s. If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," denotes more than one entity, then the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import is the completion of all of them."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("em",null,"external_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," and ",(0,n.kt)("em",null,"link_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import or Export shall be static."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," of each of these pragmas shall denote a declaration that may have the similarly named aspect specified. "),(0,n.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," An interfacing pragma specifies various aspects of the entity denoted by the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," as follows: "),(0,n.kt)("p",null,"The Convention aspect (see B.1) is ",(0,n.kt)("em",null,"convention_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.3#S0002"},"identifier")),"."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import specifies that the Import aspect (see B.1) is True."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Export specifies that the Export aspect (see B.1) is True."),(0,n.kt)("p",null,"For both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Import and Export, if an external name is given in the pragma, the External_Name aspect (see B.1) is specified to be ",(0,n.kt)("em",null,"external_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),". If a link name is given in the pragma, the Link_Name aspect (see B.1) is specified to be the ",(0,n.kt)("em",null,"link_name_string_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),". "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-5"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragmas Import, Export, and Convention were moved here from B.1; aspects Import, Export, Convention, Link_Name, and External_Name live there now. "),(0,n.kt)("h2",{id:"j156--pragma-unchecked_union"},"J.15.6  Pragma Unchecked_Union"),(0,n.kt)("h4",{id:"syntax-5"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Unchecked_Union, which is a representation pragma (see 13.1), is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Unchecked_Union (",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"); "),(0,n.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Unchecked_Union shall denote an unconstrained discriminated record subtype having a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.8#S0071"},"variant_part")),". "),(0,n.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Unchecked_Union specifies that the Unchecked_Union aspect (see B.3.3) for the type denoted by ",(0,n.kt)("em",null,"first_subtype_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," has the value True. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-6"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Unchecked_Union was moved here from B.3.3; aspect Unchecked_Union lives there now. "),(0,n.kt)("h2",{id:"j157--pragmas-interrupt_handler-and-attach_handler"},"J.15.7  Pragmas Interrupt_Handler and Attach_Handler"),(0,n.kt)("h4",{id:"syntax-6"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Interrupt_Handler is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Interrupt_Handler (",(0,n.kt)("em",null,"handler_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Attach_Handler is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Attach_Handler (",(0,n.kt)("em",null,"handler_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"); "),(0,n.kt)("h4",{id:"name-resolution-rules-3"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For the Interrupt_Handler and Attach_Handler pragmas, the ",(0,n.kt)("em",null,"handler_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," shall resolve to denote a protected procedure with a parameterless profile."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For the Attach_Handler pragma, the expected type for the expression is Interrupts.Interrupt_Id (see C.3.2). "),(0,n.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0033-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The Attach_Handler and Interrupt_Handler pragmas are only allowed immediately within the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition"))," where the corresponding subprogram is declared. The corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0249"},"protected_type_declaration"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0250"},"single_protected_declaration"))," shall be a library-level declaration, and shall not be declared within a generic body. In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"In the case of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0249"},"protected_type_declaration")),", an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration"))," of an object of that type need not be at library level."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0033-1"),"}"," We cannot allow these pragmas in a generic body, because legality rules are not checked for instance bodies, and these should not be allowed if the instance is not at the library level. The protected types can be declared in the private part if this is desired. Note that while the 'Access to use the handler would provide the check in the case of Interrupt_Handler, there is no other check for Attach_Handler. Since these pragmas are so similar, we want the rules to be the same. "),(0,n.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For an implementation that supports Annex C, a pragma Interrupt_Handler specifies the Interrupt_Handler aspect (see C.3.1) for the protected procedure ",(0,n.kt)("em",null,"handler_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," to have the value True. For an implementation that supports Annex C, a pragma Attach_Handler specifies the Attach_Handler aspect (see C.3.1) for the protected procedure ",(0,n.kt)("em",null,"handler_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name"))," to have the value of the given ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"[ as evaluated at object creation time]. "),(0,n.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0033-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Added missing generic contract wording for the pragma Attach_Handler and Interrupt_Handler. This means that nested instances with these pragmas in the private part are now illegal. This is not likely to occur in practice. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-7"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragmas Interrupt_Handler and Attach_Handler were moved here from C.3.1; aspects Interrupt_Handler and Attach_Handler live there now. "),(0,n.kt)("h2",{id:"j158--shared-variable-pragmas"},"J.15.8  Shared Variable Pragmas"),(0,n.kt)("h4",{id:"syntax-7"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0425-1"),"}"," The following ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are defined with the given forms: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Atomic (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Volatile (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0009-1"),"}","   ",(0,n.kt)("strong",null,"pragma")," Independent (",(0,n.kt)("em",null,"component_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Atomic_Components (",(0,n.kt)("em",null,"array_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Volatile_Components (",(0,n.kt)("em",null,"array_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0009-1"),"}","   ",(0,n.kt)("strong",null,"pragma")," Independent_Components (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),");"),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI05-0009-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," Pragmas Independent and Independent_Components are born obsolescent; they are defined to provide consistency with the existing shared variable pragmas. As with all obsolescent features, these pragmas are not optional; all Ada implementations need to implement them. Also note that these pragmas were defined as a ",(0,n.kt)("strong",null,"Correction"),"; as such, they are expected to be implemented as part of Ada 2005 implementations (and they would not be obsolescent there). "),(0,n.kt)("h4",{id:"name-resolution-rules-4"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0009-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," in an Atomic or Volatile pragma shall resolve to denote either an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration")),", a noninherited ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.8#S0070"},"component_declaration")),", or a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.2#S0024"},"full_type_declaration")),". The ",(0,n.kt)("em",null,"component_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," in an Independent pragma shall resolve to denote a noninherited ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.8#S0070"},"component_declaration")),". The ",(0,n.kt)("em",null,"array_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," in an Atomic_Components or Volatile_Components pragma shall resolve to denote the declaration of an array type or an array object of an anonymous type. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," in an Independent_Components pragma shall resolve to denote the declaration of an array or record type or an array object of an anonymous type. "),(0,n.kt)("h4",{id:"static-semantics-8"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," These ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are representation pragmas (see 13.1). Each of these ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s specifies that the similarly named aspect (see C.6) of the type, object, or component denoted by its argument is True. "),(0,n.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," of each of these ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s shall denote a declaration that may have the similarly named aspect specified. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-8"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. These pragmas were moved here from C.6; various aspects live there now. "),(0,n.kt)("h2",{id:"j159--pragma-cpu"},"J.15.9  Pragma CPU"),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," This pragma is born obsolescent; it is defined to provide consistency with existing real-time pragmas. As with all obsolescent features, this pragma is not optional; all Ada implementations need to implement it. "),(0,n.kt)("h4",{id:"syntax-8"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," CPU is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," CPU (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");"),(0,n.kt)("h4",{id:"name-resolution-rules-5"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The expected type for the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," CPU is System.Multiprocessors.CPU_Range. "),(0,n.kt)("h4",{id:"legality-rules-8"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0281-1"),"}"," A CPU pragma is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),", or the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),"."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For a CPU pragma that appears in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," shall be static. "),(0,n.kt)("h4",{id:"static-semantics-9"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0281-1"),"}"," For an implementation that supports Annex D, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," CPU specifies the value of the CPU aspect (see D.16). If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the task type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0245"},"single_task_declaration"))," that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),". If the pragma appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the protected type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0250"},"single_protected_declaration"))," that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),". Otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the subprogram that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),". "),(0,n.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0009-1"),"}"," Pragma CPU is new. "),(0,n.kt)("h2",{id:"j1510--pragma-dispatching_domain"},"J.15.10  Pragma Dispatching_Domain"),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI05-0167-1"),"}"," This pragma is born obsolescent; it is defined to provide consistency with existing real-time pragmas. As with all obsolescent features, this pragma is not optional; all Ada implementations need to implement it. "),(0,n.kt)("h4",{id:"syntax-9"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0167-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Dispatching_Domain is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Dispatching_Domain (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");"),(0,n.kt)("h4",{id:"name-resolution-rules-6"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0167-1"),"}"," The expected type for the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is System.Multiprocessors.Dispatching_Domains.Dispatching_Domain. "),(0,n.kt)("h4",{id:"legality-rules-9"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0167-1"),"}"," A Dispatching_Domain pragma is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),". "),(0,n.kt)("h4",{id:"static-semantics-10"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0167-1"),"}"," For an implementation that supports Annex D, a pragma Dispatching_Domain specifies the value of the Dispatching_Domain aspect (see D.16.1). The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the task type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0245"},"single_task_declaration"))," that contains the pragma. "),(0,n.kt)("h4",{id:"extensions-to-ada-2005-1"},"Extensions to Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0009-1"),"}"," Pragma Dispatching_Domain is new. "),(0,n.kt)("h2",{id:"j1511--pragmas-priority-and-interrupt_priority"},"J.15.11  Pragmas Priority and Interrupt_Priority"),(0,n.kt)("h4",{id:"syntax-10"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Priority is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Priority (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Interrupt_Priority is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Interrupt_Priority [(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");]"),(0,n.kt)("h4",{id:"name-resolution-rules-7"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The expected type for the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," in a Priority or Interrupt_Priority pragma is Integer. "),(0,n.kt)("h4",{id:"legality-rules-10"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A Priority pragma is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),", or the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),". An Interrupt_Priority pragma is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition"))," or a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),"."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For a Priority pragma that appears in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," shall be static, and its value shall be in the range of System.Priority. "),(0,n.kt)("h4",{id:"static-semantics-11"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For an implementation that supports Annex D, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Priority specifies the value of the Priority aspect (see D.1) and a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Interrupt_Priority specifies the value of the Interrupt_Priority aspect as follows:"),(0,n.kt)("p",null,"If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the task type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0245"},"single_task_declaration"))," that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),";"),(0,n.kt)("p",null,"If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0251"},"protected_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the protected type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.4#S0250"},"single_protected_declaration"))," that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),";"),(0,n.kt)("p",null,"If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," appears in the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the subprogram that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," If there is no ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," in an Interrupt_Priority pragma, the Interrupt_Priority aspect has the value Interrupt_Priority'Last. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-9"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragmas Interrupt_Priority and Priority were moved here from D.1; aspects Interrupt_Priority and Priority live there now. "),(0,n.kt)("h2",{id:"j1512--pragma-relative_deadline"},"J.15.12  Pragma Relative_Deadline"),(0,n.kt)("h4",{id:"syntax-11"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Relative_Deadline is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Relative_Deadline (",(0,n.kt)("em",null,"relative_deadline_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression")),");"),(0,n.kt)("h4",{id:"name-resolution-rules-8"},"Name Resolution Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The expected type for a ",(0,n.kt)("em",null,"relative_deadline_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is Real_Time.Time_Span. "),(0,n.kt)("h4",{id:"legality-rules-11"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A Relative_Deadline pragma is allowed only immediately within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition"))," or the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-3.11#S0086"},"declarative_part"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body")),". "),(0,n.kt)("h4",{id:"static-semantics-12"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For an implementation that supports Annex D, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Relative_Deadline specifies the value of the Relative_Deadline aspect (see D.2.6). If the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0246"},"task_definition")),", the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the task type or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-9.1#S0245"},"single_task_declaration"))," that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"; otherwise, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," is associated with the aspect for the subprogram that contains the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),". "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-10"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Relative_Deadline was moved here from D.2.6; aspect Relative_Deadline lives there now. "),(0,n.kt)("h2",{id:"j1513--pragma-asynchronous"},"J.15.13  Pragma Asynchronous"),(0,n.kt)("h4",{id:"syntax-12"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The form of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Asynchronous, which is a representation pragma (see 13.1), is as follows: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Asynchronous (",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name")),"); "),(0,n.kt)("h4",{id:"static-semantics-13"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," For an implementation that supports Annex E, a pragma Asynchronous specifies that the Asynchronous aspect (see E.4.1) for the procedure or type denoted by ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," has the value True. "),(0,n.kt)("h4",{id:"legality-rules-12"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-13.1#S0345"},"local_name"))," of a pragma Asynchronous shall denote a declaration that may have aspect Asynchronous specified. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2005-11"},"Wording Changes from Ada 2005"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0299-1"),"}"," This subclause is new. Pragma Asynchronous was moved here from E.4.1; aspect Asynchronous lives there now. "),(0,n.kt)("h2",{id:"j1514--elaboration-control-pragmas"},"J.15.14  Elaboration Control Pragmas"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," This subclause defines pragmas that specify aspects that help control the elaboration order of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-10.1#S0287"},"library_item")),"s."),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," Pragmas that do not have associated aspects still appear in 10.2.1. These pragmas are presented in the order that the aspects are defined in 10.2.1. "),(0,n.kt)("h4",{id:"syntax-13"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," The following ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are defined with the given forms: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Preelaborate[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Preelaborable_Initialization(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name")),");"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Pure[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Elaborate_Body[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma")),"s Preelaborate, Pure, and Elaborate_Body are library unit pragmas. "),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"Pragma"))," Preelaborable_Initialization is ",(0,n.kt)("strong",null,"not")," a library unit pragma. "),(0,n.kt)("h4",{id:"static-semantics-14"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Preelaborate specifies that a library unit is preelaborated, namely that the Preelaborate aspect (see 10.2.1) of the library unit is True."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Pure specifies that a library unit is declared pure, namely that the Pure aspect (see 10.2.1) of the library unit is True."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Elaborate_Body specifies that [a library unit requires a completion, namely that] the Elaborate_Body aspect (see 10.2.1) of the library unit is True. "),(0,n.kt)("h4",{id:"legality-rules-13"},"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Preelaborable_Initialization specifies that the Preelaborable_Initialization aspect (see 10.2.1) for a composite type is True. This pragma shall appear in the visible part of a package or generic package."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," If the pragma appears in the first declaration list of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-7.1#S0230"},"package_specification")),", then the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name"))," shall denote the first subtype of a composite type, and the type shall be declared immediately within the same package as the pragma. The composite type shall be one for which the Preelaborable_Initialization aspect can be directly specified as True. In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," If the pragma appears in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-12.1#S0313"},"generic_formal_part")),", then the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0092"},"direct_name"))," shall denote a type declared in the same ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-12.1#S0313"},"generic_formal_part"))," as the pragma, and be one for which the Preelaborable_Initialization aspect can be directly specified as True. "),(0,n.kt)("p",null,"NOTE 1   ","{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," Pragmas Elaborate and Elaborate_All, which do not have associated aspects, are found in 10.2.1. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-2012-2"},"Wording Changes from Ada 2012"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0409-1"),"}"," This subclause is new. These pragmas were moved here from 10.2.1. "),(0,n.kt)("h2",{id:"j1515--distribution-pragmas"},"J.15.15  Distribution Pragmas"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," This subclause defines pragmas that specify properties of units for distributed systems."),(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," These pragmas are presented in the order that the aspects are defined in Annex E. "),(0,n.kt)("h4",{id:"syntax-14"},"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," The following ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma")),"s are defined with the given forms: "),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Shared_Passive[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Remote_Types[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Remote_Call_Interface[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," All_Calls_Remote[(",(0,n.kt)("em",null,"library_unit_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-4.1#S0091"},"name")),")];"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," Each of these pragmas is a library unit pragma. "),(0,n.kt)("h4",{id:"static-semantics-15"},"Static Semantics"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("em",null,"categorization pragma")," is a pragma that specifies a corresponding categorization aspect."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," The pragmas Shared_Passive, Remote_Types, and Remote_Call_Interface are categorization pragmas. In addition, the pragma Pure (see J.15.14) is considered a categorization pragma. "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Shared_Passive specifies that a library unit is a shared passive library unit, namely that the Shared_Passive aspect (see E.2.1) of the library unit is True."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Remote_Types specifies that a library unit is a remote types library unit, namely that the Remote_Types aspect (see E.2.2) of the library unit is True."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," Remote_Call_Interface specifies that a library unit is a remote call interface, namely that the Remote_Call_Interface aspect (see E.2.3) of the library unit is True."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"./AA-2.8#S0019"},"pragma"))," All_Calls_Remote specifies that the All_Calls_Remote aspect (see E.2.3) of the library unit is True."),(0,n.kt)("h4",{id:"wording-changes-from-ada-2012-3"},"Wording Changes from Ada 2012"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0417-1"),"}",' This subclause is new. These pragmas were moved here from Annex E, "Distributed Systems". '))}m.isMDXComponent=!0}}]);