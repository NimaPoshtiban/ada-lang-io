"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5473],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>c});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=d(a),c=i,h=m["".concat(l,".").concat(c)]||m[c]||u[c]||r;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4089:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var n=a(9440),i=(a(6687),a(1716));const r={sidebar_position:115},s="13.13  Streams",o={unversionedId:"arm/AA-13.13",id:"arm/AA-13.13",title:"13.13  Streams",description:"A stream is a sequence of elements comprising values from possibly different types and allowing sequential access to these values. A stream type is a type in the class whose root type is Streams.RootStreamType. A stream type may be implemented in various ways, such as an external sequential file, an internal buffer, or a network channel.",source:"@site/docs/arm/AA-13.13.md",sourceDirName:"arm",slug:"/arm/AA-13.13",permalink:"/docs/arm/AA-13.13",draft:!1,tags:[],version:"current",sidebarPosition:115,frontMatter:{sidebar_position:115},sidebar:"tutorialSidebar",previous:{title:"13.12  Pragma Restrictions and Pragma Profile",permalink:"/docs/arm/AA-13.12"},next:{title:"13.14  Freezing Rules",permalink:"/docs/arm/AA-13.14"}},l={},d=[{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"13.13.1  The Streams Subsystem",id:"13131--the-streams-subsystem",level:2},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"13.13.2  Stream-Oriented Attributes",id:"13132--stream-oriented-attributes",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Implementation Advice",id:"implementation-advice-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Erroneous Execution",id:"erroneous-execution",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],p={toc:d};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1313--streams"},"13.13  Streams"),(0,i.kt)("p",null,"A stream is a sequence of elements comprising values from possibly different types and allowing sequential access to these values. A stream type is a type in the class whose root type is Streams.Root_Stream_Type. A stream type may be implemented in various ways, such as an external sequential file, an internal buffer, or a network channel. "),(0,i.kt)("p",null,"Discussion: A stream element will often be the same size as a storage element, but that is not required. "),(0,i.kt)("p",null,"Glossary entry: A stream is a sequence of elements that can be used, along with the stream-oriented attributes, to support marshalling and unmarshalling of values of most types."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[T]",",Term=","[stream]",", Def=","[a sequence of elements that can be used, along with the stream-oriented attributes, to support marshalling and unmarshalling of values of most types]"," "),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Streams are new in Ada 95. "),(0,i.kt)("h2",{id:"13131--the-streams-subsystem"},"13.13.1  The Streams Subsystem"),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"The abstract type Root_Stream_Type is the root type of the class of stream types. The types in this class represent different kinds of streams. A new stream type is defined by extending the root type (or some other stream type), overriding the Read and Write operations, and optionally defining additional primitive subprograms, according to the requirements of the particular kind of stream. The predefined stream-oriented attributes like T'Read and T'Write make dispatching calls on the Read and Write procedures of the Root_Stream_Type. (User-defined T'Read and T'Write attributes can also make such calls, or can call the Read and Write attributes of other types.)"),(0,i.kt)("p",null,"{AI12-0293-1} The library package Ada.Streams has the following declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI12-0241-1} package Ada.Streams\n    with Pure, Nonblocking =&gt False is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00161-01}     type Root_Stream_Type is abstract tagged limited private\n        with Preelaborable_Initialization;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{8652/0044} {AI95-00181-01}     type Stream_Element is mod implementation-defined;\n    type Stream_Element_Offset is range implementation-defined;\n    subtype Stream_Element_Count is\n        Stream_Element_Offset range 0..Stream_Element_Offset'Last;\n    type Stream_Element_Array is\n        array(Stream_Element_Offset range &lt&gt) of aliased Stream_Element;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Read(\n      Stream : in out Root_Stream_Type;\n      Item   : out Stream_Element_Array;\n      Last   : out Stream_Element_Offset) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Write(\n      Stream : in out Root_Stream_Type;\n      Item   : in Stream_Element_Array) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Streams;\n\n")),(0,i.kt)("p",null,"Reason: {AI12-0241-1} This package must allow blocking (Nonblocking =",">"," False) for compatibility. The purpose of this package is to provide a template for overriding user-defined routines; and such routines can only allow blocking if the root type does so. Users can still declare their overridding routines nonblocking if they wish. "),(0,i.kt)("p",null,"{AI95-00227-01} The Read operation transfers stream elements from the specified stream to fill the array Item. Elements are transferred until Item'Length elements have been transferred, or until the end of the stream is reached. If any elements are transferred, the index of the last stream element transferred is returned in Last. Otherwise, Item'First - 1 is returned in Last. Last is less than Item'Last only if the end of the stream is reached."),(0,i.kt)("p",null,"The Write operation appends Item to the specified stream."),(0,i.kt)("p",null,"Discussion: {AI95-00114-01} The index subtype of Stream_Element_Array is Stream_Element_Offset because we wish to allow maximum flexibility. Most Stream_Element_Arrays will probably have a lower bound of 0 or 1, but other lower bounds, including negative ones, make sense in some situations."),(0,i.kt)("p",null,"{AI95-00114-01} {AI05-0005-1} Note that there are some language-defined subprograms that fill part of a Stream_Element_Array, and return the index of the last element filled as a Stream_Element_Offset. The Read procedures declared here, Streams.Stream_IO (see A.12.1), and System.RPC (see E.5) behave in this manner. These will raise Constraint_Error if the resulting Last value is not in Stream_Element_Offset. This implies that the Stream_Element_Array passed to these subprograms should not have a lower bound of Stream_Element_Offset'First, because then a read of 0 elements would always raise Constraint_Error. A better choice of lower bound is 0 or 1. "),(0,i.kt)("p",null,"{AI12-0293-1} Three additional packages provide stream implementations that do not make use of any file operations. These packages provide the same operations, with Streams.Storage providing an abstract interface, and two child packages providing implementations of that interface. The difference is that for Streams.Storage.Bounded, the maximum storage is bounded."),(0,i.kt)("p",null,"{AI12-0293-1} The library package Ada.Streams.Storage has the following declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Streams.Storage\n   with Pure, Nonblocking is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Storage_Stream_Type is abstract new Root_Stream_Type with private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Element_Count (Stream : Storage_Stream_Type)\n      return Stream_Element_Count is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Clear (Stream : in out Storage_Stream_Type) is abstract;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Streams.Storage;\n\n")),(0,i.kt)("p",null,"{AI12-0293-1} The library package Ada.Streams.Storage.Unbounded has the following declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Streams.Storage.Unbounded\n   with Prelaborated, Nonblocking, Global =&gt in out synchronized is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Stream_Type is new Storage_Stream_Type with private\n      with Default_Initial_Condition =&gt\n          Element_Count (Stream_Type) = 0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   procedure Read (\n      Stream : in out Stream_Type;\n      Item   : out Stream_Element_Array;\n      Last   : out Stream_Element_Offset)\n      with Post =&gt\n          (declare\n              Num_Read : constant Stream_Element_Count :=\n                 Stream_Element_Count'Min\n                    (Element_Count(Stream)'Old, Item'Length);\n           begin\n              Last = Num_Read + Item'First - 1 and\n              Element_Count (Stream) =\n                 Element_Count (Stream)'Old - Num_Read);\n\n")),(0,i.kt)("p",null,"Discussion: Num_Read is the number of elements read; this is the minimum of Item'Length and the number of available elements. Last then is determined by that, and the Element_Count decreases by the number of elements read. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   procedure Write (\n      Stream : in out Stream_Type;\n      Item   : in Stream_Element_Array)\n      with Post =&gt\n         Element_Count (Stream) =\n         Element_Count (Stream)'Old + Item'Length;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   function Element_Count (Stream : Stream_Type)\n      return Stream_Element_Count;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   procedure Clear (Stream : in out Stream_Type)\n      with Post =&gt Element_Count (Stream) = 0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Streams.Storage.Unbounded;\n\n")),(0,i.kt)("p",null,"{AI12-0293-1} The library package Ada.Streams.Storage.Bounded has the following declaration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Ada.Streams.Storage.Bounded\n    with Pure, Nonblocking is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Stream_Type (Max_Elements : Stream_Element_Count)\n      is new Storage_Stream_Type with private\n         with Default_Initial_Condition =&gt\n            Element_Count (Stream_Type) = 0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   procedure Read (\n      Stream : in out Stream_Type;\n      Item   : out Stream_Element_Array;\n      Last   : out Stream_Element_Offset)\n      with Post =&gt\n          (declare\n              Num_Read : constant Stream_Element_Count :=\n                 Stream_Element_Count'Min\n                    (Element_Count(Stream)'Old, Item'Length);\n           begin\n              Last = Num_Read + Item'First - 1 and\n              Element_Count (Stream) =\n                 Element_Count (Stream)'Old - Num_Read);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   procedure Write (\n      Stream : in out Stream_Type;\n      Item   : in Stream_Element_Array)\n      with Pre =&gt\n              Element_Count (Stream) + Item'Length &lt= Stream.Max_Elements\n              or else (raise Constraint_Error),\n           Post =&gt\n              Element_Count (Stream) =\n              Element_Count (Stream)'Old + Item'Length;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n   function Element_Count (Stream : Stream_Type)\n      return Stream_Element_Count\n      with Post =&gt Element_Count'Result &lt= Stream.Max_Elements;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   overriding\n    procedure Clear (Stream : in out Stream_Type)\n       with Post =&gt Element_Count (Stream) = 0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"private\n   ... -- not specified by the language\nend Ada.Streams.Storage.Bounded;\n\n")),(0,i.kt)("p",null,"{AI12-0293-1} The Element_Count functions return the number of stream elements that are available for reading from the given stream."),(0,i.kt)("p",null,"{AI12-0293-1} The Read and Write procedures behave as described for package Ada.Streams above. Stream elements are read in FIFO (first-in, first-out) order; stream elements are available for reading immediately after they are written."),(0,i.kt)("p",null,"{AI12-0293-1} The Clear procedures remove any available stream elements from the given stream."),(0,i.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,i.kt)("p",null,"{8652/0044} {AI95-00181-01} {AI12-0444-1} If Stream_Element'Size is not a multiple of System.Storage_Unit, then the components of Stream_Element_Array will not be aliased. "),(0,i.kt)("p",null,"Ramification: {AI95-00114-01} If the Stream_Element'Size is less than the size of System.Storage_Unit, then components of Stream_Element_Array need not be aliased. This is necessary as the components of type Stream_Element size might not be addressable on the target architecture. "),(0,i.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,i.kt)("p",null,"{AI12-0293-1} Streams.Storage.Bounded.Stream_Type objects should be implemented without implicit pointers or dynamic allocation."),(0,i.kt)("p",null,"Implementation Advice: Streams.Storage.Bounded.Stream_Type objects should be implemented without implicit pointers or dynamic allocation."),(0,i.kt)("p",null,"Reason: The Streams.Storage.Bounded package is provided in order to make available an alternative to the Streams.Storage.Unbounded package which gives more predictable memory usage. "),(0,i.kt)("p",null,'NOTE 1   See A.12.1, "The Package Streams.Stream_IO" for an example of extending type Root_Stream_Type.'),(0,i.kt)("p",null,"NOTE 2   {AI95-00227-01} If the end of stream has been reached, and Item'First is Stream_Element_Offset'First, Read will raise Constraint_Error. "),(0,i.kt)("p",null,"Ramification: Thus, Stream_Element_Arrays should start at 0 or 1, not Stream_Element_Offset'First. "),(0,i.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00161-01} Amendment Correction: Added ",(0,i.kt)("a",{parentName:"p",href:"./AA-2.8#S0019"},"pragma")," Preelaborable_Initialization to type Root_Stream_Type. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0044} {AI95-00181-01} Corrigendum: Stream elements are aliased presuming that makes sense."),(0,i.kt)("p",null,"{AI95-00227-01} Fixed the wording for Read to properly define the result in Last when no stream elements are transfered. "),(0,i.kt)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0293-1} Package Ada.Streams.Storage and its children are new. "),(0,i.kt)("h2",{id:"13132--stream-oriented-attributes"},"13.13.2  Stream-Oriented Attributes"),(0,i.kt)("p",null,"{8652/0009} {AI95-00137-01} {AI05-0183-1} The type-related operational attributes Write, Read, Output, and Input convert values to a stream of elements and reconstruct values from a stream. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"{AI95-00270-01} For every subtype S of an elementary type T, the following representation attribute is defined: "),(0,i.kt)("p",null,"S'Stream_Size{AI95-00270-01} {AI05-0194-1} Denotes the number of bits read from or written to a stream by the default implementations of S'Read and S'Write. Hence, the number of stream elements required per item of elementary type T is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"T'Stream_Size / Ada.Streams.Stream_Element'Size\n\n")),(0,i.kt)("p",null,"The value of this attribute is of type universal_integer and is a multiple of Stream_Element'Size."),(0,i.kt)("p",null,"Stream_Size may be specified for first subtypes via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),"; the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.4#S0132"},"expression")," of such a clause shall be static, nonnegative, and a multiple of Stream_Element'Size."),(0,i.kt)("p",null,"Aspect Description for Stream_Size: Size in bits used to represent elementary objects in a stream."),(0,i.kt)("p",null,"Discussion: Stream_Size is a type-related attribute (see 13.1). "),(0,i.kt)("p",null,"Ramification: {AI05-0194-1} The value of S'Stream_Size is unaffected by the presence or absence of any ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),"s or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),"s specifying the Read or Write attributes of any ancestor of S. S'Stream_Size is defined in terms of the behavior of the default implementations of S'Read and S'Write even if those default implementations are overridden. "),(0,i.kt)("h4",{id:"implementation-advice-1"},"Implementation Advice"),(0,i.kt)("p",null,"{AI95-00270-01} If not specified, the value of Stream_Size for an elementary type should be the number of bits that corresponds to the minimum number of stream elements required by the first subtype of the type, rounded up to the nearest factor or multiple of the word size that is also a multiple of the stream element size. "),(0,i.kt)("p",null,"Implementation Advice: If not specified, the value of Stream_Size for an elementary type should be the number of bits that corresponds to the minimum number of stream elements required by the first subtype of the type, rounded up to the nearest factor or multiple of the word size that is also a multiple of the stream element size."),(0,i.kt)("p",null,"Reason: {AI95-00270-01} This is Implementation Advice because we want to allow implementations to remain compatible with their Ada 95 implementations, which may have a different handling of the number of stream elements. Users can always specify Stream_Size if they need a specific number of stream elements. "),(0,i.kt)("p",null,"{AI95-00270-01} The recommended level of support for the Stream_Size attribute is: "),(0,i.kt)("p",null,"{AI95-00270-01} A Stream_Size clause should be supported for a discrete or fixed point type T if the specified Stream_Size is a multiple of Stream_Element'Size and is no less than the size of the first subtype of T, and no greater than the size of the largest type of the same elementary class (signed integer, modular integer, enumeration, ordinary fixed point, or decimal fixed point). "),(0,i.kt)("p",null,"Implementation Advice: The recommended level of support for the Stream_Size attribute should be followed."),(0,i.kt)("p",null,"Ramification: There are no requirements beyond supporting confirming Stream_Size clauses for floating point and access types. Floating point and access types usually only have a handful of defined formats, streaming anything else makes no sense for them."),(0,i.kt)("p",null,'For discrete and fixed point types, this may require support for sizes other than the "natural" ones. For instance, on a typical machine with 32-bit integers and a Stream_Element\'Size of 8, setting Stream_Size to 24 must be supported. This is required as such formats can be useful for interoperability with unusual machines, and there is no difficulty with the implementation (drop extra bits on output, sign extend on input). '),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S of a specific type T, the following attributes are defined. "),(0,i.kt)("p",null,"S'WriteS'Write denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Write(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item : in T)\n\n")),(0,i.kt)("p",null,"S'Write writes the value of Item to Stream."),(0,i.kt)("p",null,"S'ReadS'Read denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Read(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item : out T)\n\n")),(0,i.kt)("p",null,"S'Read reads the value of Item from Stream. "),(0,i.kt)("p",null,"This paragraph was deleted.{8652/0040} {AI95-00108-01} {AI95-00444-01} {AI05-0192-1} {AI05-0419-1} "),(0,i.kt)("p",null,"{AI95-00444-01} The default implementations of the Write and Read attributes, where available, execute as follows:"),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} {AI95-00195-01} {AI95-00251-01} {AI95-00270-01} {AI05-0139-2} {AI12-0191-1} {AI12-0419-1} For nonderived elementary types, Read reads (and Write writes) the number of stream elements implied by the Stream_Size for the type T; the representation of those stream elements is implementation defined. For nonderived composite types, the Write or Read attribute for each component (excluding those, if any, that are not components of the nominal type of the object) is called in canonical order, which is last dimension varying fastest for an array (unless the convention of the array is Fortran, in which case it is first dimension varying fastest), and positional aggregate order for a record. Bounds are not included in the stream if T is an array type. If T is a discriminated type, discriminants are included only if they have defaults. If T is a tagged type, the tag is not included. "),(0,i.kt)("p",null,"Implementation defined: The contents of the stream elements read and written by the Read and Write attributes of elementary types."),(0,i.kt)("p",null,"{AI12-0419-1} For type extensions, the Write or Read attribute for the parent type is called, followed by the Write or Read attribute of each component of the extension part, in canonical order. For a limited type extension, if the attribute of the parent type or any progenitor type of T is available anywhere within the immediate scope of T, and the attribute of the parent type or the type of any of the extension components is not available at the freezing point of T, then the attribute of T shall be directly specified. For untagged derived types, the Write (resp. Read) attribute invokes the corresponding attribute of the parent type, if the attribute is available for the parent type."),(0,i.kt)("p",null,"Implementation Note: {AI12-0419-1} The default implementation of a stream-oriented attribute might not be well-defined in cases where the attribute is never available anywhere in the scope of the type. In such cases, the attribute cannot be called and is defined (far below) to raise Program_Error. "),(0,i.kt)("p",null,"{AI05-0023-1} {AI05-0264-1} {AI12-0419-1} If T is a discriminated type and its discriminants have defaults, then S'Read first reads the discriminants from the stream without modifying Item. S'Read then creates an object of type T constrained by these discriminants. The value of this object is then converted to the subtype of Item and is assigned to Item. Finally, the Read attribute for each nondiscriminant component of Item is called in canonical order as described above. Normal default initialization and finalization take place for the created object."),(0,i.kt)("p",null,'Reason: A discriminant with a default value is treated simply as a component of the object. On the other hand, an array bound or a discriminant without a default value, is treated as "descriptor" or "dope" that must be provided in order to create the object and thus is logically separate from the regular components. Such "descriptor" data are written by \'Output and produced as part of the delivered result by the \'Input function, but they are not written by \'Write nor read by \'Read. A tag is like a discriminant without a default.'),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} For limited type extensions, we must have a definition of 'Read and 'Write if the parent type has one, as it is possible to make a dispatching call through the attributes. The rule is designed to automatically do the right thing in as many cases as possible."),(0,i.kt)("p",null,"{AI95-00251-01} Similarly, a type that has a progenitor with an available attribute must also have that attribute, for the same reason."),(0,i.kt)("p",null,"{AI05-0023-1} The semantics of S'Read for a discriminated type with defaults involves an anonymous object so that the point of required initialization and finalization is well-defined, especially for objects that change shape and have controlled components. The creation of this anonymous object often can be omitted (see the Implementation Permissions below). "),(0,i.kt)("p",null,"Ramification: {AI95-00195-01} For a composite object, the subprogram denoted by the Write or Read attribute of each component is called, whether it is the default or is user-specified. Implementations are allowed to optimize these calls (see below), presuming the properties of the attributes are preserved. "),(0,i.kt)("p",null,"{AI95-00270-01} {AI05-0264-1} {AI12-0419-1} Constraint_Error is raised by the predefined Write attribute if the value of the elementary item is outside the range of values representable using Stream_Size bits. For a signed integer type, an enumeration type, or a fixed point type, the range is unsigned only if the integer code for the lower bound of the first subtype is nonnegative, and a (symmetric) signed range that covers all values of the first subtype would require more than Stream_Size bits; otherwise, the range is signed."),(0,i.kt)("p",null,"For every subtype S'Class of a class-wide type T'Class: "),(0,i.kt)("p",null,"S'Class'WriteS'Class'Write denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Class'Write(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item   : in T'Class)\n\n")),(0,i.kt)("p",null,"Dispatches to the subprogram denoted by the Write attribute of the specific type identified by the tag of Item."),(0,i.kt)("p",null,"S'Class'ReadS'Class'Read denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Class'Read(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item : out T'Class)\n\n")),(0,i.kt)("p",null,"Dispatches to the subprogram denoted by the Read attribute of the specific type identified by the tag of Item. "),(0,i.kt)("p",null,"Reason: It is necessary to have class-wide versions of Read and Write in order to avoid generic contract model violations; in a generic, we don't necessarily know at compile time whether a given type is specific or class-wide. "),(0,i.kt)("p",null,"Paragraph 17 was deleted. "),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"For every subtype S of a specific type T, the following attributes are defined. "),(0,i.kt)("p",null,"S'OutputS'Output denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Output(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item : in T)\n\n")),(0,i.kt)("p",null,"S'Output writes the value of Item to Stream, including any bounds or discriminants. "),(0,i.kt)("p",null,"Ramification: Note that the bounds are included even for an array type whose first subtype is constrained. "),(0,i.kt)("p",null,"S'InputS'Input denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} function S'Input(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class)\n   return T\n\n")),(0,i.kt)("p",null,"S'Input reads and returns one value from Stream, using any bounds or discriminants written by a corresponding S'Output to determine how much to read. "),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} {AI95-00444-01} {AI05-0192-1} {AI12-0419-1} For an untagged derived type, the default implementation of the Output (resp. Input) attribute invokes the corresponding attribute of the parent type, if the attribute is available for the parent type. For any other type, the default implementations of the Output and Input attributes, where available, execute as follows:"),(0,i.kt)("p",null,"{AI05-0269-1} If T is an array type, S'Output first writes the bounds, and S'Input first reads the bounds. If T has discriminants without defaults, S'Output first writes the discriminants (using the Write attribute of the discriminant type for each), and S'Input first reads the discriminants (using the Read attribute of the discriminant type for each)."),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0023-1} S'Output then calls S'Write to write the value of Item to the stream. S'Input then creates an object of type T, with the bounds or (when without defaults) the discriminants, if any, taken from the stream, passes it to S'Read, and returns the value of the object. If T has discriminants, then this object is unconstrained if and only the discriminants have defaults. Normal default initialization and finalization take place for this object (see 3.3.1, 7.6, and 7.6.1). "),(0,i.kt)("p",null,"{AI95-00251-01} If T is an abstract type, then S'Input is an abstract function."),(0,i.kt)("p",null,"Ramification: For an abstract type T, S'Input can be called in a dispatching call, or passed to an abstract formal subprogram. But it cannot be used in nondispatching contexts, because we don't allow objects of abstract types to exist. The designation of this function as abstract has no impact on descendants of T, as T'Input is not inherited for tagged types, but rather recreated (and the default implementation of T'Input calls T'Read, not the parent type's T'Input). Note that T'Input cannot be specified in this case, as any function with the proper profile is necessarily abstract, and specifying abstract subprograms in an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," is illegal. "),(0,i.kt)("p",null,"For every subtype S'Class of a class-wide type T'Class: "),(0,i.kt)("p",null,"S'Class'OutputS'Class'Output denotes a procedure with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure S'Class'Output(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n   Item   : in T'Class)\n\n")),(0,i.kt)("p",null,"{AI95-00344-01} First writes the external tag of Item to Stream (by calling String'Output(Stream, Tags.External_Tag(Item'Tag)) - see 3.9) and then dispatches to the subprogram denoted by the Output attribute of the specific type identified by the tag. Tag_Error is raised if the tag of Item identifies a type declared at an accessibility level deeper than that of S. "),(0,i.kt)("p",null,"Reason: {AI95-00344-01} We raise Tag_Error here for nested types as such a type cannot be successfully read with S'Class'Input, and it doesn't make sense to allow writing a value that cannot be read. "),(0,i.kt)("p",null,"S'Class'InputS'Class'Input denotes a function with the following specification: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} function S'Class'Input(\n   Stream : not null access Ada.Streams.Root_Stream_Type'Class)\n   return T'Class\n\n")),(0,i.kt)("p",null,"{AI95-00279-01} {AI95-00344-01} {AI05-0109-1} {AI12-0439-1} First reads the external tag from Stream and determines the corresponding internal tag (by calling Tags.Descendant_Tag(String'Input(Stream), S'Tag) which can raise Tag_Error - see 3.9) and then dispatches to the subprogram denoted by the Input attribute of the specific type identified by the internal tag; returns that result. If the specific type identified by the internal tag is abstract, Constraint_Error is raised."),(0,i.kt)("p",null,"Ramification: {AI05-0109-1} Descendant_Tag will ensure that the tag it returns is covered by T'Class; Tag_Error will be raised if it would not cover T'Class. "),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0228-1} In the default implementation of Read and Input for a composite type, for each scalar component that is a discriminant or that has an implicit initial value, a check is made that the value returned by Read for the component belongs to its subtype. Constraint_Error is raised if this check fails. For other scalar components, no check is made. For each component that is of an access type, if the implementation can detect that the value returned by Read for the component is not a value of its subtype, Constraint_Error is raised. If the value is not a value of its subtype and this error is not detected, the component has an abnormal value, and erroneous execution can result (see 13.9.1). In the default implementation of Read for a composite type with defaulted discriminants, if the actual parameter of Read is constrained, a check is made that the discriminants read from the stream are equal to those of the actual parameter. Constraint_Error is raised if this check fails."),(0,i.kt)("p",null,'Reason: {AI05-0228-1} The check for scalar components that have an implicit initial value is to preserve our Language Design Principle that all objects that have an implicit initial value do not become "deinitialized". '),(0,i.kt)("p",null,"Ramification: {AI05-0228-1} A scalar component can have an implicit initial value if it has a default_expression, if the component's type has the Default_Value aspect specified, or if the component is that of an array type that has the Default_Component_Value aspect specified. "),(0,i.kt)("p",null,'To be honest: {AI05-0228-1} An implementation should always be able to detect the error for a null value read into a component of an access subtype with a null exclusion; the "if the implementation can detect" is intended to cover nonnull access values. '),(0,i.kt)("p",null,"{AI95-00195-01} It is unspecified at which point and in which order these checks are performed. In particular, if Constraint_Error is raised due to the failure of one of these checks, it is unspecified how many stream elements have been read from the stream."),(0,i.kt)("p",null,"{8652/0045} {AI95-00132-01} In the default implementation of Read and Input for a type, End_Error is raised if the end of the stream is reached before the reading of a value of the type is completed."),(0,i.kt)("p",null,"{AI12-0064-2} {AI12-0396-1} The Nonblocking aspect is statically True and the Global aspect is null for the default implementations of stream-oriented attributes for elementary types. For the default implementations of stream-oriented attributes for composite types, the value of the Nonblocking aspect is that of the first subtype, and the Global aspect defaults to that of the first subtype. A default implementation of a stream-oriented attribute that has the Nonblocking aspect statically True is considered a nonblocking region. The aspect Dispatching (see H.7.1) is Read(Stream) for the default implementations of the stream-oriented attributes Read, Read'Class, Input, and Input'Class; the aspect Dispatching is Write(Stream) for the default implementations of the stream-oriented attributes Write, Write'Class, Output, and Output'Class."),(0,i.kt)("p",null,"Ramification: If the default implementation of a stream-oriented attribute A for a composite type would call other stream-oriented attribute(s) whose Global aspect was not allowed by the Global aspect ofA, then the Legality Rules of 6.1.2 are violated and the type declaration is illegal. If the stream-oriented attribute A is overridden, then the default implementation is not created and this check is not made. A similar ramification applies to the Nonblocking aspect of default implementation of a stream-oriented attribute. "),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} {AI95-00195-01} {AI95-00251-01} {AI05-0039-1} {AI12-0106-1} {AI12-0121-1} {AI12-0435-1} The stream-oriented attributes may be specified for any type via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),". [Alternatively, each of the specific stream-oriented attributes may be specified using an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," on any ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.2#S0023"},"type_declaration"),", with the aspect name being the corresponding attribute name.] Each of the class-wide stream-oriented attributes may be specified using an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," for a tagged type T using the name of the stream-oriented attribute followed by 'Class; such class-wide aspects do not apply to other descendants of T. If not directly specified, a default implementation of a stream-oriented attribute is implicitly composed for a nonlimited type, and for certain limited types, as defined above. "),(0,i.kt)("p",null,"Reason: {AI95-00195-01} {AI12-0106-1} We need the last sentence to override the blanket rule given in 13.1.1 that aspect'Class applies to the type and all descendants. "),(0,i.kt)("p",null,"This paragraph was deleted.{8652/0040} {AI95-00108-01} {AI95-00195-01} "),(0,i.kt)("p",null,"Proof: {AI12-0121-1} 13.1.1 says that all operational attributes can be specified with an aspect_specification. "),(0,i.kt)("p",null,"Aspect Description for Read'Class: Procedure to read a value from a stream for the class-wide type associated with a given type."),(0,i.kt)("p",null,"Aspect Description for Write'Class: Procedure to write a value to a stream for a the class-wide type associated with a given type."),(0,i.kt)("p",null,"Aspect Description for Input'Class: Function to read a value from a stream for a the class-wide type associated with a given type, including any bounds and discriminants."),(0,i.kt)("p",null,"Aspect Description for Output'Class: Procedure to write a value to a stream for a the class-wide type associated with a given type, including any bounds and discriminants."),(0,i.kt)("p",null,"{AI12-0121-1} The subprogram name given in such an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," shall statically denote a subprogram that is not an abstract subprogram. Furthermore, if a specific stream-oriented attribute is specified for an interface type, the subprogram name given in the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," shall statically denote a null procedure."),(0,i.kt)("p",null,"Discussion: {AI95-00251-01} Stream attributes (other than Input) are always null procedures for interface types (they have no components). We need to allow explicit setting of the Read and Write attributes in order that the class-wide attributes like LI'Class'Input can be made available. (In that case, any descendant of the interface type would require available attributes.) But we don't allow any concrete implementation because these don't participate in extensions (unless the interface is the parent type). If we didn't ban concrete implementations, the order of declaration of a pair of interfaces would become significant. For example, if Int1 and Int2 are interfaces with concrete implementations of 'Read, then the following declarations would have different implementations for 'Read: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Con1 is new Int1 and Int2 with null record;\ntype Con2 is new Int2 and Int1 with null record;\n\n")),(0,i.kt)("p",null,"This would violate our design principle that the order of the specification of the interfaces in a ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.4#S0035"},"derived_type_definition")," doesn't matter. "),(0,i.kt)("p",null,"Ramification: The Input attribute cannot be specified for an interface. As it is a function, a null procedure is impossible; a concrete function is not possible anyway as any function returning an abstract type must be abstract. And we don't allow specifying stream attributes to be abstract subprograms. This has no impact, as the availability of Int'Class'Input (where Int is a limited interface) depends on whether Int'Read (not Int'Input) is specified. There is no reason to allow Int'Output to be specified, either, but there is equally no reason to disallow it, so we don't have a special rule for that. "),(0,i.kt)("p",null,"Discussion: {AI95-00195-01} Limited types generally do not have default implementations of the stream-oriented attributes. The rules defining when a stream-oriented attribute is available (see below) determine when an attribute of a limited type is in fact well defined and usable. The rules are designed to maximize the number of cases in which the attributes are usable. For instance, when the language provides a default implementation of an attribute for a limited type based on a specified attribute for the parent type, we want to be able to call that attribute. "),(0,i.kt)("p",null,"Aspect Description for Read: Procedure to read a value from a stream for a given type."),(0,i.kt)("p",null,"Aspect Description for Write: Procedure to write a value to a stream for a given type."),(0,i.kt)("p",null,"Aspect Description for Input: Function to read a value from a stream for a given type, including any bounds and discriminants."),(0,i.kt)("p",null,"Aspect Description for Output: Procedure to write a value to a stream for a given type, including any bounds and discriminants."),(0,i.kt)("p",null,"{AI95-00195-01} A stream-oriented attribute for a subtype of a specific type T is available at places where one of the following conditions is true: "),(0,i.kt)("p",null,"T is nonlimited."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," is Read (resp. Write) and T is a limited record extension, and the attribute Read (resp. Write) is available for the parent type of T and for the types of all of the extension components. "),(0,i.kt)("p",null,"Reason: In this case, the language provides a well-defined default implementation, which we want to be able to call. "),(0,i.kt)("p",null,"{AI12-0419-1} T is a limited untagged derived type, and the attribute is available for the parent type. "),(0,i.kt)("p",null,"Reason: {AI12-0419-1} Again, the language provides a default implementation, which we want to be able to call. "),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0101"},"attribute_designator")," is Input (resp. Output), and T is a limited type, and the attribute Read (resp. Write) is available for T. "),(0,i.kt)("p",null,"Reason: The default implementation of Input and Output are based on Read and Write; so if the implementation of Read or Write is good, so is the matching implementation of Input or Output. "),(0,i.kt)("p",null,"{AI12-0419-1} The attribute has been specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),", and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," is visible. "),(0,i.kt)("p",null,"Reason: We always want to allow calling a specified attribute. But we don't want availability to break privacy. Therefore, only attributes whose specification can be seen count. Yes, we defined the visibility of an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," (see 8.3). "),(0,i.kt)("p",null,"{AI95-00195-01} A stream-oriented attribute for a subtype of a class-wide type T'Class is available at places where one of the following conditions is true:"),(0,i.kt)("p",null,"T is nonlimited;"),(0,i.kt)("p",null,"{AI12-0419-1} the attribute has been specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),", and the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," is visible; or"),(0,i.kt)("p",null,"the corresponding attribute of T is available, provided that if T has a partial view, the corresponding attribute is available at the end of the visible part where T is declared."),(0,i.kt)("p",null,"Reason: The rules are stricter for class-wide attributes because (for the default implementation) we must ensure that any specific attribute that might ever be dispatched to is available. Because we require specification of attributes for extensions of limited parent types with available attributes, we can in fact know this. Otherwise, we would not be able to use default class-wide attributes with limited types, a significant limitation. "),(0,i.kt)("p",null,"{AI95-00195-01} {AI12-0030-1} An ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," for one of the stream-oriented attributes is illegal unless the attribute is available at the place of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference"),". Furthermore, an ",(0,i.kt)("a",{parentName:"p",href:"./AA-4.1#S0100"},"attribute_reference")," for T'Input is illegal if T is an abstract type. In addition to the places where Legality Rules normally apply (see 12.3), these rules also apply in the private part of an instance of a generic unit."),(0,i.kt)("p",null,"Discussion: Stream attributes always exist. It is illegal to call them in some cases. Having the attributes not be defined for some limited types would seem to be a cleaner solution, but it would lead to contract model problems for limited private types."),(0,i.kt)("p",null,"T'Input is available for abstract types so that T'Class'Input is available. But we certainly don't want to allow calls that could create an object of an abstract type. Remember that T'Class is never abstract, so the above legality rule doesn't apply to it. We don't have to discuss whether the attribute is specified, as it cannot be: any function returning the type would have to be abstract, and we do not allow specifying an attribute with an abstract subprogram. "),(0,i.kt)("p",null,'To be honest: {AI12-0030-1} "These rules apply" refers to just this paragraph and not to the rest of the rules in this section. This rule probably should have been a Legality Rule, but the word "illegal" should key the reader that this is a Legality Rule, no matter under what text heading it occurs. '),(0,i.kt)("p",null,"{AI12-0030-1} {AI12-0419-1} Unless available for a parent type, if any, for an untagged type having a task, protected, or explicitly limited record part, the default implementation of each of the Read, Write, Input, and Output attributes raises Program_Error and performs no other action."),(0,i.kt)("p",null,"Discussion: {AI12-0030-1} {AI12-0419-1} It might seem that there is no need to specify the behavior of the default implementation of a streaming attribute of, for example, a task type because there is no way that it can be invoked. It is possible, however, to construct an example where such a stream attribute can be invoked. This involves using a formal untagged limited derived type for which some streaming attribute is available (because it was explicitly specified for the ancestor type) and a corresponding actual type for which the attribute is unspecified (because the derivation occurred in a place where the attribute is never available for the parent type). "),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0192-1} In the ",(0,i.kt)("a",{parentName:"p",href:"./AA-6.1#S0205"},"parameter_and_result_profile"),"s for the default implementations of the stream-oriented attributes, the subtype of the Item parameter is the base subtype of T if T is a scalar type, and the first subtype otherwise. The same rule applies to the result of the Input attribute."),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0007-1} {AI12-0427-1} For an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," or ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," specifying one of these attributes, the subtype of the Item parameter shall be the first subtype or the base subtype if scalar, and the first subtype if not scalar. The same rule applies to the result of the Input function."),(0,i.kt)("p",null,"Reason: This is to simplify implementation. "),(0,i.kt)("p",null,"Ramification: {AI12-0427-1} The view of the type at the point of the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," determines whether the base subtype is allowed. Thus, for a scalar type with a partial view (which is never scalar), whether the  base subtype is allowed is determined by whether the ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," occurs before or after the full definition of the scalar type. For the same reason, the base subtype is never allowed for an attribute specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," on the partial view. "),(0,i.kt)("p",null,"{AI95-00366-01} {AI05-0065-1} ","[A type is said to support external streaming if Read and Write attributes are provided for sending values of such a type between active partitions, with Write marshalling the representation, and Read unmarshalling the representation.]"," A limited type supports external streaming only if it has available Read and Write attributes. A type with a part that is of a nonremote access type supports external streaming only if that access type or the type of some part that includes the access type component, has Read and Write attributes that have been specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),", and that ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause")," is visible. ","[An anonymous access type does not support external streaming. ]","All other types (including remote access types, see E.2.2) support external streaming."),(0,i.kt)("p",null,"Ramification: A limited type with a part that is of a nonremote access type needs to satisfy both rules. "),(0,i.kt)("h4",{id:"erroneous-execution"},"Erroneous Execution"),(0,i.kt)("p",null,"{AI95-00279-01} {AI95-00344-01} If the internal tag returned by Descendant_Tag to T'Class'Input identifies a type that is not library-level and whose tag has not been created, or does not exist in the partition at the time of the call, execution is erroneous. "),(0,i.kt)("p",null,"Ramification: The definition of Descendant_Tag prevents such a tag from being provided to T'Class'Input if T is a library-level type. However, this rule is needed for nested tagged types. "),(0,i.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} For every subtype S of a language-defined nonlimited specific type T, the output generated by S'Output or S'Write shall be readable by S'Input or S'Read, respectively. This rule applies across partitions if the implementation conforms to the Distributed Systems Annex."),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0092-1} If Constraint_Error is raised during a call to Read because of failure of one the above checks, the implementation shall ensure that the discriminants of the actual parameter of Read are not modified. "),(0,i.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,i.kt)("p",null,"{AI95-00195-01} {AI05-0092-1} {AI12-0445-1} The number of calls performed by the predefined implementation of the stream-oriented attributes on the Read and Write operations of the stream type is unspecified. An implementation may take advantage of this permission to perform internal buffering. However, all the calls on the Read and Write operations of the stream type used to implement an explicit invocation of a stream-oriented attribute shall take place before this invocation returns. An explicit invocation is one appearing explicitly in the program text, possibly through a generic instantiation (see 12.3)."),(0,i.kt)("p",null,"{AI05-0023-1} {AI05-0264-1} {AI12-0445-1} If T is a discriminated type and its discriminants have defaults, then in two cases an execution of the default implementation of S'Read is not required to create an anonymous object of type T: If the discriminant values that are read in are equal to the corresponding discriminant values of Item, then creation of a new object of type T may be bypassed and Item may be used instead. If they are not equal and Item is a constrained variable, then Constraint_Error may be raised at that point, before any further values are read from the stream and before the object of type T is created."),(0,i.kt)("p",null,"{AI05-0023-1} A default implementation of S'Input that calls the default implementation of S'Read may create a constrained anonymous object with discriminants that match those in the stream. "),(0,i.kt)("p",null,"Implementation Note: This allows the combined executions of S'Input and S'Read to create one object of type T instead of two. If this option is exercised, then: "),(0,i.kt)("p",null,"The discriminants are read from the stream by S'Input, not S'Read."),(0,i.kt)("p",null,"S'Input declares an object of type T constrained by the discriminants read from the stream, not an unconstrained object."),(0,i.kt)("p",null,"The discriminant values that S'Read would normally have read from the stream are read from Item instead."),(0,i.kt)("p",null,"The permissions of the preceding paragraph then apply and no object of type T need be created by the execution of S'Read. "),(0,i.kt)("p",null,"NOTE 1   {AI12-0442-1} For a definite subtype S of a type T, only T'Write and T'Read are necessary to pass an arbitrary value of the subtype through a stream. For an indefinite subtype S of a type T, T'Output and T'Input will normally be necessary, since T'Write and T'Read do not pass bounds, discriminants, or tags."),(0,i.kt)("p",null,"NOTE 2   User-specified attributes of S'Class are not inherited by other class-wide types descended from S. "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Example of user-defined Write attribute: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"{AI95-00441-01} procedure My_Write(\n  Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n  Item   : My_Integer'Base);\nfor My_Integer'Write use My_Write;\n\n")),(0,i.kt)("p",null,"Discussion: Example of network input/output using input output attributes: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Streams; use Ada.Streams;\ngeneric\n    type Msg_Type(&lt&gt) is private;\npackage Network_IO is\n    -- Connect/Disconnect are used to establish the stream\n    procedure Connect(...);\n    procedure Disconnect(...);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    -- Send/Receive transfer messages across the network\n    procedure Send(X : in Msg_Type);\n    function Receive return Msg_Type;\nprivate\n    type Network_Stream is new Root_Stream_Type with ...\n    procedure Read(...);  -- define Read/Write for Network_Stream\n    procedure Write(...);\nend Network_IO;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Streams; use Ada.Streams;\npackage body Network_IO is\n    Current_Stream : aliased Network_Stream;\n    . . .\n    procedure Connect(...) is ...;\n    procedure Disconnect(...) is ...;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    procedure Send(X : in Msg_Type) is\n    begin\n        Msg_Type'Output(Current_Stream'Access, X);\n    end Send;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    function Receive return Msg_Type is\n    begin\n        return Msg_Type'Input(Current_Stream'Access);\n    end Receive;\nend Network_IO;\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} Corrigendum: Clarified how the default implementation for stream attributes is determined (eliminating conflicting language). The new wording provides that attributes for type extensions are created by composing the parent's attribute with those for the extension components if any. If a program was written assuming that the extension components were not included in the stream (as in original Ada 95), it would fail to work in the language as corrected by the Corrigendum."),(0,i.kt)("p",null,"{AI95-00195-01} Amendment Correction: Explicitly provided a permission that the number of calls to the underlying stream Read and Write operations may differ from the number determined by the canonical operations. If Ada 95 code somehow depended on the number of calls to Read or Write, it could fail with an Ada 2005 implementation. Such code is likely to be very rare; moreover, such code is really wrong, as the permission applies to Ada 95 as well. "),(0,i.kt)("h4",{id:"extensions-to-ada-95-1"},"Extensions to Ada 95"),(0,i.kt)("p",null,"{AI95-00270-01} The Stream_Size attribute is new. It allows specifying the number of bits that will be streamed for a type. The Implementation Advice involving this also was changed; this is not incompatible because Implementation Advice does not have to be followed."),(0,i.kt)("p",null,"{8652/0040} {AI95-00108-01} {AI95-00195-01} {AI95-00444-01} Corrigendum: Limited types may have default constructed attributes if all of the parent and (for extensions) extension components have available attributes. Ada 2005 adds the notion of availability to patch up some holes in the Corrigendum model. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,i.kt)("p",null,"{8652/0009} {AI95-00137-01} Corrigendum: Added wording to specify that these are operational attributes."),(0,i.kt)("p",null,"{8652/0045} {AI95-00132-01} Corrigendum: Clarified that End_Error is raised by the default implementation of Read and Input if the end of the stream is reached. (The result could have been abnormal without this clarification, thus this is not an inconsistency, as the programmer could not have depended on the previous behavior.)"),(0,i.kt)("p",null,"{AI95-00195-01} Clarified that the default implementation of S'Input does normal initialization on the object that it passes to S'Read."),(0,i.kt)("p",null,"{AI95-00195-01} Explicitly stated that what is read from a stream when a required check fails is unspecified."),(0,i.kt)("p",null,"{AI95-00251-01} Defined availability and default implementations for types with progenitors."),(0,i.kt)("p",null,"{AI95-00279-01} Specified that Constraint_Error is raised if the internal tag retrieved for S'Class'Input is for some type not covered by S'Class or is abstract. We also explicitly state that the program is erroneous if the tag has not been created or does not currently exist in the partition. (Ada 95 did not specify what happened in these cases; it's very unlikely to have provided some useful result, so this is not considered an inconsistency.)"),(0,i.kt)("p",null,"{AI95-00344-01} Added wording to support nested type extensions. S'Input and S'Output always raise Tag_Error for such extensions, and such extensions were not permitted in Ada 95, so this is neither an extension nor an incompatibility."),(0,i.kt)("p",null,'{AI95-00366-01} Defined supports external streaming to put all of the rules about "good" stream attributes in one place. This is used for distribution and for defining pragma Pure.'),(0,i.kt)("p",null,"{AI95-00441-01} Added the not null qualifier to the first parameter of all of the stream attributes, so that the semantics doesn't change between Ada 95 and Ada 2005. This change is compatible, because mode conformance is required for subprograms specified as stream attributes, and ",(0,i.kt)("a",{parentName:"p",href:"./AA-3.10#S0083"},"null_exclusion"),"s are not considered for mode conformance."),(0,i.kt)("p",null,"{AI95-00444-01} Improved the wording to make it clear that we don't define the default implementations of attributes that cannot be called (that is, aren't \"available\"). Also clarified when inheritance takes place. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005"),(0,i.kt)("p",null,"{AI05-0039-1} Correction: Added a requirement that stream attributes be specified by a static subprogram name rather than a dynamic expression. Expressions cannot provide any useful functionality because of the freezing rules, and the possibility of them complicates implementations. Only pathological programs should be affected. "),(0,i.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,i.kt)("p",null,"{AI05-0007-1} Correction: Stream attributes for scalar types can be specified with subprograms that take the first subtype as well as the base type. This eliminates confusion about which subtype is appropriate for attributes specified for partial views whose full type is a scalar type. It also eliminates a common user error (forgetting 'Base). "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,i.kt)("p",null,"{AI05-0023-1} Correction: Corrected the definition of the default version S'Read and S'Input to be well-defined if S is a discriminated type with defaulted discriminants and some components require initialization and/or finalizations."),(0,i.kt)("p",null,"{AI05-0065-1} Correction: Defined remote access types to support external streaming, since that is their purpose."),(0,i.kt)("p",null,"{AI05-0109-1} Correction: Removed a misleading phrase which implies that Constraint_Error is raised for internal tags of the wrong type, when Tag_Error should be raised for such tags."),(0,i.kt)("p",null,"{AI05-0139-2} Clarified that arrays with convention Fortran are written in column-major order, rather then row-major order. This is necessary in order that streaming of Fortran arrays is efficient."),(0,i.kt)("p",null,"{AI05-0192-1} Correction: Clarified that the profile of an inherited stream attribute is as defined for an inherited primitive subprogram, while the default implementation of the same attribute might have a different profile."),(0,i.kt)("p",null,"{AI05-0194-1} Correction: Clarified that Stream_Size has no effect on and is not effected by user-defined stream attributes. "),(0,i.kt)("h4",{id:"inconsistencies-with-ada-2012"},"Inconsistencies With Ada 2012"),(0,i.kt)("p",null,'{AI05-0419-1} The switch from inheritance to "implicitly composed" aspects means that there exists an exceedingly unlikely case where Ada 2022 code will raise Constraint_Error where Ada 2012 code would not. That case requires deriving a constrained untagged composite type C from an unconstrained parent type P, using a type conversion to P of the Input attribute of C, and streaming in a value that violates the constraints of C. Simply using the Input attribute of P instead of that of C will restore the Ada 2012 behavior. '),(0,i.kt)("h4",{id:"extensions-to-ada-2012-1"},"Extensions to Ada 2012"),(0,i.kt)("p",null,"{AI12-0106-1} Corrigendum: Defined how to specify a class-wide stream-oriented attribute using an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification"),". It was always intended that this was possible, but the method was not clear, as a class-wide type never has an explicit declaration. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,i.kt)("p",null,"{AI12-0030-1} Corrigendum: Defined the runtime effect of stream attributes for untagged limited types, as there is a weird corner case where they can be called. We don't specify this as an inconsistency, as it doesn't make semantic sense to stream a task, and nothing useful could have been done with that, so it should not exist in any programs."),(0,i.kt)("p",null,"{AI12-0106-1} Corrigendum: Clarified that the same Legality Rules apply when a stream-oriented attribute is specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.1#S0346"},"aspect_specification")," as applied when it is specified via an ",(0,i.kt)("a",{parentName:"p",href:"./AA-13.3#S0349"},"attribute_definition_clause"),"."),(0,i.kt)("p",null,"{AI12-0064-2} {AI12-0396-1} Added the definition of Nonblocking (see 9.5) and Global (see 6.1.2) for stream-oriented attributes."),(0,i.kt)("p",null,"{AI12-0419-1} Revised to define composition of stream-oriented attributes for untagged derived types in order to avoid using inheritance for these attributes/aspects."))}u.isMDXComponent=!0}}]);