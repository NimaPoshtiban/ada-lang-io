"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1620],{51010:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>g,default:()=>A,frontMatter:()=>d,metadata:()=>l,toc:()=>c});var t=a(58168),r=(a(96540),a(15680)),i=a(20793),o=a(91435),y=a(21432),s=a(79162),m=a(34421);const d={sidebar_position:144},g="B.4 Interfacing with COBOL",l={unversionedId:"arm/AA-B/AA-B.4",id:"arm/AA-B/AA-B.4",title:"B.4 Interfacing with COBOL",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-B/AA-B.4.mdx",sourceDirName:"arm/AA-B",slug:"/arm/AA-B/AA-B.4",permalink:"/docs/arm/AA-B/AA-B.4",draft:!1,tags:[],version:"current",sidebarPosition:144,frontMatter:{sidebar_position:144},sidebar:"referenceManualSidebar",previous:{title:"B.3 Interfacing with C and C++",permalink:"/docs/arm/AA-B/AA-B.3"},next:{title:"B.5 Interfacing with Fortran",permalink:"/docs/arm/AA-B/AA-B.5"}},p={},c=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4}],u={toc:c},T="wrapper";function A(e){let{components:n,...a}=e;return(0,r.yg)(T,(0,t.A)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"b4-interfacing-with-cobol"},"B.4 Interfacing with COBOL"),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,r.yg)(s.A,{mdxType:"MarginText"},"1/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,r.yg)("p",null,"The facilities relevant to interfacing with the COBOL language are the package Interfaces.COBOL and support for specifying the Convention aspect with ",(0,r.yg)("em",null,"convention","_"),(0,r.yg)("code",null,(0,r.yg)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," COBOL.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"2"),(0,r.yg)("p",null,"The COBOL interface package supplies several sets of facilities: ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"3"),(0,r.yg)("ul",null,(0,r.yg)("li",null,"A set of types corresponding to the native COBOL types of the supported COBOL implementation (so-called \u201cinternal COBOL representations\u201d), allowing Ada data to be passed as parameters to COBOL programs",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"4/5"),(0,r.yg)(m.A,{items:["AI12-0439-1"],mdxType:"MarginInfo"}),(0,r.yg)("li",null,"A set of types and constants reflecting external data representations such as can be found in files or databases, allowing COBOL-generated data to be read by an Ada program, and Ada-generated data to be read by COBOL programs",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"5"),(0,r.yg)("li",null,"A generic package for converting between an Ada decimal type value and either an internal or external COBOL representation ",(0,r.yg)("br",null))),(0,r.yg)("h4",{id:"static-semantics"},"Static Semantics"),(0,r.yg)(s.A,{mdxType:"MarginText"},"6"),(0,r.yg)("p",null,"The library package Interfaces.COBOL has the following declaration: ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"7/5"),(0,r.yg)(m.A,{items:["AI12-0241-1","AI12-0302-1"],mdxType:"MarginInfo"}),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"package Interfaces.COBOL ","\n","   with Preelaborate, Nonblocking, Global =",">"," in out synchronized is","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"8"),"-- Types and operations for internal data representations","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"9"),"type Floating      is digits implementation-defined;","\n","   type Long","_","Floating is digits implementation-defined;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"10"),"type Binary      is range implementation-defined;","\n","   type Long","_","Binary is range implementation-defined;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"11"),"Max","_","Digits","_","Binary      : constant := implementation-defined;","\n","   Max","_","Digits","_","Long","_","Binary : constant := implementation-defined;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"12/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type Decimal","_","Element  is mod implementation-defined;","\n","   type Packed","_","Decimal is array (Positive range ","<",">",") of Decimal","_","Element","\n","      with Pack;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"13"),"type COBOL","_","Character is implementation-defined character type;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"14"),"Ada","_","To","_","COBOL : array (Character) of COBOL","_","Character := implementation-defined;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"15"),"COBOL","_","To","_","Ada : array (COBOL","_","Character) of Character := implementation-defined;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"16/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type Alphanumeric is array (Positive range ","<",">",") of COBOL","_","Character","\n","      with Pack;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"17"),"function To","_","COBOL (Item : in String) return Alphanumeric;","\n","   function To","_","Ada   (Item : in Alphanumeric) return String;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"18"),"procedure To","_","COBOL (Item       : in String;","\n","                       Target     : out Alphanumeric;","\n","                       Last       : out Natural);","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"19"),"procedure To","_","Ada (Item     : in Alphanumeric;","\n","                     Target   : out String;","\n","                     Last     : out Natural);","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"20/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type Numeric is array (Positive range ","<",">",") of COBOL","_","Character","\n","      with Pack;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"21"),"-- Formats for COBOL data representations","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"22"),"type Display","_","Format is private;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"23"),"Unsigned             : constant Display","_","Format;","\n","   Leading","_","Separate     : constant Display","_","Format;","\n","   Trailing","_","Separate    : constant Display","_","Format;","\n","   Leading","_","Nonseparate  : constant Display","_","Format;","\n","   Trailing","_","Nonseparate : constant Display","_","Format;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"24"),"type Binary","_","Format is private;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"25"),"High","_","Order","_","First  : constant Binary","_","Format;","\n","   Low","_","Order","_","First   : constant Binary","_","Format;","\n","   Native","_","Binary     : constant Binary","_","Format;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"26"),"type Packed","_","Format is private;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"27"),"Packed","_","Unsigned   : constant Packed","_","Format;","\n","   Packed","_","Signed     : constant Packed","_","Format;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"28"),"-- Types for external representation of COBOL binary data","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"29/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type Byte is mod 2","*","*","COBOL","_","Character'Size;","\n","   type Byte","_","Array is array (Positive range ","<",">",") of Byte","\n","      with Pack;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"30"),"Conversion","_","Error : exception;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"31"),"generic","\n","      type Num is delta ","<",">"," digits ","<",">",";","\n","   package Decimal","_","Conversions is","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"32"),"-- Display Formats: data values are represented as Numeric","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"33"),"function Valid (Item   : in Numeric;","\n","                      Format : in Display","_","Format) return Boolean;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"34"),"function Length (Format : in Display","_","Format) return Natural;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"35"),"function To","_","Decimal (Item   : in Numeric;","\n","                           Format : in Display","_","Format) return Num;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"36"),"function To","_","Display (Item   : in Num;","\n","                           Format : in Display","_","Format) return Numeric;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"37"),"-- Packed Formats: data values are represented as Packed","_","Decimal","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"38"),"function Valid (Item   : in Packed","_","Decimal;","\n","                      Format : in Packed","_","Format) return Boolean;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"39"),"function Length (Format : in Packed","_","Format) return Natural;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"40"),"function To","_","Decimal (Item   : in Packed","_","Decimal;","\n","                           Format : in Packed","_","Format) return Num;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"41"),"function To","_","Packed (Item   : in Num;","\n","                          Format : in Packed","_","Format) return Packed","_","Decimal;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"42"),"-- Binary Formats: external data values are represented as Byte","_","Array","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"43"),"function Valid (Item   : in Byte","_","Array;","\n","                      Format : in Binary","_","Format) return Boolean;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"44"),"function Length (Format : in Binary","_","Format) return Natural;","\n","      function To","_","Decimal (Item   : in Byte","_","Array;","\n","                           Format : in Binary","_","Format) return Num;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"45"),"function To","_","Binary (Item   : in Num;","\n","                        Format : in Binary","_","Format) return Byte","_","Array;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"46"),"-- Internal Binary formats: data values are of type Binary or Long","_","Binary","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"47"),"function To","_","Decimal (Item : in Binary)      return Num;","\n","      function To","_","Decimal (Item : in Long","_","Binary) return Num;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"48"),"function To","_","Binary      (Item : in Num)  return Binary;","\n","      function To","_","Long","_","Binary (Item : in Num)  return Long","_","Binary;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"49"),"end Decimal","_","Conversions;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"50"),"private","\n","   ... -- not specified by the language","\n","end Interfaces.COBOL;","\n"),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"50.a/1"),(0,r.yg)(i.A,{type:"aarm",aarm:"implementation-defined",mdxType:"Admonition"},(0,r.yg)("strong",null),"The types Floating, Long","_","Floating, Binary, Long","_","Binary, Decimal","_","Element, and COBOL","_","Character; and the initializations of the variables Ada","_","To","_","COBOL and COBOL","_","To","_","Ada, in Interfaces.COBOL.",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"51"),(0,r.yg)("p",null,"Each of the types in Interfaces.COBOL is COBOL-compatible.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"52"),(0,r.yg)("p",null,"The types Floating and Long","_","Floating correspond to the native types in COBOL for data items with computational usage implemented by floating point. The types Binary and Long","_","Binary correspond to the native types in COBOL for data items with binary usage, or with computational usage implemented by binary.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"53"),(0,r.yg)("p",null,"Max","_","Digits","_","Binary is the largest number of decimal digits in a numeric value that is represented as Binary. Max","_","Digits","_","Long","_","Binary is the largest number of decimal digits in a numeric value that is represented as Long","_","Binary.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"54"),(0,r.yg)("p",null,"The type Packed","_","Decimal corresponds to COBOL's packed-decimal usage.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"55"),(0,r.yg)("p",null,"The type COBOL","_","Character defines the run-time character set used in the COBOL implementation. Ada","_","To","_","COBOL and COBOL","_","To","_","Ada are the mappings between the Ada and COBOL run-time character sets. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"55.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,r.yg)("strong",null),"The character mappings are visible variables, since the user needs the ability to modify them at run time. ",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"56"),(0,r.yg)("p",null,"Type Alphanumeric corresponds to COBOL's alphanumeric data category.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"57"),(0,r.yg)("p",null,"Each of the functions To","_","COBOL and To","_","Ada converts its parameter based on the mappings Ada","_","To","_","COBOL and COBOL","_","To","_","Ada, respectively. The length of the result for each is the length of the parameter, and the lower bound of the result is 1. Each component of the result is obtained by applying the relevant mapping to the corresponding component of the parameter.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"58"),(0,r.yg)("p",null,"Each of the procedures To","_","COBOL and To","_","Ada copies converted elements from Item to Target, using the appropriate mapping (Ada","_","To","_","COBOL or COBOL","_","To","_","Ada, respectively). The index in Target of the last element assigned is returned in Last (0 if Item is a null array). If Item'Length exceeds Target'Length, Constraint","_","Error is propagated.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"59"),(0,r.yg)("p",null,"Type Numeric corresponds to COBOL's numeric data category with display usage.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"60"),(0,r.yg)("p",null,"The types Display","_","Format, Binary","_","Format, and Packed","_","Format are used in conversions between Ada decimal type values and COBOL internal or external data representations. The value of the constant Native","_","Binary is either High","_","Order","_","First or Low","_","Order","_","First, depending on the implementation. ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"61"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Valid (Item   : in Numeric;","\n","                Format : in Display","_","Format) return Boolean;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"62"),(0,r.yg)("p",{class:"Indented4"},"The function Valid checks that the Item parameter has a value consistent with the value of Format. If the value of Format is other than Unsigned, Leading","_","Separate, and Trailing","_","Separate, the effect is implementation defined. If Format does have one of these values, the following rules apply: ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"63/3"),(0,r.yg)(m.A,{items:["AI95-00071-01","AI05-0264-1"],mdxType:"MarginInfo"}),(0,r.yg)("ul",null,(0,r.yg)("li",null,"{",(0,r.yg)("em",null,"8652/0066"),"}"," Format=Unsigned: if Item comprises one or more decimal digit characters, then Valid returns True, else it returns False.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"64/1"),(0,r.yg)(m.A,{items:["AI95-00071-01"],mdxType:"MarginInfo"}),(0,r.yg)("li",null,"{",(0,r.yg)("em",null,"8652/0066"),"}"," Format=Leading","_","Separate: if Item comprises a single occurrence of the plus or minus sign character, and then one or more decimal digit characters, then Valid returns True, else it returns False.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"65/1"),(0,r.yg)(m.A,{items:["AI95-00071-01"],mdxType:"MarginInfo"}),(0,r.yg)("li",null,"{",(0,r.yg)("em",null,"8652/0066"),"}"," Format=Trailing","_","Separate: if Item comprises one or more decimal digit characters and finally a plus or minus sign character, then Valid returns True, else it returns False. ",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"66"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Length (Format : in Display","_","Format) return Natural;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"67"),(0,r.yg)("p",{class:"Indented4"},"The Length function returns the minimal length of a Numeric value sufficient to hold any value of type Num when represented as Format.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"68"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Decimal (Item   : in Numeric;","\n","                     Format : in Display","_","Format) return Num;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"69"),(0,r.yg)("p",{class:"Indented4"},"Produces a value of type Num corresponding to Item as represented by Format. The number of digits after the assumed radix point in Item is Num'Scale. Conversion","_","Error is propagated if the value represented by Item is outside the range of Num. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"69.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,r.yg)("strong",null),"There is no issue of truncation versus rounding, since the number of decimal places is established by Num'Scale.",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"70"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Display (Item   : in Num;","\n","                     Format : in Display","_","Format) return Numeric;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"71/1"),(0,r.yg)(m.A,{items:["AI95-00072-01"],mdxType:"MarginInfo"}),(0,r.yg)("p",{class:"Indented4"},"{",(0,r.yg)("em",null,"8652/0067"),"}"," This function returns the Numeric value for Item, represented in accordance with Format. The length of the returned value is Length(Format), and the lower bound is 1. Conversion","_","Error is propagated if Num is negative and Format is Unsigned.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"72"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Valid (Item   : in Packed","_","Decimal;","\n","                Format : in Packed","_","Format) return Boolean;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"73"),(0,r.yg)("p",{class:"Indented4"},"This function returns True if Item has a value consistent with Format, and False otherwise. The rules for the formation of Packed","_","Decimal values are implementation defined.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"74"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Length (Format : in Packed","_","Format) return Natural;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"75"),(0,r.yg)("p",{class:"Indented4"},"This function returns the minimal length of a Packed","_","Decimal value sufficient to hold any value of type Num when represented as Format.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"76"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Decimal (Item   : in Packed","_","Decimal;","\n","                     Format : in Packed","_","Format) return Num;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"77"),(0,r.yg)("p",{class:"Indented4"},"Produces a value of type Num corresponding to Item as represented by Format. Num'Scale is the number of digits after the assumed radix point in Item. Conversion","_","Error is propagated if the value represented by Item is outside the range of Num.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"78"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Packed (Item   : in Num;","\n","                    Format : in Packed","_","Format) return Packed","_","Decimal;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"79/1"),(0,r.yg)(m.A,{items:["AI95-00072-01"],mdxType:"MarginInfo"}),(0,r.yg)("p",{class:"Indented4"},"{",(0,r.yg)("em",null,"8652/0067"),"}"," This function returns the Packed","_","Decimal value for Item, represented in accordance with Format. The length of the returned value is Length(Format), and the lower bound is 1. Conversion","_","Error is propagated if Num is negative and Format is Packed","_","Unsigned.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"80"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Valid (Item   : in Byte","_","Array;","\n","                Format : in Binary","_","Format) return Boolean;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"81"),(0,r.yg)("p",{class:"Indented4"},"This function returns True if Item has a value consistent with Format, and False otherwise. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"81.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,r.yg)("strong",null),"This function returns False only when the represented value is outside the range of Num.",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"82"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function Length (Format : in Binary","_","Format) return Natural;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"83"),(0,r.yg)("p",{class:"Indented4"},"This function returns the minimal length of a Byte","_","Array value sufficient to hold any value of type Num when represented as Format.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"84"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Decimal (Item   : in Byte","_","Array;","\n","                     Format : in Binary","_","Format) return Num;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"85"),(0,r.yg)("p",{class:"Indented4"},"Produces a value of type Num corresponding to Item as represented by Format. Num'Scale is the number of digits after the assumed radix point in Item. Conversion","_","Error is propagated if the value represented by Item is outside the range of Num.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"86"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Binary (Item   : in Num;","\n","                    Format : in Binary","_","Format) return Byte","_","Array;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"87/1"),(0,r.yg)(m.A,{items:["AI95-00072-01"],mdxType:"MarginInfo"}),(0,r.yg)("p",{class:"Indented4"},"{",(0,r.yg)("em",null,"8652/0067"),"}"," This function returns the Byte","_","Array value for Item, represented in accordance with Format. The length of the returned value is Length(Format), and the lower bound is 1.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"88"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Decimal (Item : in Binary)      return Num;","\n","\n","function To","_","Decimal (Item : in Long","_","Binary) return Num;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"89"),(0,r.yg)("p",{class:"Indented4"},"These functions convert from COBOL binary format to a corresponding value of the decimal type Num. Conversion","_","Error is propagated if Item is too large for Num. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"89.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,r.yg)("strong",null),"There is no rescaling performed on the conversion. That is, the returned value in each case is a \u201cbit copy\u201d if Num has a binary radix. The programmer is responsible for maintaining the correct scale. ",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"90"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"function To","_","Binary      (Item : in Num)  return Binary;","\n","\n","function To","_","Long","_","Binary (Item : in Num)  return Long","_","Binary;","\n"),(0,r.yg)(s.A,{mdxType:"MarginText"},"91"),(0,r.yg)("p",{class:"Indented4"},"These functions convert from Ada decimal to COBOL binary format. Conversion","_","Error is propagated if the value of Item is too large to be represented in the result type. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,r.yg)("strong",null),"One style of interface supported for COBOL, similar to what is provided for C, is the ability to call and pass parameters to an existing COBOL program. Thus the interface package supplies types that can be used in an Ada program as parameters to subprograms whose bodies will be in COBOL. These types map to COBOL's alphanumeric and numeric data categories.",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.b"),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Several types are provided for support of alphanumeric data. Since COBOL's run-time character set is not necessarily the same as Ada's, Interfaces.COBOL declares an implementation-defined character type COBOL","_","Character, and mappings between Character and COBOL","_","Character. These mappings are visible variables (rather than, say, functions or constant arrays), since in the situation where COBOL","_","Character is EBCDIC, the flexibility of dynamically modifying the mappings is needed. Corresponding to COBOL's alphanumeric data is the string type Alphanumeric.",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.c"),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Numeric data may have either a \u201cdisplay\u201d or \u201ccomputational\u201d representation in COBOL. On the Ada side, the data is of a decimal fixed point type. Passing an Ada decimal data item to a COBOL program requires conversion from the Ada decimal type to some type that reflects the representation expected on the COBOL side. ",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.d"),(0,r.yg)("ul",null,(0,r.yg)("li",null,"Computational Representation",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"91.e"),(0,r.yg)("li",null,"Floating point representation is modeled by Ada floating point types, Floating and Long","_","Floating. Conversion between these types and Ada decimal types is obtained directly, since the type name serves as a conversion function.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"91.f"),(0,r.yg)("li",null,"Binary representation is modeled by an Ada integer type, Binary, and possibly other types such as Long","_","Binary. Conversion between, say, Binary and a decimal type is through functions from an instantiation of the generic package Decimal","_","Conversions.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"91.g"),(0,r.yg)("li",null,"Packed decimal representation is modeled by the Ada array type Packed","_","Decimal. Conversion between packed decimal and a decimal type is through functions from an instantiation of the generic package Decimal","_","Conversions.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"91.h"),(0,r.yg)("li",null,"Display Representation",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"91.i"),(0,r.yg)("li",null,"Display representation for numeric data is modeled by the array type Numeric. Conversion between display representation and a decimal type is through functions from an instantiation of the generic package Decimal","_","Conversions. A parameter to the conversion function indicates the desired interpretation of the data (e.g., signed leading separate, etc.) ",(0,r.yg)("br",null)))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.j/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The Convention of a record type may be specified as COBOL to direct the compiler to choose a COBOL-compatible representation for objects of the type.",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"91.k"),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The package Interfaces.COBOL allows the Ada programmer to deal with data from files (or databases) created by a COBOL program. For data that is alphanumeric, or in display or packed decimal format, the approach is the same as for passing parameters (instantiate Decimal","_","Conversions to obtain the needed conversion functions). For binary data, the external representation is treated as a Byte array, and an instantiation of Decimal","_","IO produces a package that declares the needed conversion functions. A parameter to the conversion function indicates the desired interpretation of the data (e.g., high- versus low-order byte first). ",(0,r.yg)("br",null))),(0,r.yg)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,r.yg)(s.A,{mdxType:"MarginText"},"92/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,r.yg)("p",null,"An implementation shall support specifying aspect Convention with a COBOL ",(0,r.yg)("em",null,"convention"),"_",(0,r.yg)("code",null,(0,r.yg)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for a COBOL-eligible type (see ",(0,r.yg)("a",{href:"../AA-B/AA-B.1"},"B.1"),"). ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"92.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,r.yg)("strong",null),"An implementation supporting this package shall ensure that if the bounds of a Packed","_","Decimal, Alphanumeric, or Numeric variable are static, then the representation of the object comprises solely the array components (that is, there is no implicit run-time \u201cdescriptor\u201d that is part of the object). ",(0,r.yg)("br",null))),(0,r.yg)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,r.yg)(s.A,{mdxType:"MarginText"},"93"),(0,r.yg)("p",null,"An implementation may provide additional constants of the private types Display","_","Format, Binary","_","Format, or Packed","_","Format. ",(0,r.yg)("br",null)),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"93.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,r.yg)("strong",null),"This is to allow exploitation of other external formats that may be available in the COBOL implementation.",(0,r.yg)("br",null))),(0,r.yg)(s.A,{mdxType:"MarginText"},"94"),(0,r.yg)("p",null,"An implementation may provide further floating point and integer types in Interfaces.COBOL to match additional native COBOL types, and may also supply corresponding conversion functions in the generic package Decimal","_","Conversions. ",(0,r.yg)("br",null)),(0,r.yg)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,r.yg)(s.A,{mdxType:"MarginText"},"95"),(0,r.yg)("p",null,"An Ada implementation should support the following interface correspondences between Ada and COBOL. ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"96"),(0,r.yg)("ul",null,(0,r.yg)("li",null,"An Ada ",(0,r.yg)("strong",null,"access")," T parameter is passed as a \u201cBY REFERENCE\u201d data item of the COBOL type corresponding to T.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"97"),(0,r.yg)("li",null,"An Ada ",(0,r.yg)("strong",null,"in")," scalar parameter is passed as a \u201cBY CONTENT\u201d data item of the corresponding COBOL type.",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"98"),(0,r.yg)("li",null,"Any other Ada parameter is passed as a \u201cBY REFERENCE\u201d data item of the COBOL type corresponding to the Ada parameter type; for scalars, a local copy is used if necessary to ensure by-copy semantics. ",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"98.a/2"),(0,r.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,r.yg)("strong",null),"If COBOL interfacing is supported, the interface correspondences between Ada and COBOL should be supported.",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"99/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   An implementation is not required to support specifying aspect Convention for access types, nor is it required to support specifying aspects Import, Export, or Convention for functions. ",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"99.a"),(0,r.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,r.yg)("strong",null),"COBOL does not have a pointer facility, and a COBOL program does not return a value. ",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"100/5"),(0,r.yg)(m.A,{items:["AI12-0440-1"],mdxType:"MarginInfo"}),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   If an Ada subprogram is exported to COBOL, then a call from COBOL call can specify either \u201cBY CONTENT\u201d or \u201cBY REFERENCE\u201d. ",(0,r.yg)("br",null))),(0,r.yg)("h4",{id:"examples"},"Examples"),(0,r.yg)(s.A,{mdxType:"MarginText"},"101"),(0,r.yg)("p",null,(0,r.yg)("em",null,"Examples of Interfaces.COBOL:")," ",(0,r.yg)("br",null)),(0,r.yg)(s.A,{mdxType:"MarginText"},"102"),(0,r.yg)(y.A,{language:"ada",mdxType:"CodeBlock"},"with Interfaces.COBOL;","\n","procedure Test","_","Call is","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"103"),"-- Calling a foreign COBOL program","\n","   -- Assume that a COBOL program PROG has the following declaration","\n","   --  in its LINKAGE section:","\n","   --  01 Parameter-Area","\n","   --     05 NAME   PIC X(20).","\n","   --     05 SSN    PIC X(9).","\n","   --     05 SALARY PIC 99999V99 USAGE COMP.","\n","   -- The effect of PROG is to update SALARY based on some algorithm","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"104"),"package COBOL renames Interfaces.COBOL;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"105"),"type Salary","_","Type is delta 0.01 digits 7;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"106/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type COBOL","_","Record is","\n","      record","\n","         Name   : COBOL.Numeric(1..20);","\n","         SSN    : COBOL.Numeric(1..9);","\n","         Salary : COBOL.Binary;  -- Assume Binary = 32 bits","\n","      end record","\n","      with Convention =",">"," COBOL;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"107/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"procedure Prog (Item : in out COBOL","_","Record)","\n","      with Import =",">"," True, Convention =",">"," COBOL;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"108"),"package Salary","_","Conversions is","\n","      new COBOL.Decimal","_","Conversions(Salary","_","Type);","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"109"),"Some","_","Salary : Salary","_","Type := 12","_","345.67;","\n","   Some","_","Record : COBOL","_","Record :=","\n","      (Name   =",">",' "Johnson, John       ",',"\n","       SSN    =",">",' "111223333",',"\n","       Salary =",">"," Salary","_","Conversions.To","_","Binary(Some","_","Salary));","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"110"),"begin","\n","   Prog (Some","_","Record);","\n","   ...","\n","end Test","_","Call;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"111"),"with Interfaces.COBOL;","\n","with COBOL","_","Sequential","_","IO; -- Assumed to be supplied by implementation","\n","procedure Test","_","External","_","Formats is","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"112/5"),(0,r.yg)(m.A,{items:["AI12-0442-1"],mdxType:"MarginInfo"}),"-- Using data created by a COBOL program","\n","   -- Assume that a COBOL program has created a sequential file with","\n","   --  the following record structure, and that we want","\n","   --  process the records in an Ada program","\n","   --  01 EMPLOYEE-RECORD","\n","   --     05 NAME    PIC X(20).","\n","   --     05 SSN     PIC X(9).","\n","   --     05 SALARY  PIC 99999V99 USAGE COMP.","\n","   --     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.","\n","   -- The COMP data is binary (32 bits), high-order byte first","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"113"),"package COBOL renames Interfaces.COBOL;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"114"),"type Salary","_","Type      is delta 0.01  digits 7;","\n","   type Adjustments","_","Type is delta 0.001 digits 6;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"115/3"),(0,r.yg)(m.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),"type COBOL","_","Employee","_","Record","_","Type is  -- External representation","\n","      record","\n","         Name    : COBOL.Alphanumeric(1..20);","\n","         SSN     : COBOL.Alphanumeric(1..9);","\n","         Salary  : COBOL.Byte","_","Array(1..4);","\n","         Adjust  : COBOL.Numeric(1..7);  -- Sign and 6 digits","\n","      end record","\n","      with Convention =",">"," COBOL;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"116"),"package COBOL","_","Employee","_","IO is","\n","      new COBOL","_","Sequential","_","IO(COBOL","_","Employee","_","Record","_","Type);","\n","   use COBOL","_","Employee","_","IO;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"117"),"COBOL","_","File : File","_","Type;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"118"),"type Ada","_","Employee","_","Record","_","Type is  -- Internal representation","\n","      record","\n","         Name    : String(1..20);","\n","         SSN     : String(1..9);","\n","         Salary  : Salary","_","Type;","\n","         Adjust  : Adjustments","_","Type;","\n","      end record;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"119"),"COBOL","_","Record : COBOL","_","Employee","_","Record","_","Type;","\n","   Ada","_","Record   : Ada","_","Employee","_","Record","_","Type;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"120"),"package Salary","_","Conversions is","\n","      new COBOL.Decimal","_","Conversions(Salary","_","Type);","\n","   use Salary","_","Conversions;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"121"),"package Adjustments","_","Conversions is","\n","      new COBOL.Decimal","_","Conversions(Adjustments","_","Type);","\n","   use Adjustments","_","Conversions;","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"122"),"begin","\n","   Open (COBOL","_","File, Name =",">",' "Some',"_",'File");',"\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"123"),"loop","\n","     Read (COBOL","_","File, COBOL","_","Record);","\n",(0,r.yg)(s.A,{mdxType:"MarginText"},"124/5"),(0,r.yg)(m.A,{items:["AI12-0178-1"],mdxType:"MarginInfo"}),"Ada","_","Record.Name := COBOL.To","_","Ada(COBOL","_","Record.Name);","\n","     Ada","_","Record.SSN  := COBOL.To","_","Ada(COBOL","_","Record.SSN);","\n","     Ada","_","Record.Salary :=","\n","        To","_","Decimal(COBOL","_","Record.Salary, COBOL.High","_","Order","_","First);","\n","     Ada","_","Record.Adjust :=","\n","        To","_","Decimal(COBOL","_","Record.Adjust, COBOL.Leading","_","Separate);","\n","     ... -- Process Ada","_","Record","\n","   end loop;","\n","exception","\n","   when End","_","Error =",">"," ...","\n","end Test","_","External","_","Formats;","\n"),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95")),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"124.a/2"),(0,r.yg)(m.A,{items:["AI95-00071-01"],mdxType:"MarginInfo"}),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,r.yg)("em",null,"8652/0066"),"}"," ",(0,r.yg)("strong",null,"Corrigendum:")," Corrected the definition of Valid to match COBOL.",(0,r.yg)("br",null))),(0,r.yg)(o.A,{mdxType:"AnnotatedOnly"},(0,r.yg)(s.A,{mdxType:"MarginText"},"124.b/2"),(0,r.yg)(m.A,{items:["AI95-00072-01"],mdxType:"MarginInfo"}),(0,r.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,r.yg)("em",null,"8652/0067"),"}"," ",(0,r.yg)("strong",null,"Corrigendum:")," Specified the bounds of the results of To","_","Display, To","_","Packed, and To","_","Binary. ",(0,r.yg)("br",null))))}A.isMDXComponent=!0}}]);