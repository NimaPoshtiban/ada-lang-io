"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3401],{2676:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>f,contentTitle:()=>k,default:()=>b,frontMatter:()=>m,metadata:()=>A,toc:()=>g});var n=i(1716),o=i(7556),a=i(3183),r=Object.defineProperty,l=Object.defineProperties,s=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,h=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,i)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,p=(e,t)=>{for(var i in t||(t={}))h.call(t,i)&&u(e,i,t[i]);if(d)for(var i of d(t))c.call(t,i)&&u(e,i,t[i]);return e};const m={sidebar_position:67},k="8.3 Visibility",A={unversionedId:"arm/AA-8/AA-8.3",id:"arm/AA-8/AA-8.3",title:"8.3 Visibility",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-8/AA-8.3.mdx",sourceDirName:"arm/AA-8",slug:"/arm/AA-8/AA-8.3",permalink:"/docs/arm/AA-8/AA-8.3",draft:!1,tags:[],version:"current",sidebarPosition:67,frontMatter:{sidebar_position:67},sidebar:"tutorialSidebar",previous:{title:"8.2 Scope of Declarations",permalink:"/docs/arm/AA-8/AA-8.2"},next:{title:"8.4 Use Clauses",permalink:"/docs/arm/AA-8/AA-8.4"}},f={},g=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Incompatibilities With Ada 95",id:"incompatibilities-with-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"8.3.1  Overriding Indicators",id:"831--overriding-indicators",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4}],y={toc:g};function b(e){var t,i=e,{components:r}=i,u=((e,t)=>{var i={};for(var n in e)h.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(null!=e&&d)for(var n of d(e))t.indexOf(n)<0&&c.call(e,n)&&(i[n]=e[n]);return i})(i,["components"]);return(0,n.kt)("wrapper",(t=p(p({},y),u),l(t,s({components:r,mdxType:"MDXLayout"}))),(0,n.kt)("h1",p({},{id:"83-visibility"}),"8.3 Visibility"),(0,n.kt)("admonition",p({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",p({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"[ The ",(0,n.kt)("em",null,"visibility rules"),", given below, determine which declarations are visible and directly visible at each place within a program. The visibility rules apply to both explicit and implicit declarations.] "),(0,n.kt)("h4",p({},{id:"static-semantics"}),"Static Semantics"),(0,n.kt)("p",null,"A declaration is defined to be ",(0,n.kt)("em",null,"directly visible")," at places where a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," consisting of only an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," is sufficient to denote the declaration; that is, no ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," notation or special context (such as preceding =",">"," in a named association) is necessary to denote the declaration. A declaration is defined to be ",(0,n.kt)("em",null,"visible")," wherever it is directly visible, as well as at other places where some ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," (such as a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component")),") can denote the declaration."),(0,n.kt)("p",null,"The syntactic category ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," is used to indicate contexts where direct visibility is required. The syntactic category ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," is used to indicate contexts where visibility, but not direct visibility, is required."),(0,n.kt)("p",null,"There are two kinds of direct visibility: ",(0,n.kt)("em",null,"immediate visibility")," and ",(0,n.kt)("em",null,"use-visibility"),". A declaration is immediately visible at a place if it is directly visible because the place is within its immediate scope. A declaration is use-visible if it is directly visible because of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.4#S0235"},"use_clause"))," (see 8.4). Both conditions can apply."),(0,n.kt)("p",null,"A declaration can be ",(0,n.kt)("em",null,"hidden"),", either from direct visibility, or from all visibility, within certain parts of its scope. Where ",(0,n.kt)("em",null,"hidden from all visibility"),", it is not visible at all (neither using a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," nor a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),"). Where ",(0,n.kt)("em",null,"hidden from direct visibility"),", only direct visibility is lost; visibility using a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," is still possible."),(0,n.kt)("p",null,"[ Two or more declarations are ",(0,n.kt)("em",null,"overloaded")," if they all have the same defining name and there is a place where they are all directly visible.] "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Note that a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," can have more than one possible interpretation even if it denotes a nonoverloadable entity. For example, if there are two functions F that return records, both containing a component called C, then the name F.C has two possible interpretations, even though component declarations are not overloadable. ")),(0,n.kt)("p",null,"The declarations of callable entities [(including enumeration literals)] are ",(0,n.kt)("em",null,"overloadable"),"[, meaning that overloading is allowed for them]. "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0310"},"generic_declaration"))," is not overloadable within its own ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0313"},"generic_formal_part")),". This follows from the rules about when a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," denotes a current instance. See AI83-00286. This implies that within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0313"},"generic_formal_part")),", outer declarations with the same defining name are hidden from direct visibility. It also implies that if a generic formal parameter has the same defining name as the generic itself, the formal parameter hides the generic from direct visibility. ")),(0,n.kt)("p",null,"Two declarations are ",(0,n.kt)("em",null,"homographs")," if they have the same defining name, and, if both are overloadable, their profiles are type conformant. [An inner declaration hides any outer homograph from direct visibility.]"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Glossary entry: "),"An overriding operation is one that replaces an inherited primitive operation. Operations may be marked explicitly as overriding or not overriding.")),(0,n.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[S],Term=[overriding operation], Def=[an operation that replaces an inherited primitive operation], Note1=[Operations can be marked explicitly as overriding or not overriding.]"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0025"),"}"," ","{",(0,n.kt)("em",null,"AI95-00044-01"),"}"," [Two homographs are not generally allowed immediately within the same declarative region unless one ",(0,n.kt)("em",null,"overrides")," the other (see Legality Rules below).] The only declarations that are ",(0,n.kt)("em",null,"overridable")," are the implicit declarations for predefined operators and inherited primitive subprograms. A declaration overrides another homograph that occurs immediately within the same declarative region in the following cases: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0025"),"}"," ","{",(0,n.kt)("em",null,"AI95-00044-01"),"}"," A declaration that is not overridable overrides one that is overridable, [regardless of which declaration occurs first]; "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"{",(0,n.kt)("em",null,"8652/0025"),"}"," ","{",(0,n.kt)("em",null,"AI95-00044-01"),"}"," And regardless of whether the nonoverridable declaration is overloadable or not. For example, ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0172"},"statement_identifier")),"s are covered by this rule.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'The "regardless of which declaration occurs first" is there because the explicit declaration could be a primitive subprogram of a partial view, and then the full view might inherit a homograph. We are saying that the explicit one wins (within its scope), even though the implicit one comes later.')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"If the overriding declaration is also a subprogram, then it is a primitive subprogram.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'As explained in 7.3.1, "Private Operations", some inherited primitive subprograms are never declared. Such subprograms cannot be overridden, although they can be reached by dispatching calls in the case of a tagged type. ')),(0,n.kt)("p",null,"The implicit declaration of an inherited operator overrides that of a predefined operator; "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'In a previous version of Ada 9X, we tried to avoid the notion of predefined operators, and say that they were inherited from some magical root type. However, this seemed like too much mechanism. Therefore, a type can have a predefined "+" as well as an inherited "+". The above rule says the inherited one wins.')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00114-01"),"}",' The "regardless of which declaration occurs first" applies here as well, in the case where ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.4#S0035"},"derived_type_definition")),' in the visible part of a public library unit derives from a private type declared in the parent unit, and the full view of the parent type has additional predefined operators, as explained in 7.3.1, "Private Operations". Those predefined operators can be overridden by inherited subprograms implicitly declared earlier. ')),(0,n.kt)("p",null,"An implicit declaration of an inherited subprogram overrides a previous implicit declaration of an inherited subprogram."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00251-01"),"}"," If two or more homographs are implicitly declared at the same place:"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00251-01"),"}"," If at least one is a subprogram that is neither a null procedure nor an abstract subprogram, and does not require overriding (see 3.9.3), then they override those that are null procedures, abstract subprograms, or require overriding. If more than one such homograph remains that is not thus overridden, then they are all hidden from all visibility."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00251-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0183-1"),"}"," Otherwise (all are null procedures, abstract subprograms, or require overriding), then any null procedure overrides all abstract subprograms and all subprograms that require overriding; if more than one such homograph remains that is not thus overridden, then if the profiles of the remaining homographs are all fully conformant with one another, one is chosen arbitrarily; if not, they are all hidden from all visibility. "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"In the case where the implementation arbitrarily chooses one overrider from among a group of inherited subprograms, users should not be able to determine which member was chosen, as the set of inherited subprograms which are chosen from must be fully conformant. This rule is needed in order to allow")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package Outer is","\n","   package P1 is","\n","      type Ifc1 is interface;","\n","      procedure Null_Procedure (X : Ifc1) is null;","\n","      procedure Abstract_Subp  (X : Ifc1) is abstract;","\n","   end P1;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package P2 is","\n","      type Ifc2 is interface;","\n","      procedure Null_Procedure (X : Ifc2) is null;","\n","      procedure Abstract_Subp  (X : Ifc2) is abstract;","\n","   end P2;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"type T is abstract new P1.Ifc1 and P2.Ifc2 with null record;","\n","end Outer;","\n"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"without requiring that T explicitly override any of its inherited operations.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Full conformance is required here, as we cannot allow the parameter names to differ. If they did differ, the routine which was selected for overriding could be determined by using named parameter notation in a call.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0005-1"),"}",' When the subprograms do not conform, we chose not to adopt the "use clause" rule which would make them all visible resulting in likely ambiguity. If we had used such a rule, any successful calls would be confusing; and the fact that there are no Beaujolais-like effects to worry about means we can consider other rules. The hidden-from-all-visibility homographs are still inherited by further derivations, which avoids order-of-declaration dependencies and other anomalies.')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"We have to be careful to not include arbitrary selection if the routines have real bodies. (This can happen in generics, see the example in the incompatibilities section below.) We don't want the ability to successfully call routines where the body executed depends on the compiler or a phase of the moon.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note that if the type is concrete, abstract subprograms are inherited as subprograms that require overriding. We include functions that require overriding as well; these don't have real bodies, so they can use the more liberal rules. ")),(0,n.kt)("p",null,"[For an implicit declaration of a primitive subprogram in a generic unit, there is a copy of this declaration in an instance.] However, a whole new set of primitive subprograms is implicitly declared for each type declared within the visible part of the instance. These new declarations occur immediately after the type declaration, and override the copied ones. [The copied ones can be called only from within the instance; the new ones can be called only from outside the instance, although for tagged types, the body of a new one can be executed by a call to an old one.] "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),'In addition, this is also stated redundantly (again), and is repeated, in 12.3, "Generic Instantiation". The rationale for the rule is explained there. ')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI05-0042-1"),"}"," The implicit subprograms declared when an operation of a progenitor is implemented by an entry or subprogram also override the appropriate implicitly declared inherited operations of the progenitor. ")),(0,n.kt)("p",null,"A declaration is visible within its scope, except where hidden from all visibility, as follows: "),(0,n.kt)("p",null,"An overridden declaration is hidden from all visibility within the scope of the overriding declaration. "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"We have to talk about the scope of the overriding declaration, not its visibility, because it hides even when it is itself hidden.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note that the scope of an explicit ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," does not start until after its profile. ")),(0,n.kt)("p",null,"A declaration is hidden from all visibility until the end of the declaration, except: "),(0,n.kt)("p",null,"For a record type or record extension, the declaration is hidden from all visibility only until the reserved word ",(0,n.kt)("strong",null,"record"),";"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00345-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0177-1"),"}"," For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-7/AA-7.1#S0229"},"package_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0312"},"generic_package_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.8#S0228"},"expression_function_declaration")),", the declaration is hidden from all visibility only until the reserved word ",(0,n.kt)("strong",null,"is")," of the declaration; "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"We're talking about the ",(0,n.kt)("strong",null,"is")," of the construct itself, here, not some random ",(0,n.kt)("strong",null,"is")," that might appear in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0313"},"generic_formal_part")),". ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00345-01"),"}"," For a task declaration or protected declaration, the declaration is hidden from all visibility only until the reserved word ",(0,n.kt)("strong",null,"with")," of the declaration if there is one, or the reserved word ",(0,n.kt)("strong",null,"is")," of the declaration if there is no ",(0,n.kt)("strong",null,"with"),"."),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"If there is neither a ",(0,n.kt)("strong",null,"with")," nor ",(0,n.kt)("strong",null,"is"),", then the exception does not apply and the name is hidden from all visibility until the end of the declaration. This oddity was inherited from Ada 95. ")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),'We need the "',(0,n.kt)("strong",null,"with")," or ",(0,n.kt)("strong",null,"is"),'" rule so that the visibility within an ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.9#S0078"},"interface_list"))," does not vary by construct. That would make it harder to complete private extensions and would complicate implementations. ")),(0,n.kt)("p",null,"If the completion of a declaration is a declaration, then within the scope of the completion, the first declaration is hidden from all visibility. Similarly, a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0062"},"discriminant_specification"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," is hidden within the scope of a corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0062"},"discriminant_specification"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," of a corresponding completion, or of a corresponding ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),". "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"This rule means, for example, that within the scope of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration"))," that completes a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-7/AA-7.3#S0232"},"private_type_declaration")),", the name of the type will denote the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration")),", and therefore the full view of the type. On the other hand, if the completion is not a declaration, then it doesn't hide anything, and you can't denote it. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," ","{",(0,n.kt)("em",null,"AI95-00412-01"),"}"," The declaration of a library unit (including a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0289"},"library_unit_renaming_declaration")),") is hidden from all visibility at places outside its declarative region that are not within the scope of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0296"},"nonlimited_with_clause"))," that mentions it. The limited view of a library package is hidden from all visibility at places that are not within the scope of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0295"},"limited_with_clause"))," that mentions it; in addition, the limited view is hidden from all visibility within the declarative region of the package, as well as within the scope of any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0296"},"nonlimited_with_clause"))," that mentions the package. Where the declaration of the limited view of a package is visible, any name that denotes the package denotes the limited view, including those provided by a package renaming."),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," This is the rule that prevents ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause")),"s from being transitive; the [immediate] scope includes indirect semantic dependents. This rule also prevents the limited view of a package from being visible in the same place as the full view of the package, which prevents various ripple effects. ")),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," ","{",(0,n.kt)("em",null,"AI95-00412-01"),"}"," [For each declaration or renaming of a generic unit as a child of some parent generic package, there is a corresponding declaration nested immediately within each instance of the parent.] Such a nested declaration is hidden from all visibility except at places that are within the scope of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause"))," that mentions the child."),(0,n.kt)("p",null,"A declaration with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0203"},"defining_operator_symbol"))," is immediately visible [(and hence directly visible)] within its immediate scope  except where hidden from direct visibility, as follows: "),(0,n.kt)("p",null,"A declaration is hidden from direct visibility within the immediate scope of a homograph of the declaration, if the homograph occurs within an inner declarative region;"),(0,n.kt)("p",null,"A declaration is also hidden from direct visibility where hidden from all visibility. "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00195-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00408-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0183-1"),"}"," An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.3#S0349"},"attribute_definition_clause"))," or an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," is ",(0,n.kt)("em",null,"visible")," everywhere within its scope."),(0,n.kt)("h4",p({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," shall resolve to denote a directly visible declaration whose defining name is the same as the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name")),". A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," shall resolve to denote a visible declaration whose defining name is the same as the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),". "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),'"The same as" has the obvious meaning here, so for +, the possible interpretations are declarations whose defining name is "+" (an ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol")),"). ")),(0,n.kt)("p",null,"These rules on visibility and direct visibility do not apply in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0292"},"context_clause")),", a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name")),", or a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," that appears at the place of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0286"},"compilation_unit")),'. For those contexts, see the rules in 10.1.6, "Environment-Level Visibility Rules". '),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Direct visibility is irrelevant for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"s. In terms of overload resolution ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"s are similar to other literals, like ",(0,n.kt)("strong",null,"null")," - see 4.2. For ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),"s, there is no need to worry about hiding, since there is no way to declare homographs. ")),(0,n.kt)("h4",p({},{id:"legality-rules"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0025"),"}"," ","{",(0,n.kt)("em",null,"8652/0026"),"}"," ","{",(0,n.kt)("em",null,"AI95-00044-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00150-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00377-01"),"}"," A nonoverridable declaration is illegal if there is a homograph occurring immediately within the same declarative region that is visible at the place of the declaration, and is not hidden from all visibility by the nonoverridable declaration. In addition, a type extension is illegal if somewhere within its immediate scope it has two visible components with the same name. Similarly, the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0292"},"context_clause"))," for a compilation unit is illegal if it mentions (in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause")),") some library unit, and there is a homograph of the library unit that is visible at the place of the compilation unit, and the homograph and the mentioned library unit are both declared immediately within the same declarative region. These rules also apply to dispatching operations declared in the visible part of an instance of a generic unit. However, they do not apply to other overloadable declarations in an instance[; such declarations may have type conformant profiles in the instance, so long as the corresponding declarations in the generic were not type conformant]. "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"Normally, these rules just mean you can't explicitly declare two homographs immediately within the same declarative region. The wording is designed to handle the following special cases: ")),(0,n.kt)("p",null,"If the second declaration completes the first one, the second declaration is legal."),(0,n.kt)("p",null,"If the body of a library unit contains an explicit homograph of a child of that same library unit, this is illegal only if the body mentions the child in its ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0292"},"context_clause")),", or if some subunit mentions the child. Here's an example: "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package P is","\n","end P;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package P.Q is","\n","end P.Q;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package body P is","\n","    Q : Integer; -- OK; we cannot see package P.Q here.","\n","    procedure Sub is separate;","\n","end P;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"with P.Q;","\n","separate(P)","\n","procedure Sub is -- Illegal.","\n","begin","\n","    null;","\n","end Sub;","\n"),(0,n.kt)("p",null,'If package body P said "',(0,n.kt)("strong",null,"with")," P.Q;\", then it would be illegal to declare the homograph Q: Integer. But it does not, so the body of P is OK. However, the subunit would be able to see both P.Q's, and is therefore illegal."),(0,n.kt)("p",null,"A previous version of Ada 9X allowed the subunit, and said that references to P.Q would tend to be ambiguous. However, that was a bad idea, because it requires overload resolution to resolve references to directly visible nonoverloadable homographs, which is something compilers have never before been required to do."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0026"),"}"," ","{",(0,n.kt)("em",null,"8652/0102"),"}"," ","{",(0,n.kt)("em",null,"AI95-00150-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00157-01"),"}"," If a type extension contains a component with the same name as a component in an ancestor type, there must be no place where both components are visible. For instance: "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package A is","\n","   type T is tagged private;","\n","   package B is","\n","      type NT is new T with record","\n","         I: Integer; -- Illegal because T.I is visible in the body.","\n","      end record; -- T.I is not visible here.","\n","   end B;","\n","private","\n","   type T is tagged record","\n","      I: Integer; -- Illegal because T.I is visible in the body.","\n","   end record;","\n","end A;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"{","AI95-00114-01","}"," package body A is","\n","   package body B is","\n","      -- T.I becomes visible here.","\n","   end B;","\n","end A;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package A.C is","\n","   type NT2 is new A.T with record","\n","      I: Integer; -- Illegal because T.I is visible in the private part.","\n","   end record; -- T.I is not visible here.","\n","private","\n","    -- T.I is visible here.","\n","end A.C;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"with A;","\n","package D is","\n","   type NT3 is new A.T with record","\n","      I: Integer; -- Legal because T.I is never visible in this package.","\n","   end record;","\n","end D;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"with D;","\n","package A.E is","\n","   type NT4 is new D.NT3 with null record;","\n","   X : NT4;","\n","   I1 : Integer := X.I;        -- D.NT3.I","\n","   I2 : Integer := D.NT3(X).I; -- D.NT3.I","\n","   I3 : Integer := A.T(X).I;   -- A.T.I","\n","end A.E;","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0102"),"}"," ","{",(0,n.kt)("em",null,"AI95-00157-01"),"}"," D.NT3 can have a component I because the component I of the parent type is never visible. The parent component exists, of course, but is never declared for the type D.NT3. In the child package A.E, the component I of A.T is visible, but that does not change the fact that the A.T.I component was never declared for type D.NT3. Thus, A.E.NT4 does not (visibly) inherit the component I from A.T, while it does inherit the component I from D.NT3. Of course, both components exist, and can be accessed by a type conversion as shown above. This behavior stems from the fact that every characteristic of a type (including components) must be declared somewhere in the innermost declarative region containing the type - if the characteristic is never visible in that declarative region, it is never declared. Therefore, such characteristics do not suddenly become available even if they are in fact visible in some other scope. See 7.3.1 for more on the rules."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00377-01"),"}"," It is illegal to mention both an explicit child of an instance, and a child of the generic from which the instance was instantiated. This is easier to understand with an example: "),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"generic","\n","package G1 is","\n","end G1;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"generic","\n","package G1.G2 is","\n","end G1.G2;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"with G1;","\n","package I1 is new G1;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package I1.G2 renames ...","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"with G1.G2;","\n","with I1.G2;             -- Illegal","\n","package Bad is ...","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0300-1"),"}"," The context clause for Bad is illegal as I1 has an implicit declaration of I1.G2 based on the generic child G1.G2, as well as the mention of the explicit child I1.G2. As in the previous cases, this is illegal only if the context clause makes both children visible; the explicit child can be mentioned as long as the generic child is not (and vice versa). "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'Note that we need to be careful which things we make "hidden from all visibility" versus which things we make simply illegal for names to denote. The distinction is subtle. The rules that disallow names denoting components within a type declaration (see 3.7) do not make the components invisible at those places, so that the above rule makes components with the same name illegal. The same is true for the rule that disallows names denoting formal parameters within a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part"))," (see 6.1). ")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),'The part about instances is from AI83-00012. The reason it says "overloadable declarations" is because we don\'t want it to apply to type extensions that appear in an instance; components are not overloadable. ')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"NOTE 1   Visibility for compilation units follows from the definition of the environment in 10.1.4, except that it is necessary to apply a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause"))," to obtain visibility to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0288"},"library_unit_declaration"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0289"},"library_unit_renaming_declaration")),".")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"NOTE 2   In addition to the visibility rules given above, the meaning of the occurrence of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," at a given place in the text can depend on the overloading rules (see 8.6).")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"NOTE 3   Not all contexts where an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," are allowed require visibility of a corresponding declaration. Contexts where visibility is not required are identified by using one of these three syntactic categories directly in a syntax rule, rather than using ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name")),". ")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.5#S0015"},"character_literal"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," that occurs in one of the following contexts is not required to denote a visible or directly visible declaration: ")),(0,n.kt)("p",null,"a)A defining name."),(0,n.kt)("p",null,"b)The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0202"},"operator_symbol"))," that appear after the reserved word ",(0,n.kt)("strong",null,"end")," in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.11#S0090"},"proper_body")),'. Similarly for "',(0,n.kt)("strong",null,"end loop"),'", etc.'),(0,n.kt)("p",null,"c)An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0101"},"attribute_designator")),"."),(0,n.kt)("p",null,"d)A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"."),(0,n.kt)("p",null,"e)A ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"."),(0,n.kt)("p",null,"f)An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," specific to a pragma used in a pragma argument."),(0,n.kt)("p",null,"g)","{",(0,n.kt)("em",null,"AI05-0183-1"),"}"," An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark")),";"),(0,n.kt)("p",null,"h)","{",(0,n.kt)("em",null,"AI05-0183-1"),"}"," An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," specific to an aspect used in an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition")),". "),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The visibility rules have nothing to do with the above cases; the meanings of such things are defined elsewhere. Reserved words are not ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s; the visibility rules don't apply to them either.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'Because of the way we have defined "declaration", it is possible for a usage name to denote a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),", either within that body, or (for a nonlibrary unit) after it (since the body hides the corresponding declaration, if any). Other bodies do not work that way. Completions of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration")),"s and deferred constant declarations do work that way. ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"Accept_statement")),"s are never denoted, although the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),"s in their profiles can be.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The scope of a subprogram does not start until after its profile. Thus, the following is legal: ")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"X : constant Integer := 17;","\n","...","\n","package P is","\n","    procedure X(Y : in Integer := X);","\n","end P;","\n"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The body of the subprogram will probably be illegal, however, since the constant X will be hidden by then.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The rule is different for generic subprograms, since they are not overloadable; the following is illegal: ")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"X : constant Integer := 17;","\n","package P is","\n","    generic","\n","      Z : Integer := X; -- Illegal!","\n","    procedure X(Y : in Integer := X); -- Illegal!","\n","end P;","\n"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The constant X is hidden from direct visibility by the generic declaration. ")),(0,n.kt)("h4",p({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Declarations with the same defining name as that of a subprogram or entry being defined are nevertheless visible within the subprogram specification or entry declaration. ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'The term "visible by selection" is no longer defined. We use the terms "directly visible" and "visible" (among other things). There are only two regions of text that are of interest, here: the region in which a declaration is visible, and the region in which it is directly visible.')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Visibility is defined only for declarations. ")),(0,n.kt)("h4",p({},{id:"incompatibilities-with-ada-95"}),"Incompatibilities With Ada 95"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00251-01"),"}"," Added rules to handle the inheritance and overriding of multiple homographs for a single type declaration, in order to support multiple inheritance from interfaces. The new rules are intended to be compatible with the existing rules so that programs that do not use interfaces do not change their legality. However, there is a very rare case where this is not true: ")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"generic","\n","   type T1 is private;","\n","   type T2 is private;","\n","package G is","\n","   type T is null record;","\n","   procedure P (X : T; Y : T1);","\n","   procedure P (X : T; Z : T2);","\n","end G;]","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"package I is new G (Integer, Integer); -- Exports homographs of P.","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"type D is new I.T; -- Both Ps are inherited.","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"Obj : D;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"P (Obj, Z =",">"," 10); -- Legal in Ada 95, illegal in Ada 2005.","\n"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The call to P would resolve in Ada 95 by using the parameter name, while the procedures P would be hidden from all visibility in Ada 2005 and thus would not resolve. This case doesn't seem worth making the rules any more complex than they already are.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00377-01"),"}"," ",(0,n.kt)("strong",null,"Amendment Correction:")," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause"))," is illegal if it would create a homograph of an implicitly declared generic child (see 10.1.1). An Ada 95 compiler could have allowed this, but which unit of the two units involved would be denoted wasn't specified, so any successful use isn't portable. Removing one of the two ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0294"},"with_clause")),"s involved will fix the problem. ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0025"),"}"," ","{",(0,n.kt)("em",null,"AI95-00044-01"),"}"," ",(0,n.kt)("strong",null,"Corrigendum:"),' Clarified the overriding rules so that "/=" and ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0172"},"statement_identifier")),"s are covered.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"8652/0026"),"}"," ","{",(0,n.kt)("em",null,"AI95-00150-01"),"}"," ",(0,n.kt)("strong",null,"Corrigendum:")," Clarified that is it never possible for two components with the same name to be visible; any such program is illegal.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00195-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00408-01"),"}"," The visibility of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.3#S0349"},"attribute_definition_clause"))," is defined so that it can be used by the stream attribute availability rules (see 13.13.2).")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00217-06"),"}"," The visibility of a limited view of a library package is defined (see 10.1.1). ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0177-1"),"}"," ","{",(0,n.kt)("em",null,"AI12-0157-1"),"}"," Added wording so that the parameters of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.8#S0228"},"expression_function_declaration"))," are visible in the return expression of the function. (It would be pretty useless without such a rule.)")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0183-1"),"}"," The visibility of an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," is defined so that it can be used in various other rules. ")),(0,n.kt)("h2",p({},{id:"831--overriding-indicators"}),"8.3.1  Overriding Indicators"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00218-03"),"}"," An ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is used to declare that an operation is intended to override (or not override) an inherited operation. "),(0,n.kt)("h4",p({},{id:"syntax"}),"Syntax"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00218-03"),"}"," ",(0,n.kt)("code",null,"overriding_indicator"),(0,n.kt)("a",{id:"S0234"}),(0,n.kt)("code",null," ::= "),"[",(0,n.kt)("strong",null,"not"),"] ",(0,n.kt)("strong",null,"overriding")),(0,n.kt)("h4",p({},{id:"legality-rules-1"}),"Legality Rules"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00218-03"),"}"," ","{",(0,n.kt)("em",null,"AI95-00348-01"),"}"," ","{",(0,n.kt)("em",null,"AI95-00397-01"),"}"," ","{",(0,n.kt)("em",null,"AI05-0177-1"),"}"," If an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.9#S0076"},"abstract_subprogram_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.7#S0227"},"null_procedure_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.8#S0228"},"expression_function_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0298"},"subprogram_body_stub")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.3#S0315"},"generic_instantiation"))," of a subprogram, or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," other than a protected subprogram has an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),", then:"),(0,n.kt)("p",null,"the operation shall be a primitive operation for some type;"),(0,n.kt)("p",null,"if the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is ",(0,n.kt)("strong",null,"overriding"),", then the operation shall override a homograph at the place of the declaration or body;"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI05-0005-1"),"}"," This doesn't require that the overriding happen at precisely the place of the declaration or body; it only requires that the region in  which the overriding is known to have happened includes this place. That is, the overriding can happen at or before the place of the declaration or body. ")),(0,n.kt)("p",null,"if the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is ",(0,n.kt)("strong",null,"not overriding"),", then the operation shall not override any homograph (at any place). "),(0,n.kt)("p",null,"In addition to the places where Legality Rules normally apply, these rules also apply in the private part of an instance of a generic unit."),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"The ",(0,n.kt)("strong",null,"overriding")," and ",(0,n.kt)("strong",null,"not overriding")," rules differ slightly. For ",(0,n.kt)("strong",null,"overriding"),', we want the indicator to reflect the overriding state at the place of the declaration; otherwise the indicator would be "lying". Whether a homograph is implicitly declared after the declaration (see 7.3.1 to see how this can happen) has no impact on this check. However, ',(0,n.kt)("strong",null,"not overriding"),' is different; "lying" would happen if a homograph declared later actually is overriding. So, we require this check to take into account later overridings. That can be implemented either by looking ahead, or by rechecking when additional operations are declared.')),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'The "no lying" rules are needed to prevent a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body"))," from having contradictory ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"s. ")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"NOTE 1   ","{",(0,n.kt)("em",null,"AI95-00397-01"),"}"," Rules for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"s of task and protected entries and of protected subprograms are found in 9.5.2 and 9.4, respectively. ")),(0,n.kt)("h4",p({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00433-01"),"}"," ","{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,"Example of use of an overriding indicator when declaring a security queue derived from the Queue interface of 3.9.4:")),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"type Security_Queue is new Queue with record ...;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"overriding","\n","procedure Append(Q : in out Security_Queue; Person : in Person_Name);","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"{","AI12-0178-1","}"," overriding","\n","procedure Remove_First(Q : in out Security_Queue; Person : out Person_Name);","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"overriding","\n","function Cur_Count(Q : in Security_Queue) return Natural;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"overriding","\n","function Max_Count(Q : in Security_Queue) return Natural;","\n"),(0,n.kt)(o.Z,{mdxType:"CodeBlock"},"not overriding","\n","procedure Arrest(Q : in out Security_Queue; Person : in Person_Name);","\n"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0429-1"),"}"," ",(0,n.kt)("em",null,"The first four subprogram declarations guarantee that these subprograms will override the four subprograms inherited from the Queue interface. A misspelling in one of these subprograms will be detected at compile time by the implementation. Conversely, the declaration of Arrest guarantees that this is a new operation.")),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),'In this case, the subprograms are abstract, so misspellings will get detected anyway. But for other subprograms (especially when deriving from concrete types), the error might never be detected, and a body other than the one the programmer intended might be executed without warning. Thus our new motto: "Overriding indicators - don\'t derive a type without them!" ')),(0,n.kt)("h4",p({},{id:"extensions-to-ada-95"}),"Extensions to Ada 95"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00218-03"),"}"," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"Overriding_indicator")),"s are new. These let the programmer state her overriding intentions to the compiler; if the compiler disagrees, an error will be produced rather than a hard to find bug. ")),(0,n.kt)("h4",p({},{id:"wording-changes-from-ada-2005-1"}),"Wording Changes from Ada 2005"),(0,n.kt)(a.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-0177-1"),"}"," Expression functions can have overriding indicators. ")))}b.isMDXComponent=!0}}]);