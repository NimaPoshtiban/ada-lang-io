"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6920],{366:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>k,default:()=>v,frontMatter:()=>p,metadata:()=>m,toc:()=>y});var a=n(1716),o=n(7556),i=n(9464),l=Object.defineProperty,r=Object.defineProperties,d=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,c=Object.prototype.hasOwnProperty,h=Object.prototype.propertyIsEnumerable,A=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))c.call(t,n)&&A(e,n,t[n]);if(s)for(var n of s(t))h.call(t,n)&&A(e,n,t[n]);return e};const p={sidebar_position:65},k="8.1 Declarative Region",m={unversionedId:"arm/AA-8/AA-8.1",id:"arm/AA-8/AA-8.1",title:"8.1 Declarative Region",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-8/AA-8.1.mdx",sourceDirName:"arm/AA-8",slug:"/arm/AA-8/AA-8.1",permalink:"/docs/arm/AA-8/AA-8.1",draft:!1,tags:[],version:"current",sidebarPosition:65,frontMatter:{sidebar_position:65},sidebar:"referenceManualSidebar",previous:{title:"8 Visibility Rules",permalink:"/docs/arm/AA-8/"},next:{title:"8.2 Scope of Declarations",permalink:"/docs/arm/AA-8/AA-8.2"}},f={},y=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],g={toc:y};function v(e){var t,n=e,{components:l}=n,A=((e,t)=>{var n={};for(var a in e)c.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&s)for(var a of s(e))t.indexOf(a)<0&&h.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},g),A),r(t,d({components:l,mdxType:"MDXLayout"}))),(0,a.kt)("h1",u({},{id:"81-declarative-region"}),"8.1 Declarative Region"),(0,a.kt)("admonition",u({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)("h4",u({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)("p",null,"For each of the following constructs, there is a portion of the program text called its ",(0,a.kt)("em",null,"declarative region"),", [within which nested declarations can occur]: "),(0,a.kt)("p",null,"any declaration, other than that of an enumeration type, that is not a completion [of a previous declaration];"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0094-1"),"}"," an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition")),";"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0061-1"),"}"," an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0119"},"iterated_component_association")),";"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0131"},"iterated_element_association")),";"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0255-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0153"},"quantified_expression")),";"),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0236-1"),"}"," a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0156"},"declare_expression")),";"),(0,a.kt)("p",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.6#S0191"},"block_statement")),";"),(0,a.kt)("p",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.5#S0178"},"loop_statement")),";"),(0,a.kt)("p",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI05-0255-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," "),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00318-02"),"}"," an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.5#S0225"},"extended_return_statement")),";"),(0,a.kt)("p",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),";"),(0,a.kt)("p",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),". "),(0,a.kt)("p",null,"The declarative region includes the text of the construct together with additional text determined [(recursively)], as follows: "),(0,a.kt)("p",null,"If a declaration is included, so is its completion, if any."),(0,a.kt)("p",null,"If the declaration of a library unit [(including Standard - see 10.1.1)] is included, so are the declarations of any child units [(and their completions, by the previous rule)]. The child declarations occur after the declaration."),(0,a.kt)("p",null,"If a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0297"},"body_stub"))," is included, so is the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0302"},"subunit")),"."),(0,a.kt)("p",null,"If a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration"))," is included, then so is a corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.5#S0352"},"record_representation_clause")),", if any. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"This is so that the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.8#S0070"},"component_declaration")),"s can be directly visible in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.5#S0352"},"record_representation_clause")),". ")),(0,a.kt)("p",null,"The declarative region of a declaration is also called the ",(0,a.kt)("em",null,"declarative region")," of any view or entity declared by the declaration. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Reason: "),"The constructs that have declarative regions are the constructs that can have declarations nested inside them. Nested declarations are declared in that declarative region. The one exception is for enumeration literals; although they are nested inside an enumeration type declaration, they behave as if they were declared at the same level as the type. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"A declarative region does not include ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0291"},"parent_unit_name")),"s. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),"A declarative region does not include ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-10/AA-10.1#S0292"},"context_clause")),"s. ")),(0,a.kt)("p",null,"A declaration occurs ",(0,a.kt)("em",null,"immediately within")," a declarative region if this region is the innermost declarative region that encloses the declaration (the ",(0,a.kt)("em",null,"immediately enclosing")," declarative region), not counting the declarative region (if any) associated with the declaration itself. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"Don't confuse the declarative region of a declaration with the declarative region in which it immediately occurs. ")),(0,a.kt)("p",null,"[ A declaration is ",(0,a.kt)("em",null,"local")," to a declarative region if the declaration occurs immediately within the declarative region.] [An entity is ",(0,a.kt)("em",null,"local")," to a declarative region if the entity is declared by a declaration that is local to the declarative region.] "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Ramification: "),'"Occurs immediately within" and "local to" are synonyms (when referring to declarations).')),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'Thus, "local to" applies to both declarations and entities, whereas "occurs immediately within" only applies to declarations. We use this term only informally; for cases where precision is required, we use the term "occurs immediately within", since it is less likely to cause confusion. ')),(0,a.kt)("p",null,"A declaration is ",(0,a.kt)("em",null,"global")," to a declarative region if the declaration occurs immediately within another declarative region that encloses the declarative region. An entity is ",(0,a.kt)("em",null,"global")," to a declarative region if the entity is declared by a declaration that is global to the declarative region. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'NOTE 1   The children of a parent library unit are inside the parent\'s declarative region, even though they do not occur inside the parent\'s declaration or body. This implies that one can use (for example) "P.Q" to refer to a child of P whose defining name is Q, and that after "',(0,a.kt)("strong",null,"use"),' P;" Q can refer (directly) to that child.')),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'NOTE 2   As explained above and in 10.1.1, "Compilation Units - Library Units", all library units are descendants of Standard, and so are contained in the declarative region of Standard. They are ',(0,a.kt)("em",null,"not")," inside the declaration or body of Standard, but they ",(0,a.kt)("em",null,"are")," inside its declarative region.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"NOTE 3   ","{",(0,a.kt)("em",null,"AI12-0442-1"),"}"," For a declarative region that comes in multiple parts, the text of the declarative region does not include any of the text that appears between the parts. Thus, when a portion of a declarative region is said to extend from one place to another in the declarative region, the portion does not contain any of the text that appears between the parts of the declarative region. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"Discussion: "),"It is necessary for the things that have a declarative region to include anything that contains declarations (except for enumeration type declarations). This includes any declaration that has a profile (that is, ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-12/AA-12.6#S0335"},"formal_subprogram_declaration")),", access-to-subprogram ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration")),"), anything that has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part"))," (that is, various kinds of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration")),"), anything that has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.8#S0068"},"component_list"))," (that is, record ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration"))," and record extension ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0023"},"type_declaration")),"), and finally the declarations of task and protected units and packages. ")),(0,a.kt)("h4",u({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"It was necessary to extend Ada 83's definition of declarative region to take the following Ada 95 features into account: ")),(0,a.kt)("p",null,"Child library units."),(0,a.kt)("p",null,"Derived types/type extensions - we need a declarative region for inherited components and also for new components."),(0,a.kt)("p",null,"All the kinds of types that allow discriminants."),(0,a.kt)("p",null,"Protected units."),(0,a.kt)("p",null,"Entries that have bodies instead of accept statements."),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0306"},"choice_parameter_specification"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),"."),(0,a.kt)("p",null,"The formal parameters of access-to-subprogram types."),(0,a.kt)("p",null,"Renamings-as-body. "),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Discriminated and access-to-subprogram type declarations need a declarative region. Enumeration type declarations cannot have one, because you don't have to say \"Color.Red\" to refer to the literal Red of Color. For other type declarations, it doesn't really matter whether or not there is an associated declarative region, so for simplicity, we give one to all types except enumeration types.")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"We now say that an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," has its own declarative region, rather than being part of the declarative region of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),', so that declarative regions are properly nested regions of text, so that it makes sense to talk about "inner declarative regions", and "...extends to the end of a declarative region". Inside an ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of one of the parameters denotes the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", not that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),". If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is nested within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.6#S0191"},"block_statement")),", these ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification")),"s can hide declarations of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.6#S0191"},"block_statement")),". The semantics of such cases was unclear in RM83. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,(0,a.kt)("strong",null,"To be honest: "),"Unfortunately, we have the same problem for the entry name itself - it should denote the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", but ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s are not declarations. They should be, and they should hide the entry from all visibility within themselves. ")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"Note that we can't generalize this to ",(0,a.kt)("code",null,"entry_bodies"),", or other bodies, because the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.11#S0086"},"declarative_part"))," of a body is not supposed to contain (explicit) homographs of things in the declaration. It works for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s only because an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," does not have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.11#S0086"},"declarative_part")),".")),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,'To avoid confusion, we use the term "local to" only informally in Ada 95. Even RM83 used the term incorrectly (see, for example, RM83-12.3(13)).')),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"In Ada 83, (root) library units were inside Standard; it was not clear whether the declaration or body of Standard was meant. In Ada 95, they are children of Standard, and so occur immediately within Standard's declarative region, but not within either the declaration or the body. (See RM83-8.6(2) and RM83-10.1.1(5).) ")),(0,a.kt)("h4",u({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00318-02"),"}"," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.5#S0225"},"Extended_return_statement"))," (see 6.5) is added to the list of constructs that have a declarative region. ")),(0,a.kt)("h4",u({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0094-1"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.10#S0084"},"access_definition"))," is added to the list of constructs that have a declarative region. This allows parameter names declared in anonymous access type subprogram types to be the same as other names declared outside. For instance: ")),(0,a.kt)(o.Z,{mdxType:"CodeBlock"},"type Foo is record","\n","   A : Natural;","\n","   B : access procedure (A : Boolean);","\n","end record;","\n"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0005-1"),"}"," This is now legal, as one would expect; it was illegal in previous versions of Ada as the parameter A and the component A were homographs in the same declarative region (see 8.3). Note that some implementations already allow this common sense interpretation, so this extension might in fact already be used in existing code. ")),(0,a.kt)("h4",u({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,a.kt)(i.Z,{type:"note",mdxType:"Admonition"},(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI12-0061-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0236-1"),"}"," ","{",(0,a.kt)("em",null,"AI12-0308-1"),"}"," Added ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0119"},"iterated_component_association")),", ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.3#S0131"},"iterated_element_association")),", and ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0156"},"declare_expression"))," to the rapidly expanding list of constructs that have a declarative region. ")))}v.isMDXComponent=!0}}]);