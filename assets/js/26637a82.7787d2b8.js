"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5980],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var i=a(6687);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),c=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(a),h=n,m=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return a?i.createElement(m,r(r({ref:t},p),{},{components:a})):i.createElement(m,r({ref:t},p))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9109:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var i=a(9440),n=(a(6687),a(1716));const o={sidebar_position:11},r="10 Program Structure and Compilation Issues",l={unversionedId:"arm/AA-10",id:"arm/AA-10",title:"10 Program Structure and Compilation Issues",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-10.md",sourceDirName:"arm",slug:"/arm/AA-10",permalink:"/docs/arm/AA-10",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"9 Tasks and Synchronization",permalink:"/docs/arm/AA-9"},next:{title:"11 Exceptions",permalink:"/docs/arm/AA-11"}},s={},c=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"10.1  Separate Compilation",id:"101--separate-compilation",level:2},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"10.1.1  Compilation Units - Library Units",id:"1011--compilation-units---library-units",level:3},{value:"Syntax",id:"syntax",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"10.1.2  Context Clauses - With Clauses",id:"1012--context-clauses---with-clauses",level:3},{value:"Language Design Principles",id:"language-design-principles-1",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"10.1.3  Subunits of Compilation Units",id:"1013--subunits-of-compilation-units",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"10.1.4  The Compilation Process",id:"1014--the-compilation-process",level:3},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"10.1.5  Pragmas and Program Units",id:"1015--pragmas-and-program-units",level:3},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules-1",level:4},{value:"Implementation Permissions",id:"implementation-permissions-2",level:4},{value:"10.1.6  Environment-Level Visibility Rules",id:"1016--environment-level-visibility-rules",level:3},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-4",level:4},{value:"10.2  Program Execution",id:"102--program-execution",level:2},{value:"Post-Compilation Rules",id:"post-compilation-rules-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-5",level:4},{value:"10.2.1  Elaboration Control",id:"1021--elaboration-control",level:3},{value:"Language Design Principles",id:"language-design-principles-2",level:4},{value:"Syntax",id:"syntax-3",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Implementation Permissions",id:"implementation-permissions-4",level:4},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"10-program-structure-and-compilation-issues"},"10 Program Structure and Compilation Issues"),(0,n.kt)("admonition",{type:"warning"},(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,n.kt)("p",null,"[The overall structure of programs and the facilities for separate compilation are described in this section. A program is a set of partitions, each of which may execute in a separate address space, possibly on a separate computer. "),(0,n.kt)("p",null,"Glossary entry: A program is a set of partitions, each of which may execute in a separate address space, possibly on a separate computer. A partition consists of a set of library units."),(0,n.kt)("p",null,"Glossary entry: A partition is a part of a program. Each partition consists of a set of library units. Each partition may run in a separate address space, possibly on a separate computer. A program may contain just one partition. A distributed program typically contains multiple partitions, which can execute concurrently."),(0,n.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[program]",", Def=","[a set of partitions, each of which can execute in a separate address space, possibly on a separate computer]"," Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[partition]",", Def=","[a part of a program, which consists of a set of interdependent library units]",", Note1=","[Each partition can run in a separate address space, possibly on a separate computer. A program can contain just one partition, or it can be distributed across multiple partitions, which can execute concurrently.]"),(0,n.kt)("p",null,'As explained below, a partition is constructed from library units. Syntactically, the declaration of a library unit is a library_item, as is the body of a library unit. An implementation may support a concept of a program library (or simply, a "library"), which contains library_items and their subunits. Library units may be organized into a hierarchy of children, grandchildren, and so on.]'),(0,n.kt)("p",null,'This section has two clauses: 10.1, "Separate Compilation" discusses compile-time issues related to separate compilation. 10.2, "Program Execution" discusses issues related to what is traditionally known as "link time" and "run time" - building and executing partitions.'),(0,n.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,n.kt)("p",null,"We should avoid specifying details that are outside the domain of the language itself. The standard is intended (at least in part) to promote portability of Ada programs at the source level. It is not intended to standardize extra-language issues such as how one invokes the compiler (or other tools), how one's source is represented and organized, version management, the format of error messages, etc."),(0,n.kt)("p",null,"The rules of the language should be enforced even in the presence of separate compilation. Using separate compilation should not make a program less safe."),(0,n.kt)("p",null,"It should be possible to determine the legality of a compilation unit by looking only at the compilation unit itself and the compilation units upon which it depends semantically. As an example, it should be possible to analyze the legality of two compilation units in parallel if they do not depend semantically upon each other."),(0,n.kt)("p",null,"On the other hand, it may be necessary to look outside that set in order to generate code - this is generally true for generic instantiation and inlining, for example. Also on the other hand, it is generally necessary to look outside that set in order to check Post-Compilation Rules."),(0,n.kt)("p",null,'See also the "generic contract model" Language Design Principle of 12.3, "Generic Instantiation". '),(0,n.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"The section organization mentioned above is different from that of RM83. "),(0,n.kt)("h2",{id:"101--separate-compilation"},"10.1  Separate Compilation"),(0,n.kt)("p",null,"[ A program unit is either a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal. Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units. Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[program unit]",", Def=","[a language construct that is a package, a task unit, a protected unit, a protected entry, a generic unit, or an explicitly declared subprogram other than an enumeration literal]",", Note1=","[Certain kinds of program units can be separately compiled. Alternatively, they can appear physically nested within other program units.]"),(0,n.kt)("p",null,"The text of a program can be submitted to the compiler in one or more compilations. Each compilation is a succession of compilation_units. A compilation_unit contains either the declaration, the body, or a renaming of a program unit.] Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[compilation unit]",", Def=","[a program unit that is separately compiled]",", Note1=","[A compilation_unit contains either the declaration, the body, or a renaming of a program unit.]"," The representation for a compilation is implementation-defined. "),(0,n.kt)("p",null,"Implementation defined: The representation for a compilation."),(0,n.kt)("p",null,"Ramification: Some implementations might choose to make a compilation be a source (text) file. Others might allow multiple source files to be automatically concatenated to form a single compilation. Others still may represent the source in a nontextual form such as a parse tree. Note that the RM95 does not even define the concept of a source file."),(0,n.kt)("p",null,"Note that a protected subprogram is a subprogram, and therefore a program unit. An instance of a generic unit is a program unit."),(0,n.kt)("p",null,"A protected entry is a program unit, but protected entries cannot be separately compiled. "),(0,n.kt)("p",null,"A library unit is a separately compiled program unit, and is always a package, subprogram, or generic unit. Library units may have other (logically nested) library units as children, and may have other program units physically nested within them. A root library unit, together with its children and grandchildren and so on, form a subsystem. Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[library unit]",", Def=","[a separately compiled program unit, which is a package, a subprogram, or a generic unit]",", Note1=","[Library units can have other (logically nested) library units as children, and can have other program units physically nested within them. A root library unit, together with its children and grandchildren and so on, form a subsystem.]"," "),(0,n.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,n.kt)("p",null,"An implementation may impose implementation-defined restrictions on compilations that contain multiple compilation_units. "),(0,n.kt)("p",null,"Implementation defined: Any restrictions on compilations that contain multiple compilation_units."),(0,n.kt)("p",null,"Discussion: For example, an implementation might disallow a compilation that contains two versions of the same compilation unit, or that contains the declarations for library packages P1 and P2, where P1 precedes P2 in the compilation but P1 has a with_clause that mentions P2. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"The interactions between language issues and environmental issues are left open in Ada 95. The environment concept is new. In Ada 83, the concept of the program library, for example, appeared to be quite concrete, although the rules had no force, since implementations could get around them simply by defining various mappings from the concept of an Ada program library to whatever data structures were actually stored in support of separate compilation. Indeed, implementations were encouraged to do so."),(0,n.kt)("p",null,'In RM83, it was unclear which was the official definition of "program unit". Definitions appeared in RM83-5, 6, 7, and 9, but not 12. Placing it here seems logical, since a program unit is sort of a potential compilation unit. '),(0,n.kt)("h3",{id:"1011--compilation-units---library-units"},"10.1.1  Compilation Units - Library Units"),(0,n.kt)("p",null,"[A library_item is a compilation unit that is the declaration, body, or renaming of a library unit. Each library unit (except Standard) has a parent unit, which is a library package or generic library package.]"," A library unit is a child of its parent unit. The root library units are the children of the predefined library package Standard. "),(0,n.kt)("p",null,"Ramification: Standard is a library unit. "),(0,n.kt)("h4",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"compilation ::= {compilation_unit}"),(0,n.kt)("p",null,"compilation_unit ::=\ncontext_clause library_item\n| context_clause subunit"),(0,n.kt)("p",null,"library_item ::= ","[private]"," library_unit_declaration\n| library_unit_body\n| ","[private]"," library_unit_renaming_declaration"),(0,n.kt)("p",null,"library_unit_declaration ::=\nsubprogram_declaration\t| package_declaration\n| generic_declaration\t| generic_instantiation"),(0,n.kt)("p",null,"library_unit_renaming_declaration ::=\npackage_renaming_declaration\n| generic_renaming_declaration\n| subprogram_renaming_declaration"),(0,n.kt)("p",null,"library_unit_body ::= subprogram_body | package_body"),(0,n.kt)("p",null,"parent_unit_name ::= name"),(0,n.kt)("p",null,'A library unit is a program unit that is declared by a library_item. When a program unit is a library unit, the prefix "library" is used to refer to it (or "generic library" if generic), as well as to its declaration and body, as in "library procedure", "library package_body", or "generic library package". The term compilation unit is used to refer to a compilation_unit. When the meaning is clear from context, the term is also used to refer to the library_item of a compilation_unit or to the proper_body of a subunit ',"[(that is, the compilation_unit without the context_clause and the separate (parent_unit_name))]",". "),(0,n.kt)("p",null,"Discussion: In this example: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Text_IO;\npackage P is\n    ...\nend P;\n\n")),(0,n.kt)("p",null,'the term "compilation unit" can refer to this text: "with Ada.Text_IO; package P is ... end P;" or to this text: "package P is ... end P;". We use this shorthand because it corresponds to common usage.'),(0,n.kt)("p",null,'We like to use the word "unit" for declaration-plus-body things, and "item" for declaration or body separately (as in declarative_item). The terms "compilation_unit", "compilation unit", and "subunit" are exceptions to this rule. We considered changing "compilation_unit", "compilation unit" to "compilation_item", "compilation item", respectively, but we decided not to. '),(0,n.kt)("p",null,"The parent declaration of a library_item (and of the library unit) is the declaration denoted by the parent_unit_name, if any, of the defining_program_unit_name of the library_item. If there is no parent_unit_name, the parent declaration is the declaration of Standard, the library_item is a root library_item, and the library unit (renaming) is a root library unit (renaming). The declaration and body of Standard itself have no parent declaration. The parent unit of a library_item or library unit is the library unit declared by its parent declaration. "),(0,n.kt)("p",null,"Discussion: The declaration and body of Standard are presumed to exist from the beginning of time, as it were. There is no way to actually write them, since there is no syntactic way to indicate lack of a parent. An attempt to compile a package Standard would result in Standard.Standard. "),(0,n.kt)("p",null,'Reason: Library units (other than Standard) have "parent declarations" and "parent units". Subunits have "parent bodies". We didn\'t bother to define the other possibilities: parent body of a library unit, parent declaration of a subunit, parent unit of a subunit. These are not needed, and might get in the way of a correct definition of "child". '),(0,n.kt)("p",null,"[The children of a library unit occur immediately within the declarative region of the declaration of the library unit.]"," The ancestors of a library unit are itself, its parent, its parent's parent, and so on. ","[(Standard is an ancestor of every library unit.)]"," The descendant relation is the inverse of the ancestor relation. "),(0,n.kt)("p",null,"Reason: These definitions are worded carefully to avoid defining subunits as children. Only library units can be children."),(0,n.kt)("p",null,'We use the unadorned term "ancestors" here to concisely define both "ancestor unit" and "ancestor declaration". '),(0,n.kt)("p",null,"A library_unit_declaration or a library_unit_renaming_declaration is private if the declaration is immediately preceded by the reserved word private; it is otherwise public. A library unit is private or public according to its declaration. The public descendants of a library unit are the library unit itself, and the public descendants of its public children. Its other descendants are private descendants. "),(0,n.kt)("p",null,"Discussion: The first concept defined here is that a library_item is either public or private (not in relation to anything else - it's just a property of the library unit). The second concept is that a library_item is a public descendant or private descendant of a given ancestor. A given library_item can be a public descendant of one of its ancestors, but a private descendant of some other ancestor."),(0,n.kt)("p",null,"A subprogram declared by a subprogram_body (as opposed to a subprogram_declaration) is always public, since the syntax rules disallow the reserved word private on a body."),(0,n.kt)("p",null,"Note that a private library unit is a public descendant of itself, but a private descendant of its parent. This is because it is visible outside itself - its privateness means that it is not visible outside its parent."),(0,n.kt)("p",null,'Private children of Standard are legal, and follow the normal rules. It is intended that implementations might have some method for taking an existing environment, and treating it as a package to be "imported" into another environment, treating children of Standard in the imported environment as children of the imported package. '),(0,n.kt)("p",null,"Ramification: Suppose we have a public library unit A, a private library unit A.B, and a public library unit A.B.C. A.B.C is a public descendant of itself and of A.B, but a private descendant of A; since A.B is private to A, we don't allow A.B.C to escape outside A either. This is similar to the situation that would occur with physical nesting, like this: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A is\nprivate\n    package B is\n        package C is\n        end C;\n    private\n    end B;\nend A;\n\n")),(0,n.kt)("p",null,"Here, A.B.C is visible outside itself and outside A.B, but not outside A. (Note that this example is intended to illustrate the visibility of program units from the outside; the visibility within child units is not quite identical to that of physically nested units, since child units are nested after their parent's declaration.) "),(0,n.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,n.kt)("p",null,"The parent unit of a library_item shall be a ","[library]"," package or generic ","[library]"," package."),(0,n.kt)("p",null,"If a defining_program_unit_name of a given declaration or body has a parent_unit_name, then the given declaration or body shall be a library_item. The body of a program unit shall be a library_item if and only if the declaration of the program unit is a library_item. In a library_unit_renaming_declaration, the ","[(old)]"," name shall denote a library_item. "),(0,n.kt)("p",null,"Discussion: We could have allowed nested program units to be children of other program units; their semantics would make sense. We disallow them to keep things simpler and because they wouldn't be particularly useful. "),(0,n.kt)("p",null,"A parent_unit_name ","[(which can be used within a defining_program_unit_name of a library_item and in the separate clause of a subunit)]",", and each of its prefixes, shall not denote a renaming_declaration. ","[On the other hand, a name that denotes a library_unit_renaming_declaration is allowed in a with_clause and other places where the name of a library unit is allowed.]"),(0,n.kt)("p",null,"If a library package is an instance of a generic package, then every child of the library package shall either be itself an instance or be a renaming of a library unit. "),(0,n.kt)("p",null,"Discussion: A child of an instance of a given generic unit will often be an instance of a (generic) child of the given generic unit. This is not required, however. "),(0,n.kt)("p",null,"Reason: Instances are forbidden from having noninstance children for two reasons: "),(0,n.kt)("p",null,'a)We want all source code that can depend on information from the private part of a library unit to be inside the "subsystem" rooted at the library unit. If an instance of a generic unit were allowed to have a noninstance as a child, the source code of that child might depend on information from the private part of the generic unit, even though it is outside the subsystem rooted at the generic unit.'),(0,n.kt)("p",null,"b)Disallowing noninstance children simplifies the description of the semantics of children of generic packages. "),(0,n.kt)("p",null,"A child of a generic library package shall either be itself a generic unit or be a renaming of some other child of the same generic unit. The renaming of a child of a generic package shall occur only within the declarative region of the generic package."),(0,n.kt)("p",null,"A child of a parent generic package shall be instantiated or renamed only within the declarative region of the parent generic."),(0,n.kt)("p",null,"For each declaration or renaming of a generic unit as a child of some parent generic package, there is a corresponding declaration  nested immediately within each instance of the parent. ","[This declaration is visible only within the scope of a with_clause that mentions the child generic unit.]"),(0,n.kt)("p",null,'Implementation Note: Within the child, like anything nested in a generic unit, one can make up-level references to the current instance of its parent, and thereby gain access to the formal parameters of the parent, to the types declared in the parent, etc. This "nesting" model applies even within the generic_formal_part of the child, as it does for a generic child of a nongeneric unit. '),(0,n.kt)("p",null,"Ramification: Suppose P is a generic library package, and P.C is a generic child of P. P.C can be instantiated inside the declarative region of P. Outside P, P.C can be mentioned only in a with_clause. Conceptually, an instance I of P is a package that has a nested generic unit called I.C. Mentioning P.C in a with_clause allows I.C to be instantiated. I need not be a library unit, and the instantiation of I.C need not be a library unit. If I is a library unit, and an instance of I.C is a child of I, then this instance has to be called something other than C."),(0,n.kt)("p",null,"A library subprogram shall not override a primitive subprogram. "),(0,n.kt)("p",null,"Reason: This prevents certain obscure anomalies. For example, if a library subprogram were to override a subprogram declared in its parent package, then in a compilation unit that depends indirectly on the library subprogram, the library subprogram could hide the overridden operation from all visibility, but the library subprogram itself would not be visible."),(0,n.kt)("p",null,"Note that even without this rule, such subprograms would be illegal for tagged types, because of the freezing rules. "),(0,n.kt)("p",null,"The defining name of a function that is a compilation unit shall not be an operator_symbol. "),(0,n.kt)("p",null,"Reason: Since overloading is not permitted among compilation units, it seems unlikely that it would be useful to define one as an operator. Note that a subunit could be renamed within its parent to be an operator. "),(0,n.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,n.kt)("p",null,"A subprogram_renaming_declaration that is a library_unit_renaming_declaration is a renaming-as-declaration, not a renaming-as-body."),(0,n.kt)("p",null,"[There are two kinds of dependences among compilation units:]"," "),(0,n.kt)("p",null,"[The semantic dependences (see below) are the ones needed to check the compile-time rules across compilation unit boundaries; a compilation unit depends semantically on the other compilation units needed to determine its legality. The visibility rules are based on the semantic dependences."),(0,n.kt)("p",null,"The elaboration dependences (see 10.2) determine the order of elaboration of library_items.] "),(0,n.kt)("p",null,'Discussion: Don\'t confuse these kinds of dependences with the run-time dependences among tasks and masters defined in 9.3, "Task Dependence - Termination of Tasks". '),(0,n.kt)("p",null,"A library_item depends semantically upon its parent declaration. A subunit depends semantically upon its parent body. A library_unit_body depends semantically upon the corresponding library_unit_declaration, if any. A compilation unit depends semantically upon each library_item mentioned in a with_clause of the compilation unit. In addition, if a given compilation unit contains an attribute_reference of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. The semantic dependence relationship is transitive."),(0,n.kt)("p",null,'Discussion: The "if any" in the third sentence is necessary because library subprograms are not required to have a subprogram_declaration. '),(0,n.kt)("p",null,"To be honest: If a given compilation unit contains a choice_parameter_specification, then the given compilation unit depends semantically upon the declaration of Ada.Exceptions."),(0,n.kt)("p",null,"If a given compilation unit contains a pragma with an argument of a type defined in another compilation unit, then the given compilation unit depends semantically upon the other compilation unit. "),(0,n.kt)("p",null,"Discussion: For example, a compilation unit containing X'Address depends semantically upon the declaration of package System."),(0,n.kt)("p",null,"For the Address attribute, this fixes a hole in Ada 83. Note that in almost all cases, the dependence will need to exist due to with_clauses, even without this rule. Hence, the rule has very little effect on programmers."),(0,n.kt)("p",null,"Note that the semantic dependence does not have the same effect as a with_clause; in order to denote a declaration in one of those packages, a with_clause will generally be needed."),(0,n.kt)("p",null,"Note that no special rule is needed for an attribute_definition_clause, since an expression after use will require semantic dependence upon the compilation unit containing the type_declaration of interest."),(0,n.kt)("p",null,"NOTE 1   A simple program may consist of a single compilation unit. A compilation need not have any compilation units; for example, its text can consist of pragmas. "),(0,n.kt)("p",null,"Ramification: Such pragmas cannot have any arguments that are names, by a previous rule of this subclause. A compilation can even be entirely empty, which is probably not useful."),(0,n.kt)("p",null,"Some interesting properties of the three kinds of dependence: The elaboration dependences also include the semantic dependences, except that subunits are taken together with their parents. The semantic dependences partly determine the order in which the compilation units appear in the environment at compile time. At run time, the order is partly determined by the elaboration dependences."),(0,n.kt)("p",null,"The model whereby a child is inside its parent's declarative region, after the parent's declaration, as explained in 8.1, has the following ramifications: "),(0,n.kt)("p",null,'The restrictions on "early" use of a private type (RM83-7.4.1(4)) or a deferred constant (RM83-7.4.3(2)) do not apply to uses in child units, because they follow the full declaration.'),(0,n.kt)("p",null,"A library subprogram is never primitive, even if its profile includes a type declared immediately within the parent's package_specification, because the child is not declared immediately within the same package_specification as the type (so it doesn't declare a new primitive subprogram), and because the child is forbidden from overriding an old primitive subprogram. It is immediately within the same declarative region, but not the same package_specification. Thus, for a tagged type, it is not possible to call a child subprogram in a dispatching manner. (This is also forbidden by the freezing rules.) Similarly, it is not possible for the user to declare primitive subprograms of the types declared in the declaration of Standard, such as Integer (even if the rules were changed to allow a library unit whose name is an operator symbol)."),(0,n.kt)("p",null,'When the parent unit is "used" the simple names of the with\'d child units are directly visible (see 8.4, "Use Clauses").'),(0,n.kt)("p",null,"When a parent body with's its own child, the defining name of the child is directly visible, and the parent body is not allowed to include a declaration of a homograph of the child unit immediately within the declarative_part of the body (RM83-8.3(17)). "),(0,n.kt)("p",null,'Note that "declaration of a library unit" is different from "library_unit_declaration" - the former includes subprogram_body. Also, we sometimes really mean "declaration of a view of a library unit", which includes library_unit_renaming_declarations.'),(0,n.kt)("p",null,"The visibility rules generally imply that the renamed view of a library_unit_renaming_declaration has to be mentioned in a with_clause of the library_unit_renaming_declaration. "),(0,n.kt)("p",null,"To be honest: The real rule is that the renamed library unit has to be visible in the library_unit_renaming_declaration. "),(0,n.kt)("p",null,'Reason: In most cases, "has to be visible" means there has to be a with_clause. However, it is possible in obscure cases to avoid the need for a with_clause; in particular, a compilation unit such as "package P.Q renames P;" is legal with no with_clauses (though not particularly interesting). ASCII is physically nested in Standard, and so is not a library unit, and cannot be renamed as a library unit. '),(0,n.kt)("p",null,"NOTE 2   The designator of a library function cannot be an operator_symbol, but a nonlibrary renaming_declaration is allowed to rename a library function as an operator. Within a partition, two library subprograms are required to have distinct names and hence cannot overload each other. However, renaming_declarations are allowed to define overloaded names for such subprograms, and a locally declared subprogram is allowed to overload a library subprogram. The expanded name Standard.L can be used to denote a root library unit L (unless the declaration of Standard is hidden) since root library unit declarations occur immediately within the declarative region of package Standard. "),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("p",null,"Examples of library units: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package Rational_Numbers.IO is  -- public child of Rational_Numbers, see 7.1\n   procedure Put(R : in  Rational);\n   procedure Get(R : out Rational);\nend Rational_Numbers.IO;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"private procedure Rational_Numbers.Reduce(R : in out Rational);\n                                -- private child of Rational_Numbers\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Rational_Numbers.Reduce;   -- refer to a private child\npackage body Rational_Numbers is\n   ...\nend Rational_Numbers;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'with Rational_Numbers.IO; use Rational_Numbers;\nwith Ada.Text_io;               -- see A.10\nprocedure Main is               -- a root library procedure\n   R : Rational;\nbegin\n   R := 5/3;                    -- construct a rational number, see 7.1\n   Ada.Text_IO.Put("The answer is: ");\n   IO.Put(R);\n   Ada.Text_IO.New_Line;\nend Main;\n\n')),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Rational_Numbers.IO;\npackage Rational_IO renames Rational_Numbers.IO;\n                                -- a library unit renaming declaration\n\n")),(0,n.kt)("p",null,"Each of the above library_items can be submitted to the compiler separately. "),(0,n.kt)("p",null,"Discussion: Example of a generic package with children:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Element is private;\n   with function Image(E : Element) return String;\npackage Generic_Bags is\n   type Bag is limited private; -- A bag of Elements.\n   procedure Add(B : in out Bag; E : Element);\n   function Bag_Image(B : Bag) return String;\nprivate\n   type Bag is ...;\nend Generic_Bags;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"generic\npackage Generic_Bags.Generic_Iterators is\n   ... -- various additional operations on Bags.\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   generic\n      with procedure Use_Element(E : in Element);\n         -- Called once per bag element.\n   procedure Iterate(B : in Bag);\nend Generic_Bags.Generic_Iterators;\n\n")),(0,n.kt)("p",null,"A package that instantiates the above generic units: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Generic_Bags;\nwith Generic_Bags.Generic_Iterators;\npackage My_Abstraction is\n    type My_Type is ...;\n    function Image(X : My_Type) return String;\n    package Bags_Of_My_Type is new Generic_Bags(My_Type, Image);\n    package Iterators_Of_Bags_Of_My_Type is new Bags_Of_My_Type.Generic_Iterators;\nend My_Abstraction;\n\n")),(0,n.kt)("p",null,"In the above example, Bags_Of_My_Type has a nested generic unit called Generic_Iterators. The second with_clause makes that nested unit visible."),(0,n.kt)("p",null,"Here we show how the generic body could depend on one of its own children: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Generic_Bags.Generic_Iterators;\npackage body Generic_Bags is\n   procedure Add(B : in out Bag; E : Element) is ... end Add;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   package Iters is new Generic_Iterators;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"   function Bag_Image(B : Bag) return String is\n      Buffer : String(1..10_000);\n      Last : Integer := 0;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"      procedure Append_Image(E : in Element) is\n         Im : constant String := Image(E);\n      begin\n         if Last /= 0 then -- Insert a comma.\n            Last := Last + 1;\n            Buffer(Last) := ',';\n         end if;\n         Buffer(Last+1 .. Last+Im'Length) := Im;\n         Last := Last + Im'Length;\n      end Append_Image;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"      procedure Append_All is new Iters.Iterate(Append_Image);\n   begin\n      Append_All(B);\n      return Buffer(1..Last);\n   end Bag_Image;\nend Generic_Bags;\n\n")),(0,n.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The syntax rule for library_item is modified to allow the reserved word private before a library_unit_declaration."),(0,n.kt)("p",null,"Children (other than children of Standard) are new in Ada 95."),(0,n.kt)("p",null,"Library unit renaming is new in Ada 95. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"Standard is considered a library unit in Ada 95. This simplifies the descriptions, since it implies that the parent of each library unit is a library unit. (Standard itself has no parent, of course.) As in Ada 83, the language does not define any way to recompile Standard, since the name given in the declaration of a library unit is always interpreted in relation to Standard. That is, an attempt to compile a package Standard would result in Standard.Standard. "),(0,n.kt)("h3",{id:"1012--context-clauses---with-clauses"},"10.1.2  Context Clauses - With Clauses"),(0,n.kt)("p",null,"[A context_clause is used to specify the library_items whose names are needed within a compilation unit.]"," "),(0,n.kt)("h4",{id:"language-design-principles-1"},"Language Design Principles"),(0,n.kt)("p",null,"The reader should be able to understand a context_clause without looking ahead. Similarly, when compiling a context_clause, the compiler should not have to look ahead at subsequent context_items, nor at the compilation unit to which the context_clause is attached. (We have not completely achieved this.)"),(0,n.kt)("h4",{id:"syntax-1"},"Syntax"),(0,n.kt)("p",null,"context_clause ::= {context_item}"),(0,n.kt)("p",null,"context_item ::= with_clause | use_clause"),(0,n.kt)("p",null,"with_clause ::= with library_unit_name {, library_unit_name};"),(0,n.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,n.kt)("p",null,"The scope of a with_clause that appears on a library_unit_declaration or library_unit_renaming_declaration consists of the entire declarative region of the declaration","[, which includes all children and subunits]",". The scope of a with_clause that appears on a body consists of the body","[, which includes all subunits]",". "),(0,n.kt)("p",null,'Discussion: Suppose a  with_clause of a public library unit mentions one of its private siblings. (This is only allowed on the body of the public library unit.) We considered making the scope of that with_clause not include the visible part of the public library unit. (This would only matter for a subprogram_body, since those are the only kinds of body that have a visible part, and only if the subprogram_body completes a subprogram_declaration, since otherwise the with_clause would be illegal.) We did not put in such a rule for two reasons: (1) It would complicate the wording of the rules, because we would have to split each with_clause into pieces, in order to correctly handle "with P, Q;" where P is public and Q is private. (2) The conformance rules prevent any problems. It doesn\'t matter if a type name in the spec of the body denotes the completion of a private_type_declaration.'),(0,n.kt)("p",null,"A with_clause also affects visibility within subsequent use_clauses and pragmas of the same context_clause, even though those are not in the scope of the with_clause. "),(0,n.kt)("p",null,"A library_item is mentioned in a with_clause if it is denoted by a library_unit_name or a prefix in the with_clause. "),(0,n.kt)("p",null,"Discussion: With_clauses control the visibility of declarations or renamings of library units. Mentioning a root library unit in a with_clause makes its declaration directly visible. Mentioning a nonroot library unit makes its declaration visible. See Section 8 for details."),(0,n.kt)("p",null,'Note that this rule implies that "with A.B.C;" is equivalent to "with A, A.B, A.B.C;" The reason for making a with_clause apply to all the ancestor units is to avoid "visibility holes" - situations in which an inner program unit is visible while an outer one is not. Visibility holes would cause semantic complexity and implementation difficulty.'),(0,n.kt)("p",null,"[Outside its own declarative region, the declaration or renaming of a library unit can be visible only within the scope of a with_clause that mentions it. The visibility of the declaration or renaming of a library unit otherwise follows from its placement in the environment.]"," "),(0,n.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,n.kt)("p",null,"If a with_clause of a given compilation_unit mentions a private child of some library unit, then the given compilation_unit shall be either the declaration of a private descendant of that library unit or the body or subunit of a ","[(public or private)]"," descendant of that library unit. "),(0,n.kt)("p",null,"Reason: The purpose of this rule is to prevent a private child from being visible (or even semantically depended-on) from outside the subsystem rooted at its parent. "),(0,n.kt)("p",null,"Discussion: This rule violates the one-pass context_clauses Language Design Principle. We rationalize this by saying that at least that Language Design Principle works for legal compilation units."),(0,n.kt)("p",null,"Example: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A is\nend A;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A.B is\nend A.B;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"private package A.B.C is\nend A.B.C;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A.B.C.D is\nend A.B.C.D;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with A.B.C; -- (1)\nprivate package A.B.X is\nend A.B.X;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A.B.Y is\nend A.B.Y;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with A.B.C; -- (2)\npackage body A.B.Y is\nend A.B.Y;\n\n")),(0,n.kt)("p",null,'(1) is OK because it\'s a private child of A.B - it would be illegal if we made A.B.X a public child of A.B. (2) is OK because it\'s the body of a child of A.B. It would be illegal to say "with A.B.C;" on any library_item whose name does not start with "A.B". Note that mentioning A.B.C.D in a with_clause automatically mentions A.B.C as well, so "with A.B.C.D;" is illegal in the same places as "with A.B.C;". '),(0,n.kt)("p",null,"To be honest: For the purposes of this rule, if a subprogram_body has no preceding subprogram_declaration, the subprogram_body should be considered a declaration and not a body. Thus, it is illegal for such a subprogram_body to mention one of its siblings in a with_clause if the sibling is a private library unit. "),(0,n.kt)("p",null,"NOTE   A library_item mentioned in a with_clause of a compilation unit is visible within the compilation unit and hence acts just like an ordinary declaration. Thus, within a compilation unit that mentions its declaration, the name of a library package can be given in use_clauses and can be used to form expanded names, a library subprogram can be called, and instances of a generic library unit can be declared. If a child of a parent generic package is mentioned in a with_clause, then the corresponding declaration nested within each visible instance is visible within the compilation unit."),(0,n.kt)("p",null,"Ramification: The rules given for with_clauses are such that the same effect is obtained whether the name of a library unit is mentioned once or more than once by the applicable with_clauses, or even within a given with_clause."),(0,n.kt)("p",null,'If a with_clause mentions a library_unit_renaming_declaration, it only "mentions" the prefixes appearing explicitly in the with_clause (and the renamed view itself); the with_clause is not defined to mention the ancestors of the renamed entity. Thus, if X renames Y.Z, then "with X;" does not make the declarations of Y or Z visible. Note that this does not cause the dreaded visibility holes mentioned above. '),(0,n.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The syntax rule for with_clause is modified to allow expanded name notation."),(0,n.kt)("p",null,"A use_clause in a context_clause may be for a package (or type) nested in a library package. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"The syntax rule for context_clause is modified to more closely reflect the semantics. The Ada 83 syntax rule implies that the use_clauses that appear immediately after a particular with_clause are somehow attached to that with_clause, which is not true. The new syntax allows a use_clause to appear first, but that is prevented by a textual rule that already exists in Ada 83."),(0,n.kt)("p",null,'The concept of "scope of a with_clause" (which is a region of text) replaces RM83\'s notion of "apply to" (a with_clause applies to a library_item) The visibility rules are interested in a region of text, not in a set of compilation units.'),(0,n.kt)("p",null,'No need to define "apply to" for use_clauses. Their semantics are fully covered by the "scope (of a use_clause)" definition in 8.4. '),(0,n.kt)("h3",{id:"1013--subunits-of-compilation-units"},"10.1.3  Subunits of Compilation Units"),(0,n.kt)("p",null,"[Subunits are like child units, with these (important) differences: subunits support the separate compilation of bodies only (not declarations); the parent contains a body_stub to indicate the existence and place of each of its subunits; declarations appearing in the parent's body can be visible within the subunits.]"," "),(0,n.kt)("h4",{id:"syntax-2"},"Syntax"),(0,n.kt)("p",null,"body_stub ::=\nsubprogram_body_stub | package_body_stub | task_body_stub | protected_body_stub"),(0,n.kt)("p",null,"subprogram_body_stub ::= subprogram_specification is separate;"),(0,n.kt)("p",null,'Discussion: Although this syntax allows a parent_unit_name, that is disallowed by 10.1.1, "Compilation Units - Library Units". '),(0,n.kt)("p",null,"package_body_stub ::= package body defining_identifier is separate;"),(0,n.kt)("p",null,"task_body_stub ::= task body defining_identifier is separate;"),(0,n.kt)("p",null,"protected_body_stub ::= protected body defining_identifier is separate;"),(0,n.kt)("p",null,"subunit ::= separate (parent_unit_name) proper_body"),(0,n.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,n.kt)("p",null,"The parent body of a subunit is the body of the program unit denoted by its parent_unit_name.  The term subunit is used to refer to a subunit and also to the proper_body of a subunit. "),(0,n.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[subunit]",", Def=","[the body of a program unit that can be compiled separately from its enclosing program unit]"),(0,n.kt)("p",null,"The parent body of a subunit shall be present in the current environment, and shall contain a corresponding body_stub with the same defining_identifier as the subunit. "),(0,n.kt)("p",null,"Discussion: This can't be a Name Resolution Rule, because a subunit is not a complete context. "),(0,n.kt)("p",null,"A package_body_stub shall be the completion of a package_declaration or generic_package_declaration; a task_body_stub shall be the completion of a task_declaration; a protected_body_stub shall be the completion of a protected_declaration."),(0,n.kt)("p",null,"In contrast, a subprogram_body_stub need not be the completion of a previous declaration, ","[in which case the _stub declares the subprogram]",". If the _stub is a completion, it shall be the completion of a subprogram_declaration or generic_subprogram_declaration. The profile of a subprogram_body_stub that completes a declaration shall conform fully to that of the declaration. "),(0,n.kt)("p",null,'Discussion: The part about subprogram_body_stubs echoes the corresponding rule for subprogram_bodies in 6.3, "Subprogram Bodies". '),(0,n.kt)("p",null,"A subunit that corresponds to a body",(0,n.kt)("em",{parentName:"p"},"stub shall be of the same kind (package"),", subprogram",(0,n.kt)("em",{parentName:"p"},", task"),", or protected_) as the body_stub. The profile of a subprogram_body subunit shall be fully conformant to that of the corresponding body_stub. "),(0,n.kt)("p",null,"A body_stub shall appear immediately within the declarative_part of a compilation unit body. This rule does not apply within an instance of a generic unit. "),(0,n.kt)("p",null,"Discussion: This is a methodological restriction; that is, it is not necessary for the semantics of the language to make sense. "),(0,n.kt)("p",null,"The defining_identifiers of all body_stubs that appear immediately within a particular declarative_part shall be distinct. "),(0,n.kt)("h4",{id:"post-compilation-rules"},"Post-Compilation Rules"),(0,n.kt)("p",null,"For each body_stub, there shall be a subunit containing the corresponding proper_body. "),(0,n.kt)("p",null,'NOTE   The rules in 10.1.4, "The Compilation Process" say that a body_stub is equivalent to the corresponding proper_body. This implies: '),(0,n.kt)("p",null,"Visibility within a subunit is the visibility that would be obtained at the place of the corresponding body_stub (within the parent body) if the context_clause of the subunit were appended to that of the parent body. "),(0,n.kt)("p",null,"Ramification: Recursively. Note that this transformation might make the parent illegal; hence it is not a true equivalence, but applies only to visibility within the subunit. "),(0,n.kt)("p",null,"The effect of the elaboration of a body_stub is to elaborate the subunit. "),(0,n.kt)("p",null,"Ramification: The elaboration of a subunit is part of its parent body's elaboration, whereas the elaboration of a child unit is not part of its parent declaration's elaboration. "),(0,n.kt)("p",null,"Ramification: A library_item that is mentioned in a with_clause of a subunit can be hidden (from direct visiblity) by a declaration (with the same identifier) given in the subunit. Moreover, such a library_item can even be hidden by a declaration given within the parent body since a library unit is declared in its parent's declarative region; this however does not affect the interpretation of the with_clauses themselves, since only library_items are visible or directly visible in with_clauses."),(0,n.kt)("p",null,"The body of a protected operation cannot be a subunit. This follows from the syntax rules. The body of a protected unit can be a subunit. "),(0,n.kt)("h4",{id:"examples-1"},"Examples"),(0,n.kt)("p",null,"The package Parent is first written without subunits: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package Parent is\n    procedure Inner;\nend Parent;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'with Ada.Text_IO;\npackage body Parent is\n    Variable : String := "Hello, there.";\n    procedure Inner is\n    begin\n        Ada.Text_IO.Put_Line(Variable);\n    end Inner;\nend Parent;\n\n')),(0,n.kt)("p",null,"The body of procedure Inner may be turned into a subunit by rewriting the package body as follows (with the declaration of Parent remaining the same): "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},'package body Parent is\n    Variable : String := "Hello, there.";\n    procedure Inner is separate;\nend Parent;\n\n')),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with Ada.Text_IO;\nseparate(Parent)\nprocedure Inner is\nbegin\n    Ada.Text_IO.Put_Line(Variable);\nend Inner;\n\n")),(0,n.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,n.kt)("p",null,"Subunits of the same ancestor library unit are no longer restricted to have distinct identifiers. Instead, we require only that the full expanded names be distinct. "),(0,n.kt)("h3",{id:"1014--the-compilation-process"},"10.1.4  The Compilation Process"),(0,n.kt)("p",null,'Each compilation unit submitted to the compiler is compiled in the context of an environment declarative_part (or simply, an environment), which is a conceptual declarative_part that forms the outermost declarative region of the context of any compilation. At run time, an environment forms the declarative_part of the body of the environment task of a partition (see 10.2, "Program Execution"). '),(0,n.kt)("p",null,"Ramification: At compile time, there is no particular construct that the declarative region is considered to be nested within - the environment is the universe. "),(0,n.kt)("p",null,"To be honest: The environment is really just a portion of a declarative_part, since there might, for example, be bodies that do not yet exist. "),(0,n.kt)("p",null,"The declarative_items of the environment are library_items appearing in an order such that there are no forward semantic dependences. Each included subunit occurs in place of the corresponding stub. The visibility rules apply as if the environment were the outermost declarative region, except that with_clauses are needed to make declarations of library units visible (see 10.1.2)."),(0,n.kt)("p",null,"The mechanisms for creating an environment and for adding and replacing compilation units within an environment are implementation defined. "),(0,n.kt)("p",null,"Implementation defined: The mechanisms for creating an environment and for adding and replacing compilation units."),(0,n.kt)("p",null,"Ramification: The traditional model, used by most Ada 83 implementations, is that one places a compilation unit in the environment by compiling it. Other models are possible. For example, an implementation might define the environment to be a directory; that is, the compilation units in the environment are all the compilation units in the source files contained in the directory. In this model, the mechanism for replacing a compilation unit with a new one is simply to edit the source file containing that compilation unit. "),(0,n.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,n.kt)("p",null,"If a library_unit_body that is a subprogram_body is submitted to the compiler, it is interpreted only as a completion if a library_unit_declaration for a subprogram or a generic subprogram with the same defining_program_unit_name already exists in the environment (even if the profile of the body is not type conformant with that of the declaration); otherwise the subprogram_body is interpreted as both the declaration and body of a library subprogram. "),(0,n.kt)("p",null,'Ramification: The principle here is that a subprogram_body should be interpreted as only a completion if and only if it "might" be legal as the completion of some preexisting declaration, where "might" is defined in a way that does not require overload resolution to determine.'),(0,n.kt)("p",null,'Hence, if the preexisting declaration is a subprogram_declaration or generic_subprogram_declaration, we treat the new subprogram_body as its completion, because it "might" be legal. If it turns out that the profiles don\'t fully conform, it\'s an error. In all other cases (the preexisting declaration is a package or a generic package, or an instance of a generic subprogram, or a renaming, or a "spec-less" subprogram, or in the case where there is no preexisting thing), the subprogram_body declares a new subprogram.'),(0,n.kt)("p",null,"See also AI83-00266/09. "),(0,n.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,n.kt)("p",null,"When a compilation unit is compiled, all compilation units upon which it depends semantically shall already exist in the environment; the set of these compilation units shall be consistent in the sense that the new compilation unit shall not semantically depend (directly or indirectly) on two different versions of the same compilation unit, nor on an earlier version of itself. "),(0,n.kt)("p",null,'Discussion: For example, if package declarations A and B both say "with X;", and the user compiles a compilation unit that says "with A, B;", then the A and B have to be talking about the same version of X. '),(0,n.kt)("p",null,'Ramification: What it means to be a "different version" is not specified by the language. In some implementations, it means that the compilation unit has been recompiled. In others, it means that the source of the compilation unit has been edited in some significant way.'),(0,n.kt)("p",null,"Note that an implementation cannot require the existence of compilation units upon which the given one does not semantically depend. For example, an implementation is required to be able to compile a compilation unit that says \"with A;\" when A's body does not exist. It has to be able to detect errors without looking at A's body."),(0,n.kt)("p",null,"Similarly, the implementation has to be able to compile a call to a subprogram for which a pragma Inline has been specified without seeing the body of that subprogram - inlining would not be achieved in this case, but the call is still legal."),(0,n.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,n.kt)("p",null,"The implementation may require that a compilation unit be legal before inserting it into the environment."),(0,n.kt)("p",null,"When a compilation unit that declares or renames a library unit is added to the environment, the implementation may remove from the environment any preexisting library_item with the same defining_program_unit_name. When a compilation unit that is a subunit or the body of a library unit is added to the environment, the implementation may remove from the environment any preexisting version of the same compilation unit. When a given compilation unit is removed from the environment, the implementation may also remove any compilation unit that depends semantically upon the given one. If the given compilation unit contains the body of a subprogram to which a pragma Inline applies, the implementation may also remove any compilation unit containing a call to that subprogram. "),(0,n.kt)("p",null,"Ramification: The permissions given in this paragraph correspond to the traditional model, where compilation units enter the environment by being compiled into it, and the compiler checks their legality at that time. A implementation model in which the environment consists of all source files in a given directory might not want to take advantage of these permissions. Compilation units would not be checked for legality as soon as they enter the environment; legality checking would happen later, when compilation units are compiled. In this model, compilation units might never be automatically removed from the environment; they would be removed when the user explicitly deletes a source file."),(0,n.kt)("p",null,"Note that the rule is recursive: if the above permission is used to remove a compilation unit containing an inlined subprogram call, then compilation units that depend semantically upon the removed one may also be removed, and so on."),(0,n.kt)("p",null,"Note that here we are talking about dependences among existing compilation units in the environment; it doesn't matter what with_clauses are attached to the new compilation unit that triggered all this."),(0,n.kt)("p",null,"An implementation may have other modes in which compilation units in addition to the ones mentioned above are removed. For example, an implementation might inline subprogram calls without an explicit pragma Inline. If so, it either has to have a mode in which that optimization is turned off, or it has to automatically regenerate code for the inlined calls without requiring the user to resubmit them to the compiler. "),(0,n.kt)("p",null,"NOTE 1   The rules of the language are enforced across compilation and compilation unit boundaries, just as they are enforced within a single compilation unit. "),(0,n.kt)("p",null,"Ramification: Note that Section 1 requires an implementation to detect illegal compilation units at compile time. "),(0,n.kt)("p",null,"NOTE 2   An implementation may support a concept of a library, which contains library_items. If multiple libraries are supported, the implementation has to define how a single environment is constructed when a compilation unit is submitted to the compiler. Naming conflicts between different libraries might be resolved by treating each library as the root of a hierarchy of child library units. "),(0,n.kt)("p",null,"Implementation Note: Alternatively, naming conflicts could be resolved via some sort of hiding rule. "),(0,n.kt)("p",null,'Discussion: For example, the implementation might support a command to import library Y into library X. If a root library unit called LU (that is, Standard.LU) exists in Y, then from the point of view of library X, it could be called Y.LU. X might contain library units that say, "with Y.LU;". '),(0,n.kt)("p",null,"NOTE 3   A compilation unit containing an instantiation of a separately compiled generic unit does not semantically depend on the body of the generic unit. Therefore, replacing the generic body in the environment does not result in the removal of the compilation unit containing the instantiation. "),(0,n.kt)("p",null,"Implementation Note: Therefore, implementations have to be prepared to automatically instantiate generic bodies at link-time, as needed. This might imply a complete automatic recompilation, but it is the intent of the language that generic bodies can be (re)instantiated without forcing all of the compilation units that semantically depend on the compilation unit containing the instantiation to be recompiled. "),(0,n.kt)("h3",{id:"1015--pragmas-and-program-units"},"10.1.5  Pragmas and Program Units"),(0,n.kt)("p",null,"[This subclause discusses pragmas related to program units, library units, and compilations.]"," "),(0,n.kt)("h4",{id:"name-resolution-rules-2"},"Name Resolution Rules"),(0,n.kt)("p",null,"Certain pragmas are defined to be program unit pragmas. A name given as the argument of a program unit pragma shall resolve to denote the declarations or renamings of one or more program units that occur immediately within the declarative region or compilation in which the pragma immediately occurs, or it shall resolve to denote the declaration of the immediately enclosing program unit (if any); the pragma applies to the denoted program unit(s). If there are no names given as arguments, the pragma applies to the immediately enclosing program unit. "),(0,n.kt)("p",null,"Ramification: The fact that this is a Name Resolution Rule means that the pragma will not apply to declarations from outer declarative regions. "),(0,n.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,n.kt)("p",null,"A program unit pragma shall appear in one of these places: "),(0,n.kt)("p",null,"At the place of a compilation_unit, in which case the pragma shall immediately follow in the same compilation (except for other pragmas) a library_unit_declaration that is a subprogram_declaration, generic_subprogram_declaration, or generic_instantiation, and the pragma shall have an argument that is a name denoting that declaration. "),(0,n.kt)("p",null,"Ramification: The name has to denote the immediately preceding library_unit_declaration. "),(0,n.kt)("p",null,"Immediately within the declaration of a program unit and before any nested declaration, in which case the argument, if any, shall be a direct_name that denotes the immediately enclosing program unit declaration. "),(0,n.kt)("p",null,"Ramification: The argument is optional in this case. "),(0,n.kt)("p",null,"At the place of a declaration other than the first, of a declarative_part or program unit declaration, in which case the pragma shall have an argument, which shall be a direct_name that denotes one or more of the following (and nothing else): a subprogram_declaration, a generic_subprogram_declaration, or a generic_instantiation, of the same declarative_part or program unit declaration. "),(0,n.kt)("p",null,"Ramification: If you want to denote a subprogram_body that is not a completion, or a package_declaration, for example, you have to put the pragma inside. "),(0,n.kt)("p",null,"Certain program unit pragmas are defined to be library unit pragmas. The name, if any, in a library unit pragma shall denote the declaration of a library unit. "),(0,n.kt)("p",null,"Ramification: This, together with the rules for program unit pragmas above, implies that if a library unit pragma applies to a subprogram_declaration (and similar things), it has to appear immediately after the compilation_unit, whereas if the pragma applies to a package_declaration, a subprogram_body that is not a completion (and similar things), it has to appear inside, as the first declarative_item. "),(0,n.kt)("h4",{id:"post-compilation-rules-1"},"Post-Compilation Rules"),(0,n.kt)("p",null,"Certain pragmas are defined to be configuration pragmas; they shall appear before the first compilation_unit of a compilation. ","[They are generally used to select a partition-wide or system-wide option.]"," The pragma applies to all compilation_units appearing in the compilation, unless there are none, in which case it applies to all future compilation_units compiled into the same environment. "),(0,n.kt)("h4",{id:"implementation-permissions-2"},"Implementation Permissions"),(0,n.kt)("p",null,"An implementation may place restrictions on configuration pragmas, so long as it allows them when the environment contains no library_items other than those of the predefined environment. "),(0,n.kt)("p",null,"This paragraph was deleted.Implementation Advice: "),(0,n.kt)("h3",{id:"1016--environment-level-visibility-rules"},"10.1.6  Environment-Level Visibility Rules"),(0,n.kt)("p",null,"[The normal visibility rules do not apply within a parent_unit_name or a context_clause, nor within a pragma that appears at the place of a compilation unit. The special visibility rules for those contexts are given here.]"," "),(0,n.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,n.kt)("p",null,"Within the parent_unit_name at the beginning of a library_item, and within a with_clause, the only declarations that are visible are those that are library_items of the environment, and the only declarations that are directly visible are those that are root library_items of the environment. Notwithstanding the rules of 4.1.3, an expanded name in a with_clause may consist of a prefix that denotes a generic package and a selector_name that denotes a child of that generic package. ","[(The child is necessarily a generic unit; see 10.1.1.)]"),(0,n.kt)("p",null,'Ramification: In "package P.Q.R is ... end P.Q.R;", this rule requires P to be a root library unit, and Q to be a library unit (because those are the things that are directly visible and visible). Note that visibility does not apply between the "end" and the ";".'),(0,n.kt)("p",null,"Physically nested declarations are not visible at these places."),(0,n.kt)("p",null,"Although Standard is visible at these places, it is impossible to name it, since it is not directly visible, and it has no parent."),(0,n.kt)("p",null,'Reason: The "notwithstanding" part allows "with A.B;" where A is a generic library package and B is one of its (generic) children. This is necessary because it is not normally legal to use an expanded name to reach inside a generic package. '),(0,n.kt)("p",null,"Within a use_clause or pragma that is within a context_clause, each library_item mentioned in a previous with_clause of the same context_clause is visible, and each root library_item so mentioned is directly visible. In addition, within such a use_clause, if a given declaration is visible or directly visible, each declaration that occurs immediately within the given declaration's visible part is also visible. No other declarations are visible or directly visible. "),(0,n.kt)("p",null,'Discussion: Note the word "same". For example, if a with_clause on a declaration mentions X, this does not make X visible in use_clauses and pragmas that are on the body. The reason for this rule is the one-pass context_clauses Language Design Principle.'),(0,n.kt)("p",null,"Note that the second part of the rule does not mention pragmas. "),(0,n.kt)("p",null,"Within the parent_unit_name of a subunit, library_items are visible as they are in the parent_unit_name of a library_item; in addition, the declaration corresponding to each body_stub in the environment is also visible. "),(0,n.kt)("p",null,"Ramification: For a subprogram without a separate subprogram_declaration, the body_stub itself is the declaration. "),(0,n.kt)("p",null,"Within a pragma that appears at the place of a compilation unit, the immediately preceding library_item and each of its ancestors is visible. The ancestor root library_item is directly visible."),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-4"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,"The special visibility rules that apply within a parent_unit_name or a context_clause, and within a pragma that appears at the place of a compilation_unit are clarified."),(0,n.kt)("p",null,"Note that a context_clause is not part of any declarative region."),(0,n.kt)("p",null,"We considered making the visibility rules within parent_unit_names and context_clauses follow from the context of compilation. However, this attempt failed for various reasons. For example, it would require use_clauses in context_clauses to be within the declarative region of Standard, which sounds suspiciously like a kludge. And we would still need a special rule to prevent seeing things (in our own context_clause) that were with-ed by our parent, etc. "),(0,n.kt)("h2",{id:"102--program-execution"},"10.2  Program Execution"),(0,n.kt)("p",null,"An Ada program consists of a set of partitions","[, which can execute in parallel with one another, possibly in a separate address space, and possibly on a separate computer.]"," "),(0,n.kt)("h4",{id:"post-compilation-rules-2"},"Post-Compilation Rules"),(0,n.kt)("p",null,"A partition is a program or part of a program that can be invoked from outside the Ada implementation. ","[For example, on many systems, a partition might be an executable file generated by the system linker.]"," The user can explicitly assign library units to a partition. The assignment is done in an implementation-defined manner. The compilation units included in a partition are those of the explicitly assigned library units, as well as other compilation units needed by those library units. The compilation units needed by a given compilation unit are determined as follows (unless specified otherwise via an implementation-defined pragma, or by some other implementation-defined means): "),(0,n.kt)("p",null,'Discussion: From a run-time point of view, an Ada 95 partition is identical to an Ada 83 program - implementations were always allowed to provide inter-program communication mechanisms. The additional semantics of partitions is that interfaces between them can be defined to obey normal language rules (as is done in Annex E, "Distributed Systems"), whereas interfaces between separate programs had no particular semantics. '),(0,n.kt)("p",null,"Implementation defined: The manner of explicitly assigning library units to a partition."),(0,n.kt)("p",null,"Implementation defined: The implementation-defined means, if any, of specifying which compilation units are needed by a given compilation unit."),(0,n.kt)("p",null,'Discussion: There are no pragmas that "specify otherwise" defined by the core language. However, an implementation is allowed to provide such pragmas, and in fact Annex E, "Distributed Systems" defines some pragmas whose semantics includes reducing the set of compilation units described here. '),(0,n.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[needed compilation unit]",", Def=","[a compilation unit that is necessary to produce an executable partition, because some entity declared or defined within the unit is used elsewhere in the partition]"),(0,n.kt)("p",null,"A compilation unit needs itself;"),(0,n.kt)("p",null,"If a compilation unit is needed, then so are any compilation units upon which it depends semantically;"),(0,n.kt)("p",null,"If a library_unit_declaration is needed, then so is any corresponding library_unit_body;"),(0,n.kt)("p",null,"If a compilation unit with stubs is needed, then so are any corresponding subunits."),(0,n.kt)("p",null,"Discussion: Note that in the environment, the stubs are replaced with the corresponding proper_bodies. "),(0,n.kt)("p",null,"Discussion: Note that a child unit is not included just because its parent is included - to include a child, mention it in a with_clause."),(0,n.kt)("p",null,"The user can optionally designate (in an implementation-defined manner) one subprogram as the main subprogram for the partition. A main subprogram, if specified, shall be a subprogram. "),(0,n.kt)("p",null,'Discussion: This may seem superfluous, since it follows from the definition. But we would like to have every error message that might be generated (before run time) by an implementation correspond to some explicitly stated "shall" rule.'),(0,n.kt)("p",null,'Of course, this does not mean that the "shall" rules correspond one-to-one with an implementation\'s error messages. For example, the rule that says overload resolution "shall" succeed in producing a single interpretation would correspond to many error messages in a good implementation - the implementation would want to explain to the user exactly why overload resolution failed. This is especially true for the syntax rules - they are considered part of overload resolution, but in most cases, one would expect an error message based on the particular syntax rule that was violated. '),(0,n.kt)("p",null,"Implementation defined: The manner of designating the main subprogram of a partition."),(0,n.kt)("p",null,"Ramification: An implementation cannot require the user to specify, say, all of the library units to be included. It has to support, for example, perhaps the most typical case, where the user specifies just one library unit, the main program. The implementation has to do the work of tracking down all the other ones. "),(0,n.kt)("p",null,"Each partition has an anonymous environment task","[, which is an implicit outermost task whose execution elaborates the library_items of the environment declarative_part, and then calls the main subprogram, if there is one. A partition's execution is that of its tasks.]"," "),(0,n.kt)("p",null,"Ramification: An environment task has no master; all nonenvironment tasks have masters."),(0,n.kt)("p",null,"An implementation is allowed to support multiple concurrent executions of the same partition. "),(0,n.kt)("p",null,"[The order of elaboration of library units is determined primarily by the elaboration dependences.]"," There is an elaboration dependence of a given library_item upon another if the given library_item or any of its subunits depends semantically on the other library_item. In addition, if a given library_item or any of its subunits has a pragma Elaborate or Elaborate_All that mentions another library unit, then there is an elaboration dependence of the given library_item upon the body of the other library unit, and, for Elaborate_All only, upon each library_item needed by the declaration of the other library unit. "),(0,n.kt)("p",null,'Discussion: See above for a definition of which library_items are "needed by" a given declaration.'),(0,n.kt)("p",null,"Note that elaboration dependences are among library_items, whereas the other two forms of dependence are among compilation units. Note that elaboration dependence includes semantic dependence. It's a little bit sad that pragma Elaborate_Body  can't be folded into this mechanism. It follows from the definition that the elaboration dependence relationship is transitive. Note that the wording of the rule does not need to take into account a semantic dependence of a library_item or one of its subunits upon a subunit of a different library unit, because that can never happen. "),(0,n.kt)("p",null,"The environment task for a partition has the following structure: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"task Environment_Task;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"task body Environment_Task is\n    ... (1) -- The environment declarative_part\n            -- (that is, the sequence of library_items) goes here.\nbegin\n    ... (2) -- Call the main subprogram, if there is one.\nend Environment_Task;\n\n")),(0,n.kt)("p",null,"Ramification: The name of the environment task is written in italics here to indicate that this task is anonymous. "),(0,n.kt)("p",null,'Discussion: The model is different for a "passive partition" (see E.1). Either there is no environment task, or its sequence_of_statements is an infinite loop rather than a call on a main subprogram. '),(0,n.kt)("p",null,"The environment declarative_part at (1) is a sequence of declarative_items consisting of copies of the library_items included in the partition","[. The order of elaboration of library_items is the order in which they appear in the environment declarative_part]",": "),(0,n.kt)("p",null,"The order of all included library_items is such that there are no forward elaboration dependences. "),(0,n.kt)("p",null,"Ramification: This rule is written so that if a library_item depends on itself, we don't require it to be elaborated before itself. See AI83-00113/12. This can happen only in pathological circumstances. For example, if a library subprogram_body has no corresponding subprogram_declaration, and one of the subunits of the subprogram_body mentions the subprogram_body in a with_clause, the subprogram_body will depend on itself. For another example, if a library_unit_body applies a pragma Elaborate_All to its own declaration, then the library_unit_body will depend on itself. "),(0,n.kt)("p",null,"Any included library_unit_declaration to which a pragma Elaborate_Body applies is immediately followed by its library_unit_body, if included. "),(0,n.kt)("p",null,'Discussion: This implies that the body of such a library unit shall not "with" any of its own children, or anything else that depends semantically upon the declaration of the library unit. '),(0,n.kt)("p",null,"All library_items declared pure occur before any that are not declared pure."),(0,n.kt)("p",null,"All preelaborated library_items occur before any that are not preelaborated. "),(0,n.kt)("p",null,'Discussion: Normally, if two partitions contain the same compilation unit, they each contain a separate copy of that compilation unit. See Annex E, "Distributed Systems" for cases where two partitions share the same copy of something.'),(0,n.kt)("p",null,"There is no requirement that the main subprogram be elaborated last. In fact, it is possible to write a partition in which the main subprogram cannot be elaborated last. "),(0,n.kt)("p",null,'Ramification: This declarative_part has the properties required of all environments (see 10.1.4). However, the environment declarative_part of a partition will typically contain fewer compilation units than the environment declarative_part used at compile time - only the "needed" ones are included in the partition. '),(0,n.kt)("p",null,"There shall be a total order of the library_items that obeys the above rules. The order is otherwise implementation defined. "),(0,n.kt)("p",null,"Discussion: The only way to violate this rule is to have Elaborate, Elaborate_All, or Elaborate_Body pragmas that cause circular ordering requirements, thus preventing an order that has no forward elaboration dependences. "),(0,n.kt)("p",null,"Implementation defined: The order of elaboration of library_items."),(0,n.kt)("p",null,"To be honest: Notwithstanding what the RM95 says elsewhere, each rule that requires a declaration to have a corresponding completion is considered to be a Post-Compilation Rule when the declaration is that of a library unit. "),(0,n.kt)("p",null,'Discussion: Such rules may be checked at "link time", for example. Rules requiring the completion to have certain properties, on the other hand, are checked at compile time of the completion. '),(0,n.kt)("p",null,"The full expanded names of the library units and subunits included in a given partition shall be distinct."),(0,n.kt)("p",null,'Reason: This is a Post-Compilation Rule because making it a Legality Rule would violate the Language Design Principle labeled "legality determinable via semantic dependences". '),(0,n.kt)("p",null,"The sequence_of_statements of the environment task (see (2) above) consists of either: "),(0,n.kt)("p",null,"A call to the main subprogram, if the partition has one. If the main subprogram has parameters, they are passed; where the actuals come from is implementation defined. What happens to the result of a main function is also implementation defined. "),(0,n.kt)("p",null,"Implementation defined: Parameter passing and function return for the main subprogram."),(0,n.kt)("p",null,"or: "),(0,n.kt)("p",null,"A null_statement, if there is no main subprogram. "),(0,n.kt)("p",null,"Discussion: For a passive partition, either there is no environment task, or its sequence_of_statements is an infinite loop. See E.1. "),(0,n.kt)("p",null,"The mechanisms for building and running partitions are implementation defined. ",'[These might be combined into one operation, as, for example, in dynamic linking, or "load-and-go" systems.]'," "),(0,n.kt)("p",null,"Implementation defined: The mechanisms for building and running partitions."),(0,n.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,n.kt)("p",null,"The execution of a program consists of the execution of a set of partitions. Further details are implementation defined. The execution of a partition starts with the execution of its environment task, ends when the environment task terminates, and includes the executions of all tasks of the partition. ","[The execution of the (implicit) task_body of the environment task acts as a master for all other tasks created as part of the execution of the partition. When the environment task completes (normally or abnormally), it waits for the termination of all such tasks, and then finalizes any remaining objects of the partition.]"," "),(0,n.kt)("p",null,'Ramification: The "further details" mentioned above include, for example, program termination - it is implementation defined. There is no need to define it here; it\'s entirely up to the implementation whether it wants to consider the program as a whole to exist beyond the existence of individual partitions. '),(0,n.kt)("p",null,"Implementation defined: The details of program execution, including program termination."),(0,n.kt)("p",null,"To be honest: The execution of the partition terminates (normally or abnormally) when the environment task terminates (normally or abnormally, respectively). "),(0,n.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,n.kt)("p",null,"Once the environment task has awaited the termination of all other tasks of the partition, any further attempt to create a task (during finalization) is a bounded error, and may result in the raising of Program_Error either upon creation or activation of the task. If such a task is activated, it is not specified whether the task is awaited prior to termination of the environment task. "),(0,n.kt)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,n.kt)("p",null,"The implementation shall ensure that all compilation units included in a partition are consistent with one another, and are legal according to the rules of the language. "),(0,n.kt)("p",null,"Discussion: The consistency requirement implies that a partition cannot contain two versions of the same compilation unit. That is, a partition cannot contain two different library units with the same full expanded name, nor two different bodies for the same program unit. For example, suppose we compile the following: "),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A is -- Version 1.\n    ...\nend A;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with A;\npackage B is\nend B;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"package A is -- Version 2.\n    ...\nend A;\n\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-ada"},"with A;\npackage C is\nend C;\n\n")),(0,n.kt)("p",null,"It would be wrong for a partition containing B and C to contain both versions of A. Typically, the implementation would require the use of Version 2 of A, which might require the recompilation of B. Alternatively, the implementation might automatically recompile B when the partition is built. A third alternative would be an incremental compiler that, when Version 2 of A is compiled, automatically patches the object code for B to reflect the changes to A (if there are any relevant changes - there might not be any)."),(0,n.kt)("p",null,"An implementation that supported fancy version management might allow the use of Version 1 in some circumstances. In no case can the implementation allow the use of both versions in the same partition (unless, of course, it can prove that the two versions are semantically identical)."),(0,n.kt)("p",null,'The core language says nothing about inter-partition consistency; see also Annex E, "Distributed Systems". '),(0,n.kt)("h4",{id:"implementation-permissions-3"},"Implementation Permissions"),(0,n.kt)("p",null,"The kind of partition described in this clause is known as an active partition. An implementation is allowed to support other kinds of partitions, with implementation-defined semantics. "),(0,n.kt)("p",null,"Implementation defined: The semantics of any nonactive partitions supported by the implementation."),(0,n.kt)("p",null,'Discussion: Annex E, "Distributed Systems" defines the concept of passive partitions; they may be thought of as a partition without an environment task, or as one with a particularly simple form of environment task, having an infinite loop rather than a call on a main subprogram as its sequence_of_statements. '),(0,n.kt)("p",null,"An implementation may restrict the kinds of subprograms it supports as main subprograms. However, an implementation is required to support all main subprograms that are public parameterless library procedures. "),(0,n.kt)("p",null,"Ramification: The implementation is required to support main subprograms that are procedures declared by generic_instantiations, as well as those that are children of library units other than Standard. Generic units are, of course, not allowed to be main subprograms, since they are not subprograms."),(0,n.kt)("p",null,"Note that renamings are irrelevant to this rule. This rules says which subprograms (not views) have to be supported. The implementation can choose any way it wants for the user to indicate which subprogram should be the main subprogram. An implementation might allow any name of any view, including those declared by renamings. Another implementation might require it to be the original name. Another implementation still might use the name of the source file or some such thing. "),(0,n.kt)("p",null,"If the environment task completes abnormally, the implementation may abort any dependent tasks. "),(0,n.kt)("p",null,"Reason: If the implementation does not take advantage of this permission, the normal action takes place - the environment task awaits those tasks."),(0,n.kt)("p",null,"The possibility of aborting them is not shown in the Environment_Task code above, because there is nowhere to put an exception_handler that can handle exceptions raised in both the environment declarative_part and the main subprogram, such that the dependent tasks can be aborted. If we put an exception_handler in the body of the environment task, then it won't handle exceptions that occur during elaboration of the environment declarative_part. If we were to move those things into a nested block_statement, with the exception_handler outside that, then the block_statement would await the library tasks we are trying to abort."),(0,n.kt)("p",null,"Furthermore, this is merely a permission, and is not fundamental to the model, so it is probably better to state it separately anyway."),(0,n.kt)("p",null,"Note that implementations (and tools like debuggers) can have modes that provide other behaviors in addition. "),(0,n.kt)("p",null,'NOTE 1   An implementation may provide inter-partition communication mechanism(s) via special packages and pragmas. Standard pragmas for distribution and methods for specifying inter-partition communication are defined in Annex E, "Distributed Systems". If no such mechanisms are provided, then each partition is isolated from all others, and behaves as a program in and of itself. '),(0,n.kt)("p",null,"Ramification: Not providing such mechanisms is equivalent to disallowing multi-partition programs."),(0,n.kt)("p",null,'An implementation may provide mechanisms to facilitate checking the consistency of library units elaborated in different partitions; Annex E, "Distributed Systems" does so. '),(0,n.kt)("p",null,"NOTE 2   Partitions are not required to run in separate address spaces. For example, an implementation might support dynamic linking via the partition concept."),(0,n.kt)("p",null,"NOTE 3   An order of elaboration of library_items that is consistent with the partial ordering defined above does not always ensure that each library_unit_body is elaborated before any other compilation unit whose elaboration necessitates that the library_unit_body be already elaborated. (In particular, there is no requirement that the body of a library unit be elaborated as soon as possible after the library_unit_declaration is elaborated, unless the pragmas in subclause 10.2.1 are used.)"),(0,n.kt)("p",null,'NOTE 4   A partition (active or otherwise) need not have a main subprogram. In such a case, all the work done by the partition would be done by elaboration of various library_items, and by tasks created by that elaboration. Passive partitions, which cannot have main subprograms, are defined in Annex E, "Distributed Systems". '),(0,n.kt)("p",null,"Ramification: The environment task is the outermost semantic level defined by the language."),(0,n.kt)("p",null,"Standard has no private part. This prevents strange implementation-dependences involving private children of Standard having visibility upon Standard's private part. It doesn't matter where the body of Standard appears in the environment, since it doesn't do anything. See Annex A, \"Predefined Language Environment\"."),(0,n.kt)("p",null,'Note that elaboration dependence is carefully defined in such a way that if (say) the body of something doesn\'t exist yet, then there is no elaboration dependence upon the nonexistent body. (This follows from the fact that "needed by" is defined that way, and the elaboration dependences caused by a pragma Elaborate or Elaborate_All are defined in terms of "needed by".) This property allows us to use the environment concept both at compile time and at partition-construction time/run time. '),(0,n.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The concept of partitions is new to Ada 95."),(0,n.kt)("p",null,"A main subprogram is now optional. The language-defined restrictions on main subprograms are relaxed. "),(0,n.kt)("h4",{id:"wording-changes-from-ada-83-5"},"Wording Changes from Ada 83"),(0,n.kt)("p",null,'Ada 95 uses the term "main subprogram" instead of Ada 83\'s "main program" (which was inherited from Pascal). This is done to avoid confusion - a main subprogram is a subprogram, not a program. The program as a whole is an entirely different thing. '),(0,n.kt)("h3",{id:"1021--elaboration-control"},"10.2.1  Elaboration Control"),(0,n.kt)("p",null,"[ This subclause defines pragmas that help control the elaboration order of library_items.]"," "),(0,n.kt)("h4",{id:"language-design-principles-2"},"Language Design Principles"),(0,n.kt)("p",null,'The rules governing preelaboration are designed to allow it to be done largely by bulk initialization of statically allocated storage from information in a "load module" created by a linker. Some implementations may require run-time code to be executed in some cases, but we consider these cases rare enough that we need not further complicate the rules.'),(0,n.kt)("p",null,"It is important that programs be able to declare data structures that are link-time initialized with aggregates, string_literals, and concatenations thereof. It is important to be able to write link-time evaluated expressions involving the First, Last, and Length attributes of such data structures (including variables), because they might be initialized with positional aggregates or string_literals, and we don't want the user to have to count the elements. There is no corresponding need for accessing discriminants, since they can be initialized with a static constant, and then the constant can be referred to elsewhere. It is important to allow link-time initialized data structures involving discriminant-dependent components. It is important to be able to write link-time evaluated expressions involving pointers (both access values and addresses) to the above-mentioned data structures."),(0,n.kt)("p",null,"The rules also ensure that no Elaboration_Check need be performed for calls on library-level subprograms declared within a preelaborated package. This is true also of the Elaboration_Check on task activation for library level task types declared in a preelaborated package. However, it is not true of the Elaboration_Check on instantiations."),(0,n.kt)("p",null,"A static expression should never prevent a library unit from being preelaborable."),(0,n.kt)("h4",{id:"syntax-3"},"Syntax"),(0,n.kt)("p",null,"The form of a pragma Preelaborate is as follows: "),(0,n.kt)("p",null,"  pragma Preelaborate","[(library_unit_name)]",";"),(0,n.kt)("p",null,"A pragma Preelaborate is a library unit pragma. "),(0,n.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,n.kt)("p",null,"An elaborable construct is preelaborable unless its elaboration performs any of the following actions: "),(0,n.kt)("p",null,"Ramification: A preelaborable construct can be elaborated without using any information that is available only at run time. Note that we don't try to prevent exceptions in preelaborable constructs; if the implementation wishes to generate code to raise an exception, that's OK."),(0,n.kt)("p",null,"Because there is no flow of control and there are no calls (other than to predefined subprograms), these run-time properties can actually be detected at compile time. This is necessary in order to require compile-time enforcement of the rules. "),(0,n.kt)("p",null,"The execution of a statement other than a null_statement. "),(0,n.kt)("p",null,"Ramification: A preelaborable construct can contain labels and null_statements. "),(0,n.kt)("p",null,"A call to a subprogram other than a static function. "),(0,n.kt)("p",null,"The evaluation of a primary that is a name of an object, unless the name is a static expression, or statically denotes a discriminant of an enclosing type. "),(0,n.kt)("p",null,"Ramification: One can evaluate such a name, but not as a primary. For example, one can evaluate an attribute of the object. One can evaluate an attribute_reference, so long as it does not denote an object, and its prefix does not disobey any of these rules. For example, Obj'Access, Obj'Unchecked_Access, and Obj'Address are generally legal in preelaborated library units. "),(0,n.kt)("p",null,"The creation of a default-initialized object ","[(including a component)]"," of a descendant of a private type, private extension, controlled type, task type, or protected type with entry_declarations; similarly the evaluation of an extension_aggregate with an ancestor subtype_mark denoting a subtype of such a type."),(0,n.kt)("p",null,"Ramification: One can declare these kinds of types, but one cannot create objects of those types."),(0,n.kt)("p",null,"It is also nonpreelaborable to create an object if that will cause the evaluation of a default expression that will call a user-defined function. This follows from the rule above forbidding nonnull statements. "),(0,n.kt)("p",null,"Reason: Controlled objects are disallowed because most implementations will have to take some run-time action during initialization, even if the Initialize procedure is null. "),(0,n.kt)("p",null,"A generic body is preelaborable only if elaboration of a corresponding instance body would not perform any such actions, presuming that the actual for each formal private type (or extension) is a private type (or extension), and the actual for each formal subprogram is a user-defined subprogram. "),(0,n.kt)("p",null,"Reason: Without this rule about generics, we would have to forbid instantiations in preelaborated library units, which would significantly reduce their usefulness. "),(0,n.kt)("p",null,"If a pragma Preelaborate (or pragma Pure - see below) applies to a library unit, then it is preelaborated. ","[ If a library unit is preelaborated, then its declaration, if any, and body, if any, are elaborated prior to all nonpreelaborated library_items of the partition.]"," All compilation units of a preelaborated library unit shall be preelaborable. In addition to the places where Legality Rules normally apply (see 12.3), this rule applies also in the private part of an instance of a generic unit. In addition, all compilation units of a preelaborated library unit shall depend semantically only on compilation units of other preelaborated library units. "),(0,n.kt)("p",null,"Ramification: In a generic body, we assume the worst about formal private types and extensions."),(0,n.kt)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,n.kt)("p",null,"In an implementation, a type declared in a preelaborated package should have the same representation in every elaboration of a given version of the package, whether the elaborations occur in distinct executions of the same program, or in executions of distinct programs or partitions that include the given version. "),(0,n.kt)("p",null,"The form of a pragma Pure is as follows: "),(0,n.kt)("p",null,"  pragma Pure","[(library_unit_name)]",";"),(0,n.kt)("p",null,"A pragma Pure is a library unit pragma. "),(0,n.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,n.kt)("p",null,"A pure library_item is a preelaborable library_item that does not contain the declaration of any variable or named access within a subprogram, generic subprogram, task unit, or protected unit."),(0,n.kt)("p",null,"A pragma Pure is used to declare that a library unit is pure. If a pragma Pure applies to a library unit, then its compilation units shall be pure, and they shall depend semantically only on compilation units of other library units that are declared pure. "),(0,n.kt)("p",null,"To be honest: A declared-pure library unit is one to which a pragma Pure applies. Its declaration and body are also said to be declared pure. "),(0,n.kt)("p",null,"Discussion: A declared-pure package is useful for defining types to be shared between partitions with no common address space. "),(0,n.kt)("p",null,"Reason: Note that generic packages are not mentioned in the list of things that can contain variable declarations. Note that the Ada 95 rules for deferred constants make them allowable in library units that are declared pure; that isn't true of Ada 83's deferred constants. "),(0,n.kt)("p",null,"Ramification: Anonymous access types (that is, access discriminants and access parameters) are allowed."),(0,n.kt)("p",null,'Reason: The primary reason for disallowing named access types is that an allocator has a side effect; the pool constitutes variable data. We considered somehow allowing allocator-less access types. However, these (including access-to-subprogram types) would cause trouble for Annex E, "Distributed Systems", because such types would  allow access values in a shared passive partition to designate objects in an active partition, thus allowing inter-address space references.Furthermore, a named access-to-object type without a pool would be a new concept, adding complexity from the user\'s point of view. Finally, the prevention of allocators would have to be a runtime check, in order to avoid violations of the generic contract model. '),(0,n.kt)("h4",{id:"implementation-permissions-4"},"Implementation Permissions"),(0,n.kt)("p",null,"If a library unit is declared pure, then the implementation is permitted to omit a call on a library-level subprogram of the library unit if the results are not needed after the call. Similarly, it may omit such a call and simply reuse the results produced by an earlier call on the same subprogram, provided that none of the parameters are of a limited type, and the addresses and values of all by-reference actual parameters, and the values of all by-copy-in actual parameters, are the same as they were at the earlier call. ","[This permission applies even if the subprogram produces other side effects when called.]"," "),(0,n.kt)("p",null,'Discussion: A declared-pure library_item has no variable state. Hence, a call on one of its (nonnested) subprograms cannot "normally" have side effects. The only possible side effects from such a call would be through machine code insertions,unchecked conversion to an access type declared within the subprogram, and similar features. The compiler may omit a call to such a subprogram even if such side effects exist, so the writer of such a subprogram has to keep this in mind. '),(0,n.kt)("h4",{id:"syntax-4"},"Syntax"),(0,n.kt)("p",null,"The form of a pragma Elaborate, Elaborate_All, or Elaborate_Body is as follows:: "),(0,n.kt)("p",null,"  pragma Elaborate(library_unit_name{, library_unit_name});"),(0,n.kt)("p",null,"  pragma Elaborate_All(library_unit_name{, library_unit_name});"),(0,n.kt)("p",null,"  pragma Elaborate_Body","[(library_unit_name);]"),(0,n.kt)("p",null,"A pragma Elaborate or Elaborate_All is only allowed within a context_clause. "),(0,n.kt)("p",null,'Ramification: "Within a context_clause" allows it to be the last item in the context_clause. It can\'t be first, because the name has to denote something mentioned earlier. '),(0,n.kt)("p",null,"A pragma Elaborate_Body is a library unit pragma. "),(0,n.kt)("p",null,"Discussion: Hence, a pragma Elaborate or Elaborate_All is not elaborated, not that it makes any practical difference."),(0,n.kt)("p",null,"Note that a pragma Elaborate or Elaborate_All is neither a program unit pragma, nor a library unit pragma."),(0,n.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,n.kt)("p",null,"If a pragma Elaborate_Body applies to a declaration, then the declaration requires a completion ","[(a body)]","."),(0,n.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,n.kt)("p",null,"[A pragma Elaborate specifies that the body of the named library unit is elaborated before the current library_item. A pragma Elaborate_All specifies that each library_item that is needed by the named library unit declaration is elaborated before the current library_item. A pragma Elaborate_Body specifies that the body of the library unit is elaborated immediately after its declaration.]"),(0,n.kt)("p",null,"Proof: The official statement of the semantics of these pragmas is given in 10.2. "),(0,n.kt)("p",null,"Implementation Note: The presence of a pragma Elaborate_Body simplifies the removal of unnecessary Elaboration_Checks. For a subprogram declared immediately within a library unit to which a pragma Elaborate_Body applies, the only calls that can fail the Elaboration_Check are those that occur in the library unit itself, between the declaration and body of the called subprogram; if there are no such calls (which can easily be detected at compile time if there are no stubs), then no Elaboration_Checks are needed for that subprogram. The same is true for Elaboration_Checks on task activations and instantiations, and for library subprograms and generic units. "),(0,n.kt)("p",null,"Ramification: The fact that the unit of elaboration is the library_item means that if a subprogram_body is not a completion, it is impossible for any library_item to be elaborated between the declaration and the body of such a subprogram. Therefore, it is impossible for a call to such a subprogram to fail its Elaboration_Check. "),(0,n.kt)("p",null,"Discussion: The visibility rules imply that each library_unit_name of a pragma Elaborate or Elaborate_All has to denote a library unit mentioned by a previous with_clause of the same context_clause. "),(0,n.kt)("p",null,"NOTE 1   A preelaborated library unit is allowed to have nonpreelaborable children. "),(0,n.kt)("p",null,"Ramification: But not nonpreelaborated subunits. "),(0,n.kt)("p",null,"NOTE 2   A library unit that is declared pure is allowed to have impure children. "),(0,n.kt)("p",null,"Ramification: But not impure subunits. "),(0,n.kt)("p",null,"Ramification: Pragma Elaborate is mainly for closely related library units, such as when two package bodies 'with' each other's declarations. In such cases, Elaborate_All sometimes won't work. "),(0,n.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,n.kt)("p",null,"The concepts of preelaborability and purity are new to Ada 95. The Elaborate_All, Elaborate_Body, Preelaborate, and Pure pragmas are new to Ada 95."),(0,n.kt)("p",null,"Pragmas Elaborate are allowed to be mixed in with the other things in the context_clause - in Ada 83, they were required to appear last."))}d.isMDXComponent=!0}}]);