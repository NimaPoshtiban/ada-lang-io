"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8171],{7605:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>g,contentTitle:()=>u,default:()=>w,frontMatter:()=>c,metadata:()=>k,toc:()=>f});var n=a(1716),i=a(7556),o=a(3183),l=Object.defineProperty,r=Object.defineProperties,s=Object.getOwnPropertyDescriptors,m=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,A=(e,t,a)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,h=(e,t)=>{for(var a in t||(t={}))d.call(t,a)&&A(e,a,t[a]);if(m)for(var a of m(t))p.call(t,a)&&A(e,a,t[a]);return e};const c={sidebar_position:14},u="2.8 Pragmas",k={unversionedId:"arm/AA-2/AA-2.8",id:"arm/AA-2/AA-2.8",title:"2.8 Pragmas",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-2/AA-2.8.mdx",sourceDirName:"arm/AA-2",slug:"/arm/AA-2/AA-2.8",permalink:"/docs/arm/AA-2/AA-2.8",draft:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"referenceManualSidebar",previous:{title:"2.7 Comments",permalink:"/docs/arm/AA-2/AA-2.7"},next:{title:"2.9 Reserved Words",permalink:"/docs/arm/AA-2/AA-2.9"}},g={},f=[{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4}],y={toc:f};function w(e){var t,a=e,{components:l}=a,A=((e,t)=>{var a={};for(var n in e)d.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&m)for(var n of m(e))t.indexOf(n)<0&&p.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=h(h({},y),A),r(t,s({components:l,mdxType:"MDXLayout"}))),(0,n.kt)("h1",h({},{id:"28-pragmas"}),"2.8 Pragmas"),(0,n.kt)("admonition",h({},{type:"warning"}),(0,n.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,n.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,n.kt)("p",null,"A pragma is a compiler directive. There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation may support additional (implementation-defined) pragmas. Version=[5],Kind=(AddedNormal),Group=[C],Term=[pragma], Def=[a compiler directive to provide control over and above that provided by the other syntactic constructs of the language], Note1=[There are language-defined pragmas that give instructions for optimization, listing control, etc. An implementation can support additional (implementation-defined) pragmas.] "),(0,n.kt)("h4",h({},{id:"language-design-principles"}),"Language Design Principles"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0100-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0163-1"),"}"," In general, if all ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are treated as unrecognized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s, the program should remain both syntactically and semantically legal. There are a few exceptions to this general principle (for example, ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Import can eliminate the need for a completion), but the principle remains, and is strictly true at the syntactic level. Certainly any implementation-defined ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s should obey this principle both syntactically and semantically, so that if the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are not recognized by some other implementation, the program will remain legal. ")),(0,n.kt)("h4",h({},{id:"syntax"}),"Syntax"),(0,n.kt)("p",null,(0,n.kt)("code",null,"pragma"),(0,n.kt)("a",{id:"S0019"}),(0,n.kt)("code",null," ::= "),"   ",(0,n.kt)("strong",null,"pragma")," ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," [(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0020"},"pragma_argument_association"))," ","{",", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0020"},"pragma_argument_association")),"}",")];"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0290-1"),"}"," ",(0,n.kt)("code",null,"pragma_argument_association"),(0,n.kt)("a",{id:"S0020"}),(0,n.kt)("code",null," ::= "),"     [",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"   | [",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," =",">","] ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),"   | ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark"))," =",">","  ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"   | ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark"))," =",">","  ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0290-1"),"}"," In a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),", any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0020"},"pragma_argument_association")),"s without a ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark"))," shall precede any associations with a ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," or ",(0,n.kt)("em",null,"pragma_argument_"),(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark")),"."),(0,n.kt)("p",null,(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"Pragma")),"s are only allowed at the following places in a program: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0236-1"),"}"," After a semicolon delimiter, but not within a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-6/AA-6.1#S0206"},"formal_part")),", ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.7#S0059"},"discriminant_part")),", or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0156"},"declare_expression")),"."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0100-1"),"}"," ","{",(0,n.kt)("em",null,"AI05-0163-1"),"}",' At any place where the syntax rules allow a construct defined by a syntactic category whose name ends with "',(0,n.kt)("code",null,"declaration"),'", "',(0,n.kt)("code",null,"item"),'", "',(0,n.kt)("code",null,"statement"),'", "',(0,n.kt)("code",null,"clause"),'", or "',(0,n.kt)("code",null,"alternative"),'", or one of the syntactic categories ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.8#S0072"},"variant"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),"; but not in place of such a construct if the construct is required, or is part of a list that is required to have at least one such construct."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0163-1"),"}"," In place of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0167"},"statement"))," in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),"."),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0100-1"),"}"," At any place where a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0286"},"compilation_unit"))," is allowed. "),(0,n.kt)("p",null,"Additional syntax rules and placement restrictions exist for specific pragmas. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"The above rule is written in text, rather than in BNF; the syntactic category ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is not used in any BNF syntax rule. ")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is allowed where a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-12/AA-12.1#S0314"},"generic_formal_parameter_declaration"))," is allowed. ")),(0,n.kt)("p",null,"The ",(0,n.kt)("em",null,"name")," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is the identifier following the reserved word ",(0,n.kt)("strong",null,"pragma"),". The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0020"},"pragma_argument_association"))," is a ",(0,n.kt)("em",null,"pragma argument"),"."),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"{",(0,n.kt)("em",null,"AI95-00284-02"),"}"," For compatibility with Ada 83, the name of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),' may also be "',(0,n.kt)("strong",null,"interface"),'", which is not an identifier (because it is a reserved word). See J.12. ')),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0272-1"),"}"," An ",(0,n.kt)("em",null,"identifier specific to a pragma")," is an identifier or reserved word that is used in a pragma argument with special meaning for that pragma. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),'Whenever the syntax rules for a given pragma allow "',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),'" as an argument of the ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),", that ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," is an identifier specific to that pragma.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0272-1"),"}",' In a few cases, a reserved word is allowed as "an identifier specific to a pragma". Even in these cases, the syntax still is written as ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," (the reserved word(s) are not shown). For example, the restriction No_Use_Of_Attribute (see 13.12.1) allows the reserved words which can be attribute designators, but the syntax for a restriction does not include these reserved words. ")),(0,n.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,n.kt)("p",null,"If an implementation does not recognize the name of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),", then it has no effect on the semantics of the program. Inside such a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),", the only rules that apply are the Syntax Rules. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"This rule takes precedence over any other rules that imply otherwise. ")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Note well: this rule applies only to ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s whose name is not recognized. If anything else is wrong with a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," (at compile time), the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is illegal. This is true whether the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is language defined or implementation defined.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"For example, an expression in an unrecognized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),' does not cause freezing, even though the rules in 13.14, "Freezing Rules" say it does; the above rule overrules those other rules. On the other hand, an expression in a recognized ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," causes freezing, even if this makes something illegal.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"For another example, an expression that would be ambiguous is not illegal if it is inside an unrecognized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),".")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note, however, that implementations have to recognize ",(0,n.kt)("strong",null,"pragma")," Inline(Foo) and freeze things accordingly, even if they choose to never do inlining.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Obviously, the contradiction needs to be resolved one way or the other. The reasons for resolving it this way are: The implementation is simple - the compiler can just ignore the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," altogether. The interpretation of constructs appearing inside implementation-defined ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),'s is implementation defined. For example: "',(0,n.kt)("strong",null,"pragma")," Mumble(X);\". If the current implementation has never heard of Mumble, then it doesn't know whether X is a name, an expression, or an identifier specific to the pragma Mumble. ")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"The syntax of individual pragmas overrides the general syntax for ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),". ")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"Thus, an identifier specific to a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is not a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),", syntactically; if it were, the visibility rules would be invoked, which is not what we want.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}",' This also implies that named associations do not allow one to give the arguments in an arbitrary order - the order given in the syntax rule for each individual pragma must be obeyed. However, it is generally possible to leave out earlier arguments when later ones are given; for example, this is allowed by the syntax rule for pragma Import (see J.15.5, "Interfacing Pragmas"). As for subprogram calls, positional notation precedes named notation.')),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note that Ada 83 had no pragmas for which the order of named associations mattered, since there was never more than one argument that allowed named associations. ")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"To be honest: "),"The interpretation of the arguments of implementation-defined pragmas is implementation defined. However, the syntax rules have to be obeyed. ")),(0,n.kt)("h4",h({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,n.kt)("p",null,"Any ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," that appears at the place of an executable construct is executed. Unless otherwise specified for a particular pragma, this execution consists of the evaluation of each evaluable pragma argument in an arbitrary order. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"For a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," that appears at the place of an elaborable construct, execution is elaboration.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"An identifier specific to a pragma is neither a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," nor an ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," - such identifiers are not evaluated (unless an implementation defines them to be evaluated in the case of an implementation-defined ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),").")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'The "unless otherwise specified" part allows us (and implementations) to make exceptions, so a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," can contain an expression that is not evaluated. Note that ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s in ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-3/AA-3.2#S0025"},"type_definition")),"s may contain expressions that depend on discriminants.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"When we wish to define a pragma with some run-time effect, we usually make sure that it appears in an executable context; otherwise, special rules are needed to define the run-time effect and when it happens. ")),(0,n.kt)("h4",h({},{id:"implementation-requirements"}),"Implementation Requirements"),(0,n.kt)("p",null,"The implementation shall give a warning message for an unrecognized pragma name. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"An implementation is also allowed to have modes in which a warning message is suppressed, or in which the presence of an unrecognized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is a compile-time error. ")),(0,n.kt)("h4",h({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,n.kt)("p",null,"An implementation may provide implementation-defined pragmas; the name of an implementation-defined pragma shall differ from those of the language-defined pragmas. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation defined: "),"Implementation-defined pragmas.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"The semantics of implementation-defined pragmas, and any associated rules (such as restrictions on their placement or arguments), are, of course, implementation defined. Implementation-defined pragmas may have run-time effects. ")),(0,n.kt)("p",null,"An implementation may ignore an unrecognized pragma even if it violates some of the Syntax Rules, if detecting the syntax error is too complex. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Reason: "),"Many compilers use extra post-parsing checks to enforce the syntax rules, since the Ada syntax rules are not LR(k) (for any k). (The grammar is ambiguous, in fact.) This paragraph allows them to ignore an unrecognized pragma, without having to perform such post-parsing checks. ")),(0,n.kt)("h4",h({},{id:"implementation-advice"}),"Implementation Advice"),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0163-1"),"}"," Normally, implementation-defined pragmas should have no semantic effect for error-free programs; that is, if the implementation-defined pragmas in a working program are replaced with unrecognized pragmas, the program should still be legal, and should still have the same semantics. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation Advice: "),"Implementation-defined pragmas should have no semantic effect for error-free programs.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'Note that "semantics" is not the same as "effect;" as explained in , the semantics defines a set of possible effects.')),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Note that adding a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," to a program might cause an error (either at compile time or at run time). On the other hand, if the language-specified semantics for a feature are in part implementation defined, it makes sense to support pragmas that control the feature, and that have real semantics; thus, this paragraph is merely a recommendation. ")),(0,n.kt)("p",null,"Normally, an implementation should not define pragmas that can make an illegal program legal, except as follows: "),(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," used to complete a declaration;"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," There are no language-defined pragmas which can be completions; ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Import was defined this way in Ada 95 and Ada 2005, but in Ada 2012 ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Import just sets aspect Import which disallows having any completion. ")),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," used to configure the environment by adding, removing, or replacing ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0287"},"library_item")),"s. "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation Advice: "),"Implementation-defined pragmas should not make an illegal program legal, unless they complete a declaration or configure the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0287"},"library_item")),"s in an environment.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),"For example, it is OK to support Interface, System_Name, Storage_Unit, and Memory_Size ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s for upward compatibility reasons, even though all of these ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s can make an illegal program legal. (The latter three can affect legality in a rather subtle way: They affect the value of named numbers in System, and can therefore affect the legality in cases where static expressions are required.)")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"On the other hand, adding implementation-defined pragmas to a legal program can make it illegal. For example, a common kind of implementation-defined pragma is one that promises some property that allows more efficient code to be generated. If the promise is a lie, it is best if the user gets an error message. ")),(0,n.kt)("h4",h({},{id:"incompatibilities-with-ada-83"}),"Incompatibilities With Ada 83"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'In Ada 83, "bad" ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are ignored. In Ada 95, they are illegal, except in the case where the name of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," itself is not recognized by the implementation. ")),(0,n.kt)("h4",h({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Implementation-defined ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s may affect the legality of a program. ")),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-83"}),"Wording Changes from Ada 83"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"Implementation-defined ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),'s may affect the run-time semantics of the program. This was always true in Ada 83 (since it was not explicitly forbidden by RM83), but it was not clear, because there was no definition of "executing" or "elaborating" a ',(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),". ")),(0,n.kt)("h4",h({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0163-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Allow ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s in place of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0167"},"statement")),", even if there are no other ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0167"},"statement")),"s in a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-5/AA-5.1#S0166"},"sequence_of_statements")),".")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0272-1"),"}"," Identifiers specific to a pragma can be reserved words.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0290-1"),"}"," Pragma arguments can be identified with ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-13/AA-13.1#S0347"},"aspect_mark")),"s; this allows ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"'Class in this context. As usual, this is only allowed if specifically allowed by a particular pragma. ")),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0100-1"),"}"," ",(0,n.kt)("strong",null,"Correction:")," Clarified where ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are (and are not) allowed. ")),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI12-0236-1"),"}"," Added wording to ensure that ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are not allowed in ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-4/AA-4.5#S0156"},"declare_expression")),"s. We don't allow this as the definition of most pragmas assume that they're given between entities. We also don't want to answer questions about conformance of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s, especially unrecognized ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s and ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s whose state can change between the specification and body. ")),(0,n.kt)("h4",h({},{id:"syntax-1"}),"Syntax"),(0,n.kt)("p",null,"The forms of List, Page, and Optimize ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s are as follows:"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," List(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),");"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Page;"),(0,n.kt)("p",null,"  ",(0,n.kt)("strong",null,"pragma")," Optimize(",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),");"),(0,n.kt)("p",null,"[Other pragmas are defined throughout this Reference Manual, and are summarized in Annex L.] "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Ramification: "),'The language-defined pragmas are supported by every implementation, although "supporting" some of them (for example, Inline) requires nothing more than checking the arguments, since they act only as advice to the implementation. ')),(0,n.kt)("h4",h({},{id:"static-semantics-1"}),"Static Semantics"),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," List takes one of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s On or Off as the single argument. This pragma is allowed anywhere a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is allowed. It specifies that listing of the compilation is to be continued or suspended until a List ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," with the opposite argument is given within the same compilation. The ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," itself is always listed if the compiler is producing a listing."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Page is allowed anywhere a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is allowed. It specifies that the program text which follows the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," should start on a new page (if the compiler is currently producing a listing)."),(0,n.kt)("p",null,"A ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Optimize takes one of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"s Time, Space, or Off as the single argument. This ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is allowed anywhere a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," is allowed, and it applies until the end of the immediately enclosing declarative region, or for a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," at the place of a ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0286"},"compilation_unit")),", to the end of the ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-10/AA-10.1#S0285"},"compilation")),". It gives advice to the implementation as to whether time or space is the primary optimization criterion, or that optional optimizations should be turned off. [It is implementation defined how this advice is followed.] "),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Implementation defined: "),"Effect of pragma Optimize.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,(0,n.kt)("strong",null,"Discussion: "),"For example, a compiler might use Time vs. Space to control whether generic instantiations are implemented with a macro-expansion model, versus a shared-generic-body model.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'We don\'t define what constitutes an "optimization" - in fact, it cannot be formally defined in the context of Ada. One compiler might call something an optional optimization, whereas another compiler might consider that same thing to be a normal part of code generation. Thus, the programmer cannot rely on this pragma having any particular portable effect on the generated code. Some compilers might even ignore the pragma altogether. ')),(0,n.kt)("h4",h({},{id:"examples"}),"Examples"),(0,n.kt)("p",null,(0,n.kt)("em",null,"Examples of pragmas:")," "),(0,n.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00433-01","}"," ","{","AI05-0229-1","}"," ","{","AI12-0417-1","}"," pragma List(Off); -- turn off listing generation","\n","pragma Optimize(Off); -- turn off optional optimizations","\n","pragma Assertion_Policy(Check); -- check assertions","\n","pragma Assert(Exists(File_Name),","\n","              Message =",">",' "Nonexistent file"); -- assert file exists',"\n"),(0,n.kt)("h4",h({},{id:"extensions-to-ada-83-1"}),"Extensions to Ada 83"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"The Optimize ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," now allows the identifier Off to request that normal optimization be turned off.")),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"An Optimize ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," may appear anywhere pragmas are allowed. ")),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-83-1"}),"Wording Changes from Ada 83"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,'We now describe the pragmas Page, List, and Optimize here, to act as examples, and to remove the normative material from Annex L, "Language-Defined Pragmas", so it can be entirely an informative annex. ')),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI95-00433-01"),"}"," Updated the example of named pragma parameters, because the second parameter of ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Suppress is obsolescent. ")),(0,n.kt)("h4",h({},{id:"wording-changes-from-ada-2005-1"}),"Wording Changes from Ada 2005"),(0,n.kt)(o.Z,{type:"note",mdxType:"Admonition"},(0,n.kt)("p",null,"{",(0,n.kt)("em",null,"AI05-0229-1"),"}"," Updated the example of pragmas, because both ",(0,n.kt)("code",null,(0,n.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s Inline and Import are obsolescent. ")))}w.isMDXComponent=!0}}]);