"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6583],{17675:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>m,default:()=>b,frontMatter:()=>p,metadata:()=>h,toc:()=>g});var a=n(91716),i=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&d(e,n,t[n]);if(l)for(var n of l(t))c.call(t,n)&&d(e,n,t[n]);return e};const p={title:"5.4 Data Structures"},m=void 0,h={unversionedId:"style-guide/s5/04",id:"style-guide/s5/04",title:"5.4 Data Structures",description:"The data structuring capabilities of Ada are a powerful resource;",source:"@site/docs/style-guide/s5/04.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/04",permalink:"/docs/style-guide/s5/04",draft:!1,tags:[],version:"current",frontMatter:{title:"5.4 Data Structures"},sidebar:"styleGuideSidebar",previous:{title:"5.3 Types",permalink:"/docs/style-guide/s5/03"},next:{title:"5.5 Expressions",permalink:"/docs/style-guide/s5/05"}},y={},g=[{value:"Discriminated Records",id:"discriminated-records",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"Heterogeneous Related Data",id:"heterogeneous-related-data",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"notes",id:"notes",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Heterogeneous Polymorphic Data",id:"heterogeneous-polymorphic-data",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Nested Records",id:"nested-records",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes-1",level:4},{value:"Dynamic Data",id:"dynamic-data",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"exceptions",id:"exceptions-2",level:4},{value:"Aliased Objects",id:"aliased-objects",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"Access Discriminants",id:"access-discriminants",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"Modular Types",id:"modular-types",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-7",level:4}],f={toc:g};function b(e){var t,n=e,{components:i}=n,d=((e,t)=>{var n={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&l)for(var a of l(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},f),d),o(t,r({components:i,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"The data structuring capabilities of Ada are a powerful resource;\ntherefore, use them to model the data as closely as possible. It is\npossible to group logically related data and let the language control\nthe abstraction and operations on the data rather than requiring the\nprogrammer or maintainer to do so. Data can also be organized in a\nbuilding block fashion. In addition to showing how a data structure is\norganized (and possibly giving the reader an indication as to why it was\norganized that way), creating the data structure from smaller components\nallows those components to be reused. Using the features that Ada\nprovides can increase the maintainability of your code."),(0,a.kt)("h3",u({},{id:"discriminated-records"}),"Discriminated Records"),(0,a.kt)("h4",u({},{id:"guideline"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When declaring a discriminant, use as constrained a subtype as\npossible (i.e., subtype with as specific a range constraint as\npossible)."),(0,a.kt)("li",{parentName:"ul"},"Use a discriminated record rather than a constrained array to\nrepresent an array whose actual values are unconstrained.")),(0,a.kt)("h4",u({},{id:"example"}),"example"),(0,a.kt)("p",null,"An object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_Holder_1")," could potentially hold a string whose\nlength is ",(0,a.kt)("inlineCode",{parentName:"p"},"Natural'Last"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Number_List is array (Integer range <>) of Integer;\n\ntype Number_Holder_1 (Current_Length : Natural := 0) is\n   record\n      Numbers : Number_List (1 .. Current_Length);\n   end record;\n")),(0,a.kt)("p",null,"An object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Name_Holder_2")," imposes a more reasonable restriction\non the length of its string component:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type    Number_List is array (Integer range <>) of Integer;\nsubtype Max_Numbers is Natural range 0 .. 42;\n\ntype Number_Holder_2 (Current_Length : Max_Numbers := 0) is\n   record\n      Numbers : Number_List (1 .. Current_Length);\n   end record;\n")),(0,a.kt)("h4",u({},{id:"rationale"}),"rationale"),(0,a.kt)("p",null,"When you use the discriminant to constrain an array inside a\ndiscriminated record, the larger the range of values the discriminant\ncan assume, the more space an object of the type might require. Although\nyour program may compile and link, it will fail at execution when the\nrun-time system is unable to create an object of the potential size\nrequired."),(0,a.kt)("p",null,"The discriminated record captures the intent of an array whose bounds\nmay vary at run-time. A simple constrained array definition (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"type Number_List is array (1 .. 42) of Integer;"),") does not capture the intent\nthat there are at most 42 possible numbers in the list."),(0,a.kt)("h3",u({},{id:"heterogeneous-related-data"}),"Heterogeneous Related Data"),(0,a.kt)("h4",u({},{id:"guideline-1"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use records to group heterogeneous but related data."),(0,a.kt)("li",{parentName:"ul"},"Consider records to map to I/O device data.")),(0,a.kt)("h4",u({},{id:"example-1"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Propulsion_Method is (Sail, Diesel, Nuclear);\ntype Craft is\n   record\n      Name   : Common_Name;\n      Plant  : Propulsion_Method;\n      Length : Feet;\n      Beam   : Feet;\n      Draft  : Feet;\n   end record;\ntype Fleet is array (1 .. Fleet_Size) of Craft;\n")),(0,a.kt)("h4",u({},{id:"rationale-1"}),"rationale"),(0,a.kt)("p",null,"You help the maintainer find all of the related data by gathering it\ninto the same construct, simplifying any modifications that apply to all\nrather than part. This, in turn, increases reliability. Neither you nor\nan unknown maintainer is liable to forget to deal with all the pieces of\ninformation in the executable statements, especially if updates are done\nwith aggregate assignments whenever possible."),(0,a.kt)("p",null,"The idea is to put the information a maintainer needs to know where it\ncan be found with the minimum of effort. For example, if all information\nrelating to a given ",(0,a.kt)("inlineCode",{parentName:"p"},"Craft")," is in the same place, the relationship is\nclear both in the declarations and especially in the code accessing and\nupdating that information. But, if it is scattered among several data\nstructures, it is less obvious that this is an intended relationship as\nopposed to a coincidental one. In the latter case, the declarations may\nbe grouped together to imply intent, but it may not be possible to group\nthe accessing and updating code that way. Ensuring the use of the same\nindex to access the corresponding element in each of several parallel\narrays is difficult if the accesses are at all scattered."),(0,a.kt)("p",null,"If the application must interface directly to hardware, the use of\nrecords, especially in conjunction with record representation clauses,\ncould be useful to map onto the layout of the hardware in question."),(0,a.kt)("h4",u({},{id:"notes"}),"notes"),(0,a.kt)("p",null,"It may seem desirable to store heterogeneous data in parallel arrays in\nwhat amounts to a FORTRAN-like style. This style is an artifact of\nFORTRAN's data structuring limitations. FORTRAN only has facilities for\nconstructing homogeneous arrays."),(0,a.kt)("h4",u({},{id:"exceptions"}),"exceptions"),(0,a.kt)("p",null,"If the application must interface directly to hardware, and the hardware\nrequires that information be distributed among various locations, then\nit may not be possible to use records."),(0,a.kt)("h3",u({},{id:"heterogeneous-polymorphic-data"}),"Heterogeneous Polymorphic Data"),(0,a.kt)("h4",u({},{id:"guideline-2"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access types to class-wide types to implement heterogeneous\npolymorphic data structures."),(0,a.kt)("li",{parentName:"ul"},"Use tagged types and type extension rather than variant records (in\ncombination with enumeration types and case statements).")),(0,a.kt)("h4",u({},{id:"example-2"}),"example"),(0,a.kt)("p",null,"An array of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Employee_List")," can contain pointers to part-time and\nfull-time employees (and possibly other kinds of employees in the\nfuture):"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"-----------------------------------------------------------------------------------\npackage Personnel is\n   type Employee  is tagged limited private;\n   type Reference is access all Employee'Class;\n   ...\nprivate\n   ...\nend Personnel;\n-----------------------------------------------------------------------------------\nwith Personnel;\npackage Part_Time_Staff is\n   type Part_Time_Employee is new Personnel.Employee with\n      record\n         ...\n      end record;\n   ...\nend Part_Time_Staff;\n-----------------------------------------------------------------------------------\nwith Personnel;\npackage Full_Time_Staff is\n   type Full_Time_Employee is new Personnel.Employee with\n      record\n         ...\n      end record;\n   ...\nend Full_Time_Staff;\n-----------------------------------------------------------------------------------\n\n...\n\ntype Employee_List is array (Positive range <>) of Personnel.Reference;\n\nCurrent_Employees : Employee_List (1..10);\n\n...\n\nCurrent_Employees(1) := new Full_Time_Staff.Full_Time_Employee;\nCurrent_Employees(2) := new Part_Time_Staff.Part_Time_Employee;\n...\n")),(0,a.kt)("h4",u({},{id:"rationale-2"}),"rationale"),(0,a.kt)("p",null,"Polymorphism is a means of factoring out the differences among a\ncollection of abstractions so that programs may be written in terms of\nthe common properties. Polymorphism allows the different objects in a\nheterogeneous data structure to be treated the same way, based on\ndispatching operations defined on the root tagged type. This eliminates\nthe need for ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements to select the processing required for\neach specific type. Guideline 5.6.3 discusses the maintenance impact of\nusing ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements."),(0,a.kt)("p",null,"Enumeration types, variant records, and case statements are hard to\nmaintain because the expertise on a given variant of the data type tends\nto be spread all over the program. When you create a tagged type\nhierarchy (tagged types and type extension), you can avoid the variant\nrecords, case statement, and single enumeration type that only supports\nthe variant record discriminant. Moreover, you localize the\n",(0,a.kt)("em",{parentName:"p"},'"expertise"')," about the variant within the data structure by having all\nthe corresponding primitives for a single operation call common\n",(0,a.kt)("em",{parentName:"p"},'"operation-specific"')," code."),(0,a.kt)("p",null,"See also Guideline 9.2.1 for a more detailed discussion of tagged types."),(0,a.kt)("h4",u({},{id:"exceptions-1"}),"exceptions"),(0,a.kt)("p",null,"In some instances, you may want to use a variant record approach to\norganize modularity around operations. For graphic output, for example,\nyou may find it more maintainable to use variant records. You must make\nthe tradeoff of whether adding a new operation will be less work than\nadding a new variant."),(0,a.kt)("h3",u({},{id:"nested-records"}),"Nested Records"),(0,a.kt)("h4",u({},{id:"guideline-3"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Record structures should not always be flat. Factor out common\nparts."),(0,a.kt)("li",{parentName:"ul"},"For a large record structure, group related components into smaller\nsubrecords."),(0,a.kt)("li",{parentName:"ul"},"For nested records, pick element names that read well when inner\nelements are referenced."),(0,a.kt)("li",{parentName:"ul"},"Consider using type extension to organize large data structures.")),(0,a.kt)("h4",u({},{id:"example-3"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"type Coordinate is\n   record\n      Row    : Local_Float;\n      Column : Local_Float;\n   end record;\ntype Window is\n   record\n      Top_Left     : Coordinate;\n      Bottom_Right : Coordinate;\n   end record;\n")),(0,a.kt)("h4",u({},{id:"rationale-3"}),"rationale"),(0,a.kt)("p",null,"You can make complex data structures understandable and comprehensible\nby composing them of familiar building blocks. This technique works\nespecially well for large record types with parts that fall into natural\ngroupings. The components factored into separately declared records,\nbased on a common quality or purpose, correspond to a lower level of\nabstraction than that represented by the larger record."),(0,a.kt)("p",null,'When designing a complex data structure, you must consider whether type\ncomposition or type extension is the best suited technique. Type\ncomposition refers to creating a record component whose type is itself a\nrecord. You will often need a hybrid of these techniques, that is, some\ncomponents you include through type composition and others you create\nthrough type extension. Type extension may provide a cleaner design if\nthe "intermediate" records are all instances of the same abstraction\nfamily. See also Guidelines 5.4.2 and 9.2.1 .'),(0,a.kt)("h4",u({},{id:"notes-1"}),"notes"),(0,a.kt)("p",null,"A carefully chosen name for the component of the larger record that is\nused to select the smaller enhances readability, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"if Window1.Bottom_Right.Row > Window2.Top_Left.Row then . . .\n")),(0,a.kt)("h3",u({},{id:"dynamic-data"}),"Dynamic Data"),(0,a.kt)("h4",u({},{id:"guideline-4"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Differentiate between static and dynamic data. Use dynamically\nallocated objects with caution."),(0,a.kt)("li",{parentName:"ul"},"Use dynamically allocated data structures only when it is necessary\nto create and destroy them dynamically or to be able to reference\nthem by different names."),(0,a.kt)("li",{parentName:"ul"},"Do not drop pointers to undeallocated objects."),(0,a.kt)("li",{parentName:"ul"},"Do not leave dangling references to deallocated objects."),(0,a.kt)("li",{parentName:"ul"},"Initialize all access variables and components within a record."),(0,a.kt)("li",{parentName:"ul"},"Do not rely on memory deallocation."),(0,a.kt)("li",{parentName:"ul"},"Deallocate explicitly."),(0,a.kt)("li",{parentName:"ul"},"Use length clauses to specify total allocation size."),(0,a.kt)("li",{parentName:"ul"},"Provide handlers for ",(0,a.kt)("inlineCode",{parentName:"li"},"Storage_Error"),"."),(0,a.kt)("li",{parentName:"ul"},"Use controlled types to implement private types that manipulate\ndynamic data."),(0,a.kt)("li",{parentName:"ul"},"Avoid unconstrained record objects unless your run-time environment\nreliably reclaims dynamic heap storage."),(0,a.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage, declare the following items only in the outermost, unnested\ndeclarative part of either a library package, a main subprogram, or\na permanent task:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Access types"),(0,a.kt)("li",{parentName:"ul"},"Constrained composite objects with nonstatic bounds"),(0,a.kt)("li",{parentName:"ul"},"Objects of an unconstrained composite type other than\nunconstrained records"),(0,a.kt)("li",{parentName:"ul"},"Composite objects large enough (at compile time) for the\ncompiler to allocate implicitly on the heap"))),(0,a.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage or you are creating permanent, dynamically allocated tasks,\navoid declaring tasks in the following situations:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Unconstrained array subtypes whose components are tasks"),(0,a.kt)("li",{parentName:"ul"},"Discriminated record subtypes containing a component that is an\narray of tasks, where the array size depends on the value of the\ndiscriminant"),(0,a.kt)("li",{parentName:"ul"},"Any declarative region other than the outermost, unnested\ndeclarative part of either a library package or a main\nsubprogram"),(0,a.kt)("li",{parentName:"ul"},"Arrays of tasks that are not statically constrained")))),(0,a.kt)("h4",u({},{id:"example-4"}),"example"),(0,a.kt)("p",null,"These lines show how a dangling reference might be created:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"P1 := new Object;\nP2 := P1;\nUnchecked_Object_Deallocation(P2);\n")),(0,a.kt)("p",null,"This line can raise an exception due to referencing the deallocated\nobject:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"X := P1.all;\n")),(0,a.kt)("p",null,"In the following three lines, if there is no intervening assignment of\nthe value of ",(0,a.kt)("inlineCode",{parentName:"p"},"P1")," to any other pointer, the object created on the first\nline is no longer accessible after the third line. The only pointer to\nthe allocated object has been dropped:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"P1 := new Object;\n...\nP1 := P2;\n")),(0,a.kt)("p",null,"The following code shows an example of using ",(0,a.kt)("inlineCode",{parentName:"p"},"Finalize")," to make sure\nthat when an object is finalized (i.e., goes out of scope), the\ndynamically allocated elements are chained on a free list:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"with Ada.Finalization;\npackage List is\n   type Object is private;\n   function &quot;=&quot; (Left, Right : Object) return Boolean;  -- element-by-element comparison\n   ... -- Operations go here\nprivate\n   type Handle is access List.Object;\n   type Object is new Ada.Finalization.Controlled with\n      record\n         Next : List.Handle;\n         ... -- Useful information go here\n      end record;\n   procedure Adjust (L : in out List.Object);\n   procedure Finalize (L : in out List.Object);\nend List;\npackage body List is\n   Free_List : List.Handle;\n   ...\n   procedure Adjust (L : in out List.Object) is\n   begin\n      L := Deep_Copy (L);\n   end Adjust;\n   procedure Finalize (L : in out List.Object) is\n   begin\n      -- Chain L to Free_List\n   end Finalize;\nend List;\n")),(0,a.kt)("h4",u({},{id:"rationale-4"}),"rationale"),(0,a.kt)("p",null,"See also 6.3.2 for variations on these problems. A dynamically allocated\nobject is an object created by the execution of an allocator (",(0,a.kt)("inlineCode",{parentName:"p"},"new"),").\nAllocated objects referenced by access variables allow you to generate\naliases ",(0,a.kt)("em",{parentName:"p"},",")," which are multiple references to the same object. Anomalous\nbehavior can arise when you reference a deallocated object by another\nname. This is called a dangling reference. Totally disassociating a\nstill-valid object from all names is called dropping a pointer. A\ndynamically allocated object that is not associated with a name cannot\nbe referenced or explicitly deallocated."),(0,a.kt)("p",null,"A dropped pointer depends on an implicit memory manager for reclamation\nof space. It also raises questions for the reader as to whether the loss\nof access to the object was intended or accidental."),(0,a.kt)("p",null,"An Ada environment is not required to provide deallocation of\ndynamically allocated objects. If provided, it may be provided\nimplicitly (objects are deallocated when their access type goes out of\nscope), explicitly (objects are deallocated when\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," is called), or both. To increase the\nlikelihood of the storage space being reclaimed, it is best to call\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," explicitly for each dynamically created\nobject when you are finished using it. Calls to\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation")," also document a deliberate decision to\nabandon an object, making the code easier to read and understand. To be\nabsolutely certain that space is reclaimed and reused, manage your own"),(0,a.kt)("i",null,'"free list."')," Keep track of which objects you are finished with, and reuse them instead of dynamically allocating new objects later.",(0,a.kt)("p",null,"The dangers of dangling references are that you may attempt to use them,\nthereby accessing memory that you have released to the memory manager\nand that may have been subsequently allocated for another purpose in\nanother part of your program. When you read from such memory, unexpected\nerrors may occur because the other part of your program may have\npreviously written totally unrelated data there. Even worse, when you\nwrite to such memory you can cause errors in an apparently unrelated\npart of the code by changing values of variables dynamically allocated\nby that code. This type of error can be very difficult to find. Finally,\nsuch errors may be triggered in parts of your environment that you did\nnot write, for example, in the memory management system itself, which\nmay dynamically allocate memory to keep records about your dynamically\nallocated memory."),(0,a.kt)("p",null,"Keep in mind that any unreset component of a record or array can also be\na dangling reference or carry a bit pattern representing inconsistent\ndata. Components of an access type are always initialized by default to\n",(0,a.kt)("inlineCode",{parentName:"p"},"null"),"; however, you should not rely on this default initialization. To\nenhance readability and maintainability, you should include explicit\ninitialization."),(0,a.kt)("p",null,"Whenever you use dynamic allocation, it is possible to run out of space.\nAda provides a facility (a length clause) for requesting the size of the\npool of allocation space at compile time. Anticipate that you can still\nrun out at run time. Prepare handlers for the exception ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error"),",\nand consider carefully what alternatives you may be able to include in\nthe program for each such situation."),(0,a.kt)("p",null,"There is a school of thought that dictates avoidance of all dynamic\nallocation. It is largely based on the fear of running out of memory\nduring execution. Facilities, such as length clauses and exception\nhandlers for ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error"),", provide explicit control over memory\npartitioning and error recovery, making this fear unfounded."),(0,a.kt)("p",null,"When implementing a complex data structure (tree, list, sparse matrices,\netc.), you often use access types. If you are not careful, you can\nconsume all your storage with these dynamically allocated objects. You\ncould export a deallocate operation, but it is impossible to ensure that\nit is called at the proper places; you are, in effect, trusting the\nclients. If you derive from controlled types (see 8.3.3 , and 9.2.3 for\nmore information), you can use finalization to deal with deallocation of\ndynamic data, thus avoiding storage exhaustion. User-defined storage\npools give better control over the allocation policy."),(0,a.kt)("p",null,"A related but distinct issue is that of shared versus copy semantics:\neven if the data structure is implemented using access types, you do not\nnecessarily want shared semantics. In some instances you really want",(0,a.kt)("inlineCode",{parentName:"p"},":="),"\nto create a copy, not a new reference, and you really want ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," to\ncompare the contents, not the reference. You should implement your\nstructure as a controlled type. If you want copy semantics, you can\nredefine ",(0,a.kt)("inlineCode",{parentName:"p"},"Adjust")," to perform a deep copy and ",(0,a.kt)("inlineCode",{parentName:"p"},"=")," to perform a comparison\non the contents. You can also redefine ",(0,a.kt)("inlineCode",{parentName:"p"},"Finalize")," to make sure that when\nan object is finalized (i.e., goes out of scope) the dynamically\nallocated elements are chained on a free list (or deallocated by\n",(0,a.kt)("inlineCode",{parentName:"p"},"Ada.Unchecked_Deallocation"),")."),(0,a.kt)("p",null,"The implicit use of dynamic (heap) storage by an Ada program during\nexecution poses significant risks that software failures may occur. An\nAda run-time environment may use implicit dynamic (heap) storage in\nassociation with composite objects, dynamically created tasks, and\ncatenation. Often, the algorithms used to manage the dynamic allocation\nand reclamation of heap storage cause fragmentation or leakage, which\ncan lead to storage exhaustion. It is usually very difficult or\nimpossible to recover from storage exhaustion or ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage_Error")," without\nreloading and restarting the Ada program. It would be very restrictive\nto avoid all uses of implicit allocation. On the other hand, preventing\nboth explicit and implicit deallocation significantly reduces the risks\nof fragmentation and leakage without overly restricting your use of\ncomposite objects, access values, task objects, and catenation."),(0,a.kt)("h4",u({},{id:"exceptions-2"}),"exceptions"),(0,a.kt)("p",null,"If a composite object is large enough to be allocated on the heap, you\ncan still declare it as an ",(0,a.kt)("inlineCode",{parentName:"p"},"in")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"in out")," formal parameter. The\nguideline is meant to discourage declaring the object in an object\ndeclaration, a formal ",(0,a.kt)("inlineCode",{parentName:"p"},"out")," parameter, or the value returned by a\nfunction."),(0,a.kt)("p",null,"You should monitor the leakage and/or fragmentation from the heap. If\nthey become steady-state and do not continually increase during program\nor partition execution, you can use the constructs described in the\nguidelines."),(0,a.kt)("h3",u({},{id:"aliased-objects"}),"Aliased Objects"),(0,a.kt)("h4",u({},{id:"guideline-5"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Minimize the use of aliased variables."),(0,a.kt)("li",{parentName:"ul"},"Use aliasing for statically created, ragged arrays (Rationale 1995,\n\xa73.7.1 )."),(0,a.kt)("li",{parentName:"ul"},"Use aliasing to refer to part of a data structure when you want to\nhide the internal connections and bookkeeping information.")),(0,a.kt)("h4",u({},{id:"example-5"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"package Message_Services is\n   type Message_Code_Type is range 0 .. 100;\n   subtype Message is String;\n   function Get_Message (Message_Code: Message_Code_Type)\n     return Message;\n   pragma Inline (Get_Message);\nend Message_Services;\npackage body Message_Services is\n   type Message_Handle is access constant Message;\n   Message_0 : aliased constant Message := &quot;OK&quot;;\n   Message_1 : aliased constant Message := &quot;Up&quot;;\n   Message_2 : aliased constant Message := &quot;Shutdown&quot;;\n   Message_3 : aliased constant Message := &quot;Shutup&quot;;\n   . . .\n   type Message_Table_Type is array (Message_Code_Type) of Message_Handle;\n\n   Message_Table : Message_Table_Type :=\n     (0 => Message_0'Access,\n      1 => Message_1'Access,\n      2 => Message_2'Access,\n      3 => Message_3'Access,\n      -- etc.\n     );\n   function Get_Message (Message_Code : Message_Code_Type)\n     return Message is\n   begin\n      return Message_Table (Message_Code).all;\n   end Get_Message;\nend Message_Services;\n")),(0,a.kt)("p",null,"The following code fragment shows a use of aliased objects, using the\nattribute ",(0,a.kt)("inlineCode",{parentName:"p"},"'Access")," to implement a generic component that manages hashed\ncollections of objects:"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"generic\n   type Hash_Index is mod <>;\n   type Object is tagged private;\n   type Handle is access all Object;\n   with function Hash (The_Object : in Object) return Hash_Index;\npackage Collection is\n   function Insert (Object : in Collection.Object) return Collection.Handle;\n   function Find (Object : in Collection.Object) return Collection.Handle;\n   Object_Not_Found : exception;\n\n   ...\nprivate\n   type Cell;\n   type Access_Cell is access Cell;\nend Collection;\npackage body Collection is\n   type Cell is\n   record\n      Value : aliased Collection.Object;\n      Link  : Access_Cell;\n   end record;\n   type Table_Type is array (Hash_Index) of Access_Cell;\n\n   Table : Table_Type;\n   -- Go through the collision chain and return an access to the useful data.\n   function Find (Object : in Collection.Object;\n                  Index  : in Hash_Index) return Handle is\n      Current : Access_Cell := Table (Index);\n   begin\n      while Current /= null loop\n         if Current.Value = Object then\n            return Current.Value'Access;\n         else\n            Current := Current.Link;\n         end if;\n      end loop;\n      raise Object_Not_Found;\n   end Find;\n   -- The exported one\n   function Find (Object : in Collection.Object) return Collection.Handle is\n      Index : constant Hash_Index := Hash (Object);\n   begin\n      return Find (Object, Index);\n   end Find;\n   ...\nend Collection;\n")),(0,a.kt)("h4",u({},{id:"rationale-5"}),"rationale"),(0,a.kt)("p",null,"Aliasing allows the programmer to have indirect access to declared\nobjects. Because you can update aliased objects through more than one\npath, you must exercise caution to avoid unintended updates. When you\nrestrict the aliased objects to being constant, you avoid having the\nobject unintentionally modified. In the example above, the individual\nmessage objects are aliased constant message strings so their values\ncannot be changed. The ragged array is then initialized with references\nto each of these constant strings."),(0,a.kt)("p",null,"Aliasing allows you to manipulate objects using indirection while\navoiding dynamic allocation. For example, you can insert an object onto\na linked list without dynamically allocating the space for that object\n(Rationale 1995, \xa73.7.1 )."),(0,a.kt)("p",null,"Another use of aliasing is in a linked data structure in which you try\nto hide the enclosing container. This is essentially the inverse of a\nself-referential data structure (see Guideline 5.4.7 ). If a package\nmanages some data using a linked data structure, you may only want to\nexport access values that denote the ",(0,a.kt)("em",{parentName:"p"},'"useful"')," data. You can use an\naccess-to-object to return an access to the useful data, excluding the\npointers used to chain objects."),(0,a.kt)("h3",u({},{id:"access-discriminants"}),"Access Discriminants"),(0,a.kt)("h4",u({},{id:"guideline-6"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use access discriminants to create self-referential data structures,\ni.e., a data structure one of whose components points to the\nenclosing structure.")),(0,a.kt)("h4",u({},{id:"example-6"}),"example"),(0,a.kt)("p",null,"See the examples in Guidelines 8.3.6 (using access discriminants to\nbuild an iterator) and 9.5.1 (using access discriminants in multiple\ninheritance)."),(0,a.kt)("h4",u({},{id:"rationale-6"}),"rationale"),(0,a.kt)("p",null,'The access discriminant is essentially a pointer of an anonymous type\nbeing used as a discriminant. Because the access discriminant is of an\nanonymous access type, you cannot declare other objects of the type.\nThus, once you initialize the discriminant, you create a "permanent"\n(for the lifetime of the object) association between the discriminant\nand the object it accesses. When you create a self-referential\nstructure, that is, a component of the structure is initialized to point\nto the enclosing object, the ',(0,a.kt)("em",{parentName:"p"},'"constant"')," behavior of the access\ndiscriminant provides the right behavior to help you maintain the\nintegrity of the structure."),(0,a.kt)("p",null,"See also Rationale (1995, \xa74.6.3) for a discussion of access\ndiscriminants to achieve multiple views of an object."),(0,a.kt)("p",null,"See also Guideline 6.1.3 for an example of an access discriminant for a\ntask type."),(0,a.kt)("h3",u({},{id:"modular-types"}),"Modular Types"),(0,a.kt)("h4",u({},{id:"guideline-7"}),"guideline"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use modular types rather than Boolean arrays when you create data\nstructures that need bit-wise operations, such as ",(0,a.kt)("inlineCode",{parentName:"li"},"and")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"or"),".")),(0,a.kt)("h4",u({},{id:"example-7"}),"example"),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{}),"with Interfaces;\nprocedure Main is\n   type Unsigned_Byte is mod 255;\n\n   X : Unsigned_Byte;\n   Y : Unsigned_Byte;\n   Z : Unsigned_Byte;\n   X1 : Interfaces.Unsigned_16;\nbegin -- Main\n   Z := X or Y;  -- does not cause overflow\n\n   -- Show example of left shift\n   X1 := 16#FFFF#;\n   for Counter in 1 .. 16 loop\n      X1 := Interfaces.Shift_Left (Value => X1, Amount => 1);\n   end loop;\nend Main;\n")),(0,a.kt)("h4",u({},{id:"rationale-7"}),"rationale"),(0,a.kt)("p",null,"Modular types are preferred when the number of bits is known to be fewer\nthan the number of bits in a word and/or performance is a serious\nconcern. Boolean arrays are appropriate when the number of bits is not\nparticularly known in advance and performance is not a serious issue.\nSee also Guideline 10.6.3 ."))}b.isMDXComponent=!0}}]);