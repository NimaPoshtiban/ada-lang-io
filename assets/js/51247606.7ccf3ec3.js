"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8991],{1438:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var a=n(9440),o=(n(6687),n(1716)),i=n(2526);const l={sidebar_position:63},s="7.6  Assignment and Finalization",r={unversionedId:"arm/AA-7.6",id:"arm/AA-7.6",title:"7.6  Assignment and Finalization",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-7.6.mdx",sourceDirName:"arm",slug:"/arm/AA-7.6",permalink:"/docs/arm/AA-7.6",draft:!1,tags:[],version:"current",sidebarPosition:63,frontMatter:{sidebar_position:63},sidebar:"tutorialSidebar",previous:{title:"7.5  Limited Types",permalink:"/docs/arm/AA-7.5"},next:{title:"8 Visibility Rules",permalink:"/docs/arm/AA-8"}},c={},d=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Extensions to Ada 95",id:"extensions-to-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"7.6.1  Completion and Finalization",id:"761--completion-and-finalization",level:2},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Implementation Permissions",id:"implementation-permissions-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"Inconsistencies With Ada 95",id:"inconsistencies-with-ada-95",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Inconsistencies With Ada 2005",id:"inconsistencies-with-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4}],h={toc:d};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"76--assignment-and-finalization"},"7.6  Assignment and Finalization"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,o.kt)("p",null,"[ Three kinds of actions are fundamental to the manipulation of objects: initialization, finalization, and assignment. Every object is initialized, either explicitly or by default, after being created (for example, by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"). Every object is finalized before being destroyed (for example, by leaving a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.3#S0216"},"subprogram_body"))," containing an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.3#S0032"},"object_declaration")),", or by a call to an instance of Unchecked_Deallocation). An assignment operation is used as part of ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),"s, explicit initialization, parameter passing, and other operations. "),(0,o.kt)("p",null,"Default definitions for these three fundamental operations are provided by the language, but a ",(0,o.kt)("em",null,"controlled")," type gives the user additional control over parts of these operations. In particular, the user can define, for a controlled type, an Initialize procedure which is invoked immediately after the normal default initialization of a controlled object, a Finalize procedure which is invoked immediately before finalization of any of the components of a controlled object, and an Adjust procedure which is invoked as the last step of an assignment to a (nonlimited) controlled object.] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Glossary entry: "),"A controlled type supports user-defined assignment and finalization. Objects are always finalized before being destroyed."),(0,o.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[T],Term=[controlled type], Def=[a type that supports user-defined assignment and finalization], Note1=[Objects are always finalized before being destroyed.] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI95-00114-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00287-01"),"}"," Here's the basic idea of initialization, value adjustment, and finalization, whether or not user defined: When an object is created, if it is explicitly assigned an initial value, the object is either built-in-place from an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call (in which case neither Adjust nor Initialize is applied), or the assignment copies and adjusts the initial value. Otherwise, Initialize is applied to it (except in the case of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," as a whole). An ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," finalizes the target before copying in and adjusting the new value. Whenever an object goes away, it is finalized. Calls on Initialize and Adjust happen bottom-up; that is, components first, followed by the containing object. Calls on Finalize happen top-down; that is, first the containing object, and then its components. These ordering rules ensure that any components will be in a well-defined state when Initialize, Adjust, or Finalize is applied to the containing object. "),(0,o.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,o.kt)("p",null,"The following language-defined library package exists: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","8652/0020","}"," ","{","AI95-00126-01","}"," ","{","AI05-0212-1","}"," ","{","AI12-0241-1","}"," package Ada.Finalization","\n","    with Pure, Nonblocking =",">"," False is","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00161-01","}"," ","{","AI12-0399-1","}","     type Controlled is abstract tagged private","\n","       with Preelaborable_Initialization;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00348-01","}","     procedure Initialize (Object : in out Controlled) is null;","\n","    procedure Adjust     (Object : in out Controlled) is null;","\n","    procedure Finalize   (Object : in out Controlled) is null;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00161-01","}"," ","{","AI12-0399-1","}","     type Limited_Controlled is abstract tagged limited private","\n","       with Preelaborable_Initialization;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"{","AI95-00348-01","}","     procedure Initialize (Object : in out Limited_Controlled) is null;","\n","    procedure Finalize   (Object : in out Limited_Controlled) is null;","\n","private","\n","    ... -- not specified by the language","\n","end Ada.Finalization;","\n"),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI12-0241-1"),"}"," This package must allow blocking (Nonblocking =",">"," False) for compatibility. The purpose of this package is to provide a template for overriding user-defined routines; and such routines can only allow blocking if the root type does so. Users can still declare their overridding routines nonblocking if they wish. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}",' A controlled type is a descendant of Controlled or Limited_Controlled. The predefined "=" operator of type Controlled always returns True, [since this operator is incorporated into the implementation of the predefined equality operator of types derived from Controlled, as explained in 4.5.2.] The type Limited_Controlled is like Controlled, except that it is limited and it lacks the primitive subprogram Adjust. '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),'We say "nonlimited controlled type" (rather than just "controlled type";) when we want to talk about descendants of Controlled only. '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We considered making Adjust and Finalize abstract. However, a reasonable coding convention is e.g. for Finalize to always call the parent's Finalize after doing whatever work is needed for the extension part. (Unlike CLOS, we have no way to do that automatically in Ada 95.) For this to work, Finalize cannot be abstract. In a generic unit, for a generic formal abstract derived type whose ancestor is Controlled or Limited_Controlled, calling the ancestor's Finalize would be illegal if it were abstract, even though the actual type might have a concrete version."),(0,o.kt)("p",null,'Types Controlled and Limited_Controlled are abstract, even though they have no abstract primitive subprograms. It is not clear that they need to be abstract, but there seems to be no harm in it, and it might make an implementation\'s life easier to know that there are no objects of these types - in case the implementation wishes to make them "magic" in some way.'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00251-01"),"}",' For Ada 2005, we considered making these types interfaces. That would have the advantage of allowing them to be added to existing trees. But that was rejected both because it would cause massive disruptions to existing implementations, and because it would be very incompatible due to the "no hidden interfaces" rule. The latter rule would prevent a tagged private type from being completed with a derivation from Controlled or Limited_Controlled - a very common idiom. '),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00360-01"),"}"," A type is said to ",(0,o.kt)("em",null,"need finalization")," if:"),(0,o.kt)("p",null,"it is a controlled type, a task type or a protected type; or"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0092-1"),"}"," it has a component whose type  needs finalization; or"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0013-1"),"}"," it is a class-wide type; or"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0026-1"),"}"," it is a partial view whose full view needs finalization; or"),(0,o.kt)("p",null,"it is one of a number of language-defined types that are explicitly defined to need finalization."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"The fact that a type needs finalization does not require it to be implemented with a controlled type. It just has to be recognized by the No_Nested_Finalization restriction."),(0,o.kt)("p",null,"This property is defined for the type, not for a particular view. That's necessary as restrictions look in private parts to enforce their restrictions; the point is to eliminate all controlled parts, not just ones that are visible. "),(0,o.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00373-01"),"}"," During the elaboration or evaluation of a construct that causes an object to be initialized by default, for every controlled subcomponent of the object that is not assigned an initial value (as defined in 3.3.1), Initialize is called on that subcomponent. Similarly, if the object that is initialized by default as a whole is controlled, Initialize is called on the object."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0021"),"}"," ","{",(0,o.kt)("em",null,"AI95-00182-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00373-01"),"}"," For an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0111"},"extension_aggregate"))," whose ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0112"},"ancestor_part"))," is a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.2#S0028"},"subtype_mark"))," denoting a controlled subtype, the Initialize procedure of the ancestor type is called, unless that Initialize procedure is abstract. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"Example: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type T1 is new Controlled with","\n","    record","\n","        ... -- some components might have defaults","\n","    end record;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type T2 is new Controlled with","\n","    record","\n","        X : T1; -- no default","\n","        Y : T1 := ...; -- default","\n","    end record;","\n"),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"A : T2;","\n","B : T2 := ...;","\n"),(0,o.kt)("p",null,"As part of the elaboration of A's declaration, A.Y is assigned a value; therefore Initialize is not applied to A.Y. Instead, Adjust is applied to A.Y as part of the assignment operation. Initialize is applied to A.X and to A, since those objects are not assigned an initial value. The assignment to A.Y is not considered an assignment to A."),(0,o.kt)("p",null,"For the elaboration of B's declaration, Initialize is not called at all. Instead the assignment adjusts B's value; that is, it applies Adjust to B.X, B.Y, and B."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0021"),"}"," ","{",(0,o.kt)("em",null,"AI95-00182-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00373-01"),"}"," The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0112"},"ancestor_part"))," of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0111"},"extension_aggregate")),", ","<",">"," in aggregates, and the return object of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.5#S0225"},"extended_return_statement"))," are handled similarly. "),(0,o.kt)("p",null,"Initialize and other initialization operations are done in an arbitrary order, except as follows. Initialize is applied to an object after initialization of its subcomponents, if any [(including both implicit initialization and Initialize calls)]. If an object has a component with an access discriminant constrained by a per-object expression, Initialize is applied to this component after any components that do not have such discriminants. For an object with several components with such a discriminant, Initialize is applied to them in order of their ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.8#S0070"},"component_declaration")),"s. For an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),", any task activations follow all calls on Initialize. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"The fact that Initialize is done for subcomponents first allows Initialize for a composite object to refer to its subcomponents knowing they have been properly initialized."),(0,o.kt)("p",null,"The fact that Initialize is done for components with access discriminants after other components allows the Initialize operation for a component with a self-referential access discriminant to assume that other components of the enclosing object have already been properly initialized. For multiple such components, it allows some predictability. "),(0,o.kt)("p",null,"When a target object with any controlled parts is assigned a value, [either when created or in a subsequent ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),",] the ",(0,o.kt)("em",null,"assignment operation")," proceeds as follows: "),(0,o.kt)("p",null,"The value of the target becomes the assigned value."),(0,o.kt)("p",null,"The value of the target is ",(0,o.kt)("em",null,"adjusted.")," "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"If any parts of the object are controlled, abort is deferred during the assignment operation. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," To adjust the value of a composite object, the values of the components of the object are first adjusted in an arbitrary order, and then, if the object is nonlimited controlled, Adjust is called. Adjusting the value of an elementary object has no effect[, nor does adjusting the value of a composite object with no controlled parts.] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," Adjustment is never actually performed for values of an immutably limited type, since all assignment operations for such types are required to be built-in-place. Even so, we still define adjustment for all types in order that the canonical semantics is well-defined. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," The verbiage in the Initialize rule about access discriminants constrained by per-object expressions is not necessary here, since such types are either limited or do not have defaults, so the discriminant can only be changed by an assignment to an outer object. Such an assignment could happen only before any adjustments or (if part of an outer Adjust) only after any inner (component) adjustments have completed. "),(0,o.kt)("p",null,"For an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),", [ after the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," have been evaluated, and any conversion (including constraint checking) has been done,] an anonymous object is created, and the value is assigned into it; [that is, the assignment operation is applied]. [(Assignment includes value adjustment.)] The target of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," is then finalized. The value of the anonymous object is then assigned into the target of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),'. Finally, the anonymous object is finalized. [As explained below, the implementation may eliminate the intermediate anonymous object, so this description subsumes the one given in 5.2, "Assignment Statements".] '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"An alternative design for user-defined assignment might involve an Assign operation instead of Adjust: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"procedure Assign(Target : in out Controlled; Source : in out Controlled);","\n"),(0,o.kt)("p",null,"Or perhaps even a syntax like this: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},'procedure ":="(Target : in out Controlled; Source : in out Controlled);',"\n"),(0,o.kt)("p",null,'Assign (or ":=") would have the responsibility of doing the copy, as well as whatever else is necessary. This would have the advantage that the Assign operation knows about both the target and the source at the same time - it would be possible to do things like reuse storage belonging to the target, for example, which Adjust cannot do. However, this sort of design would not work in the case of unconstrained discriminated variables, because there is no way to change the discriminants individually. For example: '),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"type Mutable(D : Integer := 0) is","\n","    record","\n","        X : Array_Of_Controlled_Things(1..D);","\n","        case D is","\n","            when 17 =",">"," Y : Controlled_Thing;","\n","            when others =",">"," null;","\n","        end D;","\n","    end record;","\n"),(0,o.kt)("p",null,"An assignment to an unconstrained variable of type Mutable can cause some of the components of X, and the component Y, to appear and/or disappear. There is no way to write the Assign operation to handle this sort of case."),(0,o.kt)("p",null,"Forbidding such cases is not an option - it would cause generic contract model violations. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0439-1"),"}"," When a function call or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," is used to initialize an object, the result of the function call or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," is an anonymous object, which is assigned into the newly-created object. For such an assignment, the anonymous object may be ",(0,o.kt)("em",null,"built in place"),", in which case the assignment does not involve any copying. Under certain circumstances, the anonymous object is required to be built in place. In particular:"),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," We say assignment to built-in-place objects does not involve copying, which matches the intended implementation (see below). Of course, the implementation can do any copying it likes, if it can make such copying semantically invisible (by patching up access values to point to the copy, and so forth). "),(0,o.kt)("p",null,"If the full type of any part of the object is immutably limited, the anonymous object is built in place."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," We talk about the full types being immutably limited, as this is independent of the view of a type (in the same way that it is for determining the technique of parameter passing). That is, privacy is ignored for this purpose."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," For function calls, we only require building in place for immutably limited types. These are the types that would have been return-by-reference types in Ada 95. We limited the requirement because we want to minimize disruption to Ada 95 implementations and users. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI05-0232-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," This is a dynamic property and is determined by the specific type of the parts of the actual object. In particular, if a part has a class-wide type, the tag of the object might need to be examined in order to determine if build-in-place is required. However, we expect that most Ada implementations will determine this property at compile-time using some assume-the-worst algorithm in order to choose the appropriate method to implement a given call or aggregate. In addition, there is no attribute or other method for a program to determine if a particular object has this property (or not), so there is no value to a more careful description of this rule. "),(0,o.kt)("p",null,"In the case of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),", if the full type of any part of the newly-created object is controlled, the anonymous object is built in place."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," This is necessary to prevent elaboration problems with deferred constants of controlled types. Consider: "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"package P is","\n","   type Dyn_String is private;","\n","   Null_String : constant Dyn_String;","\n","   ...","\n","private","\n","   type Dyn_String is new Ada.Finalization.Controlled with ...","\n","   procedure Finalize(X : in out Dyn_String);","\n","   procedure Adjust(X : in out Dyn_String);","\n","\n","   Null_String : constant Dyn_String :=","\n","      (Ada.Finalization.Controlled with ...);","\n","   ...","\n","end P;","\n"),(0,o.kt)("p",null,"When Null_String is elaborated, the bodies of Finalize and Adjust clearly have not been elaborated. Without this rule, this declaration would necessarily raise Program_Error (unless the permissions given below are used by the implementation). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"An ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," with a controlled part used in the return expression of a ",(0,o.kt)("code",null,"[simple_return_statement](./AA-6.5#S0222)")," has to be built in place in the anonymous return object, as this is similar to an object declaration. (This is a change from Ada 95, but it is not an inconsistency as it only serves to restrict implementation choices.) But this only covers the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"; a separate anonymous return object can still be used unless it too is required to be built in place."),(0,o.kt)("p",null,"Similarly, an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," that has a controlled part but is not itself controlled and that is used to initialize an object also has to be built in place. This is also a change from Ada 95, but it is not an inconsistency as it only serves to restrict implementation choices. This avoids problems if a type like Dyn_String (in the example above) is used as a component in a type used as a deferred constant in package P. "),(0,o.kt)("p",null,"In other cases, it is unspecified whether the anonymous object is built in place."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This is left unspecified so the implementation can use any appropriate criteria for determining when to build in place. That includes making the decision on a call-by-call basis. Reasonable programs will not care what decision is made here anyway. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," Notwithstanding what this document says elsewhere, if an object is built in place:"),(0,o.kt)("p",null,"Upon successful completion of the return statement or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),", the anonymous object ",(0,o.kt)("em",null,"mutates into")," the newly-created object; that is, the anonymous object ceases to exist, and the newly-created object appears in its place."),(0,o.kt)("p",null,"Finalization is not performed on the anonymous object."),(0,o.kt)("p",null,"Adjustment is not performed on the newly-created object."),(0,o.kt)("p",null,"All access values that designate parts of the anonymous object now designate the corresponding parts of the newly-created object."),(0,o.kt)("p",null,"All renamings of parts of the anonymous object now denote views of the corresponding parts of the newly-created object."),(0,o.kt)("p",null,"Coextensions of the anonymous object become coextensions of the newly-created object. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI12-0005-1"),"}",' This "mutating" does not necessarily happen atomically with respect to abort and other tasks. For example, if a function call is used as the ancestor part of an ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0111"},"extension_aggregate")),", then the tag of the anonymous object (the function result) will be different from the tag of the newly-created object (the ancestor part of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0111"},"extension_aggregate")),"). In implementation terms, this involves modifying the tag field. If the current task is aborted during this modification, the object might become abnormal. Likewise, if some other task accesses the tag field during this modification, it constitutes improper use of shared variables, and is erroneous. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),'The intended implementation is that the anonymous object is allocated at the same address as the newly-created object. Thus, no run-time action is required to cause all the access values and renamings to point to the right place. They just point to the newly-created object, which is what the return object has magically "mutated into".'),(0,o.kt)("p",null,"There is no requirement that 'Address of the return object is equal to 'Address of the newly-created object, but that will be true in the intended implementation."),(0,o.kt)("p",null,'For a function call, if the size of the newly-created object is known at the call site, the object is allocated there, and the address is implicitly passed to the function; the return object is created at that address. Otherwise, a storage pool is implicitly passed to the function; the size is determined at the point of the return statement, and passed to the Allocate procedure. The address returned by the storage pool is returned from the function, and the newly-created object uses that same address. If the return statement is left without returning (via an exception or a goto, for example), then Deallocate is called.  The storage pool might be a dummy pool that represents "allocate on the stack".'),(0,o.kt)("p",null,"The Tag of the newly-created object may be different from that of the result object. Likewise, the master and accessibility level may be different."),(0,o.kt)("p",null,"An alternative implementation model might allow objects to move around to different addresses. In this case, access values and renamings would need to be modified at run time. It seems that this model requires the full power of tracing garbage collection. "),(0,o.kt)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," An implementation is allowed to relax the above rules for ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),"s in the following ways: "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," The relaxations apply only to nonlimited types, as ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),"s are not allowed for limited types. This is important so that the programmer can count on stricter semantics for limited controlled types. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0444-1"),"}"," If an object is assigned the value of that same object, the implementation may omit the entire assignment. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"In other words, even if an object is controlled and a combination of Finalize and Adjust on the object might have a net side effect, they need not be performed. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," For assignment of a noncontrolled type, the implementation may finalize and assign each component of the variable separately (rather than finalizing the entire variable and assigning the entire new value) unless a discriminant of the variable is changed by the assignment. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"For example, in a slice assignment, an anonymous object is not necessary if the slice is copied component-by-component in the right direction, since array types are not controlled (although their components may be). Note that the direction, and even the fact that it's a slice assignment, can in general be determined only at run time. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," This potentially breaks a single assignment operation into many, and thus abort deferral (see 9.8) needs to last only across an individual component assignment when the component has a controlled part. It is only important that the copy step is not separated (by an abort) from the adjust step, so aborts between component assignments is not harmful. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00147-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0444-1"),"}"," The implementation may avoid creating an anonymous object if the value being assigned is the result of evaluating a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.1#S0091"},"name"))," denoting an object (the source object) whose storage cannot overlap with the target. If the source object can overlap with the target object, then the implementation can avoid the need for an intermediary anonymous object by exercising one of the above permissions and perform the assignment one component at a time (for an overlapping array assignment), or not at all (for an assignment where the target and the source of the assignment are the same object). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," If the anonymous object is eliminated by this permission,  there is no anonymous object to be finalized and thus the Finalize call on it is eliminated."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00147-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," Note that if the anonymous object is eliminated but the new value is not built in place in the target object, that Adjust must be called directly on the target object as the last step of the assignment, since some of the subcomponents may be self-referential or otherwise position-dependent. This Adjust can be eliminated only by using one of the following permissions. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00147-01"),"}"," Furthermore, an implementation is permitted to omit implicit Initialize, Adjust, and Finalize calls and associated assignment operations on an object of a nonlimited controlled type provided that:"),(0,o.kt)("p",null,"any omitted Initialize call is not a call on a user-defined Initialize procedure, and "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"This does not apply to any calls to a user-defined Initialize routine that happen to occur in an Adjust or Finalize routine. It is intended that it is never necessary to look inside of an Adjust or Finalize routine to determine if the call can be omitted. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We don't want to eliminate objects for which the Initialize might have side effects (such as locking a resource). "),(0,o.kt)("p",null,"any usage of the value of the object after the implicit Initialize or Adjust call and before any subsequent Finalize call on the object does not change the external effect of the program, and"),(0,o.kt)("p",null,"after the omission of such calls and operations, any execution of the program that executes an Initialize or Adjust call on an object or initializes an object by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," will also later execute a Finalize call on the object and will always do so prior to assigning a new value to the object, and"),(0,o.kt)("p",null,"the assignment operations associated with omitted Adjust calls are also omitted. "),(0,o.kt)("p",null,"This permission applies to Adjust and Finalize calls even if the implicit calls have additional external effects. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),'The goal of the above permissions is to allow typical dead assignment and dead variable removal algorithms to work for nonlimited controlled types. We require that "pairs" of Initialize/Adjust/Finalize operations are removed. (These aren\'t always pairs, which is why we talk about "any execution of the program".) '),(0,o.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,o.kt)("p",null,"Controlled types and user-defined finalization are new to Ada 95. (Ada 83 had finalization semantics only for masters of tasks.) "),(0,o.kt)("h4",{id:"extensions-to-ada-95"},"Extensions to Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00161-01"),"}"," ",(0,o.kt)("strong",null,"Amendment Correction:")," Types Controlled and Limited_Controlled now have Preelaborable_Initialization, so that objects of types derived from these types can be used in preelaborated packages. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0020"),"}"," ","{",(0,o.kt)("em",null,"AI95-00126-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Clarified that Ada.Finalization is a remote types package."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0021"),"}"," ","{",(0,o.kt)("em",null,"AI95-00182-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Added wording to clarify that the default initialization (whatever it is) of an ancestor part is used."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0022"),"}"," ","{",(0,o.kt)("em",null,"AI95-00083-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Clarified that Adjust is never called on an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," used for the initialization of an object or subaggregate, or passed as a parameter."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00147-01"),"}"," Additional optimizations are allowed for nonlimited controlled types. These allow traditional dead variable elimination to be applied to such types."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," Corrected the build-in-place requirement for controlled ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"s to be consistent with the requirements for limited types."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00348-01"),"}"," The operations of types Controlled and Limited_Controlled are now declared as null procedures (see 6.7) to make the semantics clear (and to provide a good example of what null procedures can be used for)."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00360-01"),"}",' Types that need finalization are defined; this is used by the No_Nested_Finalization restriction (see D.7, "Tasking Restrictions").'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00373-01"),"}"," Generalized the description of objects that have Initialize called for them to say that it is done for all objects that are initialized by default. This is needed so that all of the new cases are covered. "),(0,o.kt)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0212-1"),"}"," Package Ada.Finalization now has Pure categorization, so it can be mentioned for any package. Note that this does not change the preelaborability of objects descended from Controlled and Limited_Controlled. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0013-1"),"}"," ",(0,o.kt)("strong",null,"Correction:"),' Eliminated coextensions from the "needs finalization" rules, as this cannot be determined in general in the compilation unit that declares the type. (The designated type of the coextension may have been imported as a limited view.) Uses of "needs finalization" need to ensure that coextensions are handled by other means (such as in No_Nested_Finalization  see D.7) or that coextensions cannot happen.'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0013-1"),"}"," ",(0,o.kt)("strong",null,"Correction:"),' Corrected the "needs finalization" rules to include class-wide types, as a future extension can include a part that needs finalization.'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0026-1"),"}"," ",(0,o.kt)("strong",null,"Correction:"),' Corrected the "needs finalization" rules to clearly say that they ignore privacy.'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0067-1"),"}"," ",(0,o.kt)("strong",null,"Correction:"),' Changed "built in place" to Dynamic Semantics and centralized the rules here. This eliminates the fiction that built in place is just a combination of a permission and a requirement; it clearly has noticeable semantic effects. This wording change is not intended to change the semantics of any correct Ada program. '),(0,o.kt)("h2",{id:"761--completion-and-finalization"},"7.6.1  Completion and Finalization"),(0,o.kt)("p",null,"[This subclause defines ",(0,o.kt)("em",null,"completion")," and ",(0,o.kt)("em",null,"leaving")," of the execution of constructs and entities. A ",(0,o.kt)("em",null,"master")," is the execution of a construct that includes finalization of local objects after it is complete (and after waiting for any local tasks - see 9.3), but before leaving. Other constructs and entities are left immediately upon completion. ]"),(0,o.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," The execution of a construct or entity is ",(0,o.kt)("em",null,"complete")," when the end of that execution has been reached, or when a transfer of control (see 5.1) causes it to be abandoned. Completion due to reaching the end of execution, or due to the transfer of control of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.7#S0193"},"exit_statement")),", return statement, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.8#S0194"},"goto_statement")),", or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.5#S0265"},"requeue_statement"))," or of the selection of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-9.7#S0275"},"terminate_alternative"))," is ",(0,o.kt)("em",null,"normal completion"),". Completion is ",(0,o.kt)("em",null,"abnormal")," otherwise [- when control is transferred out of a construct due to abort or the raising of an exception]. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"Don't confuse the run-time concept of completion with the compile-time concept of completion defined in 3.11.1. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," ","{",(0,o.kt)("em",null,"AI12-0406-1"),"}"," After execution of a construct or entity is complete, it is ",(0,o.kt)("em",null,"left"),", meaning that execution continues with the next action, as defined for the execution that is taking place. Leaving an execution happens immediately after its completion, except in the case of the execution of a ",(0,o.kt)("em",null,"master construct"),": a body other than a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-7.2#S0231"},"package_body")),"; a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0167"},"statement")),"; or an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call")),", or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.5#S0037"},"range"))," that is not part of an enclosing ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call")),", ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.5#S0037"},"range")),", or ",(0,o.kt)("code",null,"[simple_statement](./AA-5.1#S0168)")," other than a ",(0,o.kt)("code",null,"[simple_return_statement](./AA-6.5#S0222)"),". The term ",(0,o.kt)("em",null,"master")," by itself refers to the execution of a master construct. A master is finalized after it is complete, and before it is left."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"Expression")),"s and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0167"},"statement")),"s are masters so that objects created by subprogram calls (in ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"s, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s for anonymous access-to-object types, and so on) are finalized and have their tasks awaited before the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0167"},"statement")),"s are left. Note that ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s like the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.5#S0150"},"condition"))," of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.3#S0175"},"if_statement"))," are masters, because they are not enclosed by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0168"},"simple_statement")),". Similarly, a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call"))," which is renamed is a master, as it is not in a ",(0,o.kt)("code",null,"[simple_statement](./AA-5.1#S0168)"),"."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," We have to include ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call")),"s in the contexts that do not cause masters to occur so that ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s contained in a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call"))," (that is not part of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0168"},"simple_statement")),") do not individually become masters. We certainly do not want the parameter ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s of a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call"))," to be separate masters, as they would then be finalized before the function is called. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," The fact that a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call"))," is a master does not change the accessibility of the return object denoted by the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call")),"; that depends on the use of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call")),". The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-6.4#S0218"},"function_call"))," is the master of any short-lived entities (such as ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"s used as parameters of types with task or controlled parts). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Glossary entry: "),"A master is the execution of a master construct. Each object and task is associated with a master. When a master is left, associated tasks are awaited and associated objects are finalized."),(0,o.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[R],Term=[master], Def=[the execution of a master construct], Note1=[Each object and task is associated with a master. When a master is left, associated tasks are awaited and associated objects are finalized.] "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Glossary entry: "),"A master construct is one of certain executable constructs listed in 7.6.1. Execution of a master construct is a master, with which objects and tasks are associated for the purposes of waiting and finalization."),(0,o.kt)("p",null,"Version=[5],Kind=(AddedNormal),Group=[C],Term=[master construct], Def=[one of certain executable constructs for which there can be objects or tasks whose lifetime ends when the construct completes], Note1=[Execution of a master construct is a master, with which objects and tasks are associated for the purposes of waiting and finalization.] For the ",(0,o.kt)("em",null,"finalization")," of a master, dependent tasks are first awaited, as explained in 9.3. Then each object whose accessibility level is the same as that of the master is finalized if the object was successfully initialized and still exists. [These actions are performed whether the master is left by reaching the last statement or via a transfer of control.] When a transfer of control causes completion of an execution, each included master is finalized in order, from innermost outward. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"As explained in 3.10.2, the set of objects with the same accessibility level as that of the master includes objects declared immediately within the master, objects declared in nested packages, objects created by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s (if the ultimate ancestor access type is declared in one of those places) and subcomponents of all of these things. If an object was already finalized by Unchecked_Deallocation, then it is not finalized again when the master is left."),(0,o.kt)("p",null,"Note that any object whose accessibility level is deeper than that of the master would no longer exist; those objects would have been finalized by some inner master. Thus, after leaving a master, the only objects yet to be finalized are those whose accessibility level is less deep than that of the master."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"Subcomponents of objects due to be finalized are not finalized by the finalization of the master; they are finalized by the finalization of the containing object. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We need to finalize subcomponents of objects even if the containing object is not going to get finalized because it was not fully initialized. But if the containing object is finalized, we don't want to require repeated finalization of the subcomponents, as might normally be implied by the recursion in finalization of a master and the recursion in finalization of an object. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),'Formally, completion and leaving refer to executions of constructs or entities. However, the standard sometimes (informally) refers to the constructs or entities whose executions are being completed. Thus, for example, "the subprogram call or task is complete" really means "',(0,o.kt)("em",null,"the execution of"),' the subprogram call or task is complete". '),(0,o.kt)("p",null,"For the ",(0,o.kt)("em",null,"finalization")," of an object: "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," If the full type of the object is an elementary type, finalization has no effect; "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0099-1"),"}",' We say "full type" in this and the following bullets as privacy is ignored for the purpose of determining the finalization actions of an object; that is as expected for Dynamic Semantics rules. '),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," If the full type of the object is a tagged type, and the tag of the object identifies a controlled type, the Finalize procedure of that controlled type is called;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," If the full type of the object is a protected type, or if the full type of the object is a tagged type and the tag of the object identifies a protected type, the actions defined in 9.4 are performed;"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," If the full type of the object is a composite type, then after performing the above actions, if any, every component of the object is finalized in an arbitrary order, except as follows: if the object has a component with an access discriminant constrained by a per-object expression, this component is finalized before any components that do not have such discriminants; for an object with several components with such a discriminant, they are finalized in the reverse of the order of their ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-3.8#S0070"},"component_declaration")),"s; "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This allows the finalization of a component with an access discriminant to refer to other components of the enclosing object prior to their being finalized. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," The components discussed here are all of the components that the object actually has, not just those components that are statically identified by the type of the object. These can be different if the object has a class-wide type. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," If the object has coextensions (see 3.10.2), each coextension is finalized after the object whose access discriminant designates it."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0066-1"),"}"," In the case of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call that is used (in its entirety) to directly initialize a part of an object, the coextensions of the result of evaluating the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call are transfered to become coextensions of the object being initialized and are not finalized until the object being initialized is ultimately finalized, even if an anonymous object is created as part of the operation. "),(0,o.kt)("p",null,"Immediately before an instance of Unchecked_Deallocation reclaims the storage of an object, the object is finalized. [If an instance of Unchecked_Deallocation is never applied to an object created by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),", the object will still exist when the corresponding master completes, and it will be finalized then.]"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00280-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0051-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," The finalization of a master performs finalization of objects created by declarations in the master in the reverse order of their creation. After the finalization of a master is complete, the objects finalized as part of its finalization cease to ",(0,o.kt)("em",null,"exist"),", as do any types and subtypes defined and created within the master. "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"Note that a deferred constant declaration does not create the constant; the full constant declaration creates it. Therefore, the order of finalization depends on where the full constant declaration occurs, not the deferred constant declaration."),(0,o.kt)("p",null,"An imported object is not created by its declaration. It is neither initialized nor finalized. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"An implementation has to ensure that the storage for an object is not reclaimed when references to the object are still possible (unless, of course, the user explicitly requests reclamation via an instance of Unchecked_Deallocation). This implies, in general, that objects cannot be deallocated one by one as they are finalized; a subsequent finalization might reference an object that has been finalized, and that object had better be in its (well-defined) finalized state. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," Each nonderived access type ",(0,o.kt)("em",null,"T")," has an associated ",(0,o.kt)("em",null,"collection"),", which is the set of objects created by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s of ",(0,o.kt)("em",null,"T"),", or of types derived from ",(0,o.kt)("em",null,"T"),". Unchecked_Deallocation removes an object from its collection. Finalization of a collection consists of finalization of each object in the collection, in an arbitrary order. The collection of an access type is an object implicitly declared at the following place:"),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," The place of the implicit declaration determines when allocated objects are finalized. For multiple collections declared at the same place, we do not define the order of their implicit declarations."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," Finalization of allocated objects is done according to the (ultimate ancestor) ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),' type, not according to the storage pool in which they are allocated. Pool finalization might reclaim storage (see 13.11, "Storage Management"), but has nothing (directly) to do with finalization of the pool elements.'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," Note that finalization is done only for objects that still exist; if an instance of Unchecked_Deallocation has already gotten rid of a given pool element, that pool element will not be finalized when the master is left. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," Note that we talk about the type of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator"))," here. There may be access values of a (general) access type pointing at objects created by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s for some other type; these are not (necessarily) finalized at this point. "),(0,o.kt)("p",null,"For a named access type, the first freezing point (see 13.14) of the type."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," The freezing point of the ultimate ancestor access type is chosen because before that point, pool elements cannot be created, and after that point, access values designating (parts of) the pool elements can be created. This is also the point after which the pool object cannot have been declared. We don't want to finalize the pool elements until after anything finalizing objects that contain access values designating them. Nor do we want to finalize pool elements after finalizing the pool object itself. "),(0,o.kt)("p",null,"For the type of an access parameter, the call that contains the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"."),(0,o.kt)("p",null,"For the type of an access result, within the master of the call (see 3.10.2). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"{",(0,o.kt)("em",null,"AI05-0005-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," We mean at a place within the master consistent with the execution of the call within the master. We don't say that normatively, as it is difficult to explain that when the master of the call need not be the master that immediately includes the call (such as when an anonymous result is converted to a named access type). "),(0,o.kt)("p",null,"For any other anonymous access type, the first freezing point of the innermost enclosing declaration. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00256-01"),"}"," The target of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," is finalized before copying in the new value, as explained in 7.6."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0021"),"}"," ","{",(0,o.kt)("em",null,"AI95-00182-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0066-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," ","{",(0,o.kt)("em",null,"AI05-0269-1"),"}"," The master of an object is the master enclosing its creation whose accessibility level (see 3.10.2) is equal to that of the object, except in the case of an anonymous object representing the result of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call. If such an anonymous object is part of the result of evaluating the actual parameter expression for an explicitly aliased parameter of a function call, the master of the object is the innermost master enclosing the evaluation of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call, excluding the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call itself. Otherwise, the master of such an anonymous object is the innermost master enclosing the evaluation of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call, which may be the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call itself. "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"This paragraph was deleted.","\n"),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted.")),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," This effectively imports all of the special rules for the accessibility level of renames, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s, and so on, and applies them to determine where objects created in them are finalized. For instance, the master of a rename of a subprogram is that of the renamed subprogram."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0066-1"),"}"," In 3.10.2 we assign an accessibility level to the result of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call that is used to directly initialize a part of an object based on the object being initialized. This is important to ensure that any access discriminants denote objects that live at least as long as the object being initialized. However, if the result of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or function call is not built directly in the target object, but instead is built in an anonymous object that is then assigned to the target, the anonymous object needs to be finalized after the assignment rather than persisting until the target object is finalized (but not its coextensions). (Note than an implementation is never required to create such an anonymous object, and in some cases is required to ",(0,o.kt)("em",null,"not")," have such a separate object, but rather to build the result directly in the target.)"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," The special case for explicitly aliased parameters of functions is needed for the same reason, as access discriminants of the returned object may designate one of these parameters. In that case, we want to lengthen the lifetime of the anonymous objects as long as the possible lifetime of the result."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," We don't do a similar change for other kinds of calls, because the extended lifetime of the parameters adds no value, but could constitute a storage leak. For instance, such an anonymous object created by a procedure call in the elaboration part of a package body would have to live until the end of the program, even though it could not be used after the procedure returns (other than via Unchecked_Access). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," Note that the lifetime of the master given to anonymous objects in explicitly aliased parameters of functions is not necessarily as long as the lifetime of the master of the object being initialized (if the function call is used to initialize an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),", for instance). In that case, the accessibility check on explicitly aliased parameters will necessarily fail if any such anonymous objects exist. This is necessary to avoid requiring the objects to live as long as the access type or having the implementation complexity of an implicit coextension. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0066-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," In the case of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," that is a master, finalization of any (anonymous) objects occurs after completing evaluation of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression"))," and all use of the objects, prior to starting the execution of any subsequent construct."),(0,o.kt)("h4",{id:"bounded-run-time-errors"},"Bounded (Run-Time) Errors"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," It is a bounded error for a call on Finalize or Adjust that occurs as part of object finalization or assignment to propagate an exception. The possible consequences depend on what action invoked the Finalize or Adjust operation: "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"It is not a bounded error for Initialize to propagate an exception. If Initialize propagates an exception, then no further calls on Initialize are performed, and those components that have already been initialized (either explicitly or by default) are finalized in the usual way."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," It also is not a bounded error for an explicit call to Finalize or Adjust to propagate an exception. We do not want implementations to have to treat explicit calls to these routines specially. "),(0,o.kt)("p",null,"For a Finalize invoked as part of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),", Program_Error is raised at that point."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0024"),"}"," ","{",(0,o.kt)("em",null,"AI95-00193-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00256-01"),"}"," ","{",(0,o.kt)("em",null,"AI12-0445-1"),"}"," For an Adjust invoked as part of assignment operations other than those invoked as part of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),", some of the adjustments due to be performed can be performed, and then Program_Error is raised. During its propagation, finalization may be applied to objects whose Adjust failed. For an Adjust invoked as part of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),", any other adjustments due to be performed are performed, and then Program_Error is raised. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"{",(0,o.kt)("em",null,"8652/0024"),"}"," ","{",(0,o.kt)("em",null,"AI95-00193-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00256-01"),"}"," In the case of assignments that are part of initialization, there is no need to complete all adjustments if one propagates an exception, as the object will immediately be finalized. So long as a subcomponent is not going to be finalized, it need not be adjusted, even if it is initialized as part of an enclosing composite assignment operation for which some adjustments are performed. However, there is no harm in an implementation making additional Adjust calls (as long as any additional components that are adjusted are also finalized), so we allow the implementation flexibility here. On the other hand, for an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),", it is important that all adjustments be performed, even if one fails, because all controlled subcomponents are going to be finalized. Other kinds of assignment are more like initialization than ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),"s, so we include them as well in the permission. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"8652/0024"),"}"," ","{",(0,o.kt)("em",null,"AI95-00193-01"),"}"," Even if an Adjust invoked as part of the initialization of a controlled object propagates an exception, objects whose initialization (including any Adjust or Initialize calls) successfully completed will be finalized. The permission above only applies to objects whose Adjust failed. Objects for which Adjust was never even invoked must not be finalized. "),(0,o.kt)("p",null,"For a Finalize invoked as part of a call on an instance of Unchecked_Deallocation, any other finalizations due to be performed are performed, and then Program_Error is raised. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"8652/0104"),"}"," ","{",(0,o.kt)("em",null,"AI95-00179-01"),"}"," The standard does not specify if storage is recovered in this case. If storage is not recovered (and the object continues to exist), Finalize may be called on the object again (when the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"'s master is finalized). "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," ","{",(0,o.kt)("em",null,"AI05-0064-1"),"}"," "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," For a Finalize invoked due to reaching the end of the execution of a master, any other finalizations associated with the master are performed, and Program_Error is raised immediately after leaving the master."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI05-0064-1"),"}"," This rule covers both ordinary objects created by a declaration, and anonymous objects created as part of evaluating an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),". All contexts that create objects that need finalization are defined to be masters. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," For a Finalize invoked by the transfer of control of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.7#S0193"},"exit_statement")),", return statement, ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.8#S0194"},"goto_statement")),", or ",(0,o.kt)("code",null,"[requeue_statement](./AA-9.5#S0265)"),", Program_Error is raised no earlier than after the finalization of the master being finalized when the exception occurred, and no later than the point where normal execution would have continued. Any other finalizations due to be performed up to that point are performed before raising Program_Error. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"For example, upon leaving a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.6#S0191"},"block_statement"))," due to a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.8#S0194"},"goto_statement")),", the Program_Error would be raised at the point of the target statement denoted by the label, or else in some more dynamically nested place, but not so nested as to allow an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler"))," that has visibility upon the finalized object to handle it. For example, "),(0,o.kt)(i.Z,{mdxType:"CodeBlock"},"procedure Main is","\n","begin","\n","    ","<","<","The_Label",">",">","\n","    Outer_Block_Statement : declare","\n","        X : Some_Controlled_Type;","\n","    begin","\n","        Inner_Block_Statement : declare","\n","            Y : Some_Controlled_Type;","\n","            Z : Some_Controlled_Type;","\n","        begin","\n","            goto The_Label;","\n","        exception","\n","            when Program_Error =",">"," ... -- Handler number 1.","\n","        end;","\n","    exception","\n","        when Program_Error =",">"," ... -- Handler number 2.","\n","    end;","\n","exception","\n","    when Program_Error =",">"," ... -- Handler number 3.","\n","end Main;","\n"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," The ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.8#S0194"},"goto_statement"))," will first cause Finalize(Z) to be called. Suppose that Finalize(Z) propagates an exception. Program_Error will be raised after leaving Inner_Block_Statement, but before leaving Main. Thus, handler number 1 cannot handle this Program_Error; it will be handled either by handler number 2 or handler number 3. If it is handled by handler number 2, then Finalize(Y) will be done before executing the handler. If it is handled by handler number 3, then Finalize(Y) and Finalize(X) will both be done before executing the handler. "),(0,o.kt)("p",null,"For a Finalize invoked by a transfer of control that is due to raising an exception, any other finalizations due to be performed for the same master are performed; Program_Error is raised immediately after leaving the master. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," If, in the above example, the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.8#S0194"},"goto_statement"))," were replaced by a ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.3#S0308"},"raise_statement")),", then the Program_Error would be handled by handler number 2, and Finalize(Y) would be done before executing the handler. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"We considered treating this case in the same way as the others, but that would render certain ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler")),"s useless. For example, suppose the only ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler"))," is one for ",(0,o.kt)("strong",null,"others"),' in the main subprogram. If some deeply nested call raises an exception, causing some Finalize operation to be called, which then raises an exception, then normal execution "would have continued" at the beginning of the ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler")),". Raising Program_Error at that point would cause that handler's code to be skipped. One would need two nested ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler")),"s to be sure of catching such cases!"),(0,o.kt)("p",null,"On the other hand, the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-11.2#S0305"},"exception_handler"))," for a given master should not be allowed to handle exceptions raised during finalization of that master. "),(0,o.kt)("p",null,"For a Finalize invoked by a transfer of control due to an abort or selection of a terminate alternative, the exception is ignored; any other finalizations due to be performed are performed. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This case includes an asynchronous transfer of control. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"To be honest: "),"This violates the general principle that it is always possible for a bounded error to raise Program_Error (see ). "),(0,o.kt)("h4",{id:"implementation-permissions-1"},"Implementation Permissions"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0107-1"),"}"," If the execution of an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator"))," propagates an exception, any parts of the allocated object that were successfully initialized may be finalized as part of the finalization of the innermost master enclosing the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),"This allows deallocating the memory for the allocated object at the innermost master, preventing a storage leak. Otherwise, the object would have to stay around until the finalization of the collection that it belongs to, which could be the entire life of the program if the associated access type is library level. "),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0111-3"),"}"," ","{",(0,o.kt)("em",null,"AI05-0262-1"),"}"," The implementation may finalize objects created by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s for an access type whose storage pool supports subpools (see 13.11.4) as if the objects were created (in an arbitrary order) at the point where the storage pool was elaborated instead of at the first freezing point of the access type."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Ramification: "),"This allows the finalization of such objects to occur later than they otherwise would, but still as part of the finalization of the same master. Accessibility rules in 13.11.4 ensure that it is the same master (usually that of the environment task). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"{",(0,o.kt)("em",null,"AI12-0005-1"),"}",' This permission is intended to allow the allocated objects to "belong" to the subpool objects and to allow those objects to be finalized at the time that the storage pool is finalized (if they are not finalized earlier). This is expected to ease implementation, as the remaining yet-to-be deallocated objects will only need to be accessible at run time from the subpool header and not also from the overall access type collection header. That is, they only need to belong to a single list, rather than two. '),(0,o.kt)("p",null,"NOTE 1   ","{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," The rules of Clause 10 imply that immediately prior to partition termination, Finalize operations are applied to library-level controlled objects (including those created by ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s of library-level access types, except those already finalized). This occurs after waiting for library-level tasks to terminate. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"We considered defining a pragma that would apply to a controlled type that would suppress Finalize operations for library-level objects of the type upon partition termination. This would be useful for types whose finalization actions consist of simply reclaiming global heap storage, when this is already provided automatically by the environment upon program termination. "),(0,o.kt)("p",null,"NOTE 2   A constant is only constant between its initialization and finalization. Both initialization and finalization are allowed to change the value of a constant."),(0,o.kt)("p",null,"NOTE 3   Abort is deferred during certain operations related to controlled types, as explained in 9.8. Those rules prevent an abort from causing a controlled object to be left in an ill-defined state."),(0,o.kt)("p",null,"NOTE 4   The Finalize procedure is called upon finalization of a controlled object, even if Finalize was called earlier, either explicitly or as part of an assignment; hence, if a controlled type is visibly controlled (implying that its Finalize primitive is directly callable), or is nonlimited (implying that assignment is allowed), its Finalize procedure is ideally designed to have no ill effect if it is applied a second time to the same object. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),'Or equivalently, a Finalize procedure should be "idempotent"; applying it twice to the same object should be equivalent to applying it once. '),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Reason: "),'A user-written Finalize procedure should be idempotent since it can be called explicitly by a client (at least if the type is "visibly" controlled). Also, Finalize is used implicitly as part of the ',(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," if the type is nonlimited, and an abort is permitted to disrupt an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," between finalizing the left-hand side and assigning the new value to it (an abort is not permitted to disrupt an assignment operation between copying in the new value and adjusting it). "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Discussion: "),"{",(0,o.kt)("em",null,"AI95-00287-01"),"}"," Either Initialize or Adjust, but not both, is applied to (almost) every controlled object when it is created: Initialize is done when no initial value is assigned to the object, whereas Adjust is done as part of assigning the initial value. The one exception is the object initialized by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," (both the anonymous object created for an aggregate, or an object initialized by an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," that is built-in-place); Initialize is not applied to the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," as a whole, nor is the value of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," or object adjusted."),(0,o.kt)("p",null,"All of the following use the assignment operation, and thus perform value adjustment: "),(0,o.kt)("p",null,"the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement"))," (see 5.2);"),(0,o.kt)("p",null,"explicit initialization of a stand-alone object (see 3.3.1) or of a pool element (see 4.8);"),(0,o.kt)("p",null,"default initialization of a component of a stand-alone object or pool element (in this case, the value of each component is assigned, and therefore adjusted, but the value of the object as a whole is not adjusted);"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," function return, when the result is not built-in-place (adjustment of the result happens before finalization of the function);"),(0,o.kt)("p",null,"predefined operators (although the only one that matters is concatenation; see 4.5.3);"),(0,o.kt)("p",null,"generic formal objects of mode ",(0,o.kt)("strong",null,"in")," (see 12.4); these are defined in terms of constant declarations; and"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00287-01"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"s (see 4.3), when the result is not built-in-place (in this case, the value of each component, and the ancestor part, for an ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0111"},"extension_aggregate")),", is assigned, and therefore adjusted, but the value of the ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," as a whole is not adjusted; neither is Initialize called); "),(0,o.kt)("p",null,"The following also use the assignment operation, but adjustment never does anything interesting in these cases: "),(0,o.kt)("p",null,"By-copy parameter passing uses the assignment operation (see 6.4.1), but controlled objects are always passed by reference, so the assignment operation never does anything interesting in this case. If we were to allow by-copy parameter passing for controlled objects, we would need to make sure that the actual is finalized before doing the copy back for [",(0,o.kt)("strong",null,"in"),"] ",(0,o.kt)("strong",null,"out")," parameters. The finalization of the parameter itself needs to happen after the copy back (if any), similar to the finalization of an anonymous function return object or ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate"))," object."),(0,o.kt)("p",null,(0,o.kt)("strong",null,"For")," loops use the assignment operation (see 5.5), but since the type of the loop parameter is never controlled, nothing interesting happens there, either."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00318-02"),"}"," Objects initialized by function results and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.3#S0106"},"aggregate")),"s that are built-in-place. In this case, the assignment operation is never executed, and no adjustment takes place. While built-in-place is always allowed, it is required for some types - see 7.5 and 7.6 - and that's important since limited types have no Adjust to call. "),(0,o.kt)("p",null,(0,o.kt)("em",null,"This paragraph was deleted."),"{",(0,o.kt)("em",null,"AI95-00287-01"),"}"," "),(0,o.kt)("p",null,"Finalization of the parts of a protected object are not done as protected actions. It is possible (in pathological cases) to create tasks during finalization that access these parts in parallel with the finalization itself. This is an erroneous use of shared variables. "),(0,o.kt)("p",null,(0,o.kt)("strong",null,"Implementation Note: "),"One implementation technique for finalization is to chain the controlled objects together on a per-task list. When leaving a master, the list can be walked up to a marked place. The links needed to implement the list can be declared (privately) in types Controlled and Limited_Controlled, so they will be inherited by all controlled types."),(0,o.kt)("p",null,'Another implementation technique, which we refer to as the "PC-map" approach essentially implies inserting exception handlers at various places, and finalizing objects based on where the exception was raised.'),(0,o.kt)("p",null,"The PC-map approach is for the compiler/linker to create a map of code addresses; when an exception is raised, or abort occurs, the map can be consulted to see where the task was executing, and what finalization needs to be performed. This approach was given in the Ada 83 Rationale as a possible implementation strategy for exception handling - the map is consulted to determine which exception handler applies."),(0,o.kt)("p",null,"If the PC-map approach is used, the implementation must take care in the case of arrays. The generated code will generally contain a loop to initialize an array. If an exception is raised part way through the array, the components that have been initialized must be finalized, and the others must not be finalized."),(0,o.kt)("p",null,"It is our intention that both of these implementation methods should be possible. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0299-1"),"}"," Finalization depends on the concepts of completion and leaving, and on the concept of a master. Therefore, we have moved the definitions of these concepts here, from where they used to be in Clause 9. These concepts also needed to be generalized somewhat. Task waiting is closely related to user-defined finalization; the rules here refer to the task-waiting rules of Clause 9. "),(0,o.kt)("h4",{id:"inconsistencies-with-ada-95"},"Inconsistencies With Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0066-1"),"}"," ",(0,o.kt)("strong",null,"Ada 2012 Correction:")," Changed the definition of the master of an anonymous object used to directly initialize an object, so it can be finalized immediately rather than having to hang around as long as the object. In this case, the Ada 2005 definition was inconsistent with Ada 95, and Ada 2012 changes it back. It is unlikely that many compilers implemented the rule as written in Amendment 1, so an inconsistency is unlikely to arise in practice. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-95-1"},"Wording Changes from Ada 95"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0021"),"}"," ","{",(0,o.kt)("em",null,"AI95-00182-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Fixed the wording to say that anonymous objects aren't finalized until the object can't be used anymore."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0023"),"}"," ","{",(0,o.kt)("em",null,"AI95-00169-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Added wording to clarify what happens when Adjust or Finalize raises an exception; some cases had been omitted."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"8652/0024"),"}"," ","{",(0,o.kt)("em",null,"AI95-00193-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00256-01"),"}"," ",(0,o.kt)("strong",null,"Corrigendum:")," Stated that if Adjust raises an exception during initialization, nothing further is required. This is corrected in Ada 2005 to include all kinds of assignment other than ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.2#S0173"},"assignment_statement")),"s."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00162-01"),"}"," ","{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," Revised the definition of master to include ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.4#S0132"},"expression")),"s and ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-5.1#S0167"},"statement")),"s, in order to cleanly define what happens for tasks and controlled objects created as part of a subprogram call. Having done that, all of the special wording to cover those cases is eliminated (at least until the Ada comments start rolling in)."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00280-01"),"}"," We define ",(0,o.kt)("em",null,"finalization of the collection"),' here, so as to be able to conveniently refer to it in other rules (especially in 4.8, "Allocators").'),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI95-00416-01"),"}"," Clarified that a coextension is finalized at the same time as the outer object. (This was intended for Ada 95, but since the concept did not have a name, it was overlooked.) "),(0,o.kt)("h4",{id:"inconsistencies-with-ada-2005"},"Inconsistencies With Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0051-1"),"}"," ","{",(0,o.kt)("em",null,"AI05-0190-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Better defined when objects allocated from anonymous access types are finalized. This could be inconsistent if objects are finalized in a different order than in an Ada 2005 implementation and that order caused different program behavior; however programs that depend on the order of finalization within a single master are already fragile and hopefully are rare. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-2005-1"},"Wording Changes from Ada 2005"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0064-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Removed a redundant rule, which is now covered by the additional places where masters are defined."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0099-1"),"}"," ","{",(0,o.kt)("em",null,"AI12-0005-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Clarified the finalization rules so that there is no doubt that privacy is ignored, and to ensure that objects of class-wide interface types are finalized based on their specific concrete type."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0107-1"),"}"," ",(0,o.kt)("strong",null,"Correction:")," Allowed premature finalization of parts of failed ",(0,o.kt)("code",null,(0,o.kt)("a",{href:"./AA-4.8#S0164"},"allocator")),"s. This could be an inconsistency, but the previous behavior is still allowed and there is no requirement that implementations take advantage of the permission."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0111-3"),"}"," Added a permission to finalize an object allocated from a subpool later than usual."),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI05-0142-4"),"}"," Added text to specially define the master of anonymous objects which are passed as explicitly aliased parameters (see 6.1) of functions. The model for these parameters is explained in detail in 6.4.1. "),(0,o.kt)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012"),(0,o.kt)("p",null,"{",(0,o.kt)("em",null,"AI12-0406-1"),"}"," ",(0,o.kt)("strong",null,"Correction:"),' Defined the term "master construct", so as to put static accessibility rules on a firmer basis, including ensuring that those rules apply inside of generic bodies. '))}u.isMDXComponent=!0}}]);