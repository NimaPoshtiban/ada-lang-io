"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[3118],{25022:(l,e,n)=>{n.r(e),n.d(e,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>g,metadata:()=>u,toc:()=>a});var t=n(58168),y=(n(96540),n(15680)),d=n(21432);const g={sidebar_position:6},o="Syntax Cheat Sheet",u={unversionedId:"learn/cheat-sheet",id:"learn/cheat-sheet",title:"Syntax Cheat Sheet",description:"Names used in examples",source:"@site/docs/learn/cheat-sheet.mdx",sourceDirName:"learn",slug:"/learn/cheat-sheet",permalink:"/docs/learn/cheat-sheet",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Using UTF-8 encoding in GNAT",permalink:"/docs/learn/how-tos/gnat_and_utf_8"},next:{title:"Glossary",permalink:"/docs/learn/glossary"}},r={},a=[{value:"Names used in examples",id:"names-used-in-examples",level:2},{value:"Overview",id:"overview",level:2},{value:"Program Structure",id:"program-structure",level:2},{value:"Memory",id:"memory",level:2},{value:"Special Notations",id:"special-notations",level:2},{value:"Expressions",id:"expressions",level:2},{value:"Mathematics",id:"mathematics",level:2},{value:"Control Flow",id:"control-flow",level:2},{value:"Boolean Algebra",id:"boolean-algebra",level:2},{value:"Functions and Procedures",id:"functions-and-procedures",level:2},{value:"Types",id:"types",level:2},{value:"Object-Oriented Programming",id:"object-oriented-programming",level:2}],i={toc:a},s="wrapper";function c(l){let{components:e,...n}=l;return(0,y.yg)(s,(0,t.A)({},i,n,{components:e,mdxType:"MDXLayout"}),(0,y.yg)("h1",{id:"syntax-cheat-sheet"},"Syntax Cheat Sheet"),(0,y.yg)("h2",{id:"names-used-in-examples"},"Names used in examples"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,(0,y.yg)("strong",null,"Concept")),(0,y.yg)("td",null,(0,y.yg)("strong",null,"Ada"))),(0,y.yg)("tr",null,(0,y.yg)("td",null," Reference "),(0,y.yg)("td",null," Access ")),(0,y.yg)("tr",null,(0,y.yg)("td",null," Pointer "),(0,y.yg)("td",null," Access All ")),(0,y.yg)("tr",null,(0,y.yg)("td",null," Namespace "),(0,y.yg)("td",null," P, Q, R ")),(0,y.yg)("tr",null,(0,y.yg)("td",null," Class "),(0,y.yg)("td",null," Capricorn ")),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Struct "),(0,y.yg)("td",null," Scorpio ")),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Type "),(0,y.yg)("td",null," S, T, V, W ")),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Variables "),(0,y.yg)("td",null," A, B, C ")),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Function "),(0,y.yg)("td",null," Foo, Bar "))),(0,y.yg)("h2",{id:"overview"},"Overview"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Identifiers "),(0,y.yg)("td",null,"Can't start with number or underscore, ",(0,y.yg)("strong",null,"case insensitive"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Keywords "),(0,y.yg)("td",null,"Case insensitive, usually lower case ")),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Naming Conventions(s) "),(0,y.yg)("td",null,(0,y.yg)("code",null,"Ada_Case"),"(types and functions), ",(0,y.yg)("code",null,"keywords"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Declaration file "),(0,y.yg)("td",null,(0,y.yg)("code",null,"FileName.ads"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Definition file "),(0,y.yg)("td",null,(0,y.yg)("code",null,"FileName.adb"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Dependency "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"with Package.Child;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Line comment "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"-- line comment"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Block comment "),(0,y.yg)("td",null,(0,y.yg)("strong",null,"N/A"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Inline docs "),(0,y.yg)("td",null," Line comment before or after element "))),(0,y.yg)("h2",{id:"program-structure"},"Program Structure"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Compile-time config"),(0,y.yg)("td",null,(0,y.yg)("strong",null,"N/A"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Static assert"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Assert(cond);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Assert(cond, message);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Namespacing"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"package P"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Child Namespaces"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"package P.R"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Namespacing"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"package P"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Namespace aliasing"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"package TIO renames Ada.Text_IO;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Using namespace"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"use Ada.Text_IO;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Using subprograms of type"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"use type T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Scope resolution"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"P.Q.R"))),(0,y.yg)("tr",null,(0,y.yg)("td",null),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"private with Q;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"limited with P;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"private package P;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Ensuring module has no state"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"package P with Pure"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"No module initialization required"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Preelaborate(P);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Ensure elaboration immediately after specification"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Elaborate_Body;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Ensure other package is initialized before this one"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Elaborate(P);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Ensure other package and all dependencies are initialized before this one."),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Elaborate_All(P);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Prevent a dependency on another package"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Restrictions(No_Dependencies => Other_Package)")))),(0,y.yg)("h2",{id:"memory"},"Memory"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pointer "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : access all T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pointer to allocation from a specific pool"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : access T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pointer deference "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr.all"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Reference "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : not null access T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Variable used by Pointer "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A: aliased T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Address "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : access T := T'Access(A)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Address "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : access all T := T'Unchecked_Access(A)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Constant pointer "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : constant access T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pointer to constant "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : access constant T;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Constant pointer to constant "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Ptr : constant access constant T"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Prevents allocations to anonymous access types."),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Restrictions(No_Implicit_Heap_Allocation)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"pragma Restrictions(No_Anonymous_Allocators)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Dynamic allocation "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A : access T := new T;")))),(0,y.yg)("h2",{id:"special-notations"},"Special Notations"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Equality "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A = B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Inequality "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A /= B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Assignment "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A := B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Array Access "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A(i)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Range "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"min .. max"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,'"Box" '),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"<>"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Exponentiation "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Base ** Exponent"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Discrete type "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"(<>)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,'"Tick" '),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"'"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"String Concatenation"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A & B")))),(0,y.yg)("h2",{id:"expressions"},"Expressions"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"qualified expression "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"for all A of B => expr"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"qualified expression "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"for some A of B => expr"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"if expression "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A : Boolean := (if A then B else C);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"case expression "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A : Integer = (case Value is","\n   ","when 0 => 1,","\n   ","when 1 => 1,","\n   ","when 2 .. 4 => 5,","\n   ","when 5 | 9 => 10,","\n   ","when others => 0);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Expression renaming "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"L2 : Float renames V.Length * V.Length;")))),(0,y.yg)("h2",{id:"mathematics"},"Mathematics"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Modify in-place "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A := A + 1;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Modulus "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"mod"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Remainder "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"rem"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Exponentiation "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A ** B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Bit shifting "),(0,y.yg)("td",null,"In standard library "))),(0,y.yg)("h2",{id:"control-flow"},"Control Flow"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"if "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"if A then","\n   ","statements;","\n","elsif B then","\n   ","statements;","\n","else","\n   ","statements;","\n","end if;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"while "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"while A loop","\n    ","statements;","\n","end loop;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"do-while"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"loop","\n","   ","-- statements","\n","   ","exit when A;","\n","end loop;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"value-based loop"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"for Value in 0 .. 99 loop","\n","   ","statements;","\n","end loop;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"iterator-based loop"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"for Elem of Container loop","\n","   ","statements;","\n","end loop;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Multiple choice"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"case Value is","\n","   ","when 0 => Handle_Zero;","\n","   ","when 1 => Handle_One;","\n","   ","when 2 .. 4 =>","\n","      ","Handle_Range;","\n","   ","when 7 | 9 =>","\n","      ","Handle_Choices;","\n","   ","when others => Handle_Default;","\n","end case;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Iterate over enum"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"for Elem in EnumName loop","\n   ","statements;","\n","end loop;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Stop iterating"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"exit"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Start exception handling "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"declare","\n   ","statements;","\n","exception","\n   ","when A =>","\n      ","statements;","\n   ","when others =>","\n      ","statements;","\n","end;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Empty statement (pass) "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"null;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Label "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"<<LABEL_NAME>>"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"goto "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"goto LABEL_NAME")))),(0,y.yg)("h2",{id:"boolean-algebra"},"Boolean Algebra"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Equality "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A = B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Inequality "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A /= B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Not "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"not A"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Boolean operators "),(0,y.yg)("td",null)),(0,y.yg)("tr",null,(0,y.yg)("td",null,"or "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A or B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"and "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A and B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Short circuiting boolean operators "),(0,y.yg)("td",null)),(0,y.yg)("tr",null,(0,y.yg)("td",null,"or"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A or else B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"and"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A and then B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Exclusive-Or (XOR) "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A xor B"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Implies (not A, or B) "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"(if A then B)")))),(0,y.yg)("h2",{id:"functions-and-procedures"},"Functions and Procedures"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Procedure"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo(X: in T; Y: in V) is","\n","   ","begin","\n","   ","statements;","\n","end Foo;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Function "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"function Fibonacci(X: Natural) return Natural is","\n","   ","if X = 0 or X = 1 then","\n","      ","return X;","\n","   ","else","\n","      ","return Fibonacci(X - 1) + Fibonacci(X - 2);","\n","   ","end if;","\n","end Fibonacci;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Subprogram call (no parameters)"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Subprogram call with named Parameters "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Foo(Bar1 => Value, Baz => Value2)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Override specifier "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"overriding procedure Foo(obj : in Object)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Ensure that a subprogram definition does not override an existing one"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"not overriding procedure Foo(obj : in Object)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pass by pointer"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo (B : in access Bar)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Pass by reference"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo(B : in Bar)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Inline "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo with Inline"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Using functions for a type unqualified.        "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"use type P.Foo;      -- Make primitive ops visible"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"                         "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"use all type P.Foo;  -- Make all ops visible for type"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Modifiable parameters    "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo(B : in out Bar)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Expression function      "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"function Foo return T is (expr)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Empty procedure          "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo is null;")))),(0,y.yg)("h2",{id:"types"},"Types"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Statically sized array "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type Buffer is array(1 .. 128) of Integer;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Array Access "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A(i)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Multi-dimensional Array "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"Mat4 : array (1 .. 4, 1 .. 4) of Float;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Built-In Variable length array"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type Buffer is array(1 .. N) of Integer;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Semantic type "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type Microseconds is new Integer;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Range checks on type "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type My_Positive is range 1 .. 10;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Size "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"T'Size"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Alignment "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"T'Alignment"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Type Aliasing "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"subtype T is W;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Type parameterized by value (run-time)"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type S(T: t) is record -- ..."))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Enum range "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A'Range"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Membership test "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A in E"))),(0,y.yg)("tr",null,(0,y.yg)("td",null," "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A not in E"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Type invariant checks "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type T is new V with Type_Invariant => Expr(T)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Sum types "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type S is (T, V, W);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Coercion (casting) "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A := B(C);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Coercion with constraint check(casting) "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A := B'(C);")))),(0,y.yg)("h2",{id:"object-oriented-programming"},"Object-Oriented Programming"),(0,y.yg)("table",null,(0,y.yg)("tr",null,(0,y.yg)("td",null,"Class-like "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type T is private;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Abstract class "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type T is interface;","\n\n","function Foo(A : T) return V is abstract;","\n","procedure Bar(A: in out T) is abstract;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Subprogram call of object-like type"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A.B;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Subprogram call of object-like type (alternative function-style form)"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"B (A);"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Member access from pointer"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A.all.B; -- Explicit"))),(0,y.yg)("tr",null,(0,y.yg)("td",null," "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"A.B; -- Implicit"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Prevent copying "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type X is limited type;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Inheritance "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type Foo is Bar with null record;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Dynamic dispatch (virtual function call)"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo(A : T'Class)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Prevent implicit cast "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type T is new W;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Runtime type checking "),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"if A in T then end if;"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Passing parameter by base class"),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"procedure Foo(A : BaseClass'Class)"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Array-like indexing of user-defined type."),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type My_Container is tagged type with","\n   ","Constant_Indexing =>Foo","\n   ","Variable_Indexing => Bar","\n   ","-- Foo and Bar are functions defined on the type."))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Automatic dereference of a handle-type to the handle's contents."),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type Handle(Target: not null access Element) is with Implicit_Dereference => Element;","\n","-- Old usage, calling Foo A_Handle.Target.all.Foo","\n","-- New usage A_Handle.Foo","\n"))),(0,y.yg)("tr",null,(0,y.yg)("td",null,"Iterator for loops for user-defined types."),(0,y.yg)("td",null,(0,y.yg)(d.A,{mdxType:"CodeBlock"},"type My_Container with Default_Iterator => Iterate, Iterator_Element => Element_Type;","\n","type Cursor;","\n","\n","function First (M : in My_Container) return Cursor;","\n","procedure Next (C : in out Cursor);","\n","function Has_Element (C : in Cursor) return Boolean;","\n")))))}c.isMDXComponent=!0}}]);