"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9235],{5642:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>k,default:()=>A,frontMatter:()=>f,metadata:()=>y,toc:()=>T});var a=n(1716),i=n(3050),r=n(8604),o=n(7318),l=n(4768),s=Object.defineProperty,d=Object.defineProperties,m=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,g=Object.prototype.propertyIsEnumerable,c=(e,t,n)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,h=(e,t)=>{for(var n in t||(t={}))p.call(t,n)&&c(e,n,t[n]);if(u)for(var n of u(t))g.call(t,n)&&c(e,n,t[n]);return e};const f={sidebar_position:139},k="B.2 The Package Interfaces",y={unversionedId:"arm/AA-B/AA-B.2",id:"arm/AA-B/AA-B.2",title:"B.2 The Package Interfaces",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-B/AA-B.2.mdx",sourceDirName:"arm/AA-B",slug:"/arm/AA-B/AA-B.2",permalink:"/docs/arm/AA-B/AA-B.2",draft:!1,tags:[],version:"current",sidebarPosition:139,frontMatter:{sidebar_position:139},sidebar:"referenceManualSidebar",previous:{title:"B.1 Interfacing Aspects",permalink:"/docs/arm/AA-B/AA-B.1"},next:{title:"B.3 Interfacing with C and C++",permalink:"/docs/arm/AA-B/AA-B.3"}},b={},T=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4}],x={toc:T};function A(e){var t,n=e,{components:s}=n,c=((e,t)=>{var n={};for(var a in e)p.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&u)for(var a of u(e))t.indexOf(a)<0&&g.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=h(h({},x),c),d(t,m({components:s,mdxType:"MDXLayout"}))),(0,a.kt)("h1",h({},{id:"b2-the-package-interfaces"}),"B.2 The Package Interfaces"),(0,a.kt)("admonition",h({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.kt)("a",h({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)(o.Z,{mdxType:"MarginText"},"1"),(0,a.kt)("p",null,"Package Interfaces is the parent of several library packages that declare types and other entities useful for interfacing to foreign languages. It also contains some implementation-defined types that are useful across more than one language (in particular for interfacing to assembly language). ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"1.a"),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The contents of the visible part of package Interfaces and its language-defined descendants.",(0,a.kt)("br",null)),(0,a.kt)("h4",h({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"2"),(0,a.kt)("p",null,"The library package Interfaces has the following skeletal declaration: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"3/5"),(0,a.kt)(l.Z,{items:["AI12-0414-1"],mdxType:"MarginInfo"}),(0,a.kt)(r.Z,{language:"ada",mdxType:"CodeBlock"},"--  ","{","AI12-0414-1","}","\n"," package Interfaces ","\n","   with  Pure is ","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"4"),"type Integer_n is range -2**(n-1) .. 2**(n-1) - 1;  --2's complement","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"5"),"type Unsigned_n is mod 2**n;","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"6"),"function Shift_Left  (Value : Unsigned_n; Amount : Natural)","\n","      return Unsigned_n;","\n","   function Shift_Right (Value : Unsigned_n; Amount : Natural)","\n","      return Unsigned_n;","\n","   function Shift_Right_Arithmetic (Value : Unsigned_n; Amount : Natural)","\n","      return Unsigned_n;","\n","   function Rotate_Left  (Value : Unsigned_n; Amount : Natural)","\n","      return Unsigned_n;","\n","   function Rotate_Right (Value : Unsigned_n; Amount : Natural)","\n","      return Unsigned_n;","\n","   ...","\n","end Interfaces;","\n"),(0,a.kt)("h4",h({},{id:"implementation-requirements"}),"Implementation Requirements"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"7"),(0,a.kt)("p",null,"An implementation shall provide the following declarations in the visible part of package Interfaces: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"8"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Signed and modular integer types of ",(0,a.kt)("em",null,"n")," bits, if supported by the target architecture, for each ",(0,a.kt)("em",null,"n")," that is at least the size of a storage element and that is a factor of the word size. The names of these types are of the form Integer_",(0,a.kt)("em",null,"n")," for the signed types, and Unsigned_",(0,a.kt)("em",null,"n")," for the modular types; ",(0,a.kt)("br",null))),(0,a.kt)(o.Z,{mdxType:"MarginText"},"8.a"),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"For example, for a typical 32-bit machine the corresponding types might be Integer_8, Unsigned_8, Integer_16, Unsigned_16, Integer_32, and Unsigned_32.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"8.b"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"The wording above implies, for example, that Integer_16'Size = Unsigned_16'Size = 16. Unchecked conversions between same-Sized types will work as expected. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"9"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"For each such modular type in Interfaces, shifting and rotating subprograms as specified in the declaration of Interfaces above. These subprograms are Intrinsic. They operate on a bit-by-bit basis, using the binary representation of the value of the operands to yield a binary representation for the result. The Amount parameter gives the number of bits by which to shift or rotate. For shifting, zero bits are shifted in, except in the case of Shift_Right_Arithmetic, where one bits are shifted in if Value is at least half the modulus. ",(0,a.kt)("br",null))),(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.a"),(0,a.kt)(i.Z,{type:"aarm",aarm:"reason",title:"Reason: ",mdxType:"Admonition"},(0,a.kt)("strong",null),'We considered making shifting and rotating be primitive operations of all modular types. However, it is a design principle of Ada that all predefined operations should be operators (not functions named by identifiers). (Note that an early version of Ada had "',(0,a.kt)("strong",null,"abs"),'" as an identifier, but it was changed to a reserved word operator before standardization of Ada 83.) This is important because the implicit declarations would hide nonoverloadable declarations with the same name, whereas operators are always overloadable. Therefore, we would have had to make shift and rotate into reserved words, which would have been upward incompatible, or else invent new operator symbols, which seemed like too much mechanism. ',(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.b/5"),(0,a.kt)(l.Z,{items:["AI12-0264-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"{",(0,a.kt)("em",null,"AI12-0264-1"),"}"," \u201c",(0,a.kt)("br",null),"Shifting\u201d and \u201crotating\u201d have the conventional meaning. Neither of these terms is usefully defined by the usual normative references of the Reference Manual, so we provide pseudo-code here to describe the intended semantics of the above wording (all operations in these examples are using modular semantics).",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.c/5"),(0,a.kt)(r.Z,{language:"ada",mdxType:"CodeBlock"},"function Rotate_Left (Value : Unsigned_n; Amount : Natural)","\n","   return Unsigned_n is","\n","   Result : Unsigned_n := Value;","\n","   Bit : Unsigned_n range 0 .. 1;","\n","begin","\n","   for Count in 1 .. Amount loop","\n","      Bit := Result/2**(n-1); -- High-bit of Result","\n","      Result := Result*2 + Bit;","\n","   end loop;","\n","   return Result;","\n","end Rotate_Left;","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.d/5"),"function Rotate_Right (Value : Unsigned_n; Amount : Natural)","\n","   return Unsigned_n is","\n","   Result : Unsigned_n := Value;","\n","   Bit : Unsigned_n range 0 .. 1;","\n","begin","\n","   for Count in 1 .. Amount loop","\n","      Bit := Result mod 2; -- Low-bit of Result","\n","      Result := Result/2 + (Bit * 2**(n-1));","\n","   end loop;","\n","   return Result;","\n","end Rotate_Right;","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.e/5"),"function Shift_Left (Value : Unsigned_n; Amount : Natural)","\n","   return Unsigned_n is","\n","   Result : Unsigned_n := Value;","\n","begin","\n","   for Count in 1 .. Amount loop","\n","      Result := Result * 2;","\n","   end loop;","\n","   return Result;","\n","end Shift_Left;","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.f/5"),"function Shift_Right (Value : Unsigned_n; Amount : Natural)","\n","   return Unsigned_n is","\n","   Result : Unsigned_n := Value;","\n","begin","\n","   for Count in 1 .. Amount loop","\n","      Result := Result / 2;","\n","   end loop;","\n","   return Result;","\n","end Shift_Right;","\n",(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.g/5"),"function Shift_Right_Arithmetic (Value : Unsigned_n; Amount : Natural)","\n","   return Unsigned_n is","\n","   Result : Unsigned_n := Value;","\n","   Neg : constant Boolean :=","\n","      Result/2**(n-1) = 1; -- High-bit of Result","\n","begin","\n","   for Count in 1 .. Amount loop","\n","      if Neg then","\n","         Result := Result / 2 + 2**(n-1);","\n","      else","\n","         Result := Result / 2;","\n","      end if;","\n","   end loop;","\n","   return Result;","\n","end Shift_Right_Arithmetic;","\n"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"9.h/5"),(0,a.kt)(l.Z,{items:["AI12-0264-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI12-0264-1"),"}"," ",(0,a.kt)("br",null),"These generally correspond to machine instructions, although there may not be an exact match in terms of boundary conditions, as Ada requires the correct result to be produced for all values of Amount. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"10"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"Floating point types corresponding to each floating point format fully supported by the hardware. ",(0,a.kt)("br",null))),(0,a.kt)(o.Z,{mdxType:"MarginText"},"10.a"),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The names for these floating point types are not specified. However, if IEEE arithmetic is supported, then the names should be IEEE_Float_32 and IEEE_Float_64 for single and double precision, respectively.",(0,a.kt)("br",null)),(0,a.kt)("h4",h({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"11"),(0,a.kt)("p",null,"An implementation may provide implementation-defined library units that are children of Interfaces, and may add declarations to the visible part of Interfaces in addition to the ones defined above. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"11.a/2"),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-defined",title:"Implementation defined: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"Implementation-defined children of package Interfaces.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"11.1/3"),(0,a.kt)(l.Z,{items:["AI95-00204-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI95-00204-01"),"}"," ","{",(0,a.kt)("em",null,"AI05-0229-1"),"}"," ",(0,a.kt)("br",null),"A child package of package Interfaces with the name of a convention may be provided independently of whether the convention is supported by the Convention aspect and vice versa. Such a child package should contain any declarations that would be useful for interfacing to the language (implementation) represented by the convention. Any declarations useful for interfacing to any language on the given hardware architecture should be provided directly in Interfaces. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"11.b/2"),(0,a.kt)(i.Z,{type:"aarm",aarm:"ramification",title:"Ramification: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"For example, package Interfaces.XYZ_Pascal might contain declarations of types that match the data types provided by the XYZ implementation of Pascal, so that it will be more convenient to pass parameters to a subprogram whose convention is XYZ_Pascal. ",(0,a.kt)("br",null)),(0,a.kt)("h4",h({},{id:"implementation-advice"}),"Implementation Advice"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"12/2"),(0,a.kt)(l.Z,{items:["AI95-00204-01"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,(0,a.kt)("em",null,"This paragraph was deleted."),"{",(0,a.kt)("em",null,"AI95-00204-01"),"}"," ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"12.a/2"),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},(0,a.kt)("em",null,"This paragraph was deleted."),(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13/3"),(0,a.kt)(l.Z,{items:["AI05-0299-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"AI05-0299-1"),"}"," ",(0,a.kt)("br",null),"An implementation supporting an interface to C, COBOL, or Fortran should provide the corresponding package or packages described in the following subclauses. ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13.a.1/2"),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-advice",title:"Implementation Advice",mdxType:"Admonition"},(0,a.kt)("strong",null),"If an interface to C, COBOL, or Fortran is provided, the corresponding package or packages described in ",(0,a.kt)("a",{href:"../AA-B/"},"Annex B"),", \u201c",(0,a.kt)("a",{href:"../AA-B/"},"Interface to Other Languages"),"\u201d should also be provided.",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13.a"),(0,a.kt)(i.Z,{type:"aarm",aarm:"implementation-note",title:"Implementation Note: ",mdxType:"Admonition"},(0,a.kt)("strong",null),"The intention is that an implementation might support several implementations of the foreign language: Interfaces.This_Fortran and Interfaces.That_Fortran might both exist. The \u201cdefault\u201d implementation, overridable by the user, should be declared as a renaming: ",(0,a.kt)("br",null)),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13.b"),(0,a.kt)(r.Z,{language:"ada",mdxType:"CodeBlock"},"package Interfaces.Fortran renames Interfaces.This_Fortran;","\n"),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13.c/2"),(0,a.kt)(l.Z,{items:["AI95-00204-01"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI95-00204-01"),"}"," ",(0,a.kt)("br",null),"Clarified that interfacing to foreign languages is optional and has the same restrictions as a Specialized Needs Annex. ",(0,a.kt)("br",null)),(0,a.kt)("h4",h({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005"),(0,a.kt)(o.Z,{mdxType:"MarginText"},"13.d/3"),(0,a.kt)(l.Z,{items:["AI05-0262-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{type:"aarm",aarm:"note",title:"Note: ",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"AI05-0262-1"),"}"," ",(0,a.kt)("br",null),"Move the restrictions on implementations of optional features to the start of this Annex. ",(0,a.kt)("br",null)))}A.isMDXComponent=!0}}]);