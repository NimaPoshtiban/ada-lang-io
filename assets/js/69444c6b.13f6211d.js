"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[6643],{42098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>h,frontMatter:()=>m,metadata:()=>g,toc:()=>c});var a=n(58168),o=(n(96540),n(15680)),i=n(20793),l=n(91435),r=n(21432),y=n(79162),s=n(34421);const m={sidebar_position:152},d="C.6 Shared Variable Control",g={unversionedId:"arm/AA-C/AA-C.6",id:"arm/AA-C/AA-C.6",title:"C.6 Shared Variable Control",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-C/AA-C.6.mdx",sourceDirName:"arm/AA-C",slug:"/arm/AA-C/AA-C.6",permalink:"/docs/arm/AA-C/AA-C.6",draft:!1,tags:[],version:"current",sidebarPosition:152,frontMatter:{sidebar_position:152},sidebar:"referenceManualSidebar",previous:{title:"C.5 Aspect Discard_Names",permalink:"/docs/arm/AA-C/AA-C.5"},next:{title:"C.7 Task Information",permalink:"/docs/arm/AA-C/AA-C.7"}},p={},c=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Implementation Requirements",id:"implementation-requirements",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Implementation Advice",id:"implementation-advice",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Incompatibilities With Ada 2005",id:"incompatibilities-with-ada-2005",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"C.6.1  The Package System.Atomic_Operations",id:"c61--the-package-systematomic_operations",level:2},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4},{value:"C.6.2  The Package System.Atomic_Operations.Exchange",id:"c62--the-package-systematomic_operationsexchange",level:2},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-2",level:4},{value:"C.6.3  The Package System.Atomic_Operations.Test_and_Set",id:"c63--the-package-systematomic_operationstest_and_set",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-3",level:4},{value:"C.6.4  The Package System.Atomic_Operations.Integer_Arithmetic",id:"c64--the-package-systematomic_operationsinteger_arithmetic",level:2},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-4",level:4},{value:"C.6.5  The Package System.Atomic_Operations.Modular_Arithmetic",id:"c65--the-package-systematomic_operationsmodular_arithmetic",level:2},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-5",level:4}],A={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,o.yg)(u,(0,a.A)({},A,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"c6-shared-variable-control"},"C.6 Shared Variable Control"),(0,o.yg)("admonition",{type:"warning"},(0,o.yg)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/3"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI05-0299-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"[This subclause defines representation aspects that control the use of shared variables.] ",(0,o.yg)("br",null)),(0,o.yg)("p",null,(0,o.yg)("em",null,"Paragraphs 2 through 6 were moved to ",(0,o.yg)("a",{href:"../AA-J/"},"Annex J"),", \u201c",(0,o.yg)("a",{href:"../AA-J/"},"Obsolescent Features"),"\u201d.")," ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"static-semantics"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.1/5"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0282-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"For an ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration")),", a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.8#S0070"},"component_declaration")),", a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration")),", or a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-12/AA-12.5#S0321"},"formal_complete_type_declaration")),", the following representation aspects may be specified:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.2/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Atomic"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Atomic is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.a/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Atomic: "),"Declare that a type, object, or component is atomic.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.3/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Independent"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Independent is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.b/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Independent: "),"Declare that a type, object, or component is independently addressable.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.4/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Volatile"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Volatile is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.c/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Volatile: "),"Declare that a type, object, or component is volatile.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.5/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Full","_","Access","_","Only"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Full","_","Access","_","Only is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.c.1/5"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Full","_","Access","_","Only: "),"Declare that a volatile type, object, or component is full access.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.6/5"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0282-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"For a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration"))," of an array type, an ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," for an object of an anonymous array type, or the ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-12/AA-12.5#S0321"},"formal_complete_type_declaration"))," of a formal array type, the following representation aspects may be specified:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.7/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Atomic","_","Components"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Atomic","_","Components is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.d/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Atomic","_","Components: "),"Declare that the components of an array type or object are atomic.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.8/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Volatile","_","Components"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Volatile","_","Components is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.e/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Volatile","_","Components: "),"Declare that the components of an array type or object are volatile.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.9/5"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0282-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"For a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration"))," of a composite type, an ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.3#S0032"},"object_declaration"))," for an object of an anonymous composite type, or the ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-12/AA-12.5#S0321"},"formal_complete_type_declaration"))," of a formal composite type, the following representation aspect may be specified:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.10/3"),(0,o.yg)("dt",null,(0,o.yg)("br",null),"Independent","_","Components"),(0,o.yg)("dl",null,(0,o.yg)("dd",null,"The type of aspect Independent","_","Components is Boolean.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.f/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Aspect Description for "),(0,o.yg)("strong",null,"Independent","_","Components: "),"Declare that the components of an array or record type, or an array object, are independently addressable.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"6.11/5"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If any of these aspects are directly specified, the ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," shall be a static expression. If not specified for a type (including by inheritance), the Atomic, Atomic","_","Components, and Full","_","Access","_","Only aspects are False. If any of these aspects are specified True for a type, then the corresponding aspect is True for all objects of the type. If the Atomic aspect is specified True, then the aspects Volatile, Independent, and Volatile","_","Component (if defined) are True; if the Atomic","_","Components aspect is specified True, then the aspects Volatile, Volatile","_","Components, and Independent","_","Components are True. If the Volatile aspect is specified True, then the Volatile","_","Components aspect (if defined) is True, and vice versa. When not determined by one of the other aspects, or for an object by its type, the Volatile, Volatile","_","Components, Independent, and Independent","_","Components aspects are False.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.g/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"Aspects Volatile and Volatile","_","Components (when defined) are equivalent. We provide the Volatile","_","Components aspect only to give symmetry with Atomic","_","Components and Independent","_","Components aspects. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"7/3"),(0,o.yg)(s.A,{items:["AI95-00272-01","AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"An ",(0,o.yg)("em",null,"atomic")," type is one for which the aspect Atomic is True. An ",(0,o.yg)("em",null,"atomic")," object (including a component) is one for which the aspect Atomic is True, or a component of an array for which the aspect Atomic","_","Components is True for the associated type, or any object of an atomic type, other than objects obtained by evaluating a slice. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"7.a/2"),(0,o.yg)(s.A,{items:["AI95-00272-01"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"A slice of an atomic array object is not itself atomic. That's necessary as executing a read or write of a dynamic number of components in a single instruction is not possible on many targets. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"8/3"),(0,o.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"A ",(0,o.yg)("em",null,"volatile")," type is one for which the aspect Volatile is True. A ",(0,o.yg)("em",null,"volatile")," object (including a component) is one for which the aspect Volatile is True, or a component of an array for which the aspect Volatile","_","Components is True for the associated type, or any object of a volatile type. In addition, every atomic type or object is also defined to be volatile. Finally, if an object is volatile, then so are all of its subcomponents [(the same does not apply to atomic)].",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"8.1/4"),(0,o.yg)(s.A,{items:["AI05-0009-1","AI05-0229-1","AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"When True, the aspects Independent and Independent","_","Components ",(0,o.yg)("em",null,"specify as independently addressable")," the named object or component(s), or in the case of a type, all objects or components of that type. All atomic objects and aliased objects are considered to be specified as independently addressable.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"8.a/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"If the compiler cannot guarantee that an object (including a component) for which aspect Independent or aspect Independent","_","Components is True is independently addressable from any other nonoverlapping object, then the aspect specification must be rejected.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"8.b/3"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Similarly, an atomic object (including atomic components) is always independently addressable from any other nonoverlapping object. Any representation item which would prevent this from being true should be rejected, notwithstanding what this Standard says elsewhere (specifically, in the Recommended Level of Support). ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"8.2/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The Full","_","Access","_","Only aspect shall not be specified unless the associated type or object is volatile [(or atomic)]. A ",(0,o.yg)("em",null,"full access")," type is any atomic type, or a volatile type for which the aspect Full","_","Access","_","Only is True. A ",(0,o.yg)("em",null,"full access")," object (including a component) is any atomic object, or a volatile object for which the aspect Full","_","Access","_","Only is True for the object[ or its type]. A Full","_","Access","_","Only aspect is illegal if any subcomponent of the object or type is a full access object or is of a generic formal type.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"8.c/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"This last rule breaks privacy, but that is considered OK for representation clauses when there is no clear alternative. Note that atomic objects may be nested, so long as the outer atomic object does not have the Full","_","Access","_","Only aspect True. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"8.d/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,o.yg)("strong",null),"We disallow subcomponents of a generic formal type in a Full","_","Access","_","Only object or type as the actual to a formal type can be a full access type. We could have had a less restrictive rule, but such a use is unlikely as full access only objects are intended to be used to access memory-mapped devices with access restrictions, and those will need a concrete mapping not possible for generic formal types. ",(0,o.yg)("br",null))),(0,o.yg)("p",null,(0,o.yg)("em",null,"Paragraph 9 was moved to ",(0,o.yg)("a",{href:"../AA-J/"},"Annex J"),", \u201c",(0,o.yg)("a",{href:"../AA-J/"},"Obsolescent Features"),"\u201d.")," ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"legality-rules"},"Legality Rules"),(0,o.yg)(y.A,{mdxType:"MarginText"},"9.1/3"),(0,o.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If aspect Independent","_","Components is specified for a ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-3/AA-3.2#S0024"},"full_type_declaration")),", the declaration shall be that of an array or record type.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"10/4"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"It is illegal to specify either of the aspects Atomic or Atomic","_","Components to have the value True for an object or type if the implementation cannot support the indivisible and independent reads and updates required by the aspect (see below).",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"11/4"),(0,o.yg)(s.A,{items:["AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"It is illegal to specify the Size attribute of an atomic object, the Component","_","Size attribute for an array type with atomic components, or the layout attributes of an atomic component, in a way that prevents the implementation from performing the required indivisible and independent reads and updates.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"12/5"),(0,o.yg)(s.A,{items:["AI05-0142-4","AI05-0218-1","AI12-0282-1","AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If an atomic object is passed as a parameter, then the formal parameter shall either have an atomic type or allow pass by copy. If an atomic object is used as an actual for a generic formal object of mode ",(0,o.yg)("strong",null,"in out"),", then the type of the generic formal object shall be atomic. If the ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," for an Access attribute denotes an atomic object [(including a component)], then the designated type of the resulting access type shall be atomic. Corresponding rules apply to volatile objects and to full access objects.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"12.a/3"),(0,o.yg)(s.A,{items:["AI05-0142-4"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"A formal parameter allows pass by copy if it is not ",(0,o.yg)("strong",null,"aliased")," and it is of a type that allows pass by copy (that is, is not a by-reference type). ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"12.1/5"),(0,o.yg)(s.A,{items:["AI12-0128-1","AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If a nonatomic subcomponent of a full access object is passed as an actual parameter in a call then the formal parameter shall allow pass by copy (and, at run time, the parameter shall be passed by copy). A nonatomic subcomponent of a full access object shall not be used as an actual for a generic formal of mode ",(0,o.yg)("strong",null,"in out"),". The ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of an ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," for an Access attribute shall not denote a nonatomic subcomponent of a full access object.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"12.2/5"),(0,o.yg)(s.A,{items:["AI05-0218-1","AI12-0282-1","AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If the Atomic, Atomic","_","Components, Volatile, Volatile","_","Components, Independent, Independent","_","Components, or Full","_","Access","_","Only aspect is True for a generic formal type, then that aspect shall be True for the actual type. If an atomic type is used as an actual for a generic formal derived type, then the ancestor of the formal type shall be atomic. A corresponding rule applies to volatile types and similarly to full access types.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"12.3/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If a type with volatile components is used as an actual for a generic formal array type, then the components of the formal type shall be volatile. Furthermore, if the actual type has atomic components and the formal array type has aliased components, then the components of the formal array type shall also be atomic. A corresponding rule applies when the actual type has volatile full access components.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"12.b/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,o.yg)("strong",null),"The limitations on formal array types are separate for volatile and atomic because of the fact that only volatility is carried down to all subcomponents of a volatile object, while atomicity is not. The goal of both limitations is that we don't want 'Access for an access type to produce a value that designates an object whose atomicity and volatility don't agree with that of the designated type of the access type. The above rules ensure that the generic \u201csees\u201d the relevant volatility and atomicity. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"13/3"),(0,o.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"If an aspect Volatile, Volatile","_","Components, Atomic, or Atomic","_","Components is directly specified to have the value True for a stand-alone constant object, then the aspect Import shall also be specified as True for it. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"13.a"),(0,o.yg)(i.A,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,o.yg)("strong",null),"Hence, no initialization expression is allowed for such a constant. Note that a constant that is atomic or volatile because of its type is allowed. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"13.b"),(0,o.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,o.yg)("strong",null),"Stand-alone constants that are explicitly specified as Atomic or Volatile only make sense if they are being manipulated outside the Ada program. From the Ada perspective the object is read-only. Nevertheless, if imported and atomic or volatile, the implementation should presume it might be altered externally. For an imported stand-alone constant that is not atomic or volatile, the implementation can assume that it will not be altered. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"13.c/3"),(0,o.yg)(s.A,{items:["AI05-0218-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"To be honest: "),"Volatile","_","Components and Atomic","_","Components actually are aspects of the anonymous array type; this rule only applies when the aspect is specified directly on the constant object and not when the (named) array type has the aspect. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"13.1/3"),(0,o.yg)(s.A,{items:["AI05-0009-1","AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"It is illegal to specify the aspect Independent or Independent","_","Components as True for a component, object or type if the implementation cannot provide the independent addressability required by the aspect (see ",(0,o.yg)("a",{href:"../AA-9/AA-9.10"},"9.10"),").",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"13.2/3"),(0,o.yg)(s.A,{items:["AI05-0009-1","AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"It is illegal to specify a representation aspect for a component, object or type for which the aspect Independent or Independent","_","Components is True, in a way that prevents the implementation from providing the independent addressability required by the aspect.",(0,o.yg)("br",null)),(0,o.yg)("p",null,(0,o.yg)("em",null,"Paragraph 14 was moved to ",(0,o.yg)("a",{href:"../AA-J/"},"Annex J"),", \u201c",(0,o.yg)("a",{href:"../AA-J/"},"Obsolescent Features"),"\u201d.")," ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"15"),(0,o.yg)("p",null,"For an atomic object (including an atomic component) all reads and updates of the object as a whole are indivisible.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"16/3"),(0,o.yg)(s.A,{items:["AI05-0117-1","AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"All tasks of the program (on all processors) that read or update volatile variables see the same order of updates to the variables. A use of an atomic variable or other mechanism may be necessary to avoid erroneous execution and to ensure that access to nonatomic volatile variables is sequential (see ",(0,o.yg)("a",{href:"../AA-9/AA-9.10"},"9.10"),").",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"16.a/3"),(0,o.yg)(s.A,{items:["AI05-0117-1","AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,o.yg)("strong",null),"To ensure this, on a multiprocessor, any read or update of an atomic object may require the use of an appropriate memory barrier. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"16.b/3"),(0,o.yg)(s.A,{items:["AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,o.yg)("strong",null),"From ",(0,o.yg)("a",{href:"../AA-9/AA-9.10"},"9.10")," it follows that (in non-erroneous programs) accesses to variables, including those shared by multiple tasks, are always sequential. This guarantees that no task will ever see partial updates of any variable. For volatile variables (including atomic variables), the above rule additionally specifies that all tasks see the same order of updates.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"16.c/3"),(0,o.yg)(s.A,{items:["AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"If for a shared variable ",(0,o.yg)("em",null,"X"),", a read of ",(0,o.yg)("em",null,"X")," occurs sequentially after an update of ",(0,o.yg)("em",null,"X"),", then the read will return the updated value if ",(0,o.yg)("em",null,"X")," is volatile or atomic, but may or or may not return the updated value if ",(0,o.yg)("em",null,"X")," is nonvolatile. For nonvolatile accesses, a signaling action is needed in order to share the updated value.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"16.d/3"),(0,o.yg)(s.A,{items:["AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Because accesses to the same atomic variable by different tasks establish a sequential order between the actions of those tasks, implementations may be required to emit memory barriers around such updates or use atomic instructions that imply such barriers. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"17"),(0,o.yg)("p",null,"Two actions are sequential (see ",(0,o.yg)("a",{href:"../AA-9/AA-9.10"},"9.10"),") if each is the read or update of the same atomic object.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"18"),(0,o.yg)("p",null,"If a type is atomic or volatile and it is not a by-copy type, then the type is defined to be a by-reference type. If any subcomponent of a type is atomic or volatile, then the type is defined to be a by-reference type.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"19"),(0,o.yg)("p",null,"If an actual parameter is atomic or volatile, and the corresponding formal parameter is not, then the parameter is passed by copy. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"19.a"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,o.yg)("strong",null),"Note that in the case where such a parameter is normally passed by reference, a copy of the actual will have to be produced at the call-site, and a pointer to the copy passed to the formal parameter. If the actual is atomic, any copying has to use indivisible read on the way in, and indivisible write on the way out. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"19.b"),(0,o.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,o.yg)("strong",null),"It has to be known at compile time whether an atomic or a volatile parameter is to be passed by copy or by reference. For some types, it is unspecified whether parameters are passed by copy or by reference. The above rules further specify the parameter passing rules involving atomic and volatile types and objects. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"19.1/5"),(0,o.yg)(s.A,{items:["AI12-0128-1","AI12-0347-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"All reads of or writes to any nonatomic subcomponent of a full access object are performed by reading and/or writing all of the nearest enclosing full access object.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"19.c/5"),(0,o.yg)(s.A,{items:["AI12-0005-1","AI12-0128-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,o.yg)("strong",null),"}"," For example, if a 32-bit record object has four nonatomic components, each occupying one byte, then an assignment to one of those components might normally be implemented on some target machines via some sort of store","_","byte instruction; if the record object is an atomic full access object then instead a 32-bit read-modify-write must be performed. That read-modify-write need not be atomic, although the read and the write must each separately be atomic. Note that it doesn't matter whether the store","_","byte instruction would have executed atomically. This rule is needed in some cases for memory-mapped device registers. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"19.d/5"),(0,o.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,o.yg)("strong",null),"The atomic reads and writes associated with accesses to nonatomic components of a full access object that is atomic are normal atomic operations \u2014 all of the rules that apply to other atomic operations apply to these as well. In particular, these atomic reads and writes are sequential if they apply to the same object. ",(0,o.yg)("br",null))),(0,o.yg)("h4",{id:"implementation-requirements"},"Implementation Requirements"),(0,o.yg)(y.A,{mdxType:"MarginText"},"20/5"),(0,o.yg)(s.A,{items:["AI12-0128-1","AI12-0439-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The external effect of a program (see ",(0,o.yg)("a",{href:"../AA-1/AA-1.1#Subclause_1.1.3"},"1.1.3"),") is defined to include each read and update of a volatile or atomic object. The implementation shall not generate any memory reads or updates of atomic or volatile objects other than those specified by the program. However, there may be target-dependent cases where reading or writing a volatile but nonatomic object (typically a component) necessarily involves reading and/or writing neighboring storage, and that neighboring storage can overlap a volatile object. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"20.a"),(0,o.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,o.yg)("strong",null),"The presumption is that volatile or atomic objects might reside in an \u201cactive\u201d part of the address space where each read has a potential side effect, and at the very least might deliver a different value.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"20.b"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The rule above and the definition of external effect are intended to prevent (at least) the following incorrect optimizations, where V is a volatile variable: ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"20.c"),(0,o.yg)("ul",null,(0,o.yg)("li",null,"X:= V; Y:=V; cannot be allowed to be translated as Y:=V; X:=V;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.d"),(0,o.yg)("li",null,"Deleting redundant loads: X:= V; X:= V; shall read the value of V from memory twice.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.e"),(0,o.yg)("li",null,"Deleting redundant stores: V:= X; V:= X; shall write into V twice.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.f"),(0,o.yg)("li",null,"Extra stores: V:= X+Y; should not translate to something like V:= X; V:= V+Y;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.g"),(0,o.yg)("li",null,"Extra loads: X:= V; Y:= X+Z; X:=X+B; should not translate to something like Y:= V+Z; X:= V+B;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.h"),(0,o.yg)("li",null,"Reordering of loads from volatile variables: X:= V1; Y:= V2; (whether or not V1 = V2) should not translate to Y:= V2; X:= V1;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"20.i"),(0,o.yg)("li",null,"Reordering of stores to volatile variables: V1:= X; V2:= X; should not translate to V2:=X; V1:= X; ",(0,o.yg)("br",null)))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"20.j/5"),(0,o.yg)(s.A,{items:["AI12-0128-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The part about \u201ctarget-dependent cases\u201d is intended to let compilers use a read-modify-write operation when a volatile component has a size that cannot be directly read or written with the available machine instructions. (For instance, writing a Boolean component with size 1 in a volatile packed array of Boolean requires a pre-read on most existing machines.) ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"21/4"),(0,o.yg)(s.A,{items:["AI05-0229-1","AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,(0,o.yg)("em",null,"This paragraph was deleted."),(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"21.a/4"),(0,o.yg)(s.A,{items:["AI05-0009-1","AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("em",null,"This paragraph was deleted."),(0,o.yg)("br",null))),(0,o.yg)("h4",{id:"implementation-permissions"},"Implementation Permissions"),(0,o.yg)(y.A,{mdxType:"MarginText"},"21.1/5"),(0,o.yg)(s.A,{items:["AI12-0282-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Within the body of an instance of a generic unit that has a formal type ",(0,o.yg)("em",null,"T")," that is not atomic and an actual type that is atomic, if an object ",(0,o.yg)("em",null,"O")," of type ",(0,o.yg)("em",null,"T")," is declared and explicitly specified as atomic, the implementation may introduce an additional copy on passing ",(0,o.yg)("em",null,"O")," to a subprogram with a parameter of type ",(0,o.yg)("em",null,"T")," that is normally passed by reference. A corresponding permission applies to volatile parameter passing. ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"implementation-advice"},"Implementation Advice"),(0,o.yg)(y.A,{mdxType:"MarginText"},"22/5"),(0,o.yg)(s.A,{items:["AI95-00259-01","AI12-0128-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"A load or store of a volatile object whose size is a multiple of System.Storage","_","Unit and whose alignment is nonzero, should be implemented by accessing exactly the bits of the object and no others, except in the case of a volatile but nonatomic subcomponent of an atomic object. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"22.a/2"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,o.yg)("strong",null),"A load or store of a volatile object whose size is a multiple of System.Storage","_","Unit and whose alignment is nonzero, should be implemented by accessing exactly the bits of the object and no others.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"22.b/5"),(0,o.yg)(s.A,{items:["AI12-0128-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,o.yg)("strong",null),"Since any object can be a volatile object, including packed array components and bit-mapped record components, we require the above only when it is reasonable to assume that the machine can avoid accessing bits outside of the object. The exception is needed so this advice doesn't conflict with other rules of this subclauase. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"22.c/2"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,o.yg)("strong",null),"This implies that the load or store of a volatile object that meets the above requirement should not be combined with that of any other object, nor should it access any bits not belonging to any other object. This means that the suitability of the implementation for memory-mapped I/O can be determined from its documentation, as any cases where the implementation does not follow  must be documented. ",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"23/2"),(0,o.yg)(s.A,{items:["AI95-00259-01"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"A load or store of an atomic object should, where possible, be implemented by a single load or store instruction. ",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"23.a/2"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},(0,o.yg)("strong",null),"A load or store of an atomic object should be implemented by a single load or store instruction.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"24"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   An imported volatile or atomic constant behaves as a constant (i.e. read-only) with respect to other parts of the Ada program, but can still be modified by an \u201cexternal source\u201d.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"25/4"),(0,o.yg)(s.A,{items:["AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   Specifying the Pack aspect cannot override the effect of specifying an Atomic or Atomic","_","Components aspect.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26/5"),(0,o.yg)(s.A,{items:["AI12-0128-1","AI12-0440-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   When mapping an Ada object to a memory-mapped hardware register, the Ada object can be declared atomic to ensure that the compiler will read and write exactly the bits of the register as specified in the source code and no others.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.a/5"),(0,o.yg)(i.A,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,o.yg)("strong",null),"This is especially important for a write-only hardware register, as in such a case a read-modify-write cycle will not work. The only time the language guarantees such a cycle will not happen is when writing an entire atomic object. If one wants to write individual components of a write-only hardware register (assuming the hardware supports that), those also need to be declared atomic. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.b"),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Pragma Atomic replaces Ada 83's pragma Shared. The name \u201cShared\u201d was confusing, because the pragma was not used to mark variables as shared. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"wording-changes-from-ada-95"},"Wording Changes from Ada 95")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.c/2"),(0,o.yg)(s.A,{items:["AI95-00259-01"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-advice",mdxType:"Admonition"},"Added  to clarify the meaning of Atomic and Volatile in machine terms. The documentation that this advice applies will make the use of Ada implementations more predictable for low-level (such as device register) programming.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.d/2"),(0,o.yg)(s.A,{items:["AI95-00272-01"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added wording to clarify that a slice of an object of an atomic type is not atomic, just like a component of an atomic type is not (necessarily) atomic. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"incompatibilities-with-ada-2005"},"Incompatibilities With Ada 2005")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.e/3"),(0,o.yg)(s.A,{items:["AI05-0218-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,o.yg)("strong",null)," Plugged a hole involving volatile components of formal types when the formal type's component has a nonvolatile type. This was done by making certain actual types illegal for formal derived and formal array types; these types were allowed for Ada 95 and Ada 2005. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2005"},"Extensions to Ada 2005")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.f/3"),(0,o.yg)(s.A,{items:["AI05-0009-1","AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Aspects Independent and Independent","_","Components are new; they eliminate ambiguity about independent addressability.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.g/3"),(0,o.yg)(s.A,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Aspects Atomic, Atomic","_","Components, Volatile, and Volatile","_","Components are new; ",(0,o.yg)("code",null,(0,o.yg)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s Atomic, Atomic","_","Components, Volatile, and Volatile","_","Components are now obsolescent. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"wording-changes-from-ada-2005"},"Wording Changes from Ada 2005")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.h/3"),(0,o.yg)(s.A,{items:["AI05-0117-1","AI05-0275-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},'Revised the definition of volatile to eliminate overspecification and simply focus on the root requirement (that all tasks see the same view of volatile objects). This is not an inconsistency; "memory" arguably includes on-chip caches so long as those are kept consistent. Moreover, it is difficult to imagine a program that could tell the difference.',(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.i/3"),(0,o.yg)(s.A,{items:["AI05-0142-4"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added wording to take explicitly aliased parameters (see ",(0,o.yg)("a",{href:"../AA-6/AA-6.1"},"6.1"),") into account when determining the legality of parameter passing of volatile and atomic objects. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"inconsistencies-with-ada-2012"},"Inconsistencies With Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.j/5"),(0,o.yg)(s.A,{items:["AI12-0128-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Required that nonatomic components of a atomic object use a read-modify-write cycle, as well as clarifying that such a cycle is allowed for volatile objects that aren't exactly the size of a machine scalar. That can introduce a read-modify-write cycle where one was not used previously (for instance, if the components are exactly byte-sized on most machines); it is thought that this will more often fix bugs with access to hardware than it will cause them. If this is an issue, declaring the components themselves as atomic will restore the previous behavior. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.k/5"),(0,o.yg)(s.A,{items:["AI12-0282-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"These aspects now can be specified for generic formal types.",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.l/5"),(0,o.yg)(s.A,{items:["AI12-0363-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Aspect Full","_","Access","_","Only is new; it can be used to guarantee access to a complete device register for any operation even when the register is mapped to a number of components. ",(0,o.yg)("br",null))),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"wording-changes-from-ada-2012"},"Wording Changes from Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"26.m/4"),(0,o.yg)(s.A,{items:["AI12-0001-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,o.yg)("strong",null,"Corrigendum:")," Clarified that aliased objects are considered to be specified as independently addressable, and also eliminated an unnecessary rule. ",(0,o.yg)("br",null))),(0,o.yg)("a",{id:"Subclause_C.6.1"}),(0,o.yg)("h2",{id:"c61--the-package-systematomic_operations"},"C.6.1  The Package System.Atomic_Operations"),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The language-defined package System.Atomic","_","Operations is the parent of a set of child units that provide facilities for manipulating objects of atomic types and for supporting lock-free synchronization. The subprograms of this subsystem are Intrinsic subprograms (see ",(0,o.yg)("a",{href:"../AA-6/AA-6.3#Subclause_6.3.1"},"6.3.1"),") in order to provide convenient access to machine operations that can provide these capabilities if they are available in the target environment. ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"2/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The library package System.Atomic","_","Operations has the following declaration:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"3/5_C.6.1"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"package System.Atomic","_","Operations","\n","   with Pure, Nonblocking is","\n","end System.Atomic","_","Operations;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"4/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"System.Atomic","_","Operations serves as the parent of other language-defined library units that manipulate atomic objects; its declaration is empty.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"5/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"A call to a subprogram is said to be ",(0,o.yg)("em",null,"lock-free")," if the subprogram is guaranteed to return from the call while keeping the processor of the logical thread of control busy for the duration of the call.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"6/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"In each child package, a function Is","_","Lock","_","Free(...) is provided to check whether the operations of the child package can all be provided lock-free for a given object. Is","_","Lock","_","Free returns True if operations defined in the child package are lock-free when applied to the object denoted by Item, and Is","_","Lock","_","Free returns False otherwise.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012-1"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"6.a/5_C.6.1"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This package is new. ",(0,o.yg)("br",null))),(0,o.yg)("a",{id:"Subclause_C.6.2"}),(0,o.yg)("h2",{id:"c62--the-package-systematomic_operationsexchange"},"C.6.2  The Package System.Atomic_Operations.Exchange"),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The language-defined generic package System.Atomic","_","Operations.Exchange provides the following operations:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"2/5_C.6.2"),(0,o.yg)("ul",null,(0,o.yg)("li",null,"To atomically compare the value of two atomic objects, and update the first atomic object with a desired value if both objects were found to be equal, or otherwise update the second object with the value of the first object.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"3/5_C.6.2"),(0,o.yg)("li",null,"To atomically update the value of an atomic object, and then return the value that the atomic object had just prior to the update.",(0,o.yg)("br",null))),(0,o.yg)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"4/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The generic library package System.Atomic","_","Operations.Exchange has the following declaration:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"5/5_C.6.2"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"generic","\n","   type Atomic","_","Type is private with Atomic;","\n","package System.Atomic","_","Operations.Exchange","\n","   with Pure, Nonblocking is","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"6/5_C.6.2"),"function Atomic","_","Exchange (Item  : aliased in out Atomic","_","Type;","\n","                             Value : Atomic","_","Type) return Atomic","_","Type","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"7/5_C.6.2"),"function Atomic","_","Compare","_","And","_","Exchange ","\n","     (Item    : aliased in out Atomic","_","Type;","\n","      Prior   : aliased in out Atomic","_","Type;","\n","      Desired : Atomic","_","Type) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"8/5_C.6.2"),"function Is","_","Lock","_","Free (Item : aliased Atomic","_","Type) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"9/5_C.6.2"),"end System.Atomic","_","Operations.Exchange;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"10/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Atomic","_","Exchange atomically assigns the value of Value to Item, and returns the previous value of Item.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"11/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Atomic","_","Compare","_","And","_","Exchange first evaluates the value of Prior. Atomic","_","Compare","_","And","_","Exchange then performs the following steps as part of a single indivisible operation:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"12/5_C.6.2"),(0,o.yg)("ul",null,(0,o.yg)("li",null,"evaluates the value of Item;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"13/5_C.6.2"),(0,o.yg)("li",null,"compares the value of Item with the value of Prior;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"14/5_C.6.2"),(0,o.yg)("li",null,"if equal, assigns Item the value of Desired;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"15/5_C.6.2"),(0,o.yg)("li",null,"otherwise, makes no change to the value of Item.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"16/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"After these steps, if the value of Item and Prior did not match, Prior is assigned the original value of Item, and the function returns False. Otherwise, Prior is unaffected and the function returns True.",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"examples"},"Examples"),(0,o.yg)(y.A,{mdxType:"MarginText"},"17/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,(0,o.yg)("em",null,"Example of a spin lock using Atomic","_","Exchange:"),(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"18/5_C.6.2"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"type Atomic","_","Boolean is new Boolean with Atomic;","\n","package Exchange is new","\n","   Atomic","_","Operations.Exchange (Atomic","_","Type =",">"," Atomic","_","Boolean);","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"19/5_C.6.2"),"Lock : aliased Atomic","_","Boolean := False;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"20/5_C.6.2"),"...","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"21/5_C.6.2"),"begin -- Some critical section, trying to get the lock:","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"22/5_C.6.2"),"-- Obtain the lock","\n","   while Exchange.Atomic","_","Exchange (Item =",">"," Lock, Value =",">"," True) loop","\n","      null;","\n","   end loop;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"23/5_C.6.2"),"... -- Do stuff","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"24/5_C.6.2"),"Lock := False; -- Release the lock","\n","end;","\n"),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012-2"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"24.a/5_C.6.2"),(0,o.yg)(s.A,{items:["AI12-0234-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This package is new. ",(0,o.yg)("br",null))),(0,o.yg)("a",{id:"Subclause_C.6.3"}),(0,o.yg)("h2",{id:"c63--the-package-systematomic_operationstest_and_set"},"C.6.3  The Package System.Atomic_Operations.Test_and_Set"),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The language-defined package System.Atomic","_","Operations.Test","_","And","_","Set provides an operation to atomically set and clear an atomic flag object. ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"2/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The library package System.Atomic","_","Operations.Test","_","And","_","Set has the following declaration:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"3/5_C.6.3"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"package System.Atomic","_","Operations.Test","_","And","_","Set","\n","   with Pure, Nonblocking is","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"4/5_C.6.3"),"type Test","_","And","_","Set","_","Flag is mod implementation-defined","\n","      with Atomic, Default","_","Value =",">"," 0, Size =",">"," implementation-defined;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"5/5_C.6.3"),"function Atomic","_","Test","_","And","_","Set","\n","     (Item : aliased in out Test","_","And","_","Set","_","Flag) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"6/5_C.6.3"),"procedure Atomic","_","Clear","\n","     (Item : aliased in out Test","_","And","_","Set","_","Flag)","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"7/5_C.6.3"),"function Is","_","Lock","_","Free","\n","     (Item : aliased Test","_","And","_","Set","_","Flag) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"8/5_C.6.3"),"end System.Atomic","_","Operations.Test","_","And","_","Set;","\n"),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"8.a/5_C.6.3"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-defined",mdxType:"Admonition"},(0,o.yg)("strong",null),"The modulus and size of Test","_","and","_","Set","_","Flag.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"9/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Test","_","And","_","Set","_","Flag represents the state of an atomic flag object. An atomic flag object can either be considered to be set or cleared.",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"10/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Atomic","_","Test","_","And","_","Set performs an atomic test-and-set operation on Item. Item is set to some implementation-defined nonzero value. The function returns True if the previous contents were nonzero, and otherwise returns False.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"10.a/5_C.6.3"),(0,o.yg)(i.A,{type:"aarm",aarm:"implementation-defined",mdxType:"Admonition"},(0,o.yg)("strong",null),"The value used to represent the set value for Atomic","_","Test","_","and","_","Set.",(0,o.yg)("br",null))),(0,o.yg)(y.A,{mdxType:"MarginText"},"11/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"Atomic","_","Clear performs an atomic clear operation on Item. After the operation, Item contains 0. This call should be used in conjunction with Atomic","_","Test","_","And","_","Set.",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012-3"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"11.a/5_C.6.3"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This package is new. ",(0,o.yg)("br",null))),(0,o.yg)("a",{id:"Subclause_C.6.4"}),(0,o.yg)("h2",{id:"c64--the-package-systematomic_operationsinteger_arithmetic"},"C.6.4  The Package System.Atomic_Operations.Integer_Arithmetic"),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1","AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The language-defined generic package System.Atomic","_","Operations.Integer","_","Arithmetic provides operations to perform arithmetic atomically on objects of integer types. ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"2/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1","AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The generic library package System.Atomic","_","Operations.Integer","_","Arithmetic has the following declaration:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"3/5_C.6.4"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"generic","\n","   type Atomic","_","Type is range ","<",">"," with Atomic;","\n","package System.Atomic","_","Operations.Integer","_","Arithmetic","\n","   with Pure, Nonblocking is","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"4/5_C.6.4"),"procedure Atomic","_","Add (Item  : aliased in out Atomic","_","Type;","\n","                         Value : Atomic","_","Type)","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"5/5_C.6.4"),"procedure Atomic","_","Subtract (Item  : aliased in out Atomic","_","Type;","\n","                              Value : Atomic","_","Type)","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"6/5_C.6.4"),"function Atomic","_","Fetch","_","And","_","Add","\n","     (Item  : aliased in out Atomic","_","Type;","\n","      Value : Atomic","_","Type) return Atomic","_","Type","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"7/5_C.6.4"),"function Atomic","_","Fetch","_","And","_","Subtract","\n","     (Item  : aliased in out Atomic","_","Type;","\n","      Value : Atomic","_","Type) return Atomic","_","Type","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"8/5_C.6.4"),"function Is","_","Lock","_","Free (Item : aliased Atomic","_","Type) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"9/5_C.6.4"),"end System.Atomic","_","Operations.Integer","_","Arithmetic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"10/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"The operations of this package are defined as follows:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"11/5_C.6.4"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"procedure Atomic","_","Add (Item  : aliased in out Atomic","_","Type;","\n","                      Value : Atomic","_","Type)","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"12/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Item := Item + Value;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"13/5_C.6.4"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"procedure Atomic","_","Subtract (Item  : aliased in out Atomic","_","Type;","\n","                           Value : Atomic","_","Type)","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"14/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Item := Item - Value;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"15/5_C.6.4"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"function Atomic","_","Fetch","_","And","_","Add","\n","  (Item  : aliased in out Atomic","_","Type;","\n","   Value : Atomic","_","Type) return Atomic","_","Type","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"16/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Tmp := Item; Item := Item + Value; ",(0,o.yg)("strong",null,"return")," Tmp;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"17/5_C.6.4"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"function Atomic","_","Fetch","_","And","_","Subtract","\n","  (Item  : aliased in out Atomic","_","Type;","\n","   Value : Atomic","_","Type) return Atomic","_","Type","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"18/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Tmp := Item; Item := Item - Value; ",(0,o.yg)("strong",null,"return")," Tmp;",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012-4"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"18.a/5_C.6.4"),(0,o.yg)(s.A,{items:["AI12-0321-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This package is new. ",(0,o.yg)("br",null))),(0,o.yg)("a",{id:"Subclause_C.6.5"}),(0,o.yg)("h2",{id:"c65--the-package-systematomic_operationsmodular_arithmetic"},"C.6.5  The Package System.Atomic_Operations.Modular_Arithmetic"),(0,o.yg)(y.A,{mdxType:"MarginText"},"1/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The language-defined generic package System.Atomic","_","Operations.Modular","_","Arithmetic provides operations to perform arithmetic atomically on objects of modular types. ",(0,o.yg)("br",null)),(0,o.yg)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,o.yg)(y.A,{mdxType:"MarginText"},"2/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",null,"The generic library package System.Atomic","_","Operations.Modular","_","Arithmetic has the following declaration:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"3/5_C.6.5"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"generic","\n","   type Atomic","_","Type is mod ","<",">"," with Atomic;","\n","package System.Atomic","_","Operations.Modular","_","Arithmetic","\n","   with Pure, Nonblocking is","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"4/5_C.6.5"),"procedure Atomic","_","Add (Item  : aliased in out Atomic","_","Type;","\n","                         Value : Atomic","_","Type)","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"5/5_C.6.5"),"procedure Atomic","_","Subtract (Item  : aliased in out Atomic","_","Type;","\n","                              Value : Atomic","_","Type)","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"6/5_C.6.5"),"function Atomic","_","Fetch","_","And","_","Add","\n","     (Item  : aliased in out Atomic","_","Type;","\n","      Value : Atomic","_","Type) return Atomic","_","Type","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"7/5_C.6.5"),"function Atomic","_","Fetch","_","And","_","Subtract","\n","     (Item  : aliased in out Atomic","_","Type;","\n","      Value : Atomic","_","Type) return Atomic","_","Type","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"8/5_C.6.5"),"function Is","_","Lock","_","Free (Item : aliased Atomic","_","Type) return Boolean","\n","      with Convention =",">"," Intrinsic;","\n",(0,o.yg)(y.A,{mdxType:"MarginText"},"9/5_C.6.5"),"end System.Atomic","_","Operations.Modular","_","Arithmetic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"10/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"The operations of this package are defined as follows:",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"11/5_C.6.5"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"procedure Atomic","_","Add (Item  : aliased in out Atomic","_","Type;","\n","                      Value : Atomic","_","Type)","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"12/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Item := Item + Value;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"13/5_C.6.5"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"procedure Atomic","_","Subtract (Item  : aliased in out Atomic","_","Type;","\n","                           Value : Atomic","_","Type)","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"14/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Item := Item - Value;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"15/5_C.6.5"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"function Atomic","_","Fetch","_","And","_","Add","\n","  (Item  : aliased in out Atomic","_","Type;","\n","   Value : Atomic","_","Type) return Atomic","_","Type","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"16/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Tmp := Item; Item := Item + Value; ",(0,o.yg)("strong",null,"return")," Tmp;",(0,o.yg)("br",null)),(0,o.yg)(y.A,{mdxType:"MarginText"},"17/5_C.6.5"),(0,o.yg)(r.A,{language:"ada",mdxType:"CodeBlock"},"function Atomic","_","Fetch","_","And","_","Subtract","\n","  (Item  : aliased in out Atomic","_","Type;","\n","   Value : Atomic","_","Type) return Atomic","_","Type","\n","   with Convention =",">"," Intrinsic;","\n"),(0,o.yg)(y.A,{mdxType:"MarginText"},"18/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)("p",{class:"Indented4"},"Atomically performs: Tmp := Item; Item := Item - Value; ",(0,o.yg)("strong",null,"return")," Tmp;",(0,o.yg)("br",null)),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)("h4",{id:"extensions-to-ada-2012-5"},"Extensions to Ada 2012")),(0,o.yg)(l.A,{mdxType:"AnnotatedOnly"},(0,o.yg)(y.A,{mdxType:"MarginText"},"18.a/5_C.6.5"),(0,o.yg)(s.A,{items:["AI12-0364-1"],mdxType:"MarginInfo"}),(0,o.yg)(i.A,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This package is new. ",(0,o.yg)("br",null))))}h.isMDXComponent=!0}}]);