"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[5053],{1716:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(6687);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=c(a),m=i,u=h["".concat(s,".").concat(m)]||h[m]||d[m]||o;return a?n.createElement(u,r(r({ref:t},p),{},{components:a})):n.createElement(u,r({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},8494:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(9440),i=(a(6687),a(1716));const o={sidebar_position:13},r="12 Generic Units",l={unversionedId:"arm/AA-12",id:"arm/AA-12",title:"12 Generic Units",description:"We're still working on the Reference manual output.  Internal links are broken,",source:"@site/docs/arm/AA-12.md",sourceDirName:"arm",slug:"/arm/AA-12",permalink:"/docs/arm/AA-12",draft:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"11 Exceptions",permalink:"/docs/arm/AA-11"},next:{title:"13 Representation Issues",permalink:"/docs/arm/AA-13"}},s={},c=[{value:"12.1  Generic Declarations",id:"121--generic-declarations",level:2},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Examples",id:"examples",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83",level:4},{value:"12.2  Generic Bodies",id:"122--generic-bodies",level:2},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Examples",id:"examples-1",level:4},{value:"12.3  Generic Instantiation",id:"123--generic-instantiation",level:2},{value:"Language Design Principles",id:"language-design-principles",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Post-Compilation Rules",id:"post-compilation-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Inconsistencies With Ada 83",id:"inconsistencies-with-ada-83",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-1",level:4},{value:"12.4  Formal Objects",id:"124--formal-objects",level:2},{value:"Language Design Principles",id:"language-design-principles-1",level:4},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-2",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-2",level:4},{value:"12.5  Formal Types",id:"125--formal-types",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Wording Changes from Ada 83",id:"wording-changes-from-ada-83-3",level:4},{value:"12.5.1  Formal Private and Derived Types",id:"1251--formal-private-and-derived-types",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-1",level:4},{value:"12.5.2  Formal Scalar Types",id:"1252--formal-scalar-types",level:3},{value:"Syntax",id:"syntax-5",level:4},{value:"Legality Rules",id:"legality-rules-5",level:4},{value:"12.5.3  Formal Array Types",id:"1253--formal-array-types",level:3},{value:"Syntax",id:"syntax-6",level:4},{value:"Legality Rules",id:"legality-rules-6",level:4},{value:"Examples",id:"examples-4",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-2",level:4},{value:"12.5.4  Formal Access Types",id:"1254--formal-access-types",level:3},{value:"Syntax",id:"syntax-7",level:4},{value:"Legality Rules",id:"legality-rules-7",level:4},{value:"Examples",id:"examples-5",level:4},{value:"Incompatibilities With Ada 83",id:"incompatibilities-with-ada-83-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-3",level:4},{value:"12.6  Formal Subprograms",id:"126--formal-subprograms",level:2},{value:"Language Design Principles",id:"language-design-principles-2",level:4},{value:"Syntax",id:"syntax-8",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Legality Rules",id:"legality-rules-8",level:4},{value:"Static Semantics",id:"static-semantics-6",level:4},{value:"Examples",id:"examples-6",level:4},{value:"12.7  Formal Packages",id:"127--formal-packages",level:2},{value:"Syntax",id:"syntax-9",level:4},{value:"Legality Rules",id:"legality-rules-9",level:4},{value:"Static Semantics",id:"static-semantics-7",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-4",level:4},{value:"12.8  Example of a Generic Package",id:"128--example-of-a-generic-package",level:2},{value:"Examples",id:"examples-7",level:4}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"12-generic-units"},"12 Generic Units"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"We're still working on the Reference manual output.  Internal links are broken,\nas are a bunch of other things.\nSee the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"},"tracking issue"))),(0,i.kt)("p",null,"A generic unit is a program unit that is either a generic subprogram or a generic package. A generic unit is a template","[, which can be parameterized, and from which corresponding (nongeneric) subprograms or packages can be obtained]",". The resulting program units are said to be instances of the original generic unit. "),(0,i.kt)("p",null,"Glossary entry: A generic unit is a template for a (nongeneric) program unit; the template can be parameterized by objects, types, subprograms, and packages. An instance of a generic unit is created by a generic_instantiation. The rules of the language are enforced when a generic unit is compiled, using a generic contract model; additional checks are performed upon instantiation to verify the contract is met. That is, the declaration of a generic unit represents a contract between the body of the generic and instances of the generic. Generic units can be used to perform the role that macros sometimes play in other languages."),(0,i.kt)("p",null,"Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[generic unit]",", Def=","[a template for a (nongeneric) program unit]",", Note1=","[The template can be parameterized by objects, types, subprograms, and packages.]",", Note2=","[Generic units can be used to perform the role that macros sometimes play in other languages.]"," Version=","[5]",",Kind=(AddedNormal),Group=","[C]",",Term=","[generic instance]",", Def=","[a nongeneric unit created by the instantiation of a generic unit]"),(0,i.kt)("p",null,"[A generic unit is declared by a generic_declaration. This form of declaration has a generic_formal_part declaring any generic formal parameters. An instance of a generic unit is obtained as the result of a generic_instantiation with appropriate generic actual parameters for the generic formal parameters. An instance of a generic subprogram is a subprogram. An instance of a generic package is a package."),(0,i.kt)("p",null,"Generic units are templates. As templates they do not have the properties that are specific to their nongeneric counterparts. For example, a generic subprogram can be instantiated but it cannot be called. In contrast, an instance of a generic subprogram is a (nongeneric) subprogram; hence, this instance can be called but it cannot be used to produce further instances.] "),(0,i.kt)("h2",{id:"121--generic-declarations"},"12.1  Generic Declarations"),(0,i.kt)("p",null,"[A generic_declaration declares a generic unit, which is either a generic subprogram or a generic package. A generic_declaration includes a generic_formal_part declaring any generic formal parameters. A generic formal parameter can be an object; alternatively (unlike a parameter of a subprogram), it can be a type, a subprogram, or a package.]"," "),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"generic_declaration ::= generic_subprogram_declaration | generic_package_declaration"),(0,i.kt)("p",null,"generic_subprogram_declaration ::=\ngeneric_formal_part  subprogram_specification;"),(0,i.kt)("p",null,"generic_package_declaration ::=\ngeneric_formal_part  package_specification;"),(0,i.kt)("p",null,"generic_formal_part ::= generic {generic_formal_parameter_declaration | use_clause}"),(0,i.kt)("p",null,"generic_formal_parameter_declaration ::=\nformal_object_declaration\n| formal_type_declaration\n| formal_subprogram_declaration\n| formal_package_declaration"),(0,i.kt)("p",null,"The only form of subtype_indication allowed within a generic_formal_part is a subtype_mark ","[(that is, the subtype_indication shall not include an explicit constraint)]",". The defining name of a generic subprogram shall be an identifier ","[(not an operator_symbol)]",". "),(0,i.kt)("p",null,"Reason: The reason for forbidding constraints in subtype_indications is that it simplifies the elaboration of generic_declarations (since there is nothing to evaluate), and that it simplifies the matching rules, and makes them more checkable at compile time. "),(0,i.kt)("h4",{id:"static-semantics"},"Static Semantics"),(0,i.kt)("p",null,"A generic_declaration declares a generic unit - a generic package, generic procedure or generic function, as appropriate."),(0,i.kt)("p",null,'An entity is a generic formal entity if it is declared by a generic_formal_parameter_declaration. "Generic formal", or simply "formal", is used as a prefix in referring to objects, subtypes (and types), functions, procedures and packages, that are generic formal entities, as well as to their respective declarations. ','[Examples: "generic formal procedure" or a "formal integer type declaration".]'),(0,i.kt)("h4",{id:"dynamic-semantics"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a generic_declaration has no effect. "),(0,i.kt)("p",null,"NOTE 1   Outside a generic unit a name that denotes the generic_declaration denotes the generic unit. In contrast, within the declarative region of the generic unit, a name that denotes the generic_declaration denotes the current instance. "),(0,i.kt)("p",null,'Proof: This is stated officially as part of the "current instance" rule in 8.6, "The Context of Overload Resolution". See also 12.3, "Generic Instantiation". '),(0,i.kt)("p",null,"NOTE 2   Within a generic subprogram_body, the name of this program unit acts as the name of a subprogram. Hence this name can be overloaded, and it can appear in a recursive call of the current instance. For the same reason, this name cannot appear after the reserved word new in a (recursive) generic_instantiation."),(0,i.kt)("p",null,"NOTE 3   A default_expression or default_name appearing in a generic_formal_part is not evaluated during elaboration of the generic_formal_part; instead, it is evaluated when used. (The usual visibility rules apply to any name used in a default: the denoted declaration therefore has to be visible at the place of the expression.) "),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Examples of generic formal parts: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic     --  parameterless \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   Size : Natural;  --  formal object \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   Length : Integer := 200;          -- formal object with a default expression\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   Area   : Integer := Length*Length; -- formal object with a default expression\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'generic\n   type Item  is private;                       -- formal type\n   type Index is (&lt&gt);                          -- formal type\n   type Row   is array(Index range &lt&gt) of Item; -- formal type\n   with function "&lt"(X, Y : Item) return Boolean;    -- formal subprogram \n\n')),(0,i.kt)("p",null,"Examples of generic declarations declaring generic subprograms Exchange and Squaring: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Elem is private;\nprocedure Exchange(U, V : in out Elem);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'generic\n   type Item is private;\n   with function "*"(U, V : Item) return Item is &lt&gt;\nfunction Squaring(X : Item) return Item;\n\n')),(0,i.kt)("p",null,"Example of a generic declaration declaring a generic package: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Item   is private;\n   type Vector is array (Positive range &lt&gt) of Item;\n   with function Sum(X, Y : Item) return Item;\npackage On_Vectors is\n   function Sum  (A, B : Vector) return Vector;\n   function Sigma(A    : Vector) return Item;\n   Length_Error : exception;\nend On_Vectors;\n\n")),(0,i.kt)("h4",{id:"extensions-to-ada-83"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for generic_formal_parameter_declaration is modified to allow the reserved words tagged and abstract, to allow formal derived types, and to allow formal packages."),(0,i.kt)("p",null,"Use_clauses are allowed in generic_formal_parts. This is necessary in order to allow a use_clause within a formal part to provide direct visibility of declarations within a generic formal package. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'The syntax for generic_formal_parameter_declaration and formal_type_definition is split up into more named categories. The rules for these categories are moved to the appropriate clauses and subclauses. The names of the categories are changed to be more intuitive and uniform. For example, we changed generic_parameter_declaration to generic_formal_parameter_declaration, because the thing it declares is a generic formal, not a generic. In the others, we abbreviate "generic_formal" to just "formal". We can\'t do that for generic_formal_parameter_declaration, because of confusion with normal formal parameters of subprograms. '),(0,i.kt)("h2",{id:"122--generic-bodies"},"12.2  Generic Bodies"),(0,i.kt)("p",null,"The body of a generic unit (a generic body) ","[is a template for the instance bodies. The syntax of a generic body is identical to that of a nongeneric body]",". "),(0,i.kt)("p",null,'Ramification: We also use terms like "generic function body" and "nongeneric package body". '),(0,i.kt)("h4",{id:"dynamic-semantics-1"},"Dynamic Semantics"),(0,i.kt)("p",null,"The elaboration of a generic body has no other effect than to establish that the generic unit can from then on be instantiated without failing the Elaboration_Check. If the generic body is a child of a generic package, then its elaboration establishes that each corresponding declaration nested in an instance of the parent (see 10.1.1) can from then on be instantiated without failing the Elaboration_Check. "),(0,i.kt)("p",null,"NOTE 1   The syntax of generic subprograms implies that a generic subprogram body is always the completion of a declaration. "),(0,i.kt)("h4",{id:"examples-1"},"Examples"),(0,i.kt)("p",null,"Example of a generic procedure body: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Exchange(U, V : in out Elem) is  -- see 12.1\n   T : Elem;  --  the generic formal type\nbegin\n   T := U;\n   U := V;\n   V := T;\nend Exchange;\n\n")),(0,i.kt)("p",null,"Example of a generic function body: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'function Squaring(X : Item) return Item is  --  see 12.1\nbegin\n   return X*X;  --  the formal operator "*"\nend Squaring;\n\n')),(0,i.kt)("p",null,"Example of a generic package body: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body On_Vectors is  --  see 12.1\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Sum(A, B : Vector) return Vector is\n      Result : Vector(A'Range); --  the formal type Vector\n      Bias   : constant Integer := B'First - A'First;\n   begin\n      if A'Length /= B'Length then\n         raise Length_Error;\n      end if;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"      for N in A'Range loop\n         Result(N) := Sum(A(N), B(N + Bias)); -- the formal function Sum\n      end loop;\n      return Result;\n   end Sum;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   function Sigma(A : Vector) return Item is\n      Total : Item := A(A'First); --  the formal type Item\n   begin\n      for N in A'First + 1 .. A'Last loop\n         Total := Sum(Total, A(N)); --  the formal function Sum\n      end loop;\n      return Total;\n   end Sigma;\nend On_Vectors;\n\n")),(0,i.kt)("h2",{id:"123--generic-instantiation"},"12.3  Generic Instantiation"),(0,i.kt)("p",null,"[ An instance of a generic unit is declared by a generic_instantiation.]"," "),(0,i.kt)("h4",{id:"language-design-principles"},"Language Design Principles"),(0,i.kt)("p",null,'The legality of an instance should be determinable without looking at the generic body. Likewise, the legality of a generic body should be determinable without looking at any instances. Thus, the generic_declaration forms a contract between the body and the instances; if each obeys the rules with respect to the generic_declaration, then no legality problems will arise. This is really a special case of the "legality determinable via semantic dependences" Language Design Principle (see Section 10), given that a generic_instantiation does not depend semantically upon the generic body, nor vice-versa.'),(0,i.kt)("p",null,"Run-time issues are another story. For example, whether parameter passing is by copy or by reference is determined in part by the properties of the generic actuals, and thus cannot be determined at compile time of the generic body. Similarly, the contract model does not apply to Post-Compilation Rules. "),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)("p",null,"generic_instantiation ::=\npackage defining_program_unit_name is\nnew generic_package_name ","[generic_actual_part]",";\n| procedure defining_program_unit_name is\nnew generic_procedure_name ","[generic_actual_part]",";\n| function defining_designator is\nnew generic_function_name ","[generic_actual_part]",";"),(0,i.kt)("p",null,"generic_actual_part ::=\n(generic_association {, generic_association})"),(0,i.kt)("p",null,"generic_association ::=\n","[generic_formal_parameter_selector_name =",">]"," explicit_generic_actual_parameter"),(0,i.kt)("p",null,"explicit_generic_actual_parameter ::= expression | variable_name\n| subprogram_name | entry_name | subtype_mark\n| package_instance_name"),(0,i.kt)("p",null,"A generic_association is named or positional according to whether or not the generic_formal_parameter_selector_name is specified. Any positional associations shall precede any named associations. "),(0,i.kt)("p",null,'The generic actual parameter is either the explicit_generic_actual_parameter given in a generic_parameter_association for each formal, or the corresponding default_expression or default_name if no generic_parameter_association is given for the formal. When the meaning is clear from context, the term "generic actual," or simply "actual," is used as a synonym for "generic actual parameter" and also for the view denoted by one, or the value of one.'),(0,i.kt)("h4",{id:"legality-rules"},"Legality Rules"),(0,i.kt)("p",null,"In a generic_instantiation for a particular kind of program unit ","[(package, procedure, or function)]",", the name shall denote a generic unit of the corresponding kind ","[(generic package, generic procedure, or generic function, respectively)]","."),(0,i.kt)("p",null,"The generic_formal_parameter_selector_name of a generic_association shall denote a generic_formal_parameter_declaration of the generic unit being instantiated. If two or more formal subprograms have the same defining name, then named associations are not allowed for the corresponding actuals."),(0,i.kt)("p",null,"A generic_instantiation shall contain at most one generic_association for each formal. Each formal without an association shall have a default_expression or subprogram_default."),(0,i.kt)("p",null,"In a generic unit Legality Rules are enforced at compile time of the generic_declaration and generic body, given the properties of the formals. In the visible part and formal part of an instance, Legality Rules are enforced at compile time of the generic_instantiation, given the properties of the actuals. In other parts of an instance, Legality Rules are not enforced; this rule does not apply when a given rule explicitly specifies otherwise. "),(0,i.kt)("p",null,"Reason: Since rules are checked using the properties of the formals, and since these properties do not always carry over to the actuals, we need to check the rules again in the visible part of the instance. For example, only if a tagged type is limited may an extension of it have limited components in the extension_part. A formal tagged limited type is limited, but the actual might be nonlimited. Hence any rule that requires a tagged type to be limited runs into this problem. Such rules are rare; in most cases, the rules for matching of formals and actuals guarantee that if the rule is obeyed in the generic unit, then it has to be obeyed in the instance."),(0,i.kt)("p",null,'Ramification: The "properties" of the formals are determined without knowing anything about the actuals: '),(0,i.kt)("p",null,"A formal derived subtype is constrained if and only if the ancestor subtype is constrained. A formal array type is constrained if and only if the declarations says so. Other formal subtypes are unconstrained, even though they might be constrained in an instance."),(0,i.kt)("p",null,"A formal subtype can be indefinite, even though the copy might be definite in an instance."),(0,i.kt)("p",null,"A formal object of mode in is not a static constant; in an instance, the copy is static if the actual is."),(0,i.kt)("p",null,"A formal subtype is not static, even though the actual might be."),(0,i.kt)("p",null,"Formal types are specific, even though the actual can be class-wide."),(0,i.kt)("p",null,"The subtype of a formal object of mode in out is not static. (This covers the case of AI83-00878.)"),(0,i.kt)("p",null,"The subtype of a formal parameter of a formal subprogram does not provide an applicable index constraint."),(0,i.kt)("p",null,"The profile of a formal subprogram is not subtype-conformant with any other profile. "),(0,i.kt)("p",null,"A generic formal function is not static. "),(0,i.kt)("p",null,"Ramification: The exceptions to the above rule about when legality rules are enforced fall into these categories: "),(0,i.kt)("p",null,"Some rules are checked in the generic declaration, and then again in both the visible and private parts of the instance: "),(0,i.kt)("p",null,"The parent type of a record extension has to be specific (see 3.9.1). This rule is not checked in the instance body."),(0,i.kt)("p",null,"The parent type of a private extension has to be specific (see 7.3). This rule is not checked in the instance body."),(0,i.kt)("p",null,"A type with an access discriminant has to be a descendant of a type declared with limited, or be a task or protected type. This rule is irrelevant in the instance body."),(0,i.kt)("p",null,"In the declaration of a record extension, if the parent type is nonlimited, then each of the components of the record_extension_part have to be nonlimited (see 3.9.1). In the generic body, this rule is checked in an assume-the-worst manner."),(0,i.kt)("p",null,"A preelaborated library unit has to be preelaborable (see 10.2.1). In the generic body, this rule is checked in an assume-the-worst manner. "),(0,i.kt)("p",null,"For the accessibility rules, the formals have nothing to say about the property in question. Like the above rules, these rules are checked in the generic declaration, and then again in both the visible and private parts of the instance. In the generic body, we have explicit rules that essentially assume the worst (in the cases of type extensions and access-to-subprogram types), and we have runtime checks (in the case of access-to-object types). See 3.9.1, 3.10.2, and 4.6."),(0,i.kt)("p",null,"We considered runtime checks for access-to-subprogram types as well. However, this would present difficulties for implementations that share generic bodies."),(0,i.kt)("p",null,'The rules requiring "reasonable" values for static expressions are ignored when the expected type for the expression is a descendant of a generic formal type other than a generic formal derived type, and do not apply in an instance.'),(0,i.kt)("p",null,"The rule forbidding two explicit homographs in the same declarative region does not apply in an instance of a generic unit, except that it does apply in the declaration of a record extension that appears in the visible part of an instance."),(0,i.kt)("p",null,"Some rules do not apply at all in an instance, not even in the visible part: "),(0,i.kt)("p",null,"Body_stubs are not normally allowed to be multiply nested, but they can be in instances. "),(0,i.kt)("p",null,'Each rule that is an exception is marked with "generic contract issue;" look that up in the index to find them all. '),(0,i.kt)("p",null,"Ramification: The Legality Rules are the ones labeled Legality Rules. We are talking about all Legality Rules in the entire language here. Note that, with some exceptions, the legality of a generic unit is checked even if there are no instantiations of the generic unit. "),(0,i.kt)("p",null,"Ramification: The Legality Rules are described here, and the overloading rules were described earlier in this clause. Presumably, every Static Semantic Item is sucked in by one of those. Thus, we have covered all the compile-time rules of the language. There is no need to say anything special about the Post-Compilation Rules or the Dynamic Semantic Items. "),(0,i.kt)("p",null,'Discussion: Here is an example illustrating how this rule is checked: "In the declaration of a record extension, if the parent type is nonlimited, then each of the components of the record_extension_part shall be nonlimited." '),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type Parent is tagged private;\n    type Comp is limited private;\npackage G1 is\n    type Extension is new Parent with\n        record\n            C : Comp; -- Illegal!\n        end record;\nend G1;\n\n")),(0,i.kt)("p",null,"The parent type is nonlimited, and the component type is limited, which is illegal. It doesn't matter that an one could imagine writing an instantiation with the actual for Comp being nonlimited - we never get to the instance, because the generic itself is illegal."),(0,i.kt)("p",null,"On the other hand: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type Parent is tagged limited private; -- Parent is limited.\n    type Comp is limited private;\npackage G2 is\n    type Extension is new Parent with\n        record\n            C : Comp; -- OK.\n        end record;\nend G2;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Limited_Tagged is tagged limited null record;\ntype Non_Limited_Tagged is tagged null record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Limited_Untagged is limited null record;\ntype Non_Limited_Untagged is null record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Good_1 is new G2(Parent =&gt Limited_Tagged,\n                         Comp =&gt Limited_Untagged);\npackage Good_2 is new G2(Parent =&gt Non_Limited_Tagged,\n                         Comp =&gt Non_Limited_Untagged);\npackage Bad  is new G2(Parent =&gt Non_Limited_Tagged,\n                         Comp =&gt Limited_Untagged); -- Illegal!\n\n")),(0,i.kt)("p",null,"The first instantiation is legal, because in the instance the parent is limited, so the rule is not violated. Likewise, in the second instantiation, the rule is not violated in the instance. However, in the Bad instance, the parent type is nonlimited, and the component type is limited, so this instantiation is illegal. "),(0,i.kt)("h4",{id:"static-semantics-1"},"Static Semantics"),(0,i.kt)("p",null,"A generic_instantiation declares an instance; it is equivalent to the instance declaration (a package_declaration or subprogram_declaration) immediately followed by the instance body, both at the place of the instantiation. "),(0,i.kt)("p",null,'Ramification: The declaration and the body of the instance are not "implicit" in the technical sense, even though you can\'t see them in the program text. Nor are declarations within an instance "implicit" (unless they are implicit by other rules). This is necessary because implicit declarations have special semantics that should not be attached to instances. For a generic subprogram, the profile of a generic_instantiation is that of the instance declaration, by the stated equivalence. '),(0,i.kt)("p",null,'Ramification: The visible and private parts of a package instance are defined in 7.1, "Package Specifications and Declarations" and 12.7, "Formal Packages". The visible and private parts of a subprogram instance are defined in 8.2, "Scope of Declarations". '),(0,i.kt)("p",null,"The instance is a copy of the text of the template. ","[Each use of a formal parameter becomes (in the copy) a use of the actual, as explained below.]"," An instance of a generic package is a package, that of a generic procedure is a procedure, and that of a generic function is a function. "),(0,i.kt)("p",null,"Ramification: An instance is a package or subprogram (because we say so), even though it contains a copy of the generic_formal_part, and therefore doesn't look like one. This is strange, but it's OK, since the syntax rules are overloading rules, and therefore do not apply in an instance. "),(0,i.kt)("p",null,"Discussion: We use a macro-expansion model, with some explicitly-stated exceptions (see below). The main exception is that the interpretation of each construct in a generic unit (especially including the denotation of each name) is determined when the declaration and body of the generic unit (as opposed to the instance) are compiled, and in each instance this interpretation is (a copy of) the template interpretation. In other words, if a construct is interpreted as a name denoting a declaration D, then in an instance, the copy of the construct will still be a name, and will still denote D (or a copy of D). From an implementation point of view, overload resolution is performed on the template, and not on each copy."),(0,i.kt)("p",null,"We describe the substitution of generic actual parameters by saying (in most cases) that the copy of each generic formal parameter declares a view of the actual. Suppose a name in a generic unit denotes a generic_formal_parameter_declaration. The copy of that name in an instance will denote the copy of that generic_formal_parameter_declaration in the instance. Since the generic_formal_parameter_declaration in the instance declares a view of the actual, the name will denote a view of the actual."),(0,i.kt)("p",null,"Other properties of the copy (for example, staticness, classes to which types belong) are recalculated for each instance; this is implied by the fact that it's a copy."),(0,i.kt)("p",null,"Although the generic_formal_part is included in an instance, the declarations in the generic_formal_part are only visible outside the instance in the case of a generic formal package whose formal_package_actual_part is (","<",">",") - see 12.7. "),(0,i.kt)("p",null,"The interpretation of each construct within a generic declaration or body is determined using the overloading rules when that generic declaration or body is compiled. In an instance, the interpretation of each (copied) construct is the same, except in the case of a name that denotes the generic_declaration or some declaration within the generic unit; the corresponding name in the instance then denotes the corresponding copy of the denoted declaration. The overloading rules do not apply in the instance. "),(0,i.kt)("p",null,'Ramification: See 8.6, "The Context of Overload Resolution" for definitions of "interpretation" and "overloading rule".'),(0,i.kt)("p",null,"Even the generic_formal_parameter_declarations have corresponding declarations in the instance, which declare views of the actuals."),(0,i.kt)("p",null,"Although the declarations in the instance are copies of those in the generic unit, they often have quite different properties, as explained below. For example a constant declaration in the generic unit might declare a nonstatic constant, whereas the copy of that declaration might declare a static constant. This can happen when the staticness depends on some generic formal."),(0,i.kt)("p",null,'This rule is partly a ramification of the "current instance" rule in 8.6, "The Context of Overload Resolution". Note that that rule doesn\'t cover the generic_formal_part.'),(0,i.kt)("p",null,"Although the overloading rules are not observed in the instance, they are, of course, observed in the _instantiation in order to determine the interpretation of the constituents of the _instantiation."),(0,i.kt)("p",null,"Since children are considered to occur within their parent's declarative region, the above rule applies to a name that denotes a child of a generic unit, or a declaration inside such a child."),(0,i.kt)("p",null,"Since the Syntax Rules are overloading rules, it is possible (legal) to violate them in an instance. For example, it is possible for an instance body to occur in a package_specification, even though the Syntax Rules forbid bodies in package_specifications. "),(0,i.kt)("p",null,'In an instance, a generic_formal_parameter_declaration declares a view whose properties are identical to those of the actual, except as specified in 12.4, "Formal Objects" and 12.6, "Formal Subprograms". Similarly, for a declaration within a generic_formal_parameter_declaration, the corresponding declaration in an instance declares a view whose properties are identical to the corresponding declaration within the declaration of the actual. '),(0,i.kt)("p",null,'Ramification: In an instance, there are no "properties" of types and subtypes that come from the formal. The primitive operations of the type come from the formal, but these are declarations in their own right, and are therefore handled separately.'),(0,i.kt)("p",null,"Note that certain properties that come from the actuals are irrelevant in the instance. For example, if an actual type is of a class deeper in the derived-type hierarchy than the formal, it is impossible to call the additional operations of the deeper class in the instance, because any such call would have to be a copy of some corresponding call in the generic unit, which would have been illegal. However, it is sometimes possible to reach into the specification of the instance from outside, and notice such properties. For example, one could pass an object declared in the instance specification to one of the additional operations of the deeper type."),(0,i.kt)("p",null,"A formal_type_declaration can contain discriminant_specifications, a formal_subprogram_declaration can contain formal_parameter_specifications, and a formal_package_declaration can contain many kinds of declarations. These are all inside the generic unit, and have corresponding declarations in the instance."),(0,i.kt)("p",null,"This rule implies, for example, that if a subtype in a generic unit is a subtype of a generic formal subtype, then the corresponding subtype in the instance is a subtype of the corresponding actual subtype."),(0,i.kt)("p",null,"For a generic_instantiation, if a generic actual is a static ","[(scalar or string)]"," subtype, then each use of the corresponding formal parameter within the specification of the instance is considered to be static. (See AI83-00409.)"),(0,i.kt)("p",null,"Similarly, if a generic actual is a static expression and the corresponding formal parameter has a static ","[(scalar or string)]"," subtype, then each use of the formal parameter in the specification of the instance is considered to be static. (See AI83-00505.)"),(0,i.kt)("p",null,"If a primitive subprogram of a type derived from a generic formal derived tagged type is not overriding (that is, it is a new subprogram), it is possible for the copy of that subprogram in an instance to override a subprogram inherited from the actual. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T1 is tagged record ... end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type Formal is new T1;\npackage G is\n    type Derived_From_Formal is new Formal with record ... end record;\n    procedure Foo(X : in Derived_From_Formal); -- Does not override anything.\nend G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type T2 is new T1 with record ... end record;\nprocedure Foo(X : in T2);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Inst is new G(Formal =&gt T2);\n\n")),(0,i.kt)("p",null,"In the instance Inst, the declaration of Foo for Derived_From_Formal overrides the Foo inherited from T2. "),(0,i.kt)("p",null,"Implementation Note: For formal types, an implementation that shares the code among multiple instances of the same generic unit needs to beware that things like parameter passing mechanisms (by-copy vs. by-reference) and representation_clauses are determined by the actual. "),(0,i.kt)("p",null,"[Implicit declarations are also copied, and a name that denotes an implicit declaration in the generic denotes the corresponding copy in the instance. However, for a type declared within the visible part of the generic, a whole new set of primitive subprograms is implicitly declared for use outside the instance, and may differ from the copied set if the properties of the type in some way depend on the properties of some actual type specified in the instantiation. For example, if the type in the generic is derived from a formal private type, then in the instance the type will inherit subprograms from the corresponding actual type."),(0,i.kt)("p",null,"These new implicit declarations occur immediately after the type declaration in the instance, and override the copied ones. The copied ones can be called only from within the instance; the new ones can be called only from outside the instance, although for tagged types, the body of a new one can be executed by a call to an old one.] "),(0,i.kt)("p",null,'Proof: This rule is stated officially in 8.3, "Visibility". '),(0,i.kt)("p",null,'Ramification: The new ones follow from the class(es) of the formal types. For example, for a type T derived from a generic formal private type, if the actual is Integer, then the copy of T in the instance has a "+" primitive operator, which can be called from outside the instance (assuming T is declared in the visible part of the instance).'),(0,i.kt)("p",null,"AI83-00398."),(0,i.kt)("p",null,'Since an actual type is always in the class determined for the formal, the new subprograms hide all of the copied ones, except for a declaration of "/=" that corresponds to an explicit declaration of "=". Such "/=" operators are special, because unlike other implicit declarations of primitive subprograms, they do not appear by virtue of the class, but because of an explicit declaration of "=". If the declaration of "=" is implicit (and therefore overridden in the instance), then a corresponding implicitly declared "/=" is also overridden. But if the declaration of "=" is explicit (and therefore not overridden in the instance), then a corresponding implicitly declared "/=" is not overridden either, even though it\'s implicit.'),(0,i.kt)("p",null,"Note that the copied ones can be called from inside the instance, even though they are hidden from all visibility, because the names are resolved in the generic unit - visibility is irrelevant for calls in the instance. "),(0,i.kt)("p",null,"[In the visible part of an instance, an explicit declaration overrides an implicit declaration if they are homographs, as described in 8.3.]"," On the other hand, an explicit declaration in the private part of an instance overrides an implicit declaration in the instance, only if the corresponding explicit declaration in the generic overrides a corresponding implicit declaration in the generic. Corresponding rules apply to the other kinds of overriding described in 8.3. "),(0,i.kt)("p",null,"Ramification: For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Ancestor is tagged null record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n    type Formal is new Ancestor with private;\npackage G is\n    type T is new Formal with null record;\n    procedure P(X : in T); -- (1)\nprivate\n    procedure Q(X : in T); -- (2)\nend G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Actual is new Ancestor with null record;\nprocedure P(X : in Actual);\nprocedure Q(X : in Actual);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Instance is new G(Formal =&gt Actual);\n\n")),(0,i.kt)("p",null,"In the instance, the copy of P at (1) overrides Actual's P, whereas the copy of Q at (2) does not override anything; in implementation terms, it occupies a separate slot in the type descriptor. "),(0,i.kt)("p",null,"Reason: The reason for this rule is so a programmer writing an _instantiation need not look at the private part of the generic in order to determine which subprograms will be overridden. "),(0,i.kt)("h4",{id:"post-compilation-rules"},"Post-Compilation Rules"),(0,i.kt)("p",null,"Recursive generic instantiation is not allowed in the following sense: if a given generic unit includes an instantiation of a second generic unit, then the instance generated by this instantiation shall not include an instance of the first generic unit ","[(whether this instance is generated directly, or indirectly by intermediate instantiations)]",". "),(0,i.kt)("p",null,"Discussion: Note that this rule is not a violation of the generic contract model, because it is not a Legality Rule. Some implementations may be able to check this rule at compile time, but that requires access to all the bodies, so we allow implementations to check the rule at link time. "),(0,i.kt)("h4",{id:"dynamic-semantics-2"},"Dynamic Semantics"),(0,i.kt)("p",null,"For the elaboration of a generic_instantiation, each generic_association is first evaluated. If a default is used, an implicit generic_association is assumed for this rule. These evaluations are done in an arbitrary order, except that the evaluation for a default actual takes place after the evaluation for another actual if the default includes a name that denotes the other one. Finally, the instance declaration and body are elaborated. "),(0,i.kt)("p",null,"Ramification: Note that if the evaluation of a default depends on some side effect of some other evaluation, the order is still arbitrary. "),(0,i.kt)("p",null,"For the evaluation of a generic_association the generic actual parameter is evaluated. Additional actions are performed in the case of a formal object of mode in (see 12.4). "),(0,i.kt)("p",null,'To be honest: Actually, the actual is evaluated only if evaluation is defined for that kind of construct - we don\'t actually "evaluate" subtype_marks. '),(0,i.kt)("p",null,"NOTE   If a formal type is not tagged, then the type is treated as an untagged type within the generic body. Deriving from such a type in a generic body is permitted; the new type does not get a new tag value, even if the actual is tagged. Overriding operations for such a derived type cannot be dispatched to from outside the instance. "),(0,i.kt)("p",null,"Ramification: If two overloaded subprograms declared in a generic package specification differ only by the (formal) type of their parameters and results, then there exist legal instantiations for which all calls of these subprograms from outside the instance are ambiguous. For example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type A is (&lt&gt);\n   type B is private;\npackage G is\n   function Next(X : A) return A;\n   function Next(X : B) return B;\nend G;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package P is new G(A =&gt Boolean, B =&gt Boolean);\n-- All calls of P.Next are ambiguous.\n\n")),(0,i.kt)("p",null,"Ramification: The following example illustrates some of the subtleties of the substitution of formals and actuals: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'generic\n    type T1 is private;\n    -- A predefined "=" operator is implicitly declared here:\n    -- function "="(Left, Right : T1) return Boolean;\n    -- Call this "="1.\npackage G is\n    subtype S1 is T1; -- So we can get our hands on the type from\n                      -- outside an instance.\n    type T2 is new T1;\n    -- An inherited "=" operator is implicitly declared here:\n    -- function "="(Left, Right : T2) return Boolean;\n    -- Call this "="2.\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    T1_Obj : T1 := ...;\n    Bool_1 : Boolean := T1_Obj = T1_Obj;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"    T2_Obj : T2 := ...;\n    Bool_2 : Boolean := T2_Obj = T2_Obj;\nend G;\n...\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package P is\n    type My_Int is new Integer;\n    -- A predefined "=" operator is implicitly declared here:\n    -- function "="(Left, Right : My_Int) return Boolean;\n    -- Call this "="3.\n    function "="(X, Y : My_Int) return Boolean;\n    -- Call this "="4.\n    -- "="3 is hidden from all visibility by "="4.\n    -- Nonetheless, "="3 can "reemerge" in certain circumstances.\nend P;\nuse P;\n...\npackage I is new G(T1 =&gt My_Int); -- "="5 is declared in I (see below).\nuse I;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Another_T1_Obj : S1 := 13; -- Can't denote T1, but S1 will do.\nBool_3 : Boolean := Another_T1_Obj = Another_T1_Obj;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Another_T2_Obj : T2 := 45;\nBool_4 : Boolean := Another_T2_Obj = Another_T2_Obj;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Double : T2 := T2_Obj + Another_T2_Obj;\n\n")),(0,i.kt)("p",null,'In the instance I, there is a copy of "="1 (call it "="1i) and "="2 (call it "="2i). The "="1i and "="2i declare views of the predefined "=" of My_Int (that is, "="3). In the initialization of Bool_1 and Bool_2 in the generic unit G, the names "=" denote "="1 and "="2, respectively. Therefore, the copies of these names in the instances denote "="1i and "="2i, respectively. Thus, the initialization of I.Bool_1 and I.Bool_2 call the predefined equality operator of My_Int; they will not call "="4.'),(0,i.kt)("p",null,'The declarations "="1i and "="2i are hidden from all visibility. This prevents them from being called from outside the instance.'),(0,i.kt)("p",null,'The declaration of Bool_3 calls "="4.'),(0,i.kt)("p",null,'The instance I also contains implicit declarations of the primitive operators of T2, such as "=" (call it "="5) and "+". These operations cannot be called from within the instance, but the declaration of Bool_4 calls "="5. '),(0,i.kt)("h4",{id:"examples-2"},"Examples"),(0,i.kt)("p",null,"Examples of generic instantiations (see 12.1): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'procedure Swap is new Exchange(Elem =&gt Integer);\nprocedure Swap is new Exchange(Character);      --  Swap is overloaded \nfunction Square is new Squaring(Integer);   --  "*" of Integer used by default\nfunction Square is new Squaring(Item =&gt Matrix, "*" =&gt Matrix_Product);\nfunction Square is new Squaring(Matrix, Matrix_Product); -- same as previous\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'package Int_Vectors is new On_Vectors(Integer, Table, "+");\n\n')),(0,i.kt)("p",null,"Examples of uses of instantiated units: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Swap(A, B);\nA := Square(A);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'T : Table(1 .. 5) := (10, 20, 30, 40, 50);\nN : Integer := Int_Vectors.Sigma(T);  --  150\n                                      -- (see 12.2, "Generic Bodies" for the body of Sigma)\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"use Int_Vectors;\nM : Integer := Sigma(T);  --  150\n\n")),(0,i.kt)("h4",{id:"inconsistencies-with-ada-83"},"Inconsistencies With Ada 83"),(0,i.kt)("p",null,"In Ada 83, all explicit actuals are evaluated before all defaults, and the defaults are evaluated in the order of the formal declarations. This ordering requirement is relaxed in Ada 95. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"We have attempted to remove every violation of the contract model. Any remaining contract model violations should be considered bugs in the RM95. The unfortunate property of reverting to the predefined operators of the actual types is retained for upward compatibility. (Note that fixing this would require subtype conformance rules.) However, tagged types do not revert in this sense. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-1"},"Extensions to Ada 83"),(0,i.kt)("p",null,"The syntax rule for explicit_generic_actual_parameter is modified to allow a package_instance_name. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-1"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,"The fact that named associations cannot be used for two formal subprograms with the same defining name is moved to AARM-only material, because it is a ramification of other rules, and because it is not of interest to the average user."),(0,i.kt)("p",null,'The rule that "An explicit explicit_generic_actual_parameter shall not be supplied more than once for a given generic_formal_parameter" seems to be missing from RM83, although it was clearly the intent.'),(0,i.kt)("p",null,"In the explanation that the instance is a copy of the template, we have left out RM83-12.3(5)'s \"apart from the generic formal part\", because it seems that things in the formal part still need to exist in instances. This is particularly true for generic formal packages, where you're sometimes allowed to reach in and denote the formals of the formal package from outside it. This simplifies the explanation of what each name in an instance denotes: there are just two cases: the declaration can be inside or outside (where inside needs to include the generic unit itself). Note that the RM83 approach of listing many cases (see RM83-12.5(5-14)) would have become even more unwieldy with the addition of generic formal packages, and the declarations that occur therein."),(0,i.kt)("p",null,'We have corrected the definition of the elaboration of a generic_instantiation (RM83-12.3(17)); we don\'t elaborate entities, and the instance is not "implicit".'),(0,i.kt)("p",null,'In RM83, there is a rule saying the formal and actual shall match, and then there is much text defining what it means to match. Here, we simply state all the latter text as rules. For example, "A formal foo is matched by an actual greenish bar" becomes "For a formal foo, the actual shall be a greenish bar". This is necessary to split the Name Resolution Rules from the Legality Rules. Besides, there\'s really no need to define the concept of matching for generic parameters. '),(0,i.kt)("h2",{id:"124--formal-objects"},"12.4  Formal Objects"),(0,i.kt)("p",null,"[ A generic formal object can be used to pass a value or variable to a generic unit.]"," "),(0,i.kt)("h4",{id:"language-design-principles-1"},"Language Design Principles"),(0,i.kt)("p",null,"A generic formal object of mode in is like a constant initialized to the value of the explicit_generic_actual_parameter."),(0,i.kt)("p",null,"A generic formal object of mode in out is like a renaming of the explicit_generic_actual_parameter. "),(0,i.kt)("h4",{id:"syntax-2"},"Syntax"),(0,i.kt)("p",null,"formal_object_declaration ::=\ndefining_identifier_list : mode subtype_mark ","[:= default_expression]",";"),(0,i.kt)("h4",{id:"name-resolution-rules"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expected type for the default_expression, if any, of a formal object is the type of the formal object."),(0,i.kt)("p",null,"For a generic formal object of mode in, the expected type for the actual is the type of the formal."),(0,i.kt)("p",null,"For a generic formal object of mode in out, the type of the actual shall resolve to the type of the formal. "),(0,i.kt)("p",null,"Reason: See the corresponding rule for object_renaming_declarations for a discussion of the reason for this rule. "),(0,i.kt)("h4",{id:"legality-rules-1"},"Legality Rules"),(0,i.kt)("p",null,"If a generic formal object has a default_expression, then the mode shall be in ","[(either explicitly or by default)]","; otherwise, its mode shall be either in or in out. "),(0,i.kt)("p",null,"Ramification: Mode out is not allowed for generic formal objects. "),(0,i.kt)("p",null,"For a generic formal object of mode in, the actual shall be an expression. For a generic formal object of mode in out, the actual shall be a name that denotes a variable for which renaming is allowed (see 8.5.1). "),(0,i.kt)("p",null,"To be honest: The part of this that requires an expression or name is a Name Resolution Rule, but that's too pedantic to worry about. (The part about denoting a variable, and renaming being allowed, is most certainly not a Name Resolution Rule.) "),(0,i.kt)("p",null,"The type of a generic formal object of mode in shall be nonlimited."),(0,i.kt)("p",null,"Reason: Since a generic formal object is like a constant of mode in initialized to the value of the actual, a limited type would not make sense, since initializing a constant is not allowed for a limited type. That is, generic formal objects of mode in are passed by copy, and limited types are not supposed to be copied. "),(0,i.kt)("h4",{id:"static-semantics-2"},"Static Semantics"),(0,i.kt)("p",null,"A formal_object_declaration declares a generic formal object. The default mode is in. For a formal object of mode in, the nominal subtype is the one denoted by the subtype_mark in the declaration of the formal. For a formal object of mode in out, its type is determined by the subtype_mark in the declaration; its nominal subtype is nonstatic, even if the subtype_mark denotes a static subtype. "),(0,i.kt)("p",null,"In an instance, a formal_object_declaration of mode in declares a new stand-alone constant object whose initialization expression is the actual, whereas a formal_object_declaration of mode in out declares a view whose properties are identical to those of the actual. "),(0,i.kt)("p",null,"Ramification: These rules imply that generic formal objects of mode in are passed by copy, whereas generic formal objects of mode in out are passed by reference."),(0,i.kt)("p",null,'Initialization and finalization happen for the constant declared by a formal_object_declaration of mode in as for any constant; see 3.3.1, "Object Declarations" and 7.6, "User-Defined Assignment and Finalization".'),(0,i.kt)("p",null,"In an instance, the subtype of a generic formal object of mode in is as for the equivalent constant. In an instance, the subtype of a generic formal object of mode in out is the subtype of the corresponding generic actual. "),(0,i.kt)("h4",{id:"dynamic-semantics-3"},"Dynamic Semantics"),(0,i.kt)("p",null,"For the evaluation of a generic_association for a formal object of mode in, a constant object is created, the value of the actual parameter is converted to the nominal subtype of the formal object, and assigned to the object","[, including any value adjustment - see 7.6]",". "),(0,i.kt)("p",null,"Ramification: This includes evaluating the actual and doing a subtype conversion, which might raise an exception. "),(0,i.kt)("p",null,"Discussion: The rule for evaluating a generic_association for a formal object of mode in out is covered by the general Dynamic Semantics rule in 12.3. "),(0,i.kt)("p",null,"NOTE   The constraints that apply to a generic formal object of mode in out are those of the corresponding generic actual parameter (not those implied by the subtype_mark that appears in the formal_object_declaration). Therefore, to avoid confusion, it is recommended that the name of a first subtype be used for the declaration of such a formal object. "),(0,i.kt)("p",null,"Ramification: Constraint checks are done at instantiation time for formal objects of mode in, but not for formal objects of mode in out. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-2"},"Extensions to Ada 83"),(0,i.kt)("p",null,"In Ada 83, it is forbidden to pass a (nongeneric) formal parameter of mode out, or a subcomponent thereof, to a generic formal object of mode in out. This restriction is removed in Ada 95. "),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-2"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'We make "mode" explicit in the syntax. RM83 refers to the mode without saying what it is. This is also more uniform with the way (nongeneric) formal parameters are defined.'),(0,i.kt)("p",null,"We considered allowing mode out in Ada 95, for uniformity with (nongeneric) formal parameters. The semantics would be identical for modes in out and out. (Note that generic formal objects of mode in out are passed by reference. Note that for (nongeneric) formal parameters that are allowed to be passed by reference, the semantics of in out and out is the same. The difference might serve as documentation. The same would be true for generic formal objects, if out were allowed, so it would be consistent.) We decided not to make this change, because it does not produce any important benefit, and any change has some cost. "),(0,i.kt)("h2",{id:"125--formal-types"},"12.5  Formal Types"),(0,i.kt)("p",null,"[A generic formal subtype can be used to pass to a generic unit a subtype whose type is in a certain class of types.]"," "),(0,i.kt)("p",null,"Reason: We considered having intermediate syntactic categories formal_integer_type_definition, formal_real_type_definition, and formal_fixed_point_definition, to be more uniform with the syntax rules for non-generic-formal types. However, that would make the rules for formal types slightly more complicated, and it would cause confusion, since formal_discrete_type_definition would not fit into the scheme very well. "),(0,i.kt)("h4",{id:"syntax-3"},"Syntax"),(0,i.kt)("p",null,"formal_type_declaration ::=\ntype defining_identifier","[discriminant_part]"," is formal_type_definition;"),(0,i.kt)("p",null,"formal_type_definition ::=\nformal_private_type_definition\n| formal_derived_type_definition\n| formal_discrete_type_definition\n| formal_signed_integer_type_definition\n| formal_modular_type_definition\n| formal_floating_point_definition\n| formal_ordinary_fixed_point_definition\n| formal_decimal_fixed_point_definition\n| formal_array_type_definition\n| formal_access_type_definition"),(0,i.kt)("h4",{id:"legality-rules-2"},"Legality Rules"),(0,i.kt)("p",null,"For a generic formal subtype, the actual shall be a subtype_mark; it denotes the (generic) actual subtype. "),(0,i.kt)("p",null,'Ramification: When we say simply "formal" or "actual" (for a generic formal that denotes a subtype) we\'re talking about the subtype, not the type, since a name that denotes a formal_type_declaration denotes a subtype, and the corresponding actual also denotes a subtype. '),(0,i.kt)("h4",{id:"static-semantics-3"},"Static Semantics"),(0,i.kt)("p",null,"A formal_type_declaration declares a (generic) formal type, and its first subtype, the (generic) formal subtype. "),(0,i.kt)("p",null,"Ramification: A subtype (other than the first subtype) of a generic formal type is not a generic formal subtype. "),(0,i.kt)("p",null,"The form of a formal_type_definition determines a class to which the formal type belongs. For a formal_private_type_definition the reserved words tagged and limited indicate the class (see 12.5.1). For a formal_derived_type_definition the class is the derivation class rooted at the ancestor type. For other formal types, the name of the syntactic category indicates the class; a formal_discrete_type_definition defines a discrete type, and so on. "),(0,i.kt)("p",null,"Reason: This rule is clearer with the flat syntax rule for formal_type_definition given above. Adding formal_integer_type_definition and others would make this rule harder to state clearly."),(0,i.kt)("h4",{id:"legality-rules-3"},"Legality Rules"),(0,i.kt)("p",null,"The actual type shall be in the class determined for the formal. "),(0,i.kt)("p",null,"Ramification: For example, if the class determined for the formal is the class of all discrete types, then the actual has to be discrete."),(0,i.kt)("p",null,"Note that this rule does not require the actual to belong to every class to which the formal belongs. For example, formal private types are in the class of composite types, but the actual need not be composite. Furthermore, one can imagine an infinite number of classes that are just arbitrary sets of types that obey the closed-under-derivation rule, and are therefore technically classes (even though we don't give them names, since they are uninteresting). We don't want this rule to apply to those classes."),(0,i.kt)("p",null,'"Limited" is not a "interesting" class, but "nonlimited" is; it is legal to pass a nonlimited type to a limited formal type, but not the other way around. The reserved word limited really represents a class containing both limited and nonlimited types. "Private" is not a class; a generic formal private type accepts both private and nonprivate actual types.'),(0,i.kt)("p",null,"It is legal to pass a class-wide subtype as the actual if it is in the right class, so long as the formal has unknown discriminants. "),(0,i.kt)("h4",{id:"static-semantics-4"},"Static Semantics"),(0,i.kt)("p",null,"[The formal type also belongs to each class that contains the determined class.]"," The primitive subprograms of the type are as for any type in the determined class. For a formal type other than a formal derived type, these are the predefined operators of the type; they are implicitly declared immediately after the declaration of the formal type. In an instance, the copy of such an implicit declaration declares a view of the predefined operator of the actual type, even if this operator has been overridden for the actual type. ","[The rules specific to formal derived types are given in 12.5.1.]"," "),(0,i.kt)("p",null,"Ramification: All properties of the type are as for any type in the class. Some examples: The primitive operations available are as defined by the language for each class. The form of constraint applicable to a formal type in a subtype_indication depends on the class of the type as for a nonformal type. The formal type is tagged if and only if it is declared as a tagged private type, or as a type derived from a (visibly) tagged type. (Note that the actual type might be tagged even if the formal type is not.)"),(0,i.kt)("p",null,"NOTE 1   Generic formal types, like all types, are not named. Instead, a name can denote a generic formal subtype. Within a generic unit, a generic formal type is considered as being distinct from all other (formal or nonformal) types. "),(0,i.kt)("p",null,"Proof: This follows from the fact that each formal_type_declaration declares a type. "),(0,i.kt)("p",null,"NOTE 2   A discriminant_part is allowed only for certain kinds of types, and therefore only for certain kinds of generic formal types. See 3.7. "),(0,i.kt)("p",null,'Ramification: The term "formal floating point type" refers to a type defined by a formal_floating_point_definition. It does not include a formal derived type whose ancestor is floating point. Similar terminology applies to the other kinds of formal_type_definition. '),(0,i.kt)("h4",{id:"examples-3"},"Examples"),(0,i.kt)("p",null,"Examples of generic formal types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Item is private;\ntype Buffer(Length : Natural) is limited private;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Enum  is (&lt&gt);\ntype Int   is range &lt&gt;\ntype Angle is delta &lt&gt;\ntype Mass  is digits &lt&gt;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Table is array (Enum) of Item;\n\n")),(0,i.kt)("p",null,"Example of a generic formal part declaring a formal integer type: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'generic\n   type Rank is range &lt&gt;\n   First  : Rank := Rank\'First;\n   Second : Rank := First + 1;  --  the operator "+" of the type Rank  \n\n')),(0,i.kt)("h4",{id:"wording-changes-from-ada-83-3"},"Wording Changes from Ada 83"),(0,i.kt)("p",null,'RM83 has separate sections "Generic Formal Xs" and "Matching Rules for Formal Xs" (for various X\'s) with most of the text redundant between the two. We have combined the two in order to reduce the redundancy. In RM83, there is no "Matching Rules for Formal Types" section; nor is there a "Generic Formal Y Types" section (for Y = Private, Scalar, Array, and Access). This causes, for example, the duplication across all the "Matching Rules for Y Types" sections of the rule that the actual passed to a formal type shall be a subtype; the new organization avoids that problem.'),(0,i.kt)("p",null,"The matching rules are stated more concisely."),(0,i.kt)("p",null,"We no longer consider the multiplying operators that deliver a result of type universal_fixed to be predefined for the various types; there is only one of each in package Standard. Therefore, we need not mention them here as RM83 had to. "),(0,i.kt)("h3",{id:"1251--formal-private-and-derived-types"},"12.5.1  Formal Private and Derived Types"),(0,i.kt)("p",null,"[The class determined for a formal private type can be either limited or nonlimited, and either tagged or untagged; no more specific class is known for such a type. The class determined for a formal derived type is the derivation class rooted at the ancestor type.]"," "),(0,i.kt)("h4",{id:"syntax-4"},"Syntax"),(0,i.kt)("p",null,"formal_private_type_definition ::= ","[[abstract] tagged][limited]"," private"),(0,i.kt)("p",null,"formal_derived_type_definition ::= ","[abstract]"," new subtype_mark ","[with private]"),(0,i.kt)("h4",{id:"legality-rules-4"},"Legality Rules"),(0,i.kt)("p",null,"If a generic formal type declaration has a known_discriminant_part, then it shall not include a default_expression for a discriminant. "),(0,i.kt)("p",null,"Ramification: Consequently, a generic formal subtype with a known_discriminant_part is an indefinite subtype, so the declaration of a stand-alone variable has to provide a constraint on such a subtype, either explicitly, or by its initial value. "),(0,i.kt)("p",null,"The ancestor subtype of a formal derived type is the subtype denoted by the subtype_mark of the formal_derived_type_definition. For a formal derived type declaration, the reserved words with private shall appear if and only if the ancestor type is a tagged type; in this case the formal derived type is a private extension of the ancestor type and the ancestor shall not be a class-wide type. ","[Similarly, the optional reserved word abstract shall appear only if the ancestor type is a tagged type]","."),(0,i.kt)("p",null,'Reason: We use the term "ancestor" here instead of "parent" because the actual can be any descendant of the ancestor, not necessarily a direct descendant.'),(0,i.kt)("p",null,"If the formal subtype is definite, then the actual subtype shall also be definite. "),(0,i.kt)("p",null,"Ramification: On the other hand, for an indefinite formal subtype, the actual can be either definite or indefinite. "),(0,i.kt)("p",null,"For a generic formal derived type with no discriminant_part: "),(0,i.kt)("p",null,"If the ancestor subtype is constrained, the actual subtype shall be constrained, and shall be statically compatible with the ancestor; "),(0,i.kt)("p",null,'Ramification: In other words, any constraint on the ancestor subtype is considered part of the "contract". '),(0,i.kt)("p",null,"If the ancestor subtype is an unconstrained access or composite subtype, the actual subtype shall be unconstrained. "),(0,i.kt)("p",null,"Reason: This rule ensures that if a composite constraint is allowed on the formal, one is also allowed on the actual. If the ancestor subtype is an unconstrained scalar subtype, the actual is allowed to be constrained, since a scalar constraint does not cause further constraints to be illegal. "),(0,i.kt)("p",null,"If the ancestor subtype is an unconstrained discriminated subtype, then the actual shall have the same number of discriminants, and each discriminant of the actual shall correspond to a discriminant of the ancestor, in the sense of 3.7."),(0,i.kt)("p",null,"Reason: This ensures that if a discriminant constraint is given on the formal subtype, the corresponding constraint in the instance will make sense, without additional runtime checks. This is not necessary for arrays, since the bounds cannot be overridden in a type extension. An unknown_discriminant_part may be used to relax these matching requirements. "),(0,i.kt)("p",null,"The declaration of a formal derived type shall not have a known_discriminant_part. For a generic formal private type with a known_discriminant_part: "),(0,i.kt)("p",null,"The actual type shall be a type with the same number of discriminants."),(0,i.kt)("p",null,"The actual subtype shall be unconstrained."),(0,i.kt)("p",null,"The subtype of each discriminant of the actual type shall statically match the subtype of the corresponding discriminant of the formal type. "),(0,i.kt)("p",null,'Reason: We considered defining the first and third rule to be called "subtype conformance" for discriminant_parts. We rejected that idea, because it would require implicit (inherited) discriminant_parts, which seemed like too much mechanism. '),(0,i.kt)("p",null,"[For a generic formal type with an unknown_discriminant_part, the actual may, but need not, have discriminants, and may be definite or indefinite.]"),(0,i.kt)("h4",{id:"static-semantics-5"},"Static Semantics"),(0,i.kt)("p",null,"The class determined for a formal private type is as follows: "),(0,i.kt)("p",null,"Type Definition \tDetermined Class"),(0,i.kt)("p",null,"limited private \tthe class of all types\nprivate \tthe class of all nonlimited types\ntagged limited private \tthe class of all tagged types\ntagged private \tthe class of all nonlimited tagged types"),(0,i.kt)("p",null,"[The presence of the reserved word abstract determines whether the actual type may be abstract.]"),(0,i.kt)("p",null,"A formal private or derived type is a private or derived type, respectively. A formal derived tagged type is a private extension. ","[A formal private or derived type is abstract if the reserved word abstract appears in its declaration.]"),(0,i.kt)("p",null,"If the ancestor type is a composite type that is not an array type, the formal type inherits components from the ancestor type (including discriminants if a new discriminant_part is not specified), as for a derived type defined by a derived_type_definition (see 3.4)."),(0,i.kt)("p",null,"For a formal derived type, the predefined operators and inherited user-defined subprograms are determined by the ancestor type, and are implicitly declared at the earliest place, if any, within the immediate scope of the formal type, where the corresponding primitive subprogram of the ancestor is visible (see 7.3.1). In an instance, the copy of such an implicit declaration declares a view of the corresponding primitive subprogram of the ancestor, even if this primitive has been overridden for the actual type.  ","[In the case of a formal private extension, however, the tag of the formal type is that of the actual type, so if the tag in a call is statically determined to be that of the formal type, the body executed will be that corresponding to the actual type.]"," "),(0,i.kt)("p",null,"Ramification: The above rule defining the properties of primitive subprograms in an instance applies even if the subprogram has been overridden or hidden for the actual type. This rule is necessary for untagged types, because their primitive subprograms might have been overridden by operations that are not subtype-conformant with the operations defined for the class. For tagged types, the rule still applies, but the primitive subprograms will dispatch to the appropriate implementation based on the type and tag of the operands. Even for tagged types, the formal parameter names and default_expressions are determined by those of the primitive subprograms of the specified ancestor type. "),(0,i.kt)("p",null,"For a prefix S that denotes a formal indefinite subtype, the following attribute is defined: "),(0,i.kt)("p",null,"S'DefiniteS'Definite yields True if the actual subtype corresponding to S is definite; otherwise it yields False. The value of this attribute is of the predefined type Boolean. "),(0,i.kt)("p",null,"Discussion: Whether an actual subtype is definite or indefinite may have a major effect on the algorithm used in a generic. For example, in a generic I/O package, whether to use fixed-length or variable-length records could depend on whether the actual is definite or indefinite. This attribute is essentially a replacement for the Constrained attribute which is now considered obsolete. "),(0,i.kt)("p",null,'NOTE 1   In accordance with the general rule that the actual type shall belong to the class determined for the formal (see 12.5, "Formal Types"): '),(0,i.kt)("p",null,"If the formal type is nonlimited, then so shall be the actual;"),(0,i.kt)("p",null,"For a formal derived type, the actual shall be in the class rooted at the ancestor subtype. "),(0,i.kt)("p",null,"NOTE 2   The actual type can be abstract only if the formal type is abstract (see 3.9.3). "),(0,i.kt)("p",null,"Reason: This is necessary to avoid contract model problems, since one or more of its primitive subprograms are abstract; it is forbidden to create objects of the type, or to declare functions returning the type. "),(0,i.kt)("p",null,"Ramification: On the other hand, it is OK to pass a nonabstract actual to an abstract formal - abstract on the formal indicates that the actual might be abstract. "),(0,i.kt)("p",null,"NOTE 3   If the formal has a discriminant_part, the actual can be either definite or indefinite. Otherwise, the actual has to be definite. "),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-1"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,"Ada 83 does not have unknown_discriminant_parts, so it allows indefinite subtypes to be passed to definite formals, and applies a legality rule to the instance body. This is a contract model violation. Ada 95 disallows such cases at the point of the instantiation. The workaround is to add (","<",">",") as the discriminant_part of any formal subtype if it is intended to be used with indefinite actuals. If that's the intent, then there can't be anything in the generic body that would require a definite subtype."),(0,i.kt)("p",null,"The check for discriminant subtype matching is changed from a runtime check to a compile-time check. "),(0,i.kt)("h3",{id:"1252--formal-scalar-types"},"12.5.2  Formal Scalar Types"),(0,i.kt)("p",null,"A formal scalar type is one defined by any of the formal_type_definitions in this subclause. ","[The class determined for a formal scalar type is discrete, signed integer, modular, floating point, ordinary fixed point, or decimal.]"," "),(0,i.kt)("h4",{id:"syntax-5"},"Syntax"),(0,i.kt)("p",null,"formal_discrete_type_definition ::= (","<",">",")"),(0,i.kt)("p",null,"formal_signed_integer_type_definition ::= range ","<",">"),(0,i.kt)("p",null,"formal_modular_type_definition ::= mod ","<",">"),(0,i.kt)("p",null,"formal_floating_point_definition ::= digits ","<",">"),(0,i.kt)("p",null,"formal_ordinary_fixed_point_definition ::= delta ","<",">"),(0,i.kt)("p",null,"formal_decimal_fixed_point_definition ::= delta ","<",">"," digits ","<",">"),(0,i.kt)("h4",{id:"legality-rules-5"},"Legality Rules"),(0,i.kt)("p",null,"The actual type for a formal scalar type shall not be a nonstandard numeric type. "),(0,i.kt)("p",null,"Reason: This restriction is necessary because nonstandard numeric types have some number of restrictions on their use, which could cause contract model problems in a generic body. Note that nonstandard numeric types can be passed to formal derived and formal private subtypes, assuming they obey all the other rules, and assuming the implementation allows it (being nonstandard means the implementation might disallow anything). "),(0,i.kt)("p",null,'NOTE 1   The actual type shall be in the class of types implied by the syntactic category of the formal type definition (see 12.5, "Formal Types"). For example, the actual for a formal_modular_type_definition shall be a modular type. '),(0,i.kt)("h3",{id:"1253--formal-array-types"},"12.5.3  Formal Array Types"),(0,i.kt)("p",null,"[The class determined for a formal array type is the class of all array types.]"," "),(0,i.kt)("h4",{id:"syntax-6"},"Syntax"),(0,i.kt)("p",null,"formal_array_type_definition ::= array_type_definition"),(0,i.kt)("h4",{id:"legality-rules-6"},"Legality Rules"),(0,i.kt)("p",null,"The only form of discrete_subtype_definition that is allowed within the declaration of a generic formal (constrained) array subtype is a subtype_mark. "),(0,i.kt)("p",null,"Reason: The reason is the same as for forbidding constraints in subtype_indications (see 12.1). "),(0,i.kt)("p",null,"For a formal array subtype, the actual subtype shall satisfy the following conditions: "),(0,i.kt)("p",null,"The formal array type and the actual array type shall have the same dimensionality; the formal subtype and the actual subtype shall be either both constrained or both unconstrained."),(0,i.kt)("p",null,"For each index position, the index types shall be the same, and the index subtypes (if unconstrained), or the index ranges (if constrained), shall statically match (see 4.9.1). "),(0,i.kt)("p",null,"The component subtypes of the formal and actual array types shall statically match. "),(0,i.kt)("p",null,"If the formal type has aliased components, then so shall the actual. "),(0,i.kt)("p",null,"Ramification: On the other hand, if the formal's components are not aliased, then the actual's components can be either aliased or not. "),(0,i.kt)("h4",{id:"examples-4"},"Examples"),(0,i.kt)("p",null,"Example of formal array types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  given the generic package \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Item   is private;\n   type Index  is (&lt&gt);\n   type Vector is array (Index range &lt&gt) of Item;\n   type Table  is array (Index) of Item;\npackage P is\n   ...\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  and the types \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Mix    is array (Color range &lt&gt) of Boolean;\ntype Option is array (Color) of Boolean;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  then Mix can match Vector and Option can match Table \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package R is new P(Item   =&gt Boolean, Index =&gt Color,\n                   Vector =&gt Mix,     Table =&gt Option);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  Note that Mix cannot match Table and Option cannot match Vector\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-2"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,'The check for matching of component subtypes and index subtypes or index ranges is changed from a runtime check to a compile-time check. The Ada 83 rule that "If the component type is not a scalar type, then the component subtypes shall be either both constrained or both unconstrained" is removed, since it is subsumed by static matching. Likewise, the rules requiring that component types be the same is subsumed. '),(0,i.kt)("h3",{id:"1254--formal-access-types"},"12.5.4  Formal Access Types"),(0,i.kt)("p",null,"[The class determined for a formal access type is the class of all access types.]"," "),(0,i.kt)("h4",{id:"syntax-7"},"Syntax"),(0,i.kt)("p",null,"formal_access_type_definition ::= access_type_definition"),(0,i.kt)("h4",{id:"legality-rules-7"},"Legality Rules"),(0,i.kt)("p",null,"For a formal access-to-object type, the designated subtypes of the formal and actual types shall statically match. "),(0,i.kt)("p",null,"If and only if the general_access_modifier constant applies to the formal, the actual shall be an access-to-constant type. If the general_access_modifier all applies to the formal, then the actual shall be a general access-to-variable type (see 3.10). "),(0,i.kt)("p",null,"Ramification: If no _modifier applies to the formal, then the actual type may be either a pool-specific or a general access-to-variable type. "),(0,i.kt)("p",null,"For a formal access-to-subprogram subtype, the designated profiles of the formal and the actual shall be mode-conformant, and the calling convention of the actual shall be protected if and only if that of the formal is protected. "),(0,i.kt)("p",null,"Reason: We considered requiring subtype conformance here, but mode conformance is more flexible, given that there is no way in general to specify the convention of the formal. "),(0,i.kt)("h4",{id:"examples-5"},"Examples"),(0,i.kt)("p",null,"Example of formal access types: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  the formal types of the generic package \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Node is private;\n   type Link is access Node;\npackage P is\n   ...\nend P;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  can be matched by the actual types \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Car;\ntype Car_Name is access Car;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"type Car is\n   record\n      Pred, Succ : Car_Name;\n      Number     : License_Number;\n      Owner      : Person;\n   end record;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  in the following generic instantiation \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package R is new P(Node =&gt Car, Link =&gt Car_Name);\n\n")),(0,i.kt)("h4",{id:"incompatibilities-with-ada-83-3"},"Incompatibilities With Ada 83"),(0,i.kt)("p",null,'The check for matching of designated subtypes is changed from a runtime check to a compile-time check. The Ada 83 rule that "If the designated type is other than a scalar type, then the designated subtypes shall be either both constrained or both unconstrained" is removed, since it is subsumed by static matching. '),(0,i.kt)("h4",{id:"extensions-to-ada-83-3"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Formal access-to-subprogram subtypes and formal general access types are new concepts. "),(0,i.kt)("h2",{id:"126--formal-subprograms"},"12.6  Formal Subprograms"),(0,i.kt)("p",null,"[ Formal subprograms can be used to pass callable entities to a generic unit.]"," "),(0,i.kt)("h4",{id:"language-design-principles-2"},"Language Design Principles"),(0,i.kt)("p",null,"Generic formal subprograms are like renames of the explicit_generic_actual_parameter. "),(0,i.kt)("h4",{id:"syntax-8"},"Syntax"),(0,i.kt)("p",null,"formal_subprogram_declaration ::= with subprogram_specification ","[is subprogram_default]",";"),(0,i.kt)("p",null,"subprogram_default ::= default_name | ","<",">"),(0,i.kt)("p",null,"default_name ::= name"),(0,i.kt)("h4",{id:"name-resolution-rules-1"},"Name Resolution Rules"),(0,i.kt)("p",null,"The expected profile for the default_name, if any, is that of the formal subprogram. "),(0,i.kt)("p",null,"Ramification: This rule, unlike others in this clause, is observed at compile time of the generic_declaration."),(0,i.kt)("p",null,'The evaluation of the default_name takes place during the elaboration of each instantiation that uses the default, as defined in 12.3, "Generic Instantiation". '),(0,i.kt)("p",null,"For a generic formal subprogram, the expected profile for the actual is that of the formal subprogram. "),(0,i.kt)("h4",{id:"legality-rules-8"},"Legality Rules"),(0,i.kt)("p",null,"The profiles of the formal and any named default shall be mode-conformant. "),(0,i.kt)("p",null,"Ramification: This rule, unlike others in this clause, is checked at compile time of the generic_declaration. "),(0,i.kt)("p",null,"The profiles of the formal and actual shall be mode-conformant. "),(0,i.kt)("h4",{id:"static-semantics-6"},"Static Semantics"),(0,i.kt)("p",null,"A formal_subprogram_declaration declares a generic formal subprogram. The types of the formal parameters and result, if any, of the formal subprogram are those determined by the subtype_marks given in the formal_subprogram_declaration; however, independent of the particular subtypes that are denoted by the subtype_marks, the nominal subtypes of the formal parameters and result, if any, are defined to be nonstatic, and unconstrained if of an array type ","[(no applicable index constraint is provided in a call on a formal subprogram)]",". In an instance, a formal_subprogram_declaration declares a view of the actual. The profile of this view takes its subtypes and calling convention from the original profile of the actual entity, while taking the formal parameter names and default_expressions from the profile given in the formal_subprogram_declaration. The view is a function or procedure, never an entry. "),(0,i.kt)("p",null,"Discussion: This rule is intended to be the same as the one for renamings-as-declarations, where the formal_subprogram_declaration is analogous to a renaming-as-declaration, and the actual is analogous to the renamed view. "),(0,i.kt)("p",null,"If a generic unit has a subprogram_default specified by a box, and the corresponding actual parameter is omitted, then it is equivalent to an explicit actual parameter that is a usage name identical to the defining name of the formal."),(0,i.kt)("p",null,"NOTE 1   The matching rules for formal subprograms state requirements that are similar to those applying to subprogram_renaming_declarations (see 8.5.4). In particular, the name of a parameter of the formal subprogram need not be the same as that of the corresponding parameter of the actual subprogram; similarly, for these parameters, default_expressions need not correspond."),(0,i.kt)("p",null,"NOTE 2   The constraints that apply to a parameter of a formal subprogram are those of the corresponding formal parameter of the matching actual subprogram (not those implied by the corresponding subtype_mark in the _specification of the formal subprogram). A similar remark applies to the result of a function. Therefore, to avoid confusion, it is recommended that the name of a first subtype be used in any declaration of a formal subprogram."),(0,i.kt)("p",null,"NOTE 3   The subtype specified for a formal parameter of a generic formal subprogram can be any visible subtype, including a generic formal subtype of the same generic_formal_part."),(0,i.kt)("p",null,"NOTE 4   A formal subprogram is matched by an attribute of a type if the attribute is a function with a matching specification. An enumeration literal of a given type matches a parameterless formal function whose result type is the given type."),(0,i.kt)("p",null,"NOTE 5   A default_name denotes an entity that is visible or directly visible at the place of the generic_declaration; a box used as a default is equivalent to a name that denotes an entity that is directly visible at the place of the _instantiation. "),(0,i.kt)("p",null,"Proof: Visibility and name resolution are applied to the equivalent explicit actual parameter. "),(0,i.kt)("p",null,"NOTE 6   The actual subprogram cannot be abstract (see 3.9.3)."),(0,i.kt)("h4",{id:"examples-6"},"Examples"),(0,i.kt)("p",null,"Examples of generic formal subprograms: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},'with function "+"(X, Y : Item) return Item is &lt&gt;\nwith function Image(X : Enum) return String is Enum\'Image;\nwith procedure Update is Default_Update;\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  given the generic procedure declaration \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   with procedure Action (X : in Item);\nprocedure Iterate(Seq : in Item_Sequence);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  and the procedure \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Put_Item(X : in Item);\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"--  the following instantiation is possible \n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"procedure Put_List is new Iterate(Action =&gt Put_Item);\n\n")),(0,i.kt)("h2",{id:"127--formal-packages"},"12.7  Formal Packages"),(0,i.kt)("p",null,"[ Formal packages can be used to pass packages to a generic unit. The formal_package_declaration declares that the formal package is an instance of a given generic package. Upon instantiation, the actual package has to be an instance of that generic package.]"," "),(0,i.kt)("h4",{id:"syntax-9"},"Syntax"),(0,i.kt)("p",null,"formal_package_declaration ::=\nwith package defining_identifier is new generic_package_name  formal_package_actual_part;"),(0,i.kt)("p",null,"formal_package_actual_part ::=\n(","<",">",") | ","[generic_actual_part]"),(0,i.kt)("h4",{id:"legality-rules-9"},"Legality Rules"),(0,i.kt)("p",null,"The generic_package_name shall denote a generic package (the template for the formal package); the formal package is an instance of the template."),(0,i.kt)("p",null,"The actual shall be an instance of the template. If the formal_package_actual_part is (","<",">","), ","[then the actual may be any instance of the template]","; otherwise, each actual parameter of the actual instance shall match the corresponding actual parameter of the formal package ","[(whether the actual parameter is given explicitly or by default)]",", as follows:"),(0,i.kt)("p",null,"For a formal object of mode in the actuals match if they are static expressions with the same value, or if they statically denote the same constant, or if they are both the literal null. "),(0,i.kt)("p",null,"Reason: We can't simply require full conformance between the two actual parameter expressions, because the two expressions are being evaluated at different times. "),(0,i.kt)("p",null,"For a formal subtype, the actuals match if they denote statically matching subtypes. "),(0,i.kt)("p",null,"For other kinds of formals, the actuals match if they statically denote the same entity. "),(0,i.kt)("h4",{id:"static-semantics-7"},"Static Semantics"),(0,i.kt)("p",null,"A formal_package_declaration declares a generic formal package."),(0,i.kt)("p",null,"The visible part of a formal package includes the first list of basic_declarative_items of the package_specification. In addition, if the formal_package_actual_part is (","<",">","), it also includes the generic_formal_part of the template for the formal package."),(0,i.kt)("p",null,"Ramification: If the formal_package_actual_part is (","<",">","), then the declarations that occur immediately within the generic_formal_part of the template for the formal package are visible outside the formal package, and can be denoted by expanded names outside the formal package. "),(0,i.kt)("p",null,'Reason: We always want either the actuals or the formals of an instance to be namable from outside, but never both. If both were namable, one would get some funny anomalies since they denote the same entity, but, in the case of types at least, they might have different and inconsistent sets of primitive operators due to predefined operator "reemergence", Formal derived types exacerbate the difference. We want the implicit declarations of the generic_formal_part as well as the explicit declarations, so we get operations on the formal types. '),(0,i.kt)("p",null,"Ramification: A generic formal package is a package, and is an instance. Hence, it is possible to pass a generic formal package as an actual to another generic formal package. "),(0,i.kt)("h4",{id:"extensions-to-ada-83-4"},"Extensions to Ada 83"),(0,i.kt)("p",null,"Formal packages are new to Ada 95. "),(0,i.kt)("h2",{id:"128--example-of-a-generic-package"},"12.8  Example of a Generic Package"),(0,i.kt)("p",null,"The following example provides a possible formulation of stacks by means of a generic package. The size of each stack and the type of the stack elements are provided as generic formal parameters. "),(0,i.kt)("h4",{id:"examples-7"},"Examples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   Size : Positive;\n   type Item is private;\npackage Stack is\n   procedure Push(E : in  Item);\n   procedure Pop (E : out Item);\n   Overflow, Underflow : exception;\nend Stack;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package body Stack is\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   type Table is array (Positive range &lt&gt) of Item;\n   Space : Table(1 .. Size);\n   Index : Natural := 0;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Push(E : in Item) is\n   begin\n      if Index &gt= Size then\n         raise Overflow;\n      end if;\n      Index := Index + 1;\n      Space(Index) := E;\n   end Push;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"   procedure Pop(E : out Item) is\n   begin\n      if Index = 0 then\n         raise Underflow;\n      end if;\n      E := Space(Index);\n      Index := Index - 1;\n   end Pop;\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"end Stack;\n\n")),(0,i.kt)("p",null,"Instances of this generic package can be obtained as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"package Stack_Int  is new Stack(Size =&gt 200, Item =&gt Integer);\npackage Stack_Bool is new Stack(100, Boolean);\n\n")),(0,i.kt)("p",null,"Thereafter, the procedures of the instantiated packages can be called as follows: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"Stack_Int.Push(N);\nStack_Bool.Push(True);\n\n")),(0,i.kt)("p",null,"Alternatively, a generic formulation of the type Stack can be given as follows (package body omitted): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"generic\n   type Item is private;\npackage On_Stacks is\n   type Stack(Size : Positive) is limited private;\n   procedure Push(S : in out Stack; E : in  Item);\n   procedure Pop (S : in out Stack; E : out Item);\n   Overflow, Underflow : exception;\nprivate\n   type Table is array (Positive range &lt&gt) of Item;\n   type Stack(Size : Positive) is\n      record\n         Space : Table(1 .. Size);\n         Index : Natural := 0;\n      end record;\nend On_Stacks;\n\n")),(0,i.kt)("p",null,"In order to use such a package, an instance has to be created and thereafter stacks of the corresponding type can be declared: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ada"},"declare\n   package Stack_Real is new On_Stacks(Real); use Stack_Real;\n   S : Stack(100);\nbegin\n   ...\n   Push(S, 2.54);\n   ...\nend;\n\n")))}d.isMDXComponent=!0}}]);