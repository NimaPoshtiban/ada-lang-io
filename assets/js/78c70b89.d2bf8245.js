"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[9301],{9350:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>h,default:()=>b,frontMatter:()=>u,metadata:()=>m,toc:()=>f});var i=n(1716),a=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,p=(e,t)=>{for(var n in t||(t={}))l.call(t,n)&&d(e,n,t[n]);if(s)for(var n of s(t))c.call(t,n)&&d(e,n,t[n]);return e};const u={title:"Object-Oriented Features",sidebar_position:9},h=void 0,m={unversionedId:"style-guide/Object-Oriented_Features",id:"style-guide/Object-Oriented_Features",title:"Object-Oriented Features",description:"This chapter recommends ways of using Ada's object-oriented features.",source:"@site/docs/style-guide/Object-Oriented_Features.mdx",sourceDirName:"style-guide",slug:"/style-guide/Object-Oriented_Features",permalink:"/docs/style-guide/Object-Oriented_Features",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Object-Oriented Features",sidebar_position:9},sidebar:"styleGuideSidebar",previous:{title:"Reusability",permalink:"/docs/style-guide/Reusability"},next:{title:"Improving Performance",permalink:"/docs/style-guide/Improving_Performance"}},g={},f=[{value:"Object-Oriented Design",id:"object-oriented-design",level:2},{value:"Tagged Type Hierarchies",id:"tagged-type-hierarchies",level:2},{value:"Tagged Types",id:"tagged-types",level:3},{value:"guideline",id:"guideline",level:4},{value:"example",id:"example",level:4},{value:"rationale",id:"rationale",level:4},{value:"exceptions",id:"exceptions",level:4},{value:"Properties of Dispatching Operations",id:"properties-of-dispatching-operations",level:3},{value:"guideline",id:"guideline-1",level:4},{value:"example",id:"example-1",level:4},{value:"rationale",id:"rationale-1",level:4},{value:"exceptions",id:"exceptions-1",level:4},{value:"Controlled Types",id:"controlled-types",level:3},{value:"guideline",id:"guideline-2",level:4},{value:"example",id:"example-2",level:4},{value:"rationale",id:"rationale-2",level:4},{value:"Abstract Types",id:"abstract-types",level:3},{value:"guideline",id:"guideline-3",level:4},{value:"example",id:"example-3",level:4},{value:"rationale",id:"rationale-3",level:4},{value:"notes",id:"notes",level:4},{value:"Tagged Type Operations",id:"tagged-type-operations",level:2},{value:"Primitive Operations and Redispatching",id:"primitive-operations-and-redispatching",level:3},{value:"guideline",id:"guideline-4",level:4},{value:"example",id:"example-4",level:4},{value:"rationale",id:"rationale-4",level:4},{value:"Class-Wide Operations",id:"class-wide-operations",level:3},{value:"guideline",id:"guideline-5",level:4},{value:"example",id:"example-5",level:4},{value:"rationale",id:"rationale-5",level:4},{value:"Constructors",id:"constructors",level:3},{value:"guideline",id:"guideline-6",level:4},{value:"example",id:"example-6",level:4},{value:"rationale",id:"rationale-6",level:4},{value:"notes",id:"notes-1",level:4},{value:"Equality",id:"equality",level:3},{value:"guideline",id:"guideline-7",level:4},{value:"example",id:"example-7",level:4},{value:"rationale",id:"rationale-7",level:4},{value:"Polymorphism",id:"polymorphism",level:3},{value:"guideline",id:"guideline-8",level:4},{value:"example",id:"example-8",level:4},{value:"rationale",id:"rationale-8",level:4},{value:"Managing Visibility",id:"managing-visibility",level:2},{value:"Derived Tagged Types",id:"derived-tagged-types",level:3},{value:"guideline",id:"guideline-9",level:4},{value:"example",id:"example-9",level:4},{value:"rationale",id:"rationale-9",level:4},{value:"Multiple Inheritance",id:"multiple-inheritance",level:2},{value:"Multiple Inheritance Techniques",id:"multiple-inheritance-techniques",level:3},{value:"guideline",id:"guideline-10",level:4},{value:"example",id:"example-10",level:4},{value:"rationale",id:"rationale-10",level:4},{value:"Summary",id:"summary",level:2},{value:"tagged type hierarchies",id:"tagged-type-hierarchies-1",level:3},{value:"tagged type operations",id:"tagged-type-operations-1",level:3},{value:"managing visibility",id:"managing-visibility-1",level:3},{value:"multiple inheritance",id:"multiple-inheritance-1",level:3}],y={toc:f};function b(e){var t,n=e,{components:a}=n,d=((e,t)=>{var n={};for(var i in e)l.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(null!=e&&s)for(var i of s(e))t.indexOf(i)<0&&c.call(e,i)&&(n[i]=e[i]);return n})(n,["components"]);return(0,i.kt)("wrapper",(t=p(p({},y),d),o(t,r({components:a,mdxType:"MDXLayout"}))),(0,i.kt)("p",null,"This chapter recommends ways of using Ada's object-oriented features.\nAda supports inheritance and polymorphism, providing the programmer some\neffective techniques and building blocks. Disciplined use of these\nfeatures will promote programs that are easier to read and modify. These\nfeatures also give the programmer flexibility in building reusable\ncomponents."),(0,i.kt)("p",null,"The following definitions are provided in order to make this chapter\nmore understandable. The essential characteristics of object-oriented\nprogramming are encapsulation, inheritance, and polymorphism. These are\ndefined as follows in the Rationale (1995, \xa7\xa74.1 and III.1.2):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inheritance",(0,i.kt)("br",{parentName:"li"}),'A means for incrementally building new abstractions from an existing\none by "inheriting" their properties without disturbing the\nimplementation of the original abstraction or the existing clients.'),(0,i.kt)("li",{parentName:"ul"},"Multiple Inheritance",(0,i.kt)("br",{parentName:"li"}),"The means of inheriting components and operations from two or more\nparent abstractions."),(0,i.kt)("li",{parentName:"ul"},"Mixin Inheritance",(0,i.kt)("br",{parentName:"li"}),"Multiple inheritance in which one or more of the parent abstractions\ncannot have instances of their own and exist only to provide a set\nof properties for abstractions inheriting from them."),(0,i.kt)("li",{parentName:"ul"},"Polymorphism",(0,i.kt)("br",{parentName:"li"}),"A means of factoring out the differences among a collection of\nabstractions, such that programs may be written in terms of the\ncommon properties.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Static polymorphism is provided through the generic parameter\nmechanism whereby a generic unit may be instantiated at compile time\nwith any type from a class of types."),(0,i.kt)("li",{parentName:"ul"},'Dynamic polymorphism is provided through the use of so-called\nclass-wide types and the distinction is then made at runtime on the\nbasis of the value of the tag ("effectively a hidden discriminant\nidentifying the type" ',"[","Rationale 1995, \xa7II.1","]",").")),(0,i.kt)("p",null,"As stated in the Ada Reference Manual (1995, Annex N):"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A type has an associated set of values and a set of primitive\noperations that implement the fundamental aspects of its semantics.")),(0,i.kt)("p",null,"A class is a set of types that is closed under derivation, which means\nthat if a given type is in the class, then all types derived from that\ntype are also in the class. The set of types of a class share common\nproperties, such as their primitive operations. The semantics of a class\ninclude expected behavior and exceptions."),(0,i.kt)("p",null,"An object is either a constant or variable defined from a type (class).\nAn object contains a value. A subcomponent of an object is itself an\nobject."),(0,i.kt)("p",null,'Guidelines in this chapter are frequently worded "consider ..." because\nhard and fast rules cannot apply in all situations. The specific choice\nyou make in a given situation involves design tradeoffs. The rationale\nfor these guidelines is intended to give you insight into some of these\ntradeoffs.'),(0,i.kt)("h2",p({},{id:"object-oriented-design"}),"Object-Oriented Design"),(0,i.kt)("p",null,"You will find it easier to take advantage of many of the concepts in\nthis chapter if you have done an object-oriented design. The results of\nan object-oriented design would include a set of meaningful abstractions\nand hierarchy of classes. The abstractions need to include the\ndefinition of the design objects, including structure and state, the\noperations on the objects, and the intended encapsulation for each\nobject. The details on designing these abstractions and the hierarchy of\nclasses are beyond the scope of this book. A number of good sources\nexist for this detail, including Rumbaugh et al. (1991), Jacobson et al.\n(1992), Software Productivity Consortium (1993), and Booch (1994)."),(0,i.kt)("p",null,'An important part of the design process is deciding on the overall\norganization of the system. Looking at a single type, a single package,\nor even a single class of types by itself is probably the wrong place to\nstart. The appropriate level to start is more at the level of\n"subsystem" or "framework." You should use child packages (Guidelines\n4.1.1 and 4.2.2) to group sets of abstractions into subsystems\nrepresenting reusable frameworks. You should distinguish the "abstract"\nreusable core of the framework from the particular "instantiation" of\nthe framework. Presuming the framework is constructed properly, the\nabstract core and its instantiation can be separated into distinct\nsubsystems within the package hierarchy because the internals of an\nabstract reusable framework probably do not need to be visible to a\nparticular instantiation of the framework.'),(0,i.kt)("h2",p({},{id:"tagged-type-hierarchies"}),"Tagged Type Hierarchies"),(0,i.kt)("p",null,'You should use inheritance primarily as a mechanism for implementing a\nclass hierarchy from an object-oriented design. A class hierarchy should\nbe a generalization/specialization ("is-a") relationship. This\nrelationship may also be referred to as "is-a-kind-of," not to be\nconfused with "is an instance of." This "is-a" usage of inheritance is\nin contrast to other languages in which inheritance is used also to\nprovide the equivalent of the Ada context clauses with and use. In Ada,\nyou first identify the external modules of interest via with clauses and\nthen choose selectively whether to make only the name of the module\n(package) visible or its contents (via a use clause).'),(0,i.kt)("h3",p({},{id:"tagged-types"}),"Tagged Types"),(0,i.kt)("h4",p({},{id:"guideline"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using type extension when designing an is-a\n(generalization/specialization) hierarchy."),(0,i.kt)("li",{parentName:"ul"},"Use tagged types to preserve a common interface across differing\nimplementations (Taft 1995a)."),(0,i.kt)("li",{parentName:"ul"},"When defining a tagged type in a package, consider including a\ndefinition of a general access type to the corresponding class-wide\ntype."),(0,i.kt)("li",{parentName:"ul"},"In general, define only one tagged type per package.")),(0,i.kt)("h4",p({},{id:"example"}),"example"),(0,i.kt)("p",null,"Consider the type structure for a set of two-dimensional geometric\nobjects positioned in a Cartesian coordinate system (Barnes 1996). The\nancestor or root type Object is a tagged record. The components common\nto this type and all its descendants are an x and y coordinate. Various\ndescendant types include points, circles, and arbitrary shapes. Except\nfor points, these descendant types extend the root type with additional\ncomponents; for example, the circle adds a radius component:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"type Object is tagged\n   record\n      X_Coord : Float;\n      Y_Coord : Float;\n   end record;\n\ntype Circle is new Object with\n   record\n      Radius : Float;\n   end record;\n\ntype Point is new Object with null record;\n\ntype Shape is new Object with\n   record\n      -- other components\n      ...\n   end record;\n")),(0,i.kt)("p",null,"The following is an example of general access type to the corresponding\nclass-wide type:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"package Employee is\n   type Object is tagged limited private;\n   type Reference is access all Object'class;\n   ...\nprivate\n   ...\nend Employee;\n")),(0,i.kt)("h4",p({},{id:"rationale"}),"rationale"),(0,i.kt)("p",null,"You can derive new types from both tagged and untagged types, but the\neffects of this derivation are different. When you derive from an\nuntagged type, you are creating a new type whose implementation is\nidentical to the parent. Values of the derived types are subject to\nstrong type checking; thus, you cannot mix the proverbial apples and\noranges. When you derive a new type from an untagged type, you are not\nallowed to extend it with new components. You are effectively creating a\nnew interface without changing the underlying implementation (Taft\n1995a)."),(0,i.kt)("p",null,"In deriving from a tagged type, you can extend the type with new\ncomponents. Each descendant can extend a common interface (the\nparent's). The union of a tagged type and its descendants form a class,\nand a class offers some unique features not available to untagged\nderivations. You can write class-wide operations that can be applied to\nany object that is a member of the class. You can also provide new\nimplementations for the descendants of tagged types, either by\noverriding inherited primitive operations or by creating new primitive\noperations. Finally, tagged types can be used as the basis for multiple\ninheritance building blocks (see Guideline 9.5.1)."),(0,i.kt)("p",null,"Reference semantics are very commonly used in object-oriented\nprogramming. In particular, heterogeneous polymorphic data structures\nbased on tagged types require the use of access types. It is convenient\nto have a common definition for such a type provided to any client of\nthe package defining the tagged type. A heterogeneous polymorphic data\nstructure is a composite data structure (such as an array) whose\nelements have a homogeneous interface (i.e., an access to class-wide\ntype) and whose elements' implementations are heterogeneous (i.e., the\nimplementation of the elements uses different specific types). See also\nGuidelines 9.3.5 on polymorphism and 9.4.1 on managing visibility of\ntagged type hierarchies."),(0,i.kt)("p",null,'In Ada, the primitive operations of a type are implicitly associated\nwith the type through scoping rules. The definition of a tagged type and\na set of operations corresponds together to the "traditional"\nobject-oriented programming concept of a "class." Putting these into a\npackage provides a clean encapsulation mechanism.'),(0,i.kt)("h4",p({},{id:"exceptions"}),"exceptions"),(0,i.kt)("p",null,"If the root of the hierarchy does not define a complete set of values\nand operations, then use an abstract tagged type (see Guideline 9.2.4).\nThis abstract type can be thought of as the least common denominator of\nthe class, essentially a conceptual and incomplete type."),(0,i.kt)("p",null,"If a descendant needs to remove one of the components or primitive\noperations of its ancestor, it may not be appropriate to extend the\ntagged type."),(0,i.kt)("p",null,"An exception to using reference semantics is when a type is exported\nthat would not be used in a data structure or made part of a collection."),(0,i.kt)("p",null,"If the implementation of two tagged types requires mutual visibility and\nthe two types are generally used together, then it may be best to define\nthem together in one package, though thought should be given to using\nchild packages instead (see Guideline 9.4.1). Also, it can be convenient\nto define a small hierarchy of (completely) abstract types (or a small\npart of a larger hierarchy) all in one package specification; however,\nthe negative impact on maintainability may outweigh the convenience. You\ndo not provide a package body in this situation unless you have declared\nnonabstract operations on members of the hierarchy."),(0,i.kt)("h3",p({},{id:"properties-of-dispatching-operations"}),"Properties of Dispatching Operations"),(0,i.kt)("h4",p({},{id:"guideline-1"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The implementation of the dispatching operations of each type in a\nderivation class rooted in a tagged type T should conform to the\nexpected semantics of the corresponding dispatching operations of\nthe class-wide type T'Class.")),(0,i.kt)("h4",p({},{id:"example-1"}),"example"),(0,i.kt)("p",null,"The key point of both of the alternatives in the following example is\nthat it must be possible to use the class-wide type\nTransaction.Object'Class polymorphically without having to study the\nimplementations of each of the types derived from the root type\nTransaction.Object. In addition, new transactions can be added to the\nderivation class without invalidating the existing transaction\nprocessing code. These are the important practical consequences of the\ndesign rule captured in the guideline:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"with Database;\npackage Transaction is\n\n   type Object (Data : access Database.Object'Class) is abstract tagged limited\n      record\n         Has_Executed : Boolean := False;\n      end record;\n\n   function Is_Valid (T : Object) return Boolean;\n   -- checks that Has_Executed is False\n\n   procedure Execute (T : in out Object);\n   -- sets Has_Executed to True\n\n   Is_Not_Valid : exception;\n\nend Transaction;\n")),(0,i.kt)("p",null,"The precondition of Execute(T) for all T in Transaction.Object'Class is\nthat Is","_","Valid(T) is True. The postcondition is the T.Has","_","Executed =\nTrue. This model is trivially satisfied by the root type\nTransaction.Object."),(0,i.kt)("p",null,"Consider the following derived type:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"with Transaction;\nwith Personnel;\npackage Pay_Transaction is\n   type Object is new Transaction.Object with\n      record\n         Employee     : Personnel.Name;\n         Hours_Worked : Personnel.Time;\n      end record;\n   function Is_Valid (T : Object) return Boolean;\n   -- checks that Employee is a valid name, Hours_Worked is a valid\n   -- amount of work time and Has_Executed = False\n   procedure Has_Executed (T : in out Object);\n   -- computes the pay earned by the Employee for the given Hours_Worked\n   -- and updates this in the database T.Data, then sets Has_Executed to True\nend Pay_Transaction;\n")),(0,i.kt)("p",null,"The precondition for the specific operation Pay","_","Transaction.Execute(T)\nis that Pay","_","Transaction.Is","_",'Valid(T) is True, which is the same\nprecondition as for the dispatching operation Execute on the class-wide\ntype. (The actual validity check is different, but the statement of the\n"precondition" is the same.) The postcondition for\nPay',"_","Transaction.Execute(T) includes T.Has","_","Executed = True but also\nincludes the appropriate condition on T.Data for computation of pay."),(0,i.kt)("p",null,"The class-wide transaction type can then be properly used as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"type Transaction_Reference is access all Transaction.Object'Class;\ntype Transaction_List is array (Positive range <>) of Transaction_Reference;\nprocedure Process (Action : in Transaction_List) is\nbegin\n   for I in Action'Range loop\n   -- Note that calls to Is_Valid and Execute are dispatching\n      if Transaction.Is_Valid(Action(I).all) then\n         -- the precondition for Execute is satisfied\n         Transaction.Execute(Action(I).all);\n         -- the postcondition Action(I).Has_Executed = True is\n         -- guaranteed to be satisfied (as well as any stronger conditions\n         -- depending on the specific value of Action(I))\n      else\n         -- deal with the error\n         ...\n      end if;\n   end loop;\nend Process;\n")),(0,i.kt)("p",null,"If you had not defined the operation Is","_","Valid on transactions, then the\nvalidity condition for pay computation (valid name and hours worked)\nwould have to directly become the precondition for\nPay","_",'Transaction.Execute. But this would be a "stronger" precondition\nthan that on the class-wide dispatching operation, violating the\nguideline. As a result of this violation, there would be no way to\nguarantee the precondition of a dispatching call to Execute, leading to\nunexpected failures.'),(0,i.kt)("p",null,'An alternative resolution to this problem is to define an exception to\nbe raised by an Execute operation when the transaction is not valid.\nThis behavior becomes part of the semantic model for the class-wide\ntype: the precondition for Execute(T) becomes simply True (i.e., always\nvalid), but the postcondition becomes "either" the exception is not\nraised and Has',"_",'Executed = True "or" the exception is raised and\nHas',"_",'Executed = False. The implementations of Execute in all derived\ntransaction types would then need to satisfy the new postcondition. It\nis important that the "same" exception be raised by "all"\nimplementations because this is part of the expected semantic model of\nthe class-wide type.'),(0,i.kt)("p",null,"With the alternative approach, the above processing loop becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"procedure Process (Action : in Transaction_List) is\nbegin\n\n   for I in Action'Range loop\n\n    Process_A_Transaction:\n      begin\n\n         -- there is no precondition for Execute\n         Transaction.Execute (Action(I).all);\n         -- since no exception was raised, the postcondition\n         -- Action(I).Has_Executed = True is guaranteed (as well as\n         -- any stronger condition depending on the specific value of\n         -- Action(I))\n\n      exception\n         when Transaction.Is_Not_Valid =>\n            -- the exception was raised, so Action(I).Has_Executed = False\n\n            -- deal with the error\n            ...\n\n      end Process_A_Transaction;\n\n   end loop;\n\nend Process;\n")),(0,i.kt)("h4",p({},{id:"rationale-1"}),"rationale"),(0,i.kt)("p",null,'All the properties expected of a class-wide type by clients of that type\nshould be meaningful for any specific types in the derivation class of\nthe class-wide type. This rule is related to the object-oriented\nprogramming "substitutability principle" for consistency between the\nsemantics of an object-oriented superclass and its subclasses (Wegner\nand Zdonik 1988). However, the separation of the polymorphic class-wide\ntype T\'Class from the root specific type T in Ada 95 clarifies this\nprinciple as a design rule on derivation classes rather than a\ncorrectness principle for derivation itself.'),(0,i.kt)("p",null,"When a dispatching operation is used on a variable of a class-wide type\nT'Class, the actual implementation executed will depend dynamically on\nthe actual tag of the value in the variable. In order to rationally use\nT'Class, it must be possible to understand the semantics of the\noperations on T'Class without having to study the implementation of the\noperations for each of the types in the derivation class rooted in T.\nFurther, a new type added to this derivation class should not invalidate\nthis overall understanding of T'Class because this could invalidate\nexisting uses of the class-wide type. Thus, there needs to be an overall\nset of semantic properties of the operations of T'Class that is\npreserved by the implementations of the corresponding dispatching\noperations of all the types in the derivation class."),(0,i.kt)("p",null,'One way to capture the semantic properties of an operation is to define\na "precondition" that must be true before the operation is invoked and a\n"postcondition" that must be true (given the precondition) after the\noperation has executed. You can (formally or informally) define pre- and\npostconditions for each operation of T\'Class without reference to the\nimplementations of dispatching operations of specific types. These\nsemantic properties define the "minimum" set of properties common to all\ntypes in the derivation class. To preserve this minimum set of\nproperties, the implementation of the dispatching operations of all the\ntypes in the derivation class rooted in T (including the root type T)\nshould have (the same or) weaker preconditions than the corresponding\noperations of T\'Class and (the same or) stronger postconditions than the\nT\'Class operations. This means that any invocation of a dispatching\noperation on T\'Class will result in the execution of an implementation\nthat requires no more than what is expected of the dispatching operation\nin general (though it could require less) and delivers a result that is\nno less than what is expected (though it could do more).'),(0,i.kt)("h4",p({},{id:"exceptions-1"}),"exceptions"),(0,i.kt)("p",null,"Tagged types and type extension may sometimes be used primarily for type\nimplementation reasons rather than for polymorphism and dispatching. In\nparticular, a nontagged private type may be implemented using a type\nextension of a tagged type. In such cases, it may not be necessary for\nthe implementation of the derived type to preserve the semantic\nproperties of the class-wide type because the membership of the new type\nin the tagged type derivation class will not generally be known to\nclients of the type."),(0,i.kt)("h3",p({},{id:"controlled-types"}),"Controlled Types"),(0,i.kt)("h4",p({},{id:"guideline-2"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Consider using a controlled type whenever a type allocates resources\nthat must be deallocated or otherwise "cleaned up" on destruction or\noverwriting.'),(0,i.kt)("li",{parentName:"ul"},'Use a derivation from a controlled type in preference to providing\nan explicit "cleanup" operation that must be called by clients of\nthe type.'),(0,i.kt)("li",{parentName:"ul"},"When overriding the adjustment and finalization procedures derived\nfrom controlled types, define the finalization procedure to undo the\neffects of the adjustment procedure."),(0,i.kt)("li",{parentName:"ul"},"Derived type initialization procedures should call the\ninitialization procedure of their parent as part of their\ntype-specific initialization."),(0,i.kt)("li",{parentName:"ul"},"Derived type finalization procedures should call the finalization\nprocedure of their parent as part of their type-specific\nfinalization."),(0,i.kt)("li",{parentName:"ul"},"Consider deriving a data structure's components rather than the\nenclosing data structure from a controlled type.")),(0,i.kt)("h4",p({},{id:"example-2"}),"example"),(0,i.kt)("p",null,"The following example demonstrates the use of controlled types in the\nimplementation of a simple linked list. Because the Linked","_","List type is\nderived from Ada.Finalization.Controlled, the Finalize procedure will be\ncalled automatically when objects of the Linked","_","List type complete\ntheir scope of execution:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"with Ada.Finalization;\npackage Linked_List_Package is\n   type Iterator is private;\n   type Data_Type is ...\n   type Linked_List is new Ada.Finalization.Controlled with private;\n   function Head (List : Linked_List) return Iterator;\n   procedure Get_Next (Element  : in out Iterator;\n                       Data     :    out Data_Type);\n   procedure Add (List     : in out Linked_List;\n                  New_Data : in     Data_Type);\n   procedure Finalize (List : in out Linked_List); -- reset Linked_List structure\n   -- Initialize and Adjust are left to the default implementation.\nprivate\n   type Node;\n   type Node_Ptr is access Node;\n   type Node is\n      record\n         Data : Data_Type;\n         Next : Node_Ptr;\n      end record;\n   type Iterator is new Node_Ptr;\n   type Linked_List is new Ada.Finalization.Controlled with\n      record\n         Number_Of_Items : Natural := 0;\n         Root            : Node_Ptr;\n      end record;\nend Linked_List_Package;\n--------------------------------------------------------------------------\npackage body Linked_List_Package is\n\n   function Head (List : Linked_List) return Iterator is\n      Head_Node_Ptr : Iterator;\n   begin\n      Head_Node_Ptr := Iterator (List.Root);\n      return Head_Node_Ptr;  -- Return the head element of the list\n   end Head;\n\n   procedure Get_Next (Element : in out Iterator;\n                       Data    :    out Data_Type) is\n   begin\n      --\n      -- Given an element, return the next element (or null)\n      --\n   end Get_Next;\n\n   procedure Add (List     : in out Linked_List;\n                  New_Data : in     Data_Type) is\n   begin\n      --\n      -- Add a new element to the head of the list\n      --\n   end Add;\n\n   procedure Finalize (List : in out Linked_List) is\n   begin\n      -- Release all storage used by the linked list\n      --   and reinitialize.\n   end Finalize;\n\nend Linked_List_Package;\n")),(0,i.kt)("h4",p({},{id:"rationale-2"}),"rationale"),(0,i.kt)("p",null,"The three controlling operations, Initialize, Adjust, and Finalize,\nserve as automatically called procedures that control three primitive\nactivities in the life of an object (Ada Reference Manual 1995, \xa77.6).\nWhen an assignment to an object of a type derived from Controlled\noccurs, adjustment and finalization work in tandem. Finalization cleans\nup the object being overwritten (e.g., reclaims heap space), then\nadjustment finishes the assignment work once the value being assigned\nhas been copied (e.g., to implement a deep copy)."),(0,i.kt)("p",null,"You can ensure that the derived type's initialization is consistent with\nthat of the parent by calling the parent type's initialization from the\nderived type's initialization."),(0,i.kt)("p",null,"You can ensure that the derived type's finalization is consistent with\nthat of the parent by calling the parent type's finalization from the\nderived type's finalization."),(0,i.kt)("p",null,"In general, you should call parent initialization before\ndescendant-specific initialization. Similarly, you should call parent\nfinalization after descendant-specific finalization. (You may position\nthe parent initialization and/or finalization at the beginning or end of\nthe procedure.)"),(0,i.kt)("h3",p({},{id:"abstract-types"}),"Abstract Types"),(0,i.kt)("h4",p({},{id:"guideline-3"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types and operations in creating\nclassification schemes, for example, a taxonomy, in which only the\nleaf objects will be meaningful in the application."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring root types and internal nodes in a type tree as\nabstract."),(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types for generic formal derived types."),(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types to develop different implementations\nof a single abstraction.")),(0,i.kt)("h4",p({},{id:"example-3"}),"example"),(0,i.kt)("p",null,"In a banking application, there are a wide variety of account types,\neach with different features and restrictions. Some of the variations\nare fees, overdraft protection, minimum balances, allowable account\nlinkages (e.g., checking and savings), and rules on opening the account.\nCommon to all bank accounts are ownership attributes: unique account\nnumber, owner name(s), and owner tax identification number(s). Common\noperations across all types of accounts are opening, depositing,\nwithdrawing, providing current balance, and closing. The common\nattributes and operations describe the conceptual bank account. This\nidealized bank account can form the root of a\ngeneralization/specialization hierarchy that describes the bank's array\nof products. By using abstract tagged types, you ensure that only\naccount objects corresponding to a specific product will be created.\nBecause any abstract operations must be overridden with each derivation,\nyou ensure that any restrictions for a specialized account are\nimplemented (e.g., how and when the account-specific fee structure is\napplied):"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"--------------------------------------------------------------------------\npackage Bank_Account_Package is\n\n   type Bank_Account_Type is abstract tagged limited private;\n   type Money is delta 0.01 digits 15;\n\n   -- The following abstract operations must be overridden for\n   --   each derivation, thus ensuring that any restrictions\n   --   for specialized accounts will be implemented.\n\n   procedure Open (Account : in out Bank_Account_Type) is abstract;\n\n   procedure Close (Account : in out Bank_Account_Type) is abstract;\n\n   procedure Deposit (Account : in out Bank_Account_Type;\n                      Amount  : in     Money) is abstract;\n\n   procedure Withdraw (Account : in out Bank_Account_Type;\n                       Amount  : in     Money) is abstract;\n\n   function Balance (Account : Bank_Account_Type)\n     return Money is abstract;\n\nprivate\n   type Account_Number_Type is ...\n   type Account_Owner_Type  is ...\n   type Tax_ID_Number_Type  is ...\n\n   type Bank_Account_Type is abstract tagged limited\n      record\n         Account_Number : Account_Number_Type;\n         Account_Owner  : Account_Owner_Type;\n         Tax_ID_Number  : Tax_ID_Number_Type;\n      end record;\nend Bank_Account_Package;\n--------------------------------------------------------------------------\n-- Now, other specialized accounts such as a savings account can\n-- be derived from Bank_Account_Type as in the following example.\n-- Note that abstract types are still used to ensure that only\n-- account objects corresponding to specific products will be\n-- created.with Bank_Account_Package;\nwith Bank_Account_Package;\npackage Savings_Account_Package is\n   type Savings_Account_Type is abstract\n      new Bank_Account_Package.Bank_Account_Type with private;\n   -- We must override the abstract operations provided\n   --   by Bank_Account_Package.  Since we are still declaring\n   --   these operations to be abstract, they must also be\n   --   overridden by the specializations of Savings_Account_Type.\n   procedure Open (Account : in out Savings_Account_Type) is abstract;\n   procedure Close (Account : in out Savings_Account_Type) is abstract;\n\n   procedure Deposit (Account : in out Savings_Account_Type;\n                      Amount  : in     Bank_Account_Package.Money) is abstract;\n\n   procedure Withdraw (Account : in out Savings_Account_Type;\n                       Amount  : in     Bank_Account_Package.Money) is abstract;\n\n   function Balance (Account : Savings_Account_Type)\n     return Bank_Account_Package.Money is abstract;\n\nprivate\n   type Savings_Account_Type is abstract\n      new Bank_Account_Package.Bank_Account_Type with\n         record\n            Minimum_Balance : Bank_Account_Package.Money;\n         end record;\nend Savings_Account_Package;\n\n--------------------------------------------------------------------------\n")),(0,i.kt)("p",null,"See the abstract set package in Guideline 9.5.1 for an example of\ncreating an abstraction with a single interface and the potential for\nmultiple implementations. The example only shows one possible\nimplementation; however, you could provide an alternate implementation\nof the Hashed","_","Set abstraction using other data structures."),(0,i.kt)("h4",p({},{id:"rationale-3"}),"rationale"),(0,i.kt)("p",null,'In many classification schemes, for example, a taxonomy, only objects at\nthe leaves of the classification tree are meaningful in the application.\nIn other words, the root of the hierarchy does not define a complete set\nof values and operations for use by the application. The use of\n"abstract" guarantees that there will be no objects of the root or\nintermediate nodes. Concrete derivations of the abstract types and\nsubprograms are required so that the leaves of the tree become objects\nthat a client can manipulate.'),(0,i.kt)("p",null,'You can only declare abstract subprograms when the root type is also\nabstract. This is useful as you build an abstraction that forms the\nbasis for a family of abstractions. By declaring the primitive\nsubprograms to be abstract, you can write the "common class-wide parts\nof a system . . . without being dependent on the properties of any\nspecific type at all" (Rationale 1995, \xa74.2).'),(0,i.kt)("p",null,"Abstract types and operations can help you resolve problems when your\ntagged type hierarchy violates the expected semantics of the class-wide\ntype dispatching operations. The Rationale (1995, \xa74.2) explains:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"When building an abstraction that is to form the basis of a class\nof types, it is often convenient not to provide actual subprograms for\nthe root type but just abstract subprograms which can be replaced when\ninherited. This is only allowed if the root type is declared as\nabstract; objects of an abstract type cannot exist. This technique\nenables common class-wide parts of a system to be written without being\ndependent on the properties of any specific type at all. Dispatching\nalways works because it is known that there can never be any objects of\nthe abstract type and so the abstract subprograms could never be called.")),(0,i.kt)("p",null,"See Guidelines 8.3.8 and 9.2.1."),(0,i.kt)("p",null,"The multiple inheritance techniques discussed in Guideline 9.5.1 make\nuse of abstract tagged types. The basic abstraction is defined using an\nabstract tagged (limited) private type (whose full type declaration is a\nnull record) with a small set of abstract primitive operations. While\nabstract operations have no bodies and thus cannot be called, they are\ninherited. Derivatives of the abstraction then extend the root type with\ncomponents that provide the data representation and override the\nabstract operations to provide callable implementations (Rationale 1995,\n\xa74.4.3). This technique allows you to build multiple implementations of\na single abstraction. You declare a single interface and vary the\nspecifics of the data representation and operation implementation."),(0,i.kt)("h4",p({},{id:"notes"}),"notes"),(0,i.kt)("p",null,"When you use abstract data types as described in this guideline, you can\nhave multiple implementations of the same abstraction available to you\nwithin a single program. This technique differs from the idea of writing\nmultiple package bodies to provide different implementations of the\nabstraction defined in a package specification because with the package\nbody technique, you can only include one of the implementations (i.e.,\nbodies) in your program."),(0,i.kt)("h2",p({},{id:"tagged-type-operations"}),"Tagged Type Operations"),(0,i.kt)("p",null,"You can use three options when you define the operations on a tagged\ntype and its descendants. These categories are primitive abstract,\nprimitive nonabstract, and class-wide operations. An abstract operation\nmust be overridden for a nonabstract derived type. A nonabstract\noperation may be redefined for a subclass. A class-wide operation cannot\nbe overridden by a subclass definition. A class-wide operation can be\nredefined for the derivation class rooted in the derived type; however,\nthis practice is discouraged because of the ambiguities it introduces in\nthe code. Through careful usage of these options, you can ensure that\nyour abstractions preserve class-wide properties, as discussed in\nGuideline 9.2.1. As stated above, this principle requires that any type\nthat is visibly derived from some parent type must fully support the\nsemantics of the parent type."),(0,i.kt)("h3",p({},{id:"primitive-operations-and-redispatching"}),"Primitive Operations and Redispatching"),(0,i.kt)("h4",p({},{id:"guideline-4"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Consider declaring a primitive abstract operation based on the\nabsence of a meaningful "default" behavior.'),(0,i.kt)("li",{parentName:"ul"},'Consider declaring a primitive nonabstract operation based on the\npresence of a meaningful "default" behavior.'),(0,i.kt)("li",{parentName:"ul"},"When overriding an operation, the overriding subprogram should not\nraise exceptions that are not known to the users of the overridden\nsubprogram."),(0,i.kt)("li",{parentName:"ul"},'If redispatching is used in the implementation of the operations of\na type, with the specific intent that some of the redispatched-to\noperations be overridden by specializations for the derived types,\nthen document this intent clearly in the specification as part of\nthe "interface" of a parent type with its derived types.'),(0,i.kt)("li",{parentName:"ul"},"When redispatching is used (for any reason) in the implementation of\na primitive operation of a tagged type, then document (in some\nproject-consistent way) this use in the body of the operation\nsubprogram so that it can be easily found during maintenance.")),(0,i.kt)("h4",p({},{id:"example-4"}),"example"),(0,i.kt)("p",null,"This example (Volan 1994) is intended to show a clean derivation of a\nsquare from a rectangle. You do not want to derive Square from Rectangle\nbecause Rectangle has semantics that are inappropriate for Square. (For\ninstance, you can make a rectangle with any arbitrary height and width,\nbut you should not be able to make a square this way.) Instead, both\nSquare and Rectangle should be derived from some common abstract type,\nsuch as:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"Any_Rectangle:\ntype Figure is abstract tagged\n   record\n      ...\n   end record;\ntype Any_Rectangle is abstract new Figure with private;\n-- No Make function for this; it's abstract.\nfunction Area (R: Any_Rectangle) return Float;\n  -- Overrides abstract Area function inherited from Figure.\n  -- Computes area as Width(R) * Height(R), which it will\n  -- invoke via dispatching calls.\nfunction Width (R: Any_Rectangle) return Float is abstract;\nfunction Height (R: Any_Rectangle) return Float is abstract;\ntype Rectangle is new Any_Rectangle with private;\nfunction Make_Rectangle (Width, Height: Float) return Rectangle;\nfunction Width (R: Rectangle) return Float;\nfunction Height (R: Rectangle) return Float;\n-- Area for Rectangle inherited from Any_Rectangle\ntype Square is new Any_Rectangle with private;\nfunction Make_Square (Side_Length: Float) return Square;\nfunction Side_Length (S: Square) return Float;\nfunction Width (S: Square) return Float;\nfunction Height (S: Square) return Float;\n-- Area for Square inherited from Any_Rectangle\n...\n-- In the body, you could just implement Width and Height for\n-- Square as renamings of Side_Length:\nfunction Width (S: Square) return Float renames Side_Length;\nfunction Height (S: Square) return Float renames Side_Length;\nfunction Area (R: Any_Rectangle) return Float is\nbegin\n  return Width(Any_Rectangle'Class(R)) * Height(Any_Rectangle'Class(R));\n  -- Casting [sic, i.e., converting] to the class-wide type causes the function calls to\n  -- dynamically dispatch on the 'Tag of R.\n  -- [sic, i.e., redispatch on the tag of R.]\nend Area;\n\nAlternatively, you could just wait until defining types Rectangle and Square to provide actual Area functions:\n\ntype Any_Rectangle is abstract new Figure with private;\n-- Inherits abstract Area function from Figure,\n-- but that's okay, Any_Rectangle is abstract too.\nfunction Width (R: Any_Rectangle) return Float is abstract;\nfunction Height (R: Any_Rectangle) return Float is abstract;\ntype Rectangle is new Any_Rectangle with private;\nfunction Make_Rectangle (Width, Height: Float) return Rectangle;\nfunction Width (R: Rectangle) return Float;\nfunction Height (R: Rectangle) return Float;\nfunction Area (R: Rectangle) return Float; -- Overrides Area from Figure\ntype Square is new Any_Rectangle with private;\nfunction Make_Square (Side_Length: Float) return Square;\nfunction Side_Length (S: Square) return Float;\nfunction Width (S: Square) return Float;\nfunction Height (S: Square) return Float;\nfunction Area (S: Square) return Float;  -- Overrides Area from Figure\n...\nfunction Area (R: Rectangle) return Float is\nbegin\n  return Width(R) * Height(R); -- Non-dispatching calls\nend Area;\nfunction Area (S: Square) return Float is\nbegin\n  return Side_Length(S) ** 2;\nend Area;\n")),(0,i.kt)("h4",p({},{id:"rationale-4"}),"rationale"),(0,i.kt)("p",null,"The behavior of a nonabstract operation can be interpreted as the\nexpected behavior for all members of the class; therefore, the behavior\nmust be a meaningful default for all descendants. If the operation must\nbe tailored based on the descendant abstraction (e.g., computing the\narea of a geometric shape depends on the specific shape), then the\noperation should be primitive and possibly abstract. The effect of\nmaking the operation abstract is that it guarantees that each descendant\nmust define its own version of the operation. Thus, when there is no\nacceptable basic behavior, an abstract operation is appropriate because\na new version of the operation must be provided with each derivation."),(0,i.kt)("p",null,"All operations declared in the same package as the tagged type and\nfollowing the tagged type's declaration but before the next type\ndeclaration are considered its primitive operations. Therefore, when a\nnew type is derived from the tagged type, it inherits the primitive\noperations. If there are any operations that you do not want to be\ninherited, you must choose whether to declare them as class-wide\noperations (see Guideline 9.3.2) or to declare them in a separate\npackage (e.g., a child package)."),(0,i.kt)("p",null,"Exceptions are part of the semantics of the class. By modifying the\nexceptions, you are violating the semantic properties of the class-wide\ntype (see Guideline 9.2.1)."),(0,i.kt)("p",null,'There are (at least) two distinct users of a tagged type and its\nprimitives. The "ordinary" user uses the type and its primitives without\nenhancement. The "extending" user extends the type by deriving a type\nbased on the existing (tagged) type. Extending users and maintainers\nmust determine the ramifications of a possibly incorrect extension. The\nguidelines here try to strike a balance between too much documentation\n(that can then easily get out of synch with the actual code) and an\nappropriate level of documentation to enhance the maintainability of the\ncode.'),(0,i.kt)("p",null,'One of the major maintenance headaches associated with inheritance and\ndynamic binding relates to undocumented interdependencies among\nprimitive (dispatching) operations of tagged types (the equivalent of\n"methods" in typical object-oriented terminology). If a derived type\ninherits some and overrides other primitive operations, there is the\nquestion of what indirect effects on the inherited primitives are\nproduced. If no redispatching is used, the primitives may be inherited\nas "black boxes." If redispatching is used internally, then when\ninherited, the externally visible behavior of an operation may change,\ndepending on what other primitives are overridden. Maintenance problems\n(here, finding and fixing bugs) occur when someone overrides incorrectly\n(on purpose or by accident) an operation used in redispatching. Because\nthis overriding can invalidate the functioning of another operation\ndefined perhaps several levels of inheritance up from the incorrect\noperation, it can be extremely difficult to track down.'),(0,i.kt)("p",null,'In the object-oriented paradigm, redispatching is often used to\nparameterize abstractions. In other words, certain primitives are\nintended to be overridden precisely because they are redispatching.\nThese primitives may even be declared as abstract, requiring that they\nbe overridden. Because they are redispatching, they act as "parameters"\nfor the other operations. Although in Ada much of this parameterization\ncan be done using generics, there are cases where the redispatching\napproach leads to a clearer object-oriented design. When you document\nthe redispatching connection between the operations that are to be\noverridden and the operations that use them, you make the intended use\nof the type much clearer.'),(0,i.kt)("p",null,'Hence, any use of redispatching within a primitive should be considered\npart of the "interface" of the primitive, at least as far as any\ninheritor, and requires documentation at the specification level. The\nalternative (i.e., not providing such documentation in the\nspecification) is to have to delve deep into the code of all the classes\nin the derivation hierarchy in order to map out the redispatching calls.\nSuch detective work compromises the black-box nature of object-oriented\nclass definitions. Note that if you follow Guideline 9.2.1 on preserving\nthe semantics of the class-wide dispatching operations in the extensions\nof derived types, you will minimize or avoid the problems discussed here\nabout redispatching.'),(0,i.kt)("h3",p({},{id:"class-wide-operations"}),"Class-Wide Operations"),(0,i.kt)("h4",p({},{id:"guideline-5"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using a class-wide operation (i.e., an operation with\nparameter","[","s","]"," of a class-wide type) when an operation can be\nwritten, compiled, and tested without knowing all the possible\ndescendants of a given tagged type (Barnes 1996)."),(0,i.kt)("li",{parentName:"ul"},"Consider using a class-wide operation when you do not want an\noperation to be inherited and/or overridden.")),(0,i.kt)("h4",p({},{id:"example-5"}),"example"),(0,i.kt)("p",null,"The following example is adapted from Barnes (1996) using the geometric\nobjects from the example of Guideline 9.2.1 and declaring the following\nfunctions as primitives in the package specification:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"\nfunction Area (O : in Object) return Float;\n\nfunction Area (C : in Circle) return Float;\n\nfunction Area (S : in Shape) return Float;\n")),(0,i.kt)("p",null,"A function for computing the moment of a force about a fulcrum can now\nbe created using a class-wide type as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"\nfunction Moment (OC : Object'Class) return Float is\nbegin\n   return OC.X_Coord*Area(OC);\nend Moment;\n")),(0,i.kt)("p",null,"Because Moment accepts the class-wide formal parameter of Object'Class,\nit can be called with an actual parameter that is any derivation of type\nObject. Assuming that all derivations of type object have defined a\nfunction for Area, Moment will dispatch to the appropriate function when\ncalled. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"C : Circle;\nM : Float;\n\n...\n\n-- Moment will dispatch to the Area function for the Circle type.\nM := Moment(C);\n")),(0,i.kt)("h4",p({},{id:"rationale-5"}),"rationale"),(0,i.kt)("p",null,"The use of class-wide operations avoids unnecessary duplication of code.\nRun-time dispatching may be used where necessary to invoke appropriate\ntype-specific operations based on an operand's tag."),(0,i.kt)("p",null,"See also Guideline 8.4.3 for a discussion of class-wide pointers in an\nobject-oriented programming framework registry."),(0,i.kt)("h3",p({},{id:"constructors"}),"Constructors"),(0,i.kt)("p",null,"Ada does not define a unique syntax for constructors. In Ada a\nconstructor for a type is defined as an operation that produces as a\nresult a constructed object, i.e., an initialized instance of the type."),(0,i.kt)("h4",p({},{id:"guideline-6"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Avoid declaring a constructor as a primitive abstract operation."),(0,i.kt)("li",{parentName:"ul"},"Use a primitive abstract operation to declare an initialization\nfunction or constructor only when objects of the inheriting derived\ntypes will not require additional parameters for initialization."),(0,i.kt)("li",{parentName:"ul"},"Consider using access discriminants to provide parameters to default\ninitialization."),(0,i.kt)("li",{parentName:"ul"},"Use constructors for explicit initialization."),(0,i.kt)("li",{parentName:"ul"},"Consider splitting the initialization and construction of an object."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring a constructor operation in a child package."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring a constructor operation to return an access value\nto the constructed object (Dewar 1995).")),(0,i.kt)("h4",p({},{id:"example-6"}),"example"),(0,i.kt)("p",null,"The following example illustrates the declaration of a constructor in a\nchild package:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"--------------------------------------------------------------------------\npackage Game is\n   type Game_Piece is tagged ...\n   ...\n\nend Game;\n--------------------------------------------------------------------------\npackage Game.Constructors is\n   function Make_Piece return Game_Piece;\n   ...\nend Game.Constructors;\n--------------------------------------------------------------------------\n")),(0,i.kt)("p",null,"The following example shows how to split the initialization and\nconstruction of an object:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"type Vehicle is tagged ...\n\nprocedure Initialize (Self : in out Vehicle;\n                      Make : in     String);\n\n...\n\ntype Car is new Vehicle with ... ;\ntype Car_Ptr is access all Car'Class;\n\n...\n\nprocedure Initialize (Self  : in out Car_Ptr;\n                      Make  : in     String;\n                      Model : in     String) is\nbegin -- Initialize\n   Initialize (Vehicle (Self.all), Make);\n   ...\n   -- initialization of Car\nend Initialize;\n\nfunction Create (Make  : in String;\n                 Model : in String) return Car_Ptr is\n   Temp_Ptr : Car_Ptr;\nbegin -- Create\n   Temp_Ptr := new Car;\n   Initialize (Temp_Ptr, Make, Model);\n   return Temp_Ptr;\nend Create;\n")),(0,i.kt)("h4",p({},{id:"rationale-6"}),"rationale"),(0,i.kt)("p",null,"Constructor operations for the types in a type hierarchy (assuming\ntagged types and their derivatives) usually differ in their parameter\nprofiles. The constructor will typically need more parameters because of\nthe added components in the descendant types. You run into a problem\nwhen you let constructor operations be inherited because you now have\noperations for which there is no meaningful implementation (default or\noverridden). Effectively, you violate the class-wide properties (see\nGuideline 9.2.1) because the root constructor will not successfully\nconstruct a descendant object. Inherited operations cannot add\nparameters to their parameter profile, so these are inappropriate to use\nas constructors."),(0,i.kt)("p",null,"You cannot initialize a limited type at its declaration, so you may need\nto use an access discriminant and rely on default initialization. For a\ntagged type, however, you should not assume that any default\ninitialization is sufficient, and you should declare constructors. For\nlimited types, the constructors must be separate procedures or functions\nthat return an access to the limited type."),(0,i.kt)("p",null,"The example shows using a constructor in a child package. By declaring\nconstructor operations in either a child package or a nested package,\nyou avoid the problems associated with making them primitive operations.\nBecause they are no longer primitive operations, they cannot be\ninherited. By declaring them in a child package (see also Guidelines\n4.1.6 and 4.2.2 on using child packages versus nested packages), you\ngain the ability to change them without affecting the clients of the\nparent package (Taft 1995b)."),(0,i.kt)("p",null,"You should put the construction logic and initialization logic in\ndistinct subprograms so that you are able to call the initialization\nroutine for the parent tagged type."),(0,i.kt)("h4",p({},{id:"notes-1"}),"notes"),(0,i.kt)("p",null,"When you extend a tagged type (regardless whether it is an abstract\ntype), you can choose to declare as abstract some of the additional\noperations. Doing so, however, means that the derived type must also be\ndeclared as abstract. If this newly derived type has inherited any\nfunctions that name it as the return type, these inherited functions now\nalso become abstract (Barnes 1996). If one of these primitive functions\nserved as the constructor function, you have now violated the first\nguideline in that the constructor has become a primitive abstract\noperation."),(0,i.kt)("h3",p({},{id:"equality"}),"Equality"),(0,i.kt)("h4",p({},{id:"guideline-7"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'When you redefine the "=" operator on a tagged type, make sure that\nit has the expected behavior in extensions of this type and override\nit if necessary.')),(0,i.kt)("h4",p({},{id:"example-7"}),"example"),(0,i.kt)("p",null,"The following example is adapted from the discussion of equality and\ninheritance in Barnes (1996):"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),'----------------------------------------------------------------------------\npackage Object_Package is\n\n   Epsilon : constant Float := 0.01;\n\n   type Object is tagged\n      record\n         X_Coordinate : Float;\n         Y_Coordinate : Float;\n      end record;\n\n   function "=" (A, B : Object) return Boolean;\n\nend Object_Package;\n----------------------------------------------------------------------------\npackage body Object_Package is\n\n   -- redefine equality to be when two objects are located within a delta\n   -- of the same point\n   function "=" (A, B : Object) return Boolean is\n   begin\n      return (A.X_Coordinate - B.X_Coordinate) ** 2\n           + (A.Y_Coordinate - B.Y_Coordinate) ** 2 < Epsilon**2;\n   end "=";\n\nend Object_Package;\n\n----------------------------------------------------------------------------\nwith Object_Package;  use Object_Package;\npackage Circle_Package_1 is\n   type Circle is new Object with\n      record\n         Radius : Float;\n      end record;\n  function "=" (A, B : Circle) return Boolean;\nend Circle_Package_1;\n----------------------------------------------------------------------------\npackage body Circle_Package_1 is\n\n   -- Equality is overridden, otherwise two circles must have exactly\n   -- equal radii to be considered equal.\n   function "=" (A, B : Circle) return Boolean is\n   begin\n      return (Object(A) = Object(B)) and\n             (abs (A.Radius - B.Radius) < Epsilon);\n   end "=";\n\nend Circle_Package_1;\n----------------------------------------------------------------------------\nwith Object_Package;  use Object_Package;\npackage Circle_Package_2 is\n\n   type Circle is new Object with\n      record\n         Radius : Float;\n      end record;\n\n   -- don\'t override equality in this package\n\nend Circle_Package_2;\n----------------------------------------------------------------------------\nwith Object_Package;\nwith Circle_Package_1;\nwith Circle_Package_2;\nwith Ada.Text_IO;\nprocedure Equality_Test is\n   use type Object_Package.Object;\n   use type Circle_Package_1.Circle;\n   use type Circle_Package_2.Circle;\n   Object_1 : Object_Package.Object;\n   Object_2 : Object_Package.Object;\n   Circle_1 : Circle_Package_1.Circle;\n   Circle_2 : Circle_Package_1.Circle;\n   Circle_3 : Circle_Package_2.Circle;\n   Circle_4 : Circle_Package_2.Circle;\nbegin\n   Object_1 := (X_Coordinate => 1.000, Y_Coordinate => 2.000);\n   Object_2 := (X_Coordinate => 1.005, Y_Coordinate => 2.000);\n   -- These Objects are considered equal.  Equality has been redefined to be\n   -- when two objects are located within a delta of the same point.\n   if Object_1 = Object_2 then\n      Ada.Text_IO.Put_Line ("Objects equal.");\n   else\n      Ada.Text_IO.Put_Line ("Objects not equal.");\n   end if;\n   Circle_1 := (X_Coordinate => 1.000, Y_Coordinate => 2.000, Radius => 5.000);\n   Circle_2 := (X_Coordinate => 1.005, Y_Coordinate => 2.000, Radius => 5.005);\n   -- These Circles are considered equal.  Equality has been redefined to be\n   -- when the X-Y locations of the circles and their radii are both within\n   -- the delta.\n   if Circle_1 = Circle_2 then\n      Ada.Text_IO.Put_Line ("Circles equal.");\n   else\n      Ada.Text_IO.Put_Line ("Circles not equal.");\n   end if;\n   Circle_3 := (X_Coordinate => 1.000, Y_Coordinate => 2.000, Radius => 5.000);\n   Circle_4 := (X_Coordinate => 1.005, Y_Coordinate => 2.000, Radius => 5.005);\n   -- These Circles are not considered equal because predefined equality of\n   -- the extension component Radius will evaluate to False.\n   if Circle_3 = Circle_4 then\n      Ada.Text_IO.Put_Line ("Circles equal.");\n   else\n      Ada.Text_IO.Put_Line ("Circles not equal.");\n   end if;\nend Equality_Test;\n')),(0,i.kt)("h4",p({},{id:"rationale-7"}),"rationale"),(0,i.kt)("p",null,"Equality is applied to all components of a record. When you extend a\ntagged type and compare two objects of the derived type for equality,\nthe parent components as well as the new extension components will be\ncompared. Therefore, when you redefine equality on a tagged type and\ndefine extensions on this type, the parent components are compared using\nthe redefined equality. The extension components are also compared,\nusing either predefined equality or some other redefined equality if\nappropriate. The behavior of inherited equality differs from the\nbehavior of other inherited operations. When other primitives are\ninherited, if you do not override the inherited primitive, it can only\noperate on the parent components of the object of the extended type.\nEquality, on the other hand, generally does the right thing."),(0,i.kt)("h3",p({},{id:"polymorphism"}),"Polymorphism"),(0,i.kt)("h4",p({},{id:"guideline-8"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using class-wide programming to provide run-time, dynamic\npolymorphism when constructing larger, reusable, extensible\nframeworks."),(0,i.kt)("li",{parentName:"ul"},"When possible, use class-wide programming rather than variant\nrecords."),(0,i.kt)("li",{parentName:"ul"},"Use class-wide programming to provide a consistent interface across\nthe set of types in the tagged type hierarchy (i.e., class)."),(0,i.kt)("li",{parentName:"ul"},"Consider using generics to define a new type in terms of an existing\ntype, either as an extension or as a container, collection, or\ncomposite data structure."),(0,i.kt)("li",{parentName:"ul"},"Avoid using type extensions for parameterized abstractions when\ngenerics provide a more appropriate mechanism.")),(0,i.kt)("h4",p({},{id:"example-8"}),"example"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"  generic\n     type Element is private;\n  package Stack is\n     ...\n  end Stack;\n\nis preferable to:\n\n  package Stack is\n     type Element is tagged null record;\n     -- Elements to be put on the stack must be of a descendant type\n     -- of this type.\n     ...\n  end Stack;\n")),(0,i.kt)("h4",p({},{id:"rationale-8"}),"rationale"),(0,i.kt)("p",null,"Both generics and class-wide types allow a single algorithm to be\napplicable to multiple, specific types. With generics, you achieve\npolymorphism across unrelated types because the type used in the\ninstantiation must match the generic formal part. You specify required\noperations using generic formal subprograms, constructing them as needed\nfor a given instantiation. Generics are ideal for capturing relatively\nsmall, reusable algorithms and programming idioms, for example, sorting\nalgorithms, maps, bags, and iterators. As generics become large,\nhowever, they become unwieldy, and each instantiation may involve\nadditional generated code. Class-wide programming, including class-wide\ntypes and type extension, is more appropriate for building a large\nsubsystem because you avoid the additional generated code and unwieldy\nproperties of generics."),(0,i.kt)("p",null,"Class-wide programming enables you to take a set of heterogeneous data\nstructures and provide a homogeneous-looking interface across the whole\nset. See also Guideline 9.2.1 on using tagged types to describe\nheterogeneous polymorphic data."),(0,i.kt)("p",null,"In object-oriented programming languages without generic capabilities,\nit was common to use inheritance to achieve much the same effect.\nHowever, this technique is generally less clear and more cumbersome to\nuse than the equivalent explicit generic definition. The nongeneric,\ninheritance approach can always be recovered using a specific\ninstantiation of the generic. Also see Guidelines 5.3.2 and 5.4.7 for a\ndiscussion of self-referential data structures."),(0,i.kt)("h2",p({},{id:"managing-visibility"}),"Managing Visibility"),(0,i.kt)("h3",p({},{id:"derived-tagged-types"}),"Derived Tagged Types"),(0,i.kt)("h4",p({},{id:"guideline-9"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider giving derived tagged types the same visibility to the\nparent type as other clients of the parent."),(0,i.kt)("li",{parentName:"ul"},"Define a derived tagged type in a child of the package that defines\nthe base type if the implementation of the derived type requires\ngreater visibility into the implementation of the base type than\nother clients of the base type require.")),(0,i.kt)("h4",p({},{id:"example-9"}),"example"),(0,i.kt)("p",null,"The following example illustrates the need for a derived type to have\ngreater visibility into the implementation of the base type than other\nclients of the base type. In this example of a stack class hierarchy,\nPush and Pop routines provide a homogeneous interface for all variations\nof stacks. However, the implementation of these operations requires\ngreater visibility into the base types due to the differences in the\ndata elements. This example is adapted from Barbey, Kempe, and\nStrohmeier (1994):"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"generic\n   type Item_Type is private;\npackage Generic_Stack is\n   type Abstract_Stack_Type is abstract tagged limited private;\n   procedure Push (Stack : in out Abstract_Stack_Type;\n                   Item  : in     Item_Type) is abstract;\n   procedure Pop (Stack : in out Abstract_Stack_Type;\n                  Item  :    out Item_Type) is abstract;\n   function Size (Stack : Abstract_Stack_Type) return Natural;\n   Full_Error  : exception; -- May be raised by Push\n   Empty_Error : exception; -- May be raised by Pop\nprivate\n   type Abstract_Stack_Type is abstract tagged limited\n      record\n         Size : Natural := 0;\n      end record;\nend Generic_Stack;\npackage body Generic_Stack is\n   function Size (Stack : Abstract_Stack_Type)\n      return Natural is\n   begin\n      return Stack.Size;\n   end Size;\nend Generic_Stack;\n--\n-- Now, a bounded stack can be derived in a child package as follows:\n--\n----------------------------------------------------------------------\ngeneric\npackage Generic_Stack.Generic_Bounded_Stack is\n   type Stack_Type (Max : Positive) is\n      new Abstract_Stack_Type with private;\n   -- override all abstract subprograms\n   procedure Push (Stack : in out Stack_Type;\n                   Item  : in     Item_Type);\n   procedure Pop (Stack : in out Stack_Type;\n                  Item  :    out Item_Type);\nprivate\n   type Table_Type is array (Positive range <>) of Item_Type;\n   type Stack_Type (Max : Positive) is new Abstract_Stack_Type with\n      record\n         Table : Table_Type (1 .. Max); \n      end record;\nend Generic_Stack.Generic_Bounded_Stack;\n----------------------------------------------------------------------\npackage body Generic_Stack.Generic_Bounded_Stack is\n\n   procedure Push (Stack : in out Stack_Type;\n                   Item  : in     Item_Type) is\n   begin\n\n      -- The new bounded stack needs visibility into the base type\n      --   in order to update the Size element of the stack type\n      --   when adding or removing items.\n\n      if (Stack.Size = Stack.Max) then\n         raise Full_Error;\n      else\n         Stack.Size := Stack.Size + 1;\n         Stack.Table(Stack.Size) := Item;\n      end if;\n   end Push;\n\n   procedure Pop (Stack : in out Stack_Type;\n                  Item  :    out Item_Type) is\n   begin\n      ...\n   end Pop;\n\nend Generic_Stack.Generic_Bounded_Stack;\n")),(0,i.kt)("h4",p({},{id:"rationale-9"}),"rationale"),(0,i.kt)("p",null,"If the derived type can be defined without any special visibility of the\nbase type, this provides for the best possible decoupling of the\nimplementation of the derived type from changes in the implementation of\nthe base type. On the other hand, the operations of an extension of a\ntagged type may need additional information from the base type that is\nnot commonly needed by other clients."),(0,i.kt)("p",null,"When the implementation of a derived tagged type requires visibility of\nthe implementation of the base type, use a child package to define the\nderived type. Rather than providing additional public operations for\nthis information, it is better to place the definition of the derived\ntype in a child package. This gives the derived type the necessary\nvisibility without risking misuse by other clients."),(0,i.kt)("p",null,"This situation is likely to arise when you build a data structure with a\nhomogeneous interface but whose data elements have a heterogeneous\nimplementation. See also Guidelines 8.4.8, 9.2.1, and 9.3.5."),(0,i.kt)("h2",p({},{id:"multiple-inheritance"}),"Multiple Inheritance"),(0,i.kt)("p",null,'Ada provides several mechanisms to support multiple inheritance, where\nmultiple inheritance is a means for incrementally building new\nabstractions from existing ones, as defined at the beginning of this\nchapter. Specifically, Ada supports multiple inheritance module\ninclusion (via multiple with/use clauses), multiple inheritance\n"is-implemented-using" via private extensions and record composition,\nand multiple inheritance mixins via the use of generics, formal\npackages, and access discriminants (Taft 1994).'),(0,i.kt)("h3",p({},{id:"multiple-inheritance-techniques"}),"Multiple Inheritance Techniques"),(0,i.kt)("h4",p({},{id:"guideline-10"}),"guideline"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using type composition for implementation, as opposed to\ninterface, inheritance."),(0,i.kt)("li",{parentName:"ul"},'Consider using a generic to "mix in" functionality to a derivative\nof some core abstraction.'),(0,i.kt)("li",{parentName:"ul"},'Consider using access discriminants to support "full" multiple\ninheritance where an object must be referenceable as an entity of\ntwo or more distinct unrelated abstractions.')),(0,i.kt)("h4",p({},{id:"example-10"}),"example"),(0,i.kt)("p",null,"Both examples that follow are taken directly from Taft (1994). The first\nshows how to use multiple inheritance techniques to create an abstract\ntype whose interface inherits from one type and whose implementation\ninherits from another type. The second example shows how to enhance the\nfunctionality of a basic abstraction by mixing in new features."),(0,i.kt)("p",null,"The abstract type Set","_","Of","_","Strings provides the interface to inherit:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"\ntype Set_Of_Strings is abstract tagged limited private;\ntype Element_Index is new Natural;  -- Index within set.\nNo_Element : constant Element_Index := 0;\nInvalid_Index : exception;\nprocedure Enter(\n  -- Enter an element into the set, return the index\n  Set : in out Set_Of_Strings;\n  S : String;\n  Index : out Element_Index) is abstract;\nprocedure Remove(\n  -- Remove an element from the set; ignore if not there\n  Set : in out Set_Of_Strings;\n  S : String) is abstract;\nprocedure Combine(\n  -- Combine Additional_Set into Union_Set\n  Union_Set : in out Set_Of_Strings;\n  Additional_Set : Set_Of_Strings) is abstract;\nprocedure Intersect(\n  -- Remove all elements of Removal_Set from Intersection_Set\n  Intersection_Set : in out Set_Of_Strings;\n  Removal_Set : Set_Of_Strings) is abstract;\nfunction Size(Set : Set_Of_Strings) return Element_Index \n  is abstract;\n  -- Return a count of the number of elements in the set\nfunction Index(\n  -- Return the index of a given element;\n  -- return No_Element if not there.\n  Set : Set_Of_Strings;\n  S : String) return Element_Index is abstract;\nfunction Element(Index : Element_Index) return String is abstract;\n  -- Return element at given index position\n  -- raise Invalid_Index if no element there.\nprivate\n  type Set_Of_Strings is abstract tagged limited ...\n\nThe type Hashed_Set derives its interface from Set_of_Strings and its implementation from an existing (concrete) type Hash_Table:\n\ntype Hashed_Set(Table_Size : Positive) is\n  new Set_Of_Strings with private;\n-- Now we give the specs of the operations being implemented\nprocedure Enter(\n  -- Enter an element into the set, return the index\n  Set : in out Hashed_Set;\n  S : String;\n  Index : out Element_Index);\nprocedure Remove(\n  -- Remove an element from the set; ignore if not there\n  Set : in out Hashed_Set;\n  S : String);\n  -- . . . etc.\nprivate\n  type Hashed_Set(Table_Size : Positive) is\n    new Set_Of_Strings with record\n      Table : Hash_Table(1..Table_Size);\n    end record;\n")),(0,i.kt)("p",null,"In the package body, you define the bodies of the operations (i.e.,\nEnter, Remove,Combine, Size, etc.) using the operations available on\nHash","_",'Table. You must also provide any necessary "glue" code.'),(0,i.kt)("p",null,"In this second example, the type Basic","_","Window responds to various\nevents and calls:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"\ntype Basic_Window is tagged limited private;\nprocedure Display(W : Basic_Window);\nprocedure Mouse_Click(W     : in out Basic_Window;\n                      Where :        Mouse_Coords);\n          . . .\n")),(0,i.kt)("p",null,"You use mixins to add features such as labels, borders, menu bar, etc.:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"generic\n  type Some_Window is new Window with private;\n  -- take in any descendant of Window\npackage Label_Mixin is\n  type Window_With_Label is new Some_Window with private;\n    -- Jazz it up somehow.\n  -- Overridden operations:\n  procedure Display(W : Window_With_Label);\n  -- New operations:\n  procedure Set_Label(W : in out Window_With_Label; S : String);\n    -- Set the label\n  function Label(W : Window_With_Label) return String;\n    -- Fetch the label\nprivate\n  type Window_With_Label is\n    new Some_Window with record\n      Label : String_Quark := Null_Quark;\n        -- An XWindows-Like unique ID for a string\n    end record;\n")),(0,i.kt)("p",null,"In the generic body, you implement any overridden operations as well as\nthe new operations. For example, you could implement the overridden\nDisplay operation using some of the inherited operations:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"procedure Display(W : Window_With_Label) is\nbegin\n    Display(Some_Window(W));\n      -- First display the window normally,\n      -- by passing the buck to the parent type.\n    if W.Label /= Null_Quark then\n      -- Now display the label if it is not null\n        Display_On_Screen(XCoord(W), YCoord(W)-5, Value(W.Label));\n          -- Use two inherited functions on Basic_Window\n          -- to get the coordinates where to display the label.\n    end if;\nend Display;\n")),(0,i.kt)("p",null,"Assuming you have defined several generics with these additional\nfeatures, to create the desired window, you use a combination of generic\ninstantiations and private type extension, as shown in the following\ncode:"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"\n  type My_Window is new Basic_Window with private;\n  . . .\nprivate\n  package Add_Label is new Label_Mixin(Basic_Window);\n  package Add_Border is\n    new Border_Mixin(Add_Label.Window_With_Label);\n  package Add_Menu_Bar is\n    new Menu_Bar_Mixin(Add_Border.Window_With_Border);\n  type My_Window is\n    new Add_Menu_Bar.Window_With_Menu_Bar with null record;\n      -- Final window is a null extension of Window_With_Menu_Bar.\n      -- We could instead make a record extension and\n      -- add components for My_Window over and above those\n      -- needed by the mixins.\n")),(0,i.kt)("p",null,'The following example shows "full" multiple inheritance.'),(0,i.kt)("p",null,"Assume previous definition of packages for Savings","_","Account and\nChecking","_","Account. The following example shows the definition of an\ninterest-bearing checking account (NOW account):"),(0,i.kt)("pre",null,(0,i.kt)("code",p({parentName:"pre"},{className:"language-ada"}),"with Savings_Account;\nwith Checking_Account;\npackage NOW_Account is\n\n   type Object is tagged limited private;\n\n   type Savings (Self : access Object'Class) is\n      new Savings_Account.Object with null record;\n\n   -- These need to be overridden to call through to \"Self\"\n   procedure Deposit (Into_Account : in out Savings; ...);\n   procedure Withdraw (...);\n   procedure Earn_Interest (...);\n   function Interest (...) return Float;\n   function Balance (...) return Float;\n   type Checking (Self : access Object'Class) is\n      new Checking_Account.Object with null record;\n\n   procedure Deposit (Into_Account : in out Checking; ...);\n   ...\n   function Balance (...) return Float;\n\n   -- These operations will call-through to Savings_Account or\n   -- Checking_Account operations. \"Inherits\" in this way all savings and\n   -- checking operations\n\n   procedure Deposit (Into_Account : in out Object; ...);\n   ...\n   procedure Earn_Interest (...);\n   ...\n   function Balance (...) return Float;\n\nprivate\n\n   -- Could alternatively have Object be derived from either\n   -- Savings_Account.Object or Checking_Account.Object\n   type Object is tagged\n      record\n         As_Savings  : Savings (Object'Access);\n         As_Checking : Checking (Object'Access);\n      end record;\n\nend NOW_Account;\n")),(0,i.kt)("p",null,"Another possibility is that the savings and checking accounts are both\nimplemented based on a common Account abstraction, resulting in\ninheriting a Balance state twice for NOW","_","Account.Object. To resolve\nthis ambiguity, you need to use an abstract type hierarchy for the\nmultiple inheritance of interface and separate mixins for the multiple\ninheritance of implementation."),(0,i.kt)("h4",p({},{id:"rationale-10"}),"rationale"),(0,i.kt)("p",null,"In other languages such as Eiffel and C++, multiple inheritance serves\nmany purposes. In Eiffel, for instance, you must use inheritance both\nfor module inclusion and for inheritance itself (Taft 1994). Ada\nprovides context clauses for module inclusion and child libraries for\nfiner modularization control. Ada does not provide a separate syntax for\nmultiple inheritance. Rather, it provides a set of building blocks in\ntype extension and composition that allow you to mix in additional\nbehaviors."),(0,i.kt)("p",null,"A library of mixins allows the client to mix and match in order to\ndevelop an implementation. Also see Guideline 8.3.8 about implementing\nmixins."),(0,i.kt)("p",null,"You should not use multiple inheritance to derive an abstraction that is\nessentially unrelated to its parent(s). Thus, you should not try to\nderive a menu abstraction by inheriting from a command line type and a\nwindow type. However, if you have a basic abstraction such as a window,\nyou can use multiple inheritance mixins to create a more sophisticated\nabstraction, where a mixin is the package containing the type(s) and\noperations that will extend the parent abstraction."),(0,i.kt)("p",null,'Use self-referential data structures to implement types with "full"\nmultiple inheritance ("multiple polymorphism").'),(0,i.kt)("p",null,"A common mistake is to use multiple inheritance for parts-of relations.\nWhen a type is composed of several others types, you should use\nheterogeneous data structuring techniques, discussed in Guideline 5.4.2."),(0,i.kt)("h2",p({},{id:"summary"}),"Summary"),(0,i.kt)("h3",p({},{id:"tagged-type-hierarchies-1"}),"tagged type hierarchies"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using type extension when designing an is-a\n(generalization/specialization) hierarchy."),(0,i.kt)("li",{parentName:"ul"},"Use tagged types to preserve a common interface across differing\nimplementations (Taft 1995a)."),(0,i.kt)("li",{parentName:"ul"},"When defining a tagged type in a package, consider including a\ndefinition of a general access type to the corresponding class-wide\ntype."),(0,i.kt)("li",{parentName:"ul"},"In general, define only one tagged type per package."),(0,i.kt)("li",{parentName:"ul"},"The implementation of the dispatching operations of each type in a\nderivation class rooted in a tagged type T should conform to the\nexpected semantics of the corresponding dispatching operations of\nthe class-wide type T'Class."),(0,i.kt)("li",{parentName:"ul"},'Consider using a controlled type whenever a type allocates resources\nthat must be deallocated or otherwise "cleaned up" on destruction or\noverwriting.'),(0,i.kt)("li",{parentName:"ul"},'Use a derivation from a controlled type in preference to providing\nan explicit "cleanup" operation that must be called by clients of\nthe type.'),(0,i.kt)("li",{parentName:"ul"},"When overriding the adjustment and finalization procedures derived\nfrom controlled types, define the finalization procedure to undo the\neffects of the adjustment procedure."),(0,i.kt)("li",{parentName:"ul"},"Derived type initialization procedures should call the\ninitialization procedure of their parent as part of their\ntype-specific initialization."),(0,i.kt)("li",{parentName:"ul"},"Derived type finalization procedures should call the finalization\nprocedure of their parent as part of their type-specific\nfinalization."),(0,i.kt)("li",{parentName:"ul"},"Consider deriving a data structure's components rather than the\nenclosing data structure from a controlled type."),(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types and operations in creating\nclassification schemes, for example, a taxonomy, in which only the\nleaf objects will be meaningful in the application."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring root types and internal nodes in a type tree as\nabstract."),(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types for generic formal derived types."),(0,i.kt)("li",{parentName:"ul"},"Consider using abstract types to develop different implementations\nof a single abstraction.")),(0,i.kt)("h3",p({},{id:"tagged-type-operations-1"}),"tagged type operations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Consider declaring a primitive abstract operation based on the\nabsence of a meaningful "default" behavior.'),(0,i.kt)("li",{parentName:"ul"},'Consider declaring a primitive nonabstract operation based on the\npresence of a meaningful "default" behavior.'),(0,i.kt)("li",{parentName:"ul"},"When overriding an operation, the overriding subprogram should not\nraise exceptions that are not known to the users of the overridden\nsubprogram."),(0,i.kt)("li",{parentName:"ul"},'If redispatching is used in the implementation of the operations of\na type, with the specific intent that some of the redispatched-to\noperations be overridden by specializations for the derived types,\nthen document this intent clearly in the specification as part of\nthe "interface" of a parent type with its derived types.'),(0,i.kt)("li",{parentName:"ul"},"When redispatching is used (for any reason) in the implementation of\na primitive operation of a tagged type, then document (in some\nproject-consistent way) this use in the body of the operation\nsubprogram so that it can be easily found during maintenance."),(0,i.kt)("li",{parentName:"ul"},"Consider using a class-wide operation (i.e., an operation with\nparameter","[","s","]"," of a class-wide type) when an operation can be\nwritten, compiled, and tested without knowing all the possible\ndescendants of a given tagged type (Barnes 1996)."),(0,i.kt)("li",{parentName:"ul"},"Consider using a class-wide operation when you do not want an\noperation to be inherited and/or overridden."),(0,i.kt)("li",{parentName:"ul"},"Avoid declaring a constructor as a primitive abstract operation."),(0,i.kt)("li",{parentName:"ul"},"Use a primitive abstract operation to declare an initialization\nfunction or constructor only when objects of the inheriting derived\ntypes will not require additional parameters for initialization."),(0,i.kt)("li",{parentName:"ul"},"Consider using access discriminants to provide parameters to default\ninitialization."),(0,i.kt)("li",{parentName:"ul"},"Use constructors for explicit initialization."),(0,i.kt)("li",{parentName:"ul"},"Consider splitting the initialization and construction of an object."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring a constructor operation in a child package."),(0,i.kt)("li",{parentName:"ul"},"Consider declaring a constructor operation to return an access value\nto the constructed object (Dewar 1995)."),(0,i.kt)("li",{parentName:"ul"},'When you redefine the "=" operator on a tagged type, make sure that\nit has the expected behavior in extensions of this type and override\nit if necessary.'),(0,i.kt)("li",{parentName:"ul"},"Consider using class-wide programming to provide run-time, dynamic\npolymorphism when constructing larger, reusable, extensible\nframeworks."),(0,i.kt)("li",{parentName:"ul"},"When possible, use class-wide programming rather than variant\nrecords."),(0,i.kt)("li",{parentName:"ul"},"Use class-wide programming to provide a consistent interface across\nthe set of types in the tagged type hierarchy (i.e., class)."),(0,i.kt)("li",{parentName:"ul"},"Consider using generics to define a new type in terms of an existing\ntype, either as an extension or as a container, collection, or\ncomposite data structure."),(0,i.kt)("li",{parentName:"ul"},"Avoid using type extensions for parameterized abstractions when\ngenerics provide a more appropriate mechanism.")),(0,i.kt)("h3",p({},{id:"managing-visibility-1"}),"managing visibility"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider giving derived tagged types the same visibility to the\nparent type as other clients of the parent."),(0,i.kt)("li",{parentName:"ul"},"Define a derived tagged type in a child of the package that defines\nthe base type if the implementation of the derived type requires\ngreater visibility into the implementation of the base type than\nother clients of the base type require.")),(0,i.kt)("h3",p({},{id:"multiple-inheritance-1"}),"multiple inheritance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider using type composition for implementation, as opposed to\ninterface, inheritance."),(0,i.kt)("li",{parentName:"ul"},'Consider using a generic to "mix in" functionality to a derivative\nof some core abstraction.'),(0,i.kt)("li",{parentName:"ul"},'Consider using access discriminants to support "full" multiple\ninheritance where an object must be referenceable as an entity of\ntwo or more distinct unrelated abstractions.\n:::note')),(0,i.kt)("p",null,'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,i.kt)("a",p({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,i.kt)("a",p({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply.  Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work."),(0,i.kt)("p",null,":::"))}b.isMDXComponent=!0}}]);