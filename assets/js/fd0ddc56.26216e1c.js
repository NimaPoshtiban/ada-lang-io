"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[8069],{68369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>b,contentTitle:()=>f,default:()=>Z,frontMatter:()=>y,metadata:()=>g,toc:()=>x});var a=n(91716),o=n(21256),r=n(24895),i=n(28090),l=n(48424),s=n(82262),d=Object.defineProperty,c=Object.defineProperties,p=Object.getOwnPropertyDescriptors,k=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,m=Object.prototype.propertyIsEnumerable,h=(e,t,n)=>t in e?d(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,A=(e,t)=>{for(var n in t||(t={}))u.call(t,n)&&h(e,n,t[n]);if(k)for(var n of k(t))m.call(t,n)&&h(e,n,t[n]);return e};const y={sidebar_position:78},f="9.5 Intertask Communication",g={unversionedId:"arm/AA-9/AA-9.5",id:"arm/AA-9/AA-9.5",title:"9.5 Intertask Communication",description:"This Reference Manual output has not been verified,",source:"@site/docs/arm/AA-9/AA-9.5.mdx",sourceDirName:"arm/AA-9",slug:"/arm/AA-9/AA-9.5",permalink:"/docs/arm/AA-9/AA-9.5",draft:!1,tags:[],version:"current",sidebarPosition:78,frontMatter:{sidebar_position:78},sidebar:"referenceManualSidebar",previous:{title:"9.4 Protected Units and Protected Objects",permalink:"/docs/arm/AA-9/AA-9.4"},next:{title:"9.6 Delay Statements, Duration, and Time",permalink:"/docs/arm/AA-9/AA-9.6"}},b={},x=[{value:"Static Semantics",id:"static-semantics",level:4},{value:"Legality Rules",id:"legality-rules",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Static Semantics",id:"static-semantics-1",level:4},{value:"Legality Rules",id:"legality-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-2",level:4},{value:"Legality Rules",id:"legality-rules-2",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005",level:4},{value:"Wording Changes from Ada 2005",id:"wording-changes-from-ada-2005",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012",level:4},{value:"9.5.1  Protected Subprograms and Protected Actions",id:"951--protected-subprograms-and-protected-actions",level:2},{value:"Static Semantics",id:"static-semantics-3",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-1",level:4},{value:"Bounded (Run-Time) Errors",id:"bounded-run-time-errors",level:4},{value:"Examples",id:"examples",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012",level:4},{value:"9.5.2  Entries and Accept Statements",id:"952--entries-and-accept-statements",level:2},{value:"Syntax",id:"syntax-1",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules",level:4},{value:"Legality Rules",id:"legality-rules-3",level:4},{value:"Static Semantics",id:"static-semantics-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-2",level:4},{value:"Examples",id:"examples-1",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83",level:4},{value:"Wording Changes from Ada 95",id:"wording-changes-from-ada-95-2",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-1",level:4},{value:"Extensions to Ada 2012",id:"extensions-to-ada-2012-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-1",level:4},{value:"9.5.3  Entry Calls",id:"953--entry-calls",level:2},{value:"Syntax",id:"syntax-2",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-1",level:4},{value:"Static Semantics",id:"static-semantics-5",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-3",level:4},{value:"Implementation Permissions",id:"implementation-permissions",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-2",level:4},{value:"9.5.4  Requeue Statements",id:"954--requeue-statements",level:2},{value:"Syntax",id:"syntax-3",level:4},{value:"Name Resolution Rules",id:"name-resolution-rules-2",level:4},{value:"Legality Rules",id:"legality-rules-4",level:4},{value:"Dynamic Semantics",id:"dynamic-semantics-4",level:4},{value:"Examples",id:"examples-3",level:4},{value:"Extensions to Ada 83",id:"extensions-to-ada-83-1",level:4},{value:"Extensions to Ada 2005",id:"extensions-to-ada-2005-2",level:4},{value:"Inconsistencies With Ada 2012",id:"inconsistencies-with-ada-2012-1",level:4},{value:"Incompatibilities With Ada 2012",id:"incompatibilities-with-ada-2012-1",level:4},{value:"Wording Changes from Ada 2012",id:"wording-changes-from-ada-2012-3",level:4}],T={toc:x};function Z(e){var t,n=e,{components:d}=n,h=((e,t)=>{var n={};for(var a in e)u.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&k)for(var a of k(e))t.indexOf(a)<0&&m.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=A(A({},T),h),c(t,p({components:d,mdxType:"MDXLayout"}))),(0,a.kt)("h1",A({},{id:"95-intertask-communication"}),"9.5 Intertask Communication"),(0,a.kt)("admonition",A({},{type:"warning"}),(0,a.kt)("p",{parentName:"admonition"},"This Reference Manual output has not been verified,\nand may contain omissions or errors.\nReport any problems on the ",(0,a.kt)("a",A({parentName:"p"},{href:"https://github.com/ada-lang-io/ada-lang-io/issues/20"}),"tracking issue"))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"1"),(0,a.kt)("p",null,"The primary means for intertask communication is provided by calls on entries and protected subprograms. Calls on protected subprograms allow coordinated access to shared data objects. Entry calls allow for blocking the caller until a given condition is satisfied (namely, that the corresponding entry is open \u2014 see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),"), and then communicating data or control information directly with another task or indirectly via a shared protected object.",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"static-semantics"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2/3"),(0,a.kt)(s.Z,{items:["AI05-0225-1","AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"When a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes an entry, protected subprogram, or a prefixed view of a primitive subprogram of a limited interface whose first parameter is a controlling parameter, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," determines a ",(0,a.kt)("em",null,"target object"),", as follows: ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.a/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),'This wording uses "denotes" to mean "denotes a view of an entity" (when the term is used in Legality Rules), and "denotes an entity" (when the term is used in Dynamic Semantics rules). It does not mean "view of a declaration", as that would not include renames (a renames is not an entry or protected subprogram). ',(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"3/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"If it is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," or expanded name that denotes the declaration (or body) of the operation, then the target object is implicitly specified to be the current instance of the task or protected unit immediately enclosing the operation; a call using such a name is defined to be an ",(0,a.kt)("em",null,"internal call"),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"4/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("li",null,"If it is a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," that is not an expanded name, then the target object is explicitly specified to be the object denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name")),"; a call using such a name is defined to be an ",(0,a.kt)("em",null,"external call"),"; ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"4.a"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"For example: ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"4.b"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"protected type Pt is","\n","  procedure Op1;","\n","  procedure Op2;","\n","end Pt;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"4.c"),"PO : Pt;","\n","Other_Object : Some_Other_Protected_Type;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"4.d"),"protected body Pt is","\n","  procedure Op1 is begin ... end Op1;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"4.e/5"),(0,a.kt)(s.Z,{items:["AI12-0005-1"],mdxType:"MarginInfo"}),"procedure Op2 is","\n","  begin","\n","    Op1; -- An internal call.","\n","    Pt.Op1; -- Another internal call.","\n","    PO.Op1; -- An external call. If the current instance is PO, then","\n","            -- this is a bounded error (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.1"},"9.5.1"),").","\n","    Other_Object.Some_Op; -- An external call.","\n","  end Op2;","\n","end Pt;","\n")),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is a dereference (implicit or explicit) of an access-to-protected-subprogram value, then the target object is determined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," of the Access ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," that produced the access value originally; a call using such a name is defined to be an ",(0,a.kt)("em",null,"external call"),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6"),(0,a.kt)("li",null,"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),", then the target object is as determined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of the renamed entity.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6.1/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A call on an entry or a protected subprogram either uses a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," that determines a target object implicitly, as above, or is a call on (a non-prefixed view of) a primitive subprogram of a limited interface whose first parameter is a controlling parameter, in which case the target object is identified explicitly by the first parameter. This latter case is an ",(0,a.kt)("em",null,"external call"),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7"),(0,a.kt)("p",null,"A corresponding definition of target object applies to a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),"), with a corresponding distinction between an ",(0,a.kt)("em",null,"internal requeue")," and an ",(0,a.kt)("em",null,"external requeue"),".",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"legality-rules"}),"Legality Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.1/3"),(0,a.kt)(s.Z,{items:["AI95-00345-01","AI05-0225-1","AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," determines a target object, and the name denotes a protected entry or procedure, then the target object shall be a variable, unless the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is for an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference"))," to the Count attribute (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.9"},"9.9"),"). ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.a/3"),(0,a.kt)(s.Z,{items:["AI05-0225-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"The point is to prevent any calls to such a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," whose target object is a constant view of a protected object, directly, or via an access value, renames, or generic formal subprogram. It is, however, legal to say P'Count in a protected function body, even though the protected object is a constant view there. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.b/3"),(0,a.kt)(s.Z,{items:["AI05-0291-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'This rule does not apply to calls that are not to a prefixed view. Specifically a "normal" call to a primitive operation of a limited interface is not covered by this rule. In that case, the normal parameter passing mode checks will prevent passing a constant protected object to an operation implemented by a protected entry or procedure as the mode is required to be ',(0,a.kt)("strong",null,"in out")," or ",(0,a.kt)("strong",null,"out"),". ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.2/5"),(0,a.kt)(s.Z,{items:["AI12-0166-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"An internal call on a protected function shall not occur within a precondition expression (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.1#Subclause_6.1.1"},"6.1.1"),") of a protected operation nor within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0207"},"parameter_specification"))," of a protected operation.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.c/5"),(0,a.kt)(s.Z,{items:["AI125-0166-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"These calls will be made before the start of the protected action, and thus would not be subject to the expected mutual exclusion. As such, they would be an automatic race condition (the state of the called object could change before the start of the protected action for the call on the protected entry or subprogram). ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.d/5"),(0,a.kt)(s.Z,{items:["AI125-0166-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),(0,a.kt)("a",{href:"../AA-6/AA-6.1#Subclause_6.1.1"},"6.1.1"),' actually defines "specific precondition expression" and "class-wide precondition expression". This rule is intended to apply to both. ',(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"dynamic-semantics"}),"Dynamic Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"8"),(0,a.kt)("p",null,"Within the body of a protected operation, the current instance (see ",(0,a.kt)("a",{href:"../AA-8/AA-8.6"},"8.6"),") of the immediately enclosing protected unit is determined by the target object specified (implicitly or explicitly) in the call (or requeue) on the protected operation. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"8.a"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"The current instance is defined in the same way within the body of a subprogram declared immediately within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body")),". ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"9"),(0,a.kt)("p",null,"Any call on a protected procedure or entry of a target protected object is defined to be an update to the object, as is a requeue on such an entry. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"9.a"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"Read/write access to the components of a protected object is granted while inside the body of a protected procedure or entry. Also, any protected entry call can change the value of the Count attribute, which represents an update. Any protected procedure call can result in servicing the entries, which again might change the value of a Count attribute. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"syntax"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"10/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"synchronization_kind"),(0,a.kt)("a",{id:"S0256"}),(0,a.kt)("code",null," ::= "),"By_Entry | By_Protected_Procedure | Optional",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"static-semantics-1"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"11/3"),(0,a.kt)(s.Z,{items:["AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For the declaration of a primitive procedure of a synchronized tagged type the following language-defined representation aspect may be specified with an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," (see ",(0,a.kt)("a",{href:"../AA-13/AA-13.1#Subclause_13.1.1"},"13.1.1"),"):",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"12/3"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"Synchronization"),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"If specified, the aspect definition shall be a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind")),".",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"12.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Synchronization: "),"Defines whether a given primitive operation of a synchronized interface will be implemented by an entry or protected procedure.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"Inherited subprograms inherit the Synchronization aspect, if any, from the corresponding subprogram of the parent or progenitor type. If an overriding operation does not have a directly specified Synchronization aspect then the Synchronization aspect of the inherited operation is inherited by the overriding operation. ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"legality-rules-1"}),"Legality Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"14/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," By_Protected_Procedure shall not be applied to a primitive procedure of a task interface.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"15/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A procedure for which the specified ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," is By_Entry shall be implemented by an entry. A procedure for which the specified ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," is By_Protected_Procedure shall be implemented by a protected procedure. A procedure for which the specified ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," is Optional may be implemented by an entry or by a procedure (including a protected procedure).",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"16/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If a primitive procedure overrides an inherited operation for which the Synchronization aspect has been specified to be By_Entry or By_Protected_Procedure, then any specification of the aspect Synchronization applied to the overriding operation shall have the same ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind")),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"17/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"In addition to the places where Legality Rules normally apply (see ",(0,a.kt)("a",{href:"../AA-12/AA-12.3"},"12.3"),"), these rules also apply in the private part of an instance of a generic unit. ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"static-semantics-2"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"18/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For a program unit, task entry, formal package, formal subprogram, formal object of an anonymous access-to-subprogram type, enumeration literal, and for a subtype (including a formal subtype), the following language-defined operational aspect is defined:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"19/5"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"Nonblocking"),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"This aspect specifies the blocking restriction for the entity; it shall be specified by a static Boolean expression. [The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," can be omitted from the specification of this aspect; in that case, the aspect for the entity is True.]",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Nonblocking: "),"Specifies that an associated subprogram does not block.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"proof",mdxType:"Admonition"},(0,a.kt)("strong",null),(0,a.kt)("a",{href:"../AA-13/AA-13.1#Subclause_13.1.1"},"13.1.1")," allows omitting the aspect ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," for any aspect with type Boolean; we take advantage of that here. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"20/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"The Nonblocking aspect may be specified for all entities for which it is defined, except for protected operations and task entries. In particular, Nonblocking may be specified for generic formal parameters.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"The Nonblocking aspect cannot be specified for predefined operators or enumeration literals but we don't need to mention that above. One would have to declare a subprogram in order to specify the aspect in those cases, but that defines a user-defined subprogram which is itself not a predefined operator or an enumeration literal. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"21/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2","AI12-0439-1"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"When aspect Nonblocking is False for an entity, the entity can contain a potentially blocking operation; such an entity ",(0,a.kt)("em",null,"allows blocking"),". If the aspect is True for an entity, the entity is said to be ",(0,a.kt)("em",null,"nonblocking"),".",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"21.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"Specifying Nonblocking as False imposes no restrictions. Specifying Nonblocking as True imposes additional compile-time checks to prevent blocking, but does not prevent deadlock. A pragma Detect_Blocking can be used to ensure that Program_Error is raised in a deadlock situation. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"22/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For a generic instantiation and entities declared within such an instance, the aspect is determined by the Nonblocking aspect for the corresponding entity of the generic unit, ",(0,a.kt)("strong",null,"and"),"ed with the Nonblocking aspects of the actual generic parameters ",(0,a.kt)("em",null,"used")," by the entity. If the aspect is directly specified for an instance, the specified expression shall have the same value as the Nonblocking aspect of the instance (after ",(0,a.kt)("strong",null,"and"),"ing with the aspects of the used actual parameters). In the absence of a Use_Formal aspect, all actual generic parameters are presumed to be ",(0,a.kt)("em",null,"used")," by an entity (see ",(0,a.kt)("a",{href:"../AA-H/AA-H.7#Subclause_H.7.1"},"H.7.1"),").",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"22.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"We want to allow confirming aspects for instances, but nothing else. The Legality Rules of the generic body were checked assuming the Nonblocking aspect of the generic unit combined with the Nonblocking aspects of the formals where they are used, and if that is overridden on the instance, the instance body might make calls that allow blocking in subprograms that are declared nonblocking. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"23/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For a (protected or task) entry, the Nonblocking aspect is False.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"23.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"An entry can be renamed as a procedure, so the value of the aspect has to be well-defined (as the attribute can be applied to a procedure). We do not want a nonblocking subprogram to be able to call an entry, no matter how it occurs, so the value ought to be False. Moreover, we do not want a subprogram that renames an entry to be able to override a nonblocking subprogram. We could have used individual rules for these cases, but there were already many of them, and this solution avoids the need for extra rules for entries. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"24/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For an enumeration literal, the Nonblocking aspect is True.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"Enumeration literals can be renamed as functions, and passed to generic formal functions, so we need to define the value of the aspect to ensure the other rules are meaningful. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"25/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For a predefined operator of an elementary type, the Nonblocking aspect is True. For a predefined operator of a composite type, the Nonblocking aspect of the operator is the same as the Nonblocking aspect for the type.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),'Predefined operators of elementary types can never include any potentially blocking operations, so we want them to declare that. Record equality can be composed of operations including user-defined "=" operators, which might allow blocking. Array equality might use some record equality. So we have to have the possibility of allowing blocking for them. We don\'t just copy the Nonblocking aspect of the type in every case, as someone could declare an elementary type to allow blocking. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"It's not possible to specify the nonblocking expression of a predefined operator; if an operator is declared in order to do that, it is no longer predefined. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"26/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For a dereference of an access-to-subprogram type, the Nonblocking aspect of the designated subprogram is that of the access-to-subprogram type.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"27/5"),(0,a.kt)(s.Z,{items:["AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"For the base subtype of a scalar (sub)type, the Nonblocking aspect is True.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"27.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"The first subtype of a scalar type can allow blocking (which can be useful so a predicate can allow blocking), but the base subtype is always Nonblocking. We need this so the Nonblocking value is well-defined for any subtype that is built from the base subtype (T'Base). T'Base of any scalar type, including a generic formal type, is always nonblocking. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"28/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"For an inherited primitive dispatching subprogram that is null or abstract, the subprogram is nonblocking if and only if a corresponding subprogram of at least one ancestor is nonblocking. For any other inherited subprogram, it is nonblocking if and only if the corresponding subprogram of the parent is nonblocking.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"29/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"Unless directly specified, overridings of dispatching operations inherit this aspect.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"30/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"Unless directly specified, for a formal subtype, formal package, or formal subprogram, the Nonblocking aspect is that of the actual subtype, package, or subprogram.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"30.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"This means that Nonblocking legality checking for the actual parameters of the instance is only necessary when the aspect is explicitly specified for the formal type. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"31/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"Unless directly specified, for a non-first subtype ",(0,a.kt)("em",null,"S"),", the Nonblocking aspect is that of the subtype identified in the subtype_indication defining ",(0,a.kt)("em",null,"S"),"; unless directly specified for the first subtype of a derived type, the Nonblocking aspect is that of the ancestor subtype.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"31.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The expressions that can be specified for a such a subtype are limited by a Legality Rule, see below. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"32/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"Unless directly specified, for any other program unit, first subtype, or formal object, the Nonblocking aspect of the entity is determined by the Nonblocking aspect for the innermost program unit enclosing the entity.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"33/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"If not specified for a library unit, the Nonblocking aspect is True if the library unit is declared pure, or False otherwise.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"34/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0247-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The following are defined to be ",(0,a.kt)("em",null,"potentially blocking")," operations: ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"34.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"The primary purpose of these rules is to define what operations are not allowed in a protected operation (blocking is not allowed). Some of these operations are not directly blocking. However, they are still treated as potentially blocking, because allowing them in a protected action might impose an undesirable implementation burden. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"35/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"36/5"),(0,a.kt)("li",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"37/5"),(0,a.kt)("li",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement")),", or a call on a procedure that renames or is implemented by an entry;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"38/5"),(0,a.kt)("li",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.6#S0266"},"delay_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"39/5"),(0,a.kt)("li",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"40/5"),(0,a.kt)("li",null,"task creation or activation;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"41/5"),(0,a.kt)("li",null,"during a protected action, an external call on a protected subprogram (or an external requeue) with the same target object as that of the protected action.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"41.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"This is really a deadlocking call, rather than a blocking call, but we include it in this list for simplicity. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"42/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If a language-defined subprogram allows blocking, then a call on the subprogram is a potentially blocking operation.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"42.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"Calls on other subprograms that allow blocking are not themselves potentially blocking; the execution of the body could execute a potentially blocking operation.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"42.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"A user-defined instance of a language-defined generic creates user-defined subprograms for the purpose of this rule. A dispatching call to a language-defined abstract subprogram always calls a user-defined concrete subprogram, so that too is not potentially blocking for the purposes of this rule. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"legality-rules-2"}),"Legality Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"43/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0267-1","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A portion of program text is called a ",(0,a.kt)("em",null,"nonblocking region")," if it is anywhere within a parallel construct, or if the innermost enclosing program unit is nonblocking. A nonblocking region shall not contain any of the following:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"44/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"45/5"),(0,a.kt)("li",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"46/5"),(0,a.kt)("li",null,"a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.6#S0266"},"delay_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"47/5"),(0,a.kt)("li",null,"an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.8#S0284"},"abort_statement")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"48/5"),(0,a.kt)("li",null,"task creation or activation. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"49/5"),(0,a.kt)(s.Z,{items:["AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"Furthermore, a parallel construct shall neither contain a call on a callable entity for which the Nonblocking aspect is False, nor shall it contain a call on a callable entity declared within a generic unit that uses a generic formal parameter with Nonblocking aspect False (see Use_Formal aspect in ",(0,a.kt)("a",{href:"../AA-H/AA-H.7#Subclause_H.7.1"},"H.7.1"),").",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"50/5"),(0,a.kt)(s.Z,{items:["AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"Finally, a nonblocking region that is outside of a parallel construct shall not contain a call on a callable entity for which the Nonblocking aspect is False, unless the region is within a generic unit and the callable entity is associated with a generic formal parameter of the generic unit, or the call is within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0348"},"aspect_definition"))," of an assertion aspect for an entity that allows blocking.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"50.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),'A generic unit or entity declared within one is presumed to use its "used" generic formal parameters at least once each time it is invoked, and this passes through to the parallel construct check. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"50.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"Implicit calls for finalization, storage pools, and the like are covered by the above prohibition. The rules above say \u201ca call\u201d, not \u201can explicit call\u201d. Such calls are considered statically bound when that is possible, that is, when the controlling object has a known specific type (even if the actual implementation uses dispatching). ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"50.c/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"We don't need to worry specially about entry calls (even if the entry has been renamed as a procedure), as they will be detected by the prohibition against calls to entities with the Nonblocking aspect False.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"50.d/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Similarly, we don't need to specially worry about subprograms of limited interfaces that are implemented by entries, as any such subprogram necessarily has the value statically False for the Nonblocking aspect, and thus is already covered by the prohibition against calling such subprograms. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"51/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For the purposes of the above rules, an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is considered nonblocking if the immediately enclosing protected unit is nonblocking.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"51.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"An entry declaration always allows blocking (by rule); but we want to be able to compile-time check for most violations of the prohibition against potentially blocking operations in a protected action (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.1"},"9.5.1"),"). We do that by using the nonblocking status of the protected unit as the controlling factor, and enforce that by not allowing the specification of the Nonblocking aspect for any protected operation. We can't do this checking unconditionally, as that would be incompatible: existing Ada protected units might call subprograms that allow blocking. Thus a protected unit that allows blocking (which is the default) must allow calling any subprogram from an entry body. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"52/5"),(0,a.kt)(s.Z,{items:["AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For a subtype for which aspect Nonblocking is True, any predicate expression that applies to the subtype shall only contain constructs that are allowed immediately within a nonblocking program unit.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"53/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A subprogram shall be nonblocking if it overrides a nonblocking dispatching operation. An entry shall not implement a nonblocking procedure. If an inherited dispatching subprogram allows blocking, then the corresponding subprogram of each ancestor shall allow blocking.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"53.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"Rules elsewhere in the standard (",(0,a.kt)("a",{href:"../AA-4/AA-4.6"},"4.6")," and ",(0,a.kt)("a",{href:"../AA-3/AA-3.10#Subclause_3.10.2"},"3.10.2"),") ensure that access-to-subprogram conversion and the Access attribute enforce nonblocking. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"53.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"A nonblocking subprogram can override one that allows blocking, but the reverse is illegal. Thus one can declare a Finalize subprogram to be nonblocking, even though it overrides a routine that allows blocking. (This works because a nonblocking subprogram allows a strict subset of the operations allowed in allows blocking subprograms, so calling such a subprogram as if it allows blocking \u2014 as is necessary in a dispatching call \u2014 is harmless.) ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"54/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2","AI12-0396-1","AI12-0399-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"It is illegal to directly specify aspect Nonblocking for the first subtype of the full view of a type that has a partial view. If the Nonblocking aspect of the full view is inherited, it shall have the same value as that of the partial view, or have the value True.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"54.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"We need completions to agree on nonblocking with the original view. One reason this is necessary to prevent the predefined equality operator from being nonblocking in the partial view and allowing blocking in the full view. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"55/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"Aspect Nonblocking shall be directly specified for the first subtype of a derived type only if it has the same value as the Nonblocking aspect of the ancestor subtype or if it is specified True. Aspect Nonblocking shall be directly specified for a nonfirst subtype ",(0,a.kt)("em",null,"S")," only if it has the same value as the Nonblocking aspect of the subtype identified in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.2#S0027"},"subtype_indication"))," defining ",(0,a.kt)("em",null,"S")," or if it is specified True.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"55.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"Boolean-valued aspects have a similar rule to the first rule here (see ",(0,a.kt)("a",{href:"../AA-13/AA-13.1#Subclause_13.1.1"},"13.1.1"),"), we want this one to work similarly. We need non-first subtypes to allow blocking only if the original first subtype allows blocking, as that allows the programmer to know that any operation on any subtype of a type are nonblocking if the first subtype is nonblocking. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"56/5"),(0,a.kt)(s.Z,{items:["AI12-0319-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For an access-to-object type that is nonblocking, the Allocate, Deallocate, and Storage_Size operations on its storage pool shall be nonblocking.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"56.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"Standard storage pools always have nonblocking operations by definition (see ",(0,a.kt)("a",{href:"../AA-13/AA-13.11"},"13.11"),"), so this rule only can fail for user-defined storage pools. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"57/5"),(0,a.kt)(s.Z,{items:["AI12-0319-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For a composite type that is nonblocking:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"58/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"All component subtypes shall be nonblocking;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"59/5"),(0,a.kt)("li",null,"For a record type or extension, every call in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.7#S0063"},"default_expression"))," of a component (including discriminants) shall call an operation that is nonblocking;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"60/5"),(0,a.kt)("li",null,"For a controlled type, the Initialize, Finalize, and Adjust (if any) subprograms shall be nonblocking.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"60.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"These rules ensure that if a type is nonblocking, the default initialization, finalization, and assignment of the type are also nonblocking. This ensures that if a generic formal type is nonblocking, all of the basic operations of the actual type are nonblocking.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"60.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Default initialization, finalization, and assignment of elementary types are always nonblocking, so we don't need any rules for those. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"61/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The predefined equality operator for a composite type, unless it is for a record type or record extension and the operator is overridden by a primitive equality operator, is illegal if it is nonblocking and:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"62/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,'for a record type or record extension, the parent primitive "=" allows blocking; or',(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"63/5"),(0,a.kt)("li",null,"some component is of a type ",(0,a.kt)("em",null,"T"),", and:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"64/5"),(0,a.kt)("li",null,(0,a.kt)("em",null,"T"),' is a record type or record extension that has a primitive "=" that allows blocking; or',(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"65/5"),(0,a.kt)("li",null,(0,a.kt)("em",null,"T")," is neither a record type nor a record extension, and ",(0,a.kt)("em",null,"T"),' has a predefined "=" that allows blocking. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"65.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'This applies to both record and array "=".',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"65.b/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"This check occurs when the equality operator is declared, so this rule effectively makes the type illegal if the rule is violated. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"65.c/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"We don't need to check this when the operator is overridden for a record type, as the body of the new definition of equality will enforce the rules, and there is no case where the predefined operator will re-emerge. We do have to check this for array types even if the operator is overridden, as the predefined operator will re-emerge in generics and record equality. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"66/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"In a generic instantiation:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"67/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"the actual subprogram corresponding to a nonblocking formal subprogram shall be nonblocking [(an actual that is an entry is not permitted in this case)];",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"68/5"),(0,a.kt)("li",null,"the actual subtype corresponding to a nonblocking formal subtype shall be nonblocking;",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"68.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'We require matching for formal scalar or access-to-object types, even though their predefined operators are always nonblocking (and they re-emerge in the generic unit) - because a "blocking" predicate might apply to the actual subtype, which will also be enforced on operations of the formal type. ',(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"69/5"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"the actual object corresponding to a formal object of a nonblocking access-to-subprogram type shall be of a nonblocking access-to-subprogram type;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"70/5"),(0,a.kt)("li",null,"the actual instance corresponding to a nonblocking formal package shall be nonblocking.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"71/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"In addition to the places where Legality Rules normally apply (see ",(0,a.kt)("a",{href:"../AA-12/AA-12.3"},"12.3"),"), the above rules also apply in the private part of an instance of a generic unit.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"71.a/5"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"For a generic formal parameter to be nonblocking (thus, for these rules to apply), it has to explicitly specify aspect Nonblocking to be True. However, if not specified True, these rules do apply in the instance of the specification of the generic unit (the normal re-checking is needed). For instance, the body of an expression function might make a prohibited call. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE   The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," By_Protected_Procedure implies that the operation will not block. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-95"}),"Wording Changes from Ada 95")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.a/2"),(0,a.kt)(s.Z,{items:["AI95-00345-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added a Legality Rule to make it crystal-clear that the protected object of an entry or procedure call must be a variable. This rule was implied by the Dynamic Semantics here, along with the Static Semantics of ",(0,a.kt)("a",{href:"../AA-3/AA-3.3"},"3.3"),", but it is much better to explicitly say it. While many implementations have gotten this wrong, this is not an incompatibility \u2014 allowing updates of protected constants has always been wrong. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2005"}),"Extensions to Ada 2005")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.b/3"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added the Synchronization aspect to allow specifying that an interface procedure is really an entry or a protected procedure. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-2005"}),"Wording Changes from Ada 2005")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.c/3"),(0,a.kt)(s.Z,{items:["AI05-0225-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," Clarified that the target object of any name denoted a protected procedure or entry can never be a constant (other than for the 'Count attribute). This closes holes involving calls to access-to-protected, renaming as a procedure, and generic formal subprograms. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"inconsistencies-with-ada-2012"}),"Inconsistencies With Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.d/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Calls on procedures that rename an entry or are implemented by an entry are now defined to be potentially blocking. This means that such a call now might raise Program_Error. However, it never made sense for some entry calls to be excluded from being potentially blocking, and we expect that most implementations already treated all entry calls the same way. Thus do not expect this wording change to actually change the behavior of any implementation, and thus no program will change. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"incompatibilities-with-ada-2012"}),"Incompatibilities With Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.e/5"),(0,a.kt)(s.Z,{items:["AI12-0166-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," Internal protected calls are now prohibited in preconditions and default expressions of protected operations. These were allowed in Ada 2012, but as they cause race conditions and as most existing Ada 95 compilers crash when given such a default parameter, we expect such code to be extremely rare. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2012"}),"Extensions to Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"72.f/5"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0319-1","AI12-0374-2"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Aspect Nonblocking is new; it allows compile-time checks to prevent using potentially blocking operations in contexts where that is not allowed. ",(0,a.kt)("br",null))),(0,a.kt)("a",{id:"Subclause_9.5.1"}),(0,a.kt)("h2",A({},{id:"951--protected-subprograms-and-protected-actions"}),"9.5.1  Protected Subprograms and Protected Actions"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"1_9.5.1"),(0,a.kt)("p",null,"A ",(0,a.kt)("em",null,"protected subprogram")," is a subprogram declared immediately within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0251"},"protected_definition")),". Protected procedures provide exclusive read-write access to the data of a protected object; protected functions provide concurrent read-only access to the data. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"1.a_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"A subprogram declared immediately within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body"))," is not a protected subprogram; it is an intrinsic subprogram. See ",(0,a.kt)("a",{href:"../AA-6/AA-6.3#Subclause_6.3.1"},"6.3.1"),", \u201c",(0,a.kt)("a",{href:"../AA-6/AA-6.3#Subclause_6.3.1"},"Conformance Rules"),"\u201d. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"static-semantics-3"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2_9.5.1"),(0,a.kt)("p",null,"[Within the body of a protected function (or a function declared immediately within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body")),"), the current instance of the enclosing protected unit is defined to be a constant (that is, its subcomponents may be read but not updated). Within the body of a protected procedure (or a procedure declared immediately within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body")),"), and within an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", the current instance is defined to be a variable (updating is permitted).] ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.a.1/3_9.5.1"),(0,a.kt)(s.Z,{items:["AI05-0120-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"proof",mdxType:"Admonition"},(0,a.kt)("strong",null),"All constant views are defined in ",(0,a.kt)("a",{href:"../AA-3/AA-3.3"},"3.3"),", \u201c",(0,a.kt)("a",{href:"../AA-3/AA-3.3"},"Objects and Named Numbers"),"\u201d, anything not named there is a variable view. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.a_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"The current instance is like an implicit parameter, of mode ",(0,a.kt)("strong",null,"in")," for a protected function, and of mode ",(0,a.kt)("strong",null,"in out")," for a protected procedure (or protected entry). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.1/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For a type declared by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0249"},"protected_type_declaration"))," or for the anonymous type of an object declared by a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0250"},"single_protected_declaration")),", the following language-defined type-related representation aspect may be specified:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.2/4_9.5.1"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"Exclusive_Functions"),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"The type of aspect Exclusive_Functions is Boolean. If not specified (including by inheritance), the aspect is False.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.3/4_9.5.1"),(0,a.kt)("dt",null,(0,a.kt)("br",null)),(0,a.kt)("dd",null,"A value of True for this aspect indicates that protected functions behave in the same way as protected procedures with respect to mutual exclusion and queue servicing (see below).",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.a.1/4_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Aspect Description for "),(0,a.kt)("strong",null,"Exclusive_Functions: "),"Specifies mutual exclusion behavior of protected functions in a protected type.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2.4/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A protected procedure or entry is an ",(0,a.kt)("em",null,"exclusive")," protected operation. A protected function of a protected type ",(0,a.kt)("em",null,"P")," is an exclusive protected operation if the Exclusive_Functions aspect of ",(0,a.kt)("em",null,"P")," is True.",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"dynamic-semantics-1"}),"Dynamic Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"3_9.5.1"),(0,a.kt)("p",null,"For the execution of a call on a protected subprogram, the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," and of the parameter associations, and any assigning back of ",(0,a.kt)("strong",null,"in out")," or ",(0,a.kt)("strong",null,"out")," parameters, proceeds as for a normal subprogram call (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.4"},"6.4"),"). If the call is an internal call (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),"), the body of the subprogram is executed as for a normal subprogram call. If the call is an external call, then the body of the subprogram is executed as part of a new ",(0,a.kt)("em",null,"protected action")," on the target protected object; the protected action completes after the body of the subprogram is executed. [A protected action can also be started by an entry call (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),").]",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"4/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"A new protected action is not started on a protected object while another protected action on the same protected object is underway, unless both actions are the result of a call on a nonexclusive protected function. This rule is expressible in terms of the execution resource associated with the protected object: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("em",null,"Starting")," a protected action on a protected object corresponds to ",(0,a.kt)("em",null,"acquiring")," the execution resource associated with the protected object, either for exclusive read-write access if the protected action is for a call on an exclusive protected operation, or for concurrent read-only access otherwise;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6_9.5.1"),(0,a.kt)("li",null,(0,a.kt)("em",null,"Completing")," the protected action corresponds to ",(0,a.kt)("em",null,"releasing")," the associated execution resource. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"[After performing an exclusive protected operation on a protected object, but prior to completing the associated protected action, the entry queues (if any) of the protected object are serviced (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),").]",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.1/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0119-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If a parallel construct occurs within a protected action, no new logical threads of control are created. Instead, each element of the parallel construct that would have become a separate logical thread of control executes on the logical thread of control that is performing the protected action. If there are multiple such elements initiated at the same point, they execute in an arbitrary order.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.a/5_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"It would be feasible to allow multiple logical threads of control within a protected action, but it would significantly complicate the definition of \u201csequential\u201d and \u201cconcurrent\u201d actions, since we generally presume that everything occuring within protected actions of a given protected object is sequential. We could simply disallow any use of parallel constructs, but that seems unnecessary, particularly as a parallel construct might be buried within a subprogram that is declared Nonblocking. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"bounded-run-time-errors"}),"Bounded (Run-Time) Errors"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"8/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"During a protected action, it is a bounded error to invoke an operation that is potentially blocking (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),"). ",(0,a.kt)("br",null)),(0,a.kt)("p",null,(0,a.kt)("em",null,"Paragraphs 9 through 16 were moved to ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),".")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"17/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0439-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If the bounded error is detected, Program_Error is raised. If not detected, the bounded error can result in deadlock or a (nested) protected action on the same target object.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"17.a/2_9.5.1"),(0,a.kt)(s.Z,{items:["AI95-00305-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"By \u201cnested protected action\u201d, we mean that an additional protected action can be started by another task on the same protected object. This means that mutual exclusion may be broken in this bounded error case. A way to ensure that this does not happen is to use pragma Detect_Blocking (see ",(0,a.kt)("a",{href:"../AA-H/AA-H.5"},"H.5"),"). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"18/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0064-2","AI12-0247-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"During a protected action, a call on a subprogram whose body contains a potentially blocking operation is a bounded error. If the bounded error is detected, Program_Error is raised; otherwise, the call proceeds normally. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"18.b/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0247-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"This allows an implementation to check and raise Program_Error as soon as a subprogram is called, rather than waiting to find out whether it actually reaches the potentially blocking operation. If the call proceeds normally, reaching the potentially blocking operation is a separate bounded error, covered by the previous rules. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0276-1","AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   If two tasks both try to start a protected action on a protected object, and at most one is calling a protected nonexclusive function, then only one of the tasks can proceed. Although the other task cannot proceed, it is not considered blocked, and it can be consuming processing resources while it awaits its turn. Unless there is an admission policy (see ",(0,a.kt)("a",{href:"../AA-D/AA-D.4#Subclause_D.4.1"},"D.4.1"),") in effect, there is no language-defined ordering or queuing presumed for tasks competing to start a protected action \u2014 on a multiprocessor such tasks can use busy-waiting; for further monoprocessor and multiprocessor considerations, see ",(0,a.kt)("a",{href:"../AA-D/AA-D.3"},"D.3"),", \u201c",(0,a.kt)("a",{href:"../AA-D/AA-D.3"},"Priority Ceiling Locking"),"\u201d. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19.a_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The intended implementation on a multi-processor is in terms of \u201cspin locks\u201d \u2014 the waiting task will spin. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   The body of a protected unit can contain declarations and bodies for local subprograms. These are not visible outside the protected unit.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"21_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   The body of a protected function can contain internal calls on other protected functions, but not protected procedures, because the current instance is a constant. On the other hand, the body of a protected procedure can contain internal calls on both protected functions and procedures.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"22_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 4   From within a protected action, an internal call on a protected subprogram, or an external call on a protected subprogram with a different target object is not considered a potentially blocking operation. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"22.a_9.5.1"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"This is because a task is not considered blocked while attempting to acquire the execution resource associated with a protected object. The acquisition of such a resource is rather considered part of the normal competition for execution resources between the various tasks that are ready. External calls that turn out to be on the same target object are considered potentially blocking, since they can deadlock the task indefinitely. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"23/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI95-00305-01","AI12-0064-2","AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 5   The aspect Nonblocking can be specified True on the definition of a protected unit in order to reject most attempts to use potentially blocking operations within the protected unit (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),"). The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Detect_Blocking can be used to ensure that any remaining executions of potentially blocking operations during a protected action raise Program_Error. See ",(0,a.kt)("a",{href:"../AA-H/AA-H.5"},"H.5"),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"23.a/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The deadlock case cannot be detected at compile-time, so pragma Detect_Blocking is needed to give it consistent behavior. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"examples"}),"Examples"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"24_9.5.1"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of protected subprogram calls (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.4"},"9.4"),"):")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"25_9.5.1"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"Shared_Array.Set_Component(N, E);","\n","E := Shared_Array.Component(M);","\n","Control.Release;","\n"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-95-1"}),"Wording Changes from Ada 95")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.a/2_9.5.1"),(0,a.kt)(s.Z,{items:["AI95-00305-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added a note pointing out the existence of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma"))," Detect_Blocking. This pragma can be used to ensure portable (somewhat pessimistic) behavior of protected actions by converting the Bounded Error into a required check. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2012-1"}),"Extensions to Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.b/4_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Corrigendum:")," Aspect Exclusive_Functions is new. The term \u201cexclusive protected operations\u201d is new. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-2012"}),"Wording Changes from Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.c/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0064-2"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Moved the definition of potentially blocking operations to ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),", so it could be integrated into the definition of the Nonblocking aspect.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.d/5_9.5.1"),(0,a.kt)(s.Z,{items:["AI12-0247-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," Added a separate bounded error for a subprogram containing a blocking operation, to keep compatibility with Ada 95 rules without requiring a correct implementation of pragma Detect_Blocking to do full program analysis. ",(0,a.kt)("br",null))),(0,a.kt)("a",{id:"Subclause_9.5.2"}),(0,a.kt)("h2",A({},{id:"952--entries-and-accept-statements"}),"9.5.2  Entries and Accept Statements"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"1_9.5.2"),(0,a.kt)("p",null,(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"Entry_declaration")),"s, with the corresponding ",(0,a.kt)("code",null,"entry_bodies")," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s, are used to define potentially queued operations on tasks and protected objects. ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"syntax-1"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2/3_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00397-01","AI05-0183-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_declaration"),(0,a.kt)("a",{id:"S0257"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"   [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"]",(0,a.kt)("br",null),"   ",(0,a.kt)("strong",null,"entry")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," [(",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),")] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile")),(0,a.kt)("br",null),"      [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"];",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"3_9.5.2"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"accept_statement"),(0,a.kt)("a",{id:"S0258"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"   ",(0,a.kt)("strong",null,"accept")," ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," [(",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0259"},"entry_index")),")] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile"))," [",(0,a.kt)("strong",null,"do"),(0,a.kt)("br",null),"     ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements")),(0,a.kt)("br",null),"   ",(0,a.kt)("strong",null,"end")," [",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"]];",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"3.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"We cannot use ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s. Although an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is sort of like a body, it can appear nested within a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-5/AA-5.6#S0191"},"block_statement")),", and therefore be hidden from its own entry by an outer homograph. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"4_9.5.2"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_index"),(0,a.kt)("a",{id:"S0259"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression")),(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0169-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_body"),(0,a.kt)("a",{id:"S0260"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"    ",(0,a.kt)("strong",null,"entry")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0261"},"entry_body_formal_part")),(0,a.kt)("br",null),"       [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"]",(0,a.kt)("br",null),"    ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," ",(0,a.kt)("strong",null,"is"),(0,a.kt)("br",null),"       ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.11#S0086"},"declarative_part")),(0,a.kt)("br",null),"    ",(0,a.kt)("strong",null,"begin"),(0,a.kt)("br",null),"       ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements")),(0,a.kt)("br",null),"    ",(0,a.kt)("strong",null,"end")," [",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier")),"];",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.a/2_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00397-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"We don't allow an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," on an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," because entries always implement procedures at the point of the type declaration; there is no late implementation. And we don't want to have to think about ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),"s on ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6_9.5.2"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_body_formal_part"),(0,a.kt)("a",{id:"S0261"}),(0,a.kt)("code",null," ::= "),"[(",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification")),")] ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile")),(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7_9.5.2"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_barrier"),(0,a.kt)("a",{id:"S0262"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"when")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"8/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0398-1"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_index_specification"),(0,a.kt)("a",{id:"S0263"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("br",null),"    ",(0,a.kt)("strong",null,"for")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier"))," ",(0,a.kt)("strong",null,"in")," ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),"] ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"9_9.5.2"),(0,a.kt)("p",{class:"Indented2"},"If an ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," appears at the end of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", it shall repeat the ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name")),". If an ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," appears at the end of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", it shall repeat the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"10_9.5.2"),(0,a.kt)("p",{class:"Indented2"},"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," is allowed only in a protected or task declaration.] ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"10.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"proof",mdxType:"Admonition"},(0,a.kt)("strong",null),"This follows from the BNF. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"10.1/2_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00397-01"],mdxType:"MarginInfo"}),(0,a.kt)("p",{class:"Indented2"},"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is not allowed in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," that includes a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"10.a.1/2_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"An entry family can never implement something, so allowing an indicator is felt by the majority of the ARG to be redundant. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"name-resolution-rules"}),"Name Resolution Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"11_9.5.2"),(0,a.kt)("p",null,"In an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", the expected profile for the ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," is that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),"; the expected type for an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0259"},"entry_index"))," is that of the subtype defined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"12_9.5.2"),(0,a.kt)("p",null,"Within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", if a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," that denotes the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", then the entity denoted by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," is the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," is interpreted as an expanded name (see ",(0,a.kt)("a",{href:"../AA-4/AA-4.1#Subclause_4.1.3"},"4.1.3"),")[; the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0099"},"selector_name"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0098"},"selected_component"))," has to be the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.3#S0002"},"identifier"))," for some formal parameter of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"]. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"12.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"proof",mdxType:"Admonition"},(0,a.kt)("strong",null),"The only declarations that occur immediately within the declarative region of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," are those for its formal parameters. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"legality-rules-3"}),"Legality Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13_9.5.2"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," in a task declaration shall not contain a specification for an access parameter (see ",(0,a.kt)("a",{href:"../AA-3/AA-3.10"},"3.10"),"). ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"Access parameters for task entries would require a complex implementation. For example: ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.b_9.5.2"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"task T is","\n","   entry E(Z : access Integer); -- Illegal!","\n","end T;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.c_9.5.2"),"task body T is","\n","begin","\n","   declare","\n","      type A is access all Integer;","\n","      X : A;","\n","      Int : aliased Integer;","\n","      task Inner;","\n","      task body Inner is","\n","      begin","\n","         T.E(Int'Access);","\n","      end Inner;","\n","   begin","\n","      accept E(Z : access Integer) do","\n","         X := A(Z); -- Accessibility_Check","\n","      end E;","\n","   end;","\n","end T;","\n")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.d_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Implementing the Accessibility_Check inside the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," for E is difficult, since one does not know whether the entry caller is calling from inside the immediately enclosing declare block or from outside it. This means that the lexical nesting level associated with the designated object is not sufficient to determine whether the Accessibility_Check should pass or fail.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.e_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Note that such problems do not arise with protected entries, because ",(0,a.kt)("code",null,"entry_bodies")," are always nested immediately within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body")),"; they cannot be further nested as can ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s, nor can they be called from within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body"))," (since no entry calls are permitted inside a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0254"},"protected_body")),"). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.1/2_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00397-01"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," has an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator")),", then at the point of the declaration: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.2/2_9.5.2"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is ",(0,a.kt)("strong",null,"overriding"),", then the entry shall implement an inherited subprogram;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.3/2_9.5.2"),(0,a.kt)("li",null,"if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"overriding_indicator"))," is ",(0,a.kt)("strong",null,"not overriding"),", then the entry shall not implement any inherited subprogram.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.4/2_9.5.2"),(0,a.kt)("p",null,"In addition to the places where Legality Rules normally apply (see ",(0,a.kt)("a",{href:"../AA-12/AA-12.3"},"12.3"),"), these rules also apply in the private part of an instance of a generic unit.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"13.f/2_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"These rules are subtly different than those for subprograms (see ",(0,a.kt)("a",{href:"../AA-8/AA-8.3#Subclause_8.3.1"},"8.3.1"),") because there cannot be \u201clate\u201d inheritance of primitives from interfaces. Hidden (that is, private) interfaces are prohibited explicitly (see ",(0,a.kt)("a",{href:"../AA-7/AA-7.3"},"7.3"),"), as are hidden primitive operations (as private operations of public abstract types are prohibited \u2014 see ",(0,a.kt)("a",{href:"../AA-3/AA-3.9#Subclause_3.9.3"},"3.9.3"),"). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"14_9.5.2"),(0,a.kt)("p",null,"For an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", the innermost enclosing body shall be a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body")),", and the ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0092"},"direct_name"))," shall denote an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," in the corresponding task declaration; the profile of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," shall conform fully to that of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),". An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," shall have a parenthesized ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0259"},"entry_index"))," if and only if the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"15_9.5.2"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," shall not be within another ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," that corresponds to the same ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", nor within an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," inner to the enclosing ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body")),". ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"15.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"Accept_statement")),"s are required to be immediately within the enclosing ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body"))," (as opposed to being in a nested subprogram) to ensure that a nested task does not attempt to accept the entry of its enclosing task. We considered relaxing this restriction, either by making the check a run-time check, or by allowing a nested task to accept an entry of its enclosing task. However, neither change seemed to provide sufficient benefit to justify the additional implementation burden.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"15.b_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Nested ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s for the same entry (or entry family) are prohibited to ensure that there is no ambiguity in the resolution of an expanded name for a formal parameter of the entry. This could be relaxed by allowing the inner one to hide the outer one from all visibility, but again the small added benefit didn't seem to justify making the change for Ada 95.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"15.c_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"Accept_statement")),"s are not permitted within ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," statements to simplify the semantics and implementation: an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0283"},"abortable_part"))," could result in Tasking_Error being propagated from an entry call even though the target task was still callable; implementations that use multiple tasks implicitly to implement an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select")),' might have trouble supporting "up-level" accepts. Furthermore, if ',(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s were permitted in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0283"},"abortable_part")),", a task could call its own entry and then accept it in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0283"},"abortable_part")),", leading to rather unusual and possibly difficult-to-specify semantics. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"16_9.5.2"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," of a protected unit requires a completion[, which shall be an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),",] and every ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," shall be the completion of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," of a protected unit. The profile of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," shall conform fully to that of the corresponding declaration. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"16.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", unlike a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration")),", cannot be completed with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0238"},"renaming_declaration")),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"16.b/3_9.5.2"),(0,a.kt)(s.Z,{items:["AI05-0229-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"If the implementation supports it, the entry body can be imported (using aspect Import, see ",(0,a.kt)("a",{href:"../AA-B/AA-B.1"},"B.1"),"), in which case no explicit ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is allowed. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"16.c_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The above applies only to protected entries, which are the only ones completed with ",(0,a.kt)("code",null,"entry_bodies"),". Task entries have corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s instead of having ",(0,a.kt)("code",null,"entry_bodies"),", and we do not consider an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," to be a \u201ccompletion,\u201d because a task ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," is allowed to have zero, one, or more than one corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"17_9.5.2"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0261"},"entry_body_formal_part"))," shall have an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification"))," if and only if the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," has a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". In this case, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),"s of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification"))," shall fully conform to one another (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.3#Subclause_6.3.1"},"6.3.1"),"). ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"18_9.5.2"),(0,a.kt)("p",null,"A name that denotes a formal parameter of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is not allowed within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),".",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"static-semantics-4"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"19_9.5.2"),(0,a.kt)("p",null,"The parameter modes defined for parameters in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0204"},"parameter_profile"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," are the same as for a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.1#S0195"},"subprogram_declaration"))," and have the same meaning (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.2"},"6.2"),"). ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"Note that access parameters are not allowed for task entries (see above). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"20_9.5.2"),(0,a.kt)("p",null,"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," with a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," (see ",(0,a.kt)("a",{href:"../AA-3/AA-3.6"},"3.6"),") declares a ",(0,a.kt)("em",null,"family")," of distinct entries having the same profile, with one such entry for each value of the ",(0,a.kt)("em",null,"entry index subtype")," defined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),". [A name for an entry of a family takes the form of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0096"},"indexed_component")),", where the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," denotes the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," for the family, and the index value identifies the entry within the family.] The term ",(0,a.kt)("em",null,"single entry")," is used to refer to any entry other than an entry of an entry family.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"21_9.5.2"),(0,a.kt)("p",null,"In the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," for an entry family, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification"))," declares a named constant whose subtype is the entry index subtype defined by the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),"; the value of the ",(0,a.kt)("em",null,"named entry index")," identifies which entry of the family was called. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"21.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0263"},"entry_index_specification"))," is not elaborated; the subtype of the named constant declared is defined by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition"))," of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),", which is elaborated, either when the type is declared, or when the object is created, if its constraint is per-object. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"dynamic-semantics-2"}),"Dynamic Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"22/1_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00171-01"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"{",(0,a.kt)("em",null,"8652/0002"),"}"," The elaboration of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," for an entry family consists of the elaboration of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.6#S0055"},"discrete_subtype_definition")),", as described in ",(0,a.kt)("a",{href:"../AA-3/AA-3.8"},"3.8"),". The elaboration of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," for a single entry has no effect. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"22.a/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI05-0299-1","AI12-0449-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The elaboration of the declaration of a protected subprogram has no effect, as specified in ",(0,a.kt)("a",{href:"../AA-6/AA-6.1"},"6.1"),". The default initialization of an object of a task or protected type is covered in ",(0,a.kt)("a",{href:"../AA-3/AA-3.3#Subclause_3.3.1"},"3.3.1"),". ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"23_9.5.2"),(0,a.kt)("p",null,"[The actions to be performed when an entry is called are specified by the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s (if any) for an entry of a task unit, and by the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," for an entry of a protected unit.]",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"23.1/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0193-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The interaction between a task that calls an entry and an accepting task is called a ",(0,a.kt)("em",null,"rendezvous"),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"24/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0193-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"For the execution of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0259"},"entry_index")),", if any, is first evaluated and converted to the entry index subtype; this index value identifies which entry of the family is to be accepted. Further execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is then blocked until a caller of the corresponding entry is selected (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),"), whereupon the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements")),", if any, of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," is executed, with the formal parameters associated with the corresponding actual parameters of the selected entry call. Execution of the rendezvous consists of the execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements")),", performance of any postcondition or type invariant checks associated with the entry, and any initialization or finalization associated with these checks, as described in ",(0,a.kt)("a",{href:"../AA-6/AA-6.1#Subclause_6.1.1"},"6.1.1")," and ",(0,a.kt)("a",{href:"../AA-7/AA-7.3#Subclause_7.3.2"},"7.3.2"),". After execution of the rendezvous, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," completes and is left. [The two tasks then proceed independently.] When an exception is propagated from the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", the same exception is also raised by the execution of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement")),". ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"This is in addition to propagating it to the construct containing the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),". In other words, for a rendezvous, the raising splits in two, and continues concurrently in both tasks.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.b_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The caller gets a new occurrence; this isn't considered propagation.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.c_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Note that we say \u201cpropagated from the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"\u201d, not \u201cpropagated from an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"\u201d. The latter would be wrong \u2014 we don't want exceptions propagated by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0259"},"entry_index"))," to be sent to the caller (there is none yet!).",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.d/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0193-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Execution of the rendezvous does not include any checks associated with parameter copy back or any post-call subtype predicate check for a parameter which is passed by reference. These checks are performed by the caller after the execution of the rendezvous. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"25/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0193-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,(0,a.kt)("em",null,"This paragraph was deleted."),(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"26_9.5.2"),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is executed when the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," evaluates to True and a caller of the corresponding single entry, or entry of the corresponding entry family, has been selected (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),").] For the execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.11#S0086"},"declarative_part"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is elaborated, and the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," of the body is executed, as for the execution of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.3#S0216"},"subprogram_body")),". The value of the named entry index, if any, is determined by the value of the entry index specified in the ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of the selected entry call (or intermediate ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," \u2014 see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),"). ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"26.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"To be honest: "),"If the entry had been renamed as a subprogram, and the call was a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0217"},"procedure_call_statement"))," using the name declared by the renaming, the entry index (if any) comes from the entry ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," specified in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.5#S0242"},"subprogram_renaming_declaration")),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"27_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   A task entry has corresponding accept_statements (zero or more), whereas a protected entry has a corresponding entry_body (exactly one).",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"28_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   A consequence of the rule regarding the allowed placements of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s is that a task can execute ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),"s only for its own entries.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"29/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00318-02","AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   A return statement (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.5"},"6.5"),") or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),") can be used to complete the execution of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"29.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," need not have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," even if the corresponding entry has parameters. Equally, it can have a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0304"},"handled_sequence_of_statements"))," even if the corresponding entry has no parameters. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"29.b_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"A single entry overloads a subprogram, an enumeration literal, or another single entry if they have the same ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-3/AA-3.1#S0022"},"defining_identifier")),". Overloading is not allowed for entry family names. A single entry or an entry of an entry family can be renamed as a procedure as explained in ",(0,a.kt)("a",{href:"../AA-8/AA-8.5#Subclause_8.5.4"},"8.5.4"),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"30/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0440-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 4   The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," can reference anything visible except the formal parameters of the entry. This includes the entry index (if any), the components (including discriminants) of the protected object, the Count attribute of an entry of that protected object, and data global to the protected unit.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"31_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The restriction against referencing the formal parameters within an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," ensures that all calls of the same entry see the same barrier value. If it is necessary to look at the parameters of an entry call before deciding whether to handle it, the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," can be \u201c",(0,a.kt)("strong",null,"when")," True\u201d and the caller can be requeued (on some private entry) when its parameters indicate that it cannot be handled immediately. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"examples-1"}),"Examples"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"32_9.5.2"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of entry declarations:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"33_9.5.2"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"entry Read(V : out Item);","\n","entry Seize;","\n","entry Request(Level)(D : Item);  --  a family of entries","\n"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"34_9.5.2"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of accept statements:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"35_9.5.2"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"accept Shut_Down;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"36_9.5.2"),"accept Read(V : out Item) do","\n","   V := Local_Item;","\n","end Read;","\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"37_9.5.2"),"accept Request(Low)(D : Item) do","\n","   ...","\n","end Request;","\n"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-83"}),"Extensions to Ada 83")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.a_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The syntax rule for ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is new.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.b_9.5.2"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"Accept_statement")),"s can now have ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-11/AA-11.2#S0305"},"exception_handler")),"s. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-95-2"}),"Wording Changes from Ada 95")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.c/2_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00171-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"{",(0,a.kt)("em",null,"8652/0002"),"}"," ",(0,a.kt)("strong",null,"Corrigendum:")," Clarified the elaboration of per-object constraints.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.d/2_9.5.2"),(0,a.kt)(s.Z,{items:["AI95-00397-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-8/AA-8.3#S0234"},"Overriding_indicator")),"s can be used on entries; this is only useful when a task or protected type inherits from an interface. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2005-1"}),"Extensions to Ada 2005")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.e/3_9.5.2"),(0,a.kt)(s.Z,{items:["AI05-0183-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration")),". This is described in ",(0,a.kt)("a",{href:"../AA-13/AA-13.1#Subclause_13.1.1"},"13.1.1"),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2012-2"}),"Extensions to Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.f/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0169-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," An optional ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification"))," can be used in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),". All other kinds of bodies allow (only) implementation-defined aspects, we need to be consistent.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.g/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0398-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Named entry indexes now can have an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-13/AA-13.1#S0346"},"aspect_specification")),", allowing the specification of (implementation-defined) aspects for a named entry index. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-2012-1"}),"Wording Changes from Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"37.h/5_9.5.2"),(0,a.kt)(s.Z,{items:["AI12-0193-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," Clarified that postcondition and invariant checks are clearly part of the rendezvous for an entry call. ",(0,a.kt)("a",{href:"../AA-6/AA-6.1#Subclause_6.1.1"},"6.1.1")," already said this, so the intent was clear and this is not an inconsistency. ",(0,a.kt)("br",null))),(0,a.kt)("a",{id:"Subclause_9.5.3"}),(0,a.kt)("h2",A({},{id:"953--entry-calls"}),"9.5.3  Entry Calls"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"1_9.5.3"),(0,a.kt)("p",null,"[An ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement"))," (an ",(0,a.kt)("em",null,"entry call"),") can appear in various contexts.] A ",(0,a.kt)("em",null,"simple")," entry call is a stand-alone statement that represents an unconditional call on an entry of a target task or a protected object. [Entry calls can also appear as part of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),"s (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7"},"9.7"),").] ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"syntax-2"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2_9.5.3"),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"entry_call_statement"),(0,a.kt)("a",{id:"S0264"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," [",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-6/AA-6.4#S0219"},"actual_parameter_part")),"];",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"name-resolution-rules-1"}),"Name Resolution Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"3_9.5.3"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," given in an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement"))," shall resolve to denote an entry. The rules for parameter associations are the same as for subprogram calls (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.4"},"6.4")," and ",(0,a.kt)("a",{href:"../AA-6/AA-6.4#Subclause_6.4.1"},"6.4.1"),"). ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"static-semantics-5"}),"Static Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"4_9.5.3"),(0,a.kt)("p",null,"[The ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement"))," specifies (explicitly or implicitly) the target object of the call, the entry or entry family, and the entry index, if any (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),").] ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"dynamic-semantics-3"}),"Dynamic Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5_9.5.3"),(0,a.kt)("p",null,"Under certain circumstances (detailed below), an entry of a task or protected object is checked to see whether it is ",(0,a.kt)("em",null,"open")," or ",(0,a.kt)("em",null,"closed"),": ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6/3_9.5.3"),(0,a.kt)(s.Z,{items:["AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.kt)("ul",null,(0,a.kt)("li",null,"An entry of a task is open if the task is blocked on an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," that corresponds to the entry (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.2"},"9.5.2"),"), or on a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0270"},"selective_accept"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.1"},"9.7.1"),") with an open ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0273"},"accept_alternative"))," that corresponds to the entry; otherwise, it is closed.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7/3_9.5.3"),(0,a.kt)(s.Z,{items:["AI05-0264-1"],mdxType:"MarginInfo"}),(0,a.kt)("li",null,"An entry of a protected object is open if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," evaluates to True; otherwise, it is closed. If the evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," propagates an exception, the exception Program_Error is propagated to all current callers of all entries of the protected object. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),'An exception during barrier evaluation is considered essentially a fatal error. All current entry callers are notified with a Program_Error. In a fault-tolerant system, a protected object might provide a Reset protected procedure, or equivalent, to support attempts to restore such a "broken" protected object to a reasonable state. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.b_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),'Note that the definition of when a task entry is open is based on the state of the (accepting) task, whereas the "openness" of a protected entry is defined only when it is explicitly checked, since the barrier expression needs to be evaluated. Implementation permissions are given (below) to allow implementations to evaluate the barrier expression more or less often than it is checked, but the basic semantic model presumes it is evaluated at the times when it is checked. ',(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"8_9.5.3"),(0,a.kt)("p",null,"For the execution of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0264"},"entry_call_statement")),", evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," and of the parameter associations is as for a subprogram call (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.4"},"6.4"),"). The entry call is then ",(0,a.kt)("em",null,"issued"),": For a call on an entry of a protected object, a new protected action is started on the object (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.1"},"9.5.1"),"). The named entry is checked to see if it is open; if open, the entry call is said to be ",(0,a.kt)("em",null,"selected immediately"),", and the execution of the call proceeds as follows: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"9_9.5.3"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"For a call on an open entry of a task, the accepting task becomes ready and continues the execution of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.2"},"9.5.2"),").",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"10_9.5.3"),(0,a.kt)("li",null,"For a call on an open entry of a protected object, the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is executed (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.2"},"9.5.2"),") as part of the protected action. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"11_9.5.3"),(0,a.kt)("p",null,"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," completes other than by a requeue (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),"), return is made to the caller (after servicing the entry queues \u2014 see below); any necessary assigning back of formal to actual parameters occurs, as for a subprogram call (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.4#Subclause_6.4.1"},"6.4.1"),"); such assignments take place outside of any protected action. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"11.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"The return to the caller will generally not occur until the protected action completes, unless some other thread of control is given the job of completing the protected action and releasing the associated execution resource. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"12_9.5.3"),(0,a.kt)("p",null,"If the named entry is closed, the entry call is added to an ",(0,a.kt)("em",null,"entry queue")," (as part of the protected action, for a call on a protected entry), and the call remains queued until it is selected or cancelled; there is a separate (logical) entry queue for each entry of a given task or protected object [(including each entry of an entry family)].",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13_9.5.3"),(0,a.kt)("p",null,"When a queued call is ",(0,a.kt)("em",null,"selected"),", it is removed from its entry queue. Selecting a queued call from a particular entry queue is called ",(0,a.kt)("em",null,"servicing")," the entry queue. An entry with queued calls can be serviced under the following circumstances: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"14_9.5.3"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"When the associated task reaches a corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", or a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0270"},"selective_accept"))," with a corresponding open ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0273"},"accept_alternative")),";",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"15/4_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)("li",null,"If after performing, as part of a protected action on the associated protected object, an exclusive protected operation on the object, the entry is checked and found to be open. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"16_9.5.3"),(0,a.kt)("p",null,"If there is at least one call on a queue corresponding to an open entry, then one such call is selected according to the ",(0,a.kt)("em",null,"entry queuing policy")," in effect (see below), and the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," is executed as above for an entry call that is selected immediately.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"17_9.5.3"),(0,a.kt)("p",null,"The entry queuing policy controls selection among queued calls both for task and protected entry queues. The default entry queuing policy is to select calls on a given entry queue in order of arrival. If calls from two or more queues are simultaneously eligible for selection, the default entry queuing policy does not specify which queue is serviced first. Other entry queuing policies can be specified by ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-2/AA-2.8#S0019"},"pragma")),"s (see ",(0,a.kt)("a",{href:"../AA-D/AA-D.4"},"D.4"),").",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"18_9.5.3"),(0,a.kt)("p",null,"For a protected object, the above servicing of entry queues continues until there are no open entries with queued calls, at which point the protected action completes. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"18.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"While servicing the entry queues of a protected object, no new calls can be added to any entry queue of the object, except due to an internal requeue (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),"). This is because the first step of a call on a protected entry is to start a new protected action, which implies acquiring (for exclusive read-write access) the execution resource associated with the protected object, which cannot be done while another protected action is already in progress. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"19_9.5.3"),(0,a.kt)("p",null,"For an entry call that is added to a queue, and that is not the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0282"},"triggering_statement"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0280"},"asynchronous_select"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.4"},"9.7.4"),"), the calling task is blocked until the call is cancelled, or the call is selected and a corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," completes without requeuing. In addition, the calling task is blocked during a rendezvous.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"19.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"For a call on a protected entry, the caller is not blocked if the call is selected immediately, unless a requeue causes the call to be queued.",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"20_9.5.3"),(0,a.kt)("p",null,"An attempt can be made to cancel an entry call upon an abort (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.8"},"9.8"),") and as part of certain forms of ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement"))," (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.2"},"9.7.2"),", ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.3"},"9.7.3"),", and ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.4"},"9.7.4"),"). The cancellation does not take place until a point (if any) when the call is on some entry queue, and not protected from cancellation as part of a requeue (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.4"},"9.5.4"),"); at such a point, the call is removed from the entry queue and the call completes due to the cancellation. The cancellation of a call on an entry of a protected object is a protected action[, and as such cannot take place while any other protected action is occurring on the protected object. Like any protected action, it includes servicing of the entry queues (in case some entry barrier depends on a Count attribute).] ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.a/2_9.5.3"),(0,a.kt)(s.Z,{items:["AI95-00114-01"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.kt)("strong",null),"In the case of an attempted cancellation due to abort, this removal might have to be performed by the calling task itself if the ceiling priority of the protected object is lower than the priority of the task initiating the abort. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"21_9.5.3"),(0,a.kt)("p",null,"A call on an entry of a task that has already completed its execution raises the exception Tasking_Error at the point of the call; similarly, this exception is raised at the point of the call if the called task completes its execution or becomes abnormal before accepting the call or completing the rendezvous (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.8"},"9.8"),"). This applies equally to a simple entry call and to an entry call as part of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0269"},"select_statement")),".",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"implementation-permissions"}),"Implementation Permissions"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"22/5_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0444-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"An implementation may perform the sequence of steps of a protected action using any thread of control; it can be a thread other than that of the task that started the protected action. If an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," completes without requeuing, then the corresponding calling task may be made ready without waiting for the entire protected action to complete. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"22.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),'These permissions are intended to allow flexibility for implementations on multiprocessors. On a monoprocessor, which thread of control executes the protected action is essentially invisible, since the thread is not abortable in any case, and the "current_task" function is not guaranteed to work during a protected action (see ',(0,a.kt)("a",{href:"../AA-C/AA-C.7#Subclause_C.7.1"},"C.7.1"),"). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"23/5_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0129-1","AI12-0444-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"When the entry of a protected object is checked to see whether it is open, the implementation can bypass reevaluating the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of the corresponding ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," if no variable or attribute referenced by the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," (directly or indirectly) has been altered by the execution (or cancellation) of a call to an exclusive protected operation of the object since the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," was last evaluated. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"23.a/4_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'Changes to variables referenced by an entry barrier that result from actions outside of a call to an exclusive protected operation of the protected object need not be "noticed". For example, if a global variable is referenced by an entry barrier, it should not be altered (except as part of a protected action on the object) any time after the barrier is first evaluated. In other words, globals can be used to "parameterize" a protected object, but they cannot reliably be used to control it after the first use of the protected object. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"23.b_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.kt)("strong",null),"Note that even if a global variable is volatile, the implementation need only reevaluate a barrier if the global is updated during a protected action on the protected object. This ensures that an entry-open bit-vector implementation approach is possible, where the bit-vector is computed at the end of a protected action, rather than upon each entry call. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"24_9.5.3"),(0,a.kt)("p",null,"An implementation may evaluate the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition")),"s of all ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier")),"s of a given protected object any time any entry of the object is checked to see if it is open. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'In other words, any side effects of evaluating an entry barrier should be innocuous, since an entry barrier might be evaluated more or less often than is implied by the "official" dynamic semantics. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.b_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.kt)("strong",null),'It is anticipated that when the number of entries is known to be small, all barriers will be evaluated any time one of them needs to be, to produce an "entry-open bit-vector". The appropriate bit will be tested when the entry is called, and only if the bit is false will a check be made to see whether the bit-vector might need to be recomputed. This should allow an implementation to maximize the performance of a call on an open entry, which seems like the most important case.',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.c_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},'In addition to the entry-open bit-vector, an "is-valid" bit is needed per object, which indicates whether the current bit-vector setting is valid. A "depends-on-Count-attribute" bit is needed per type. The "is-valid" bit is set to false (as are all the bits of the bit-vector) when the protected object is first created, as well as any time an exception is propagated from computing the bit-vector. Is-valid would also be set false any time the Count is changed and "depends-on-Count-attribute" is true for the type, or a protected procedure or entry returns indicating it might have updated a variable referenced in some barrier.',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.d_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},'A single procedure can be compiled to evaluate all of the barriers, set the entry-open bit-vector accordingly, and set the is-valid bit to true. It could have a "when others" handler to set them all false, and call a routine to propagate Program_Error to all queued callers.',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"24.e_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"For protected types where the number of entries is not known to be small, it makes more sense to evaluate a barrier only when the corresponding entry is checked to see if it is open. It isn't worth saving the state of the entry between checks, because of the space that would be required. Furthermore, the entry queues probably want to take up space only when there is actually a caller on them, so rather than an array of all entry queues, a linked list of nonempty entry queues make the most sense in this case, with the first caller on each entry queue acting as the queue header. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"25/5_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0444-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"When an attempt is made to cancel an entry call, the implementation can use a thread of control other than that of the task (or interrupt) that initiated the cancellation; in particular, it may use the thread of control of the caller itself to attempt the cancellation, even if this can allow the entry call to be selected in the interim. ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"25.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"Because cancellation of a protected entry call is a protected action (which helps make the Count attribute of a protected entry meaningful), it might not be practical to attempt the cancellation from the thread of control that initiated the cancellation. For example, if the cancellation is due to the expiration of a delay, it is unlikely that the handler of the timer interrupt could perform the necessary protected action itself (due to being on the interrupt level). Similarly, if the cancellation is due to an abort, it is possible that the task initiating the abort has a priority higher than the ceiling priority of the protected object (for implementations that support ceiling priorities). Similar considerations could apply in a multiprocessor situation. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"26_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 1   If an exception is raised during the execution of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", it is propagated to the corresponding caller (see ",(0,a.kt)("a",{href:"../AA-11/AA-11.4"},"11.4"),").",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"27_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 2   For a call on a protected entry, the entry is checked to see if it is open prior to queuing the call, and again thereafter if its Count attribute (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.9"},"9.9"),") is referenced in some entry barrier. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"27.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"Given this, extra care is required if a reference to the Count attribute of an entry appears in the entry's own barrier. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"27.b_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"An entry is checked to see if it is open prior to queuing to maximize the performance of a call on an open entry. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"28_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 3   In addition to simple entry calls, the language permits timed, conditional, and asynchronous entry calls (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.2"},"9.7.2"),", ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.3"},"9.7.3"),", and see ",(0,a.kt)("a",{href:"../AA-9/AA-9.7#Subclause_9.7.4"},"9.7.4"),"). ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"28.a_9.5.3"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"A task can call its own entries, but the task will deadlock if the call is a simple entry call. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"29/5_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0442-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE 4   The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0262"},"entry_barrier"))," is allowed to be evaluated by an implementation more often than strictly necessary, even if the evaluation can have side effects. On the other hand, an implementation can avoid reevaluating the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," if nothing it references was updated by an intervening protected action on the protected object, even if the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.5#S0150"},"condition"))," references some global variable that is updated by an action performed from outside of a protected action. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"examples-2"}),"Examples"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"30_9.5.3"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of entry calls:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"31_9.5.3"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"Agent.Shut_Down;                      --  see ",(0,a.kt)("a",{href:"../AA-9/AA-9.1"},"9.1"),"\n","Parser.Next_Lexeme(E);                --  see ",(0,a.kt)("a",{href:"../AA-9/AA-9.1"},"9.1"),"\n","Pool(5).Read(Next_Char);              --  see ",(0,a.kt)("a",{href:"../AA-9/AA-9.1"},"9.1"),"\n","Controller.Request(Low)(Some_Item);   --  see ",(0,a.kt)("a",{href:"../AA-9/AA-9.1"},"9.1"),"\n","Flags(3).Seize;                       --  see ",(0,a.kt)("a",{href:"../AA-9/AA-9.4"},"9.4"),"\n"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-2012-2"}),"Wording Changes from Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"31.a/4_9.5.3"),(0,a.kt)(s.Z,{items:["AI12-0129-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Corrigendum:")," Revised wording to talk about \u201cexclusive protected operations\u201d (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.1"},"9.5.1"),"). ",(0,a.kt)("br",null))),(0,a.kt)("a",{id:"Subclause_9.5.4"}),(0,a.kt)("h2",A({},{id:"954--requeue-statements"}),"9.5.4  Requeue Statements"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"1_9.5.4"),(0,a.kt)("p",null,"[A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," can be used to complete an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", while redirecting the corresponding entry call to a new (or the same) entry queue. Such a ",(0,a.kt)("em",null,"requeue")," can be performed with or without allowing an intermediate cancellation of the call, due to an abort or the expiration of a delay. ]",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"syntax-3"}),"Syntax"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"2/3_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2"],mdxType:"MarginInfo"}),(0,a.kt)(i.Z,{mdxType:"CodeBlock"},(0,a.kt)("code",null,"requeue_statement"),(0,a.kt)("a",{id:"S0265"}),(0,a.kt)("code",null," ::= "),(0,a.kt)("strong",null,"requeue")," ",(0,a.kt)("em",null,"procedure_or_entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," [",(0,a.kt)("strong",null,"with")," ",(0,a.kt)("strong",null,"abort"),"];",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"name-resolution-rules-2"}),"Name Resolution Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"3/3_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The ",(0,a.kt)("em",null,"procedure_or_entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," shall resolve to denote a procedure or an entry (the ",(0,a.kt)("em",null,"requeue "),(0,a.kt)("em",null,"target"),"). The profile of the entry, or the profile or prefixed profile of the procedure, shall either have no parameters, or be type conformant (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.3#Subclause_6.3.1"},"6.3.1"),") with the profile of the innermost enclosing ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),". ",(0,a.kt)("br",null)),(0,a.kt)("h4",A({},{id:"legality-rules-4"}),"Legality Rules"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"4_9.5.4"),(0,a.kt)("p",null,"A ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," shall be within a callable construct that is either an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," or an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", and this construct shall be the innermost enclosing body or callable construct.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5/3_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If the requeue target has parameters, then its (prefixed) profile shall be subtype conformant with the profile of the innermost enclosing callable construct. ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.1/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"Given a requeue_statement where the innermost enclosing callable construct is for an entry ",(0,a.kt)("em",null,"E1"),", for every [specific or class-wide ]postcondition expression ",(0,a.kt)("em",null,"P1")," that applies to ",(0,a.kt)("em",null,"E1"),", there shall exist a postcondition expression ",(0,a.kt)("em",null,"P2")," that applies to the requeue target ",(0,a.kt)("em",null,"E2")," such that ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.2/4_9.5.4"),(0,a.kt)("ul",null,(0,a.kt)("li",null,(0,a.kt)("em",null,"P1")," is fully conformant with the expression produced by replacing each reference in ",(0,a.kt)("em",null,"P2")," to a formal parameter of ",(0,a.kt)("em",null,"E2")," with a reference to the corresponding formal paramter of ",(0,a.kt)("em",null,"E1"),"; and",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.3/4_9.5.4"),(0,a.kt)("li",null,"if ",(0,a.kt)("em",null,"P1")," is enabled, then ",(0,a.kt)("em",null,"P2")," is also enabled. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.a/4_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"Roughly speaking, the postcondition of the requeue target is required to imply that of the enclosing callable construct. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.4/5_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0090-1","AI12-0143-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The requeue target shall not have an applicable specific or class-wide postcondition that includes an Old or Index ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0100"},"attribute_reference")),".",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.5/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If the requeue target is declared immediately within the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0246"},"task_definition"))," of a named task type or the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.4#S0251"},"protected_definition"))," of a named protected type, and if the requeue statement occurs within the body of that type, and if the requeue is an external requeue, then the requeue target shall not have a specific or class-wide postcondition which includes a name denoting either the current instance of that type or any entity declared within the declaration of that type.",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.b/4_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"discussion",mdxType:"Admonition"},(0,a.kt)("strong",null),"The above pair of rules always apply; they don't depend on whether or not any of the postconditions are enabled. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"5.6/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1","AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If the target is a procedure, the name shall denote a renaming of an entry, or shall denote a view or a prefixed view of a primitive subprogram of a synchronized interface, where the first parameter of the unprefixed view of the primitive subprogram shall be a controlling parameter, and the Synchronization aspect shall be specified with ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0256"},"synchronization_kind"))," By_Entry for the primitive subprogram.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"6/3_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"In a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," of some task unit, either the target object shall be a part of a formal parameter of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", or the accessibility level of the target object shall not be equal to or statically deeper than any enclosing ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," of the task unit. In a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," of an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," of some protected unit, either the target object shall be a part of a formal parameter of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),", or the accessibility level of the target object shall not be statically deeper than that of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0257"},"entry_declaration"))," for the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),".",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"6.a_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"In the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," case, the intent is that the target object can be global, or can be a component of the protected unit, but cannot be a local variable of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body")),". ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"6.b_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"These restrictions ensure that the target object of the requeue outlives the completion and finalization of the enclosing callable construct. They also prevent requeuing from a nested ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," on a parameter of an outer ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),', which could create some strange "long-distance" connections between an entry caller and its server.',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"6.c_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Note that in the strange case where a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body"))," is nested inside an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),", it is permissible to requeue from an ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," of the inner ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body"))," on parameters of the outer ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),". This is not a problem because all calls on the inner task have to complete before returning from the outer ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement")),', meaning no "dangling calls" will be created. ',(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"6.d_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"implementation-note",mdxType:"Admonition"},(0,a.kt)("strong",null),"By disallowing certain requeues, we ensure that the normal ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.7#S0275"},"terminate_alternative"))," rules remain sensible, and that explicit clearing of the entry queues of a protected object during finalization is rarely necessary. In particular, such clearing of the entry queues is necessary only (ignoring premature Unchecked_Deallocation) for protected objects declared in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.1#S0248"},"task_body"))," (or created by an allocator for an access type declared in such a body) containing one or more ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement")),"s. Protected objects declared in subprograms, or at the library level, will never need to have their entry queues explicitly cleared during finalization. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"dynamic-semantics-4"}),"Dynamic Semantics"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7/5_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI12-0090-1","AI12-0335-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"The execution of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," begins with the following sequence of steps:",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.1/5_9.5.4"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"1."),(0,a.kt)("dl",null,(0,a.kt)("dd",null,"The ",(0,a.kt)("em",null,"procedure_or_entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," is evaluated. This includes evaluation of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0093"},"prefix"))," (if any) identifying the target task or protected object and of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.4#S0132"},"expression"))," (if any) identifying the entry within an entry family.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.2/5_9.5.4"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"2."),(0,a.kt)(s.Z,{items:["AI12-0335-1"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"If the target object is not a part of a formal parameter of the innermost enclosing callable construct, a check is made that the accessibility level of the target object is not equal to or deeper than the level of the innermost enclosing callable construct. If this check fails, Program_Error is raised.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.3/5_9.5.4"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"3."),(0,a.kt)(s.Z,{items:["AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)("dd",null,"Precondition checks are performed as for a call to the requeue target.",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"7.4/5_9.5.4"),(0,a.kt)("dt",null,(0,a.kt)("br",null),"4."),(0,a.kt)("dd",null,"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," enclosing the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," is then completed[, finalized, and left (see ",(0,a.kt)("a",{href:"../AA-7/AA-7.6#Subclause_7.6.1"},"7.6.1"),")].",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"8_9.5.4"),(0,a.kt)("p",null,"For the execution of a requeue on an entry of a target task, after leaving the enclosing callable construct, the named entry is checked to see if it is open and the requeued call is either selected immediately or queued, as for a normal entry call (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),").",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"9_9.5.4"),(0,a.kt)("p",null,"For the execution of a requeue on an entry of a target protected object, after leaving the enclosing callable construct: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"10_9.5.4"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"if the requeue is an internal requeue (that is, the requeue is back on an entry of the same protected object \u2014 see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),"), the call is added to the queue of the named entry and the ongoing protected action continues (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.1"},"9.5.1"),"); ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"10.a_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),'Note that for an internal requeue, the call is queued without checking whether the target entry is open. This is because the entry queues will be serviced before the current protected action completes anyway, and considering the requeued call immediately might allow it to "jump" ahead of existing callers on the same queue. ',(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"11_9.5.4"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"if the requeue is an external requeue (that is, the target protected object is not implicitly the same as the current object \u2014 see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5"},"9.5"),"), a protected action is started on the target object and proceeds as for a normal entry call (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.5#Subclause_9.5.3"},"9.5.3"),"). ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"12/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)("p",null,"If the requeue target named in the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," has formal parameters, then during the execution of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0258"},"accept_statement"))," or ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0260"},"entry_body"))," corresponding to the new entry and during the checking of any preconditions of the new entry, the formal parameters denote the same objects as did the corresponding formal parameters of the callable construct completed by the requeue. [In any case, no parameters are specified in a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement")),"; any parameter passing is implicit.]",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"13_9.5.4"),(0,a.kt)("p",null,"If the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," includes the reserved words ",(0,a.kt)("strong",null,"with abort")," (it is a ",(0,a.kt)("em",null,"requeue-with-abort"),"), then: ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"14_9.5.4"),(0,a.kt)("ul",null,(0,a.kt)("li",null,"if the original entry call has been aborted (see ",(0,a.kt)("a",{href:"../AA-9/AA-9.8"},"9.8"),"), then the requeue acts as an abort completion point for the call, and the call is cancelled and no requeue is performed;",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"15_9.5.4"),(0,a.kt)("li",null,"if the original entry call was timed (or conditional), then the original expiration time is the expiration time for the requeued call. ",(0,a.kt)("br",null))),(0,a.kt)(l.Z,{mdxType:"MarginText"},"16_9.5.4"),(0,a.kt)("p",null,"If the reserved words ",(0,a.kt)("strong",null,"with abort")," do not appear, then the call remains protected against cancellation while queued as the result of the ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement")),". ",(0,a.kt)("br",null)),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"16.a_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"ramification",mdxType:"Admonition"},(0,a.kt)("strong",null),"This protection against cancellation lasts only until the call completes or a subsequent requeue-with-abort is performed on the call. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"16.b_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"reason",mdxType:"Admonition"},(0,a.kt)("strong",null),"We chose to protect a requeue, by default, against abort or cancellation. This seemed safer, since it is likely that extra steps need to be taken to allow for possible cancellation once the servicing of an entry call has begun. This also means that in the absence of ",(0,a.kt)("strong",null,"with abort")," the usual Ada 83 behavior is preserved, namely that once an entry call is accepted, it cannot be cancelled until it completes. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"17/5_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0300-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"NOTE   A requeue is permitted from a single entry to an entry of an entry family, or vice versa. The entry index, if any, plays no part in the subtype conformance check between the profiles of the two entries; an entry index is part of the ",(0,a.kt)("em",null,"entry_"),(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-4/AA-4.1#S0091"},"name"))," for an entry of a family. ",(0,a.kt)("br",null))),(0,a.kt)("h4",A({},{id:"examples-3"}),"Examples"),(0,a.kt)(l.Z,{mdxType:"MarginText"},"18_9.5.4"),(0,a.kt)("p",null,(0,a.kt)("em",null,"Examples of requeue statements:")," ",(0,a.kt)("br",null)),(0,a.kt)(l.Z,{mdxType:"MarginText"},"19_9.5.4"),(0,a.kt)(i.Z,{language:"ada",mdxType:"CodeBlock"},"requeue Request(Medium) with abort;","\n","                    -- requeue on a member of an entry family of the current task, see ",(0,a.kt)("a",{href:"../AA-9/AA-9.1"},"9.1"),"\n",(0,a.kt)(l.Z,{mdxType:"MarginText"},"20_9.5.4"),"requeue Flags(I).Seize;","\n","                    -- requeue on an entry of an array component, see ",(0,a.kt)("a",{href:"../AA-9/AA-9.4"},"9.4"),"\n"),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-83-1"}),"Extensions to Ada 83")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.a_9.5.4"),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"The ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement"))," is new. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"extensions-to-ada-2005-2"}),"Extensions to Ada 2005")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.b/3_9.5.4"),(0,a.kt)(s.Z,{items:["AI05-0030-2","AI05-0215-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added the ability to requeue on operations of synchronized interfaces that are declared to be an entry. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"inconsistencies-with-ada-2012-1"}),"Inconsistencies With Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.c/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Corrigendum:")," We now define that any preconditions of the requeue target are evaluated as part of a ",(0,a.kt)("code",null,(0,a.kt)("a",{href:"../AA-9/AA-9.5#S0265"},"requeue_statement")),". Original Ada 2012 did not specify this, so a program that requeues when the preconditions fail will raise an exception when none would happen in original Ada 2012. We don't expect this to be a problem, as in that case, the entry body would be called with some of its preconditions evaluating as False; the body is likely to assume that they are true and probably will have failed in some other way anyway.",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.d/5_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0335-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"correction",mdxType:"Admonition"},(0,a.kt)("strong",null)," We now include an accessibility check on requeues. This means Program_Error could be raised for a requeue that worked in Ada 2012. This can only fail for an object for which the statically deeper relationship does not apply, for instance a stand-alone object of an anonymous access type. Most programs that are affected are erroneous anyway (as they will eventually use a nonexistent object), so we do not believe this will matter in practice. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"incompatibilities-with-ada-2012-1"}),"Incompatibilities With Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.e/4_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0090-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},(0,a.kt)("strong",null,"Corrigendum:")," If a requeue target has a different postcondition than the original entry, the requeue is now illegal. In such a case, the original postcondition would never have been evaluated, and assumptions that the caller relied upon might not be true. A requeue should be invisible to the caller with respect to any postconditions; thus we only allow it when the original entry has no postconditions or the requeue target has (at least) the same postconditions. ",(0,a.kt)("br",null))),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)("h4",A({},{id:"wording-changes-from-ada-2012-3"}),"Wording Changes from Ada 2012")),(0,a.kt)(r.Z,{mdxType:"AnnotatedOnly"},(0,a.kt)(l.Z,{mdxType:"MarginText"},"20.f/5_9.5.4"),(0,a.kt)(s.Z,{items:["AI12-0143-1"],mdxType:"MarginInfo"}),(0,a.kt)(o.Z,{type:"aarm",aarm:"note",mdxType:"Admonition"},"Added a Legality Rule for the new Index attribute (see ",(0,a.kt)("a",{href:"../AA-6/AA-6.1#Subclause_6.1.1"},"6.1.1"),"). ",(0,a.kt)("br",null))))}Z.isMDXComponent=!0}}]);