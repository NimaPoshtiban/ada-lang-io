"use strict";(self.webpackChunkada_lang_io=self.webpackChunkada_lang_io||[]).push([[1030],{32044:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>k,contentTitle:()=>c,default:()=>y,frontMatter:()=>m,metadata:()=>h,toc:()=>f});var n=a(91716),i=Object.defineProperty,r=Object.defineProperties,o=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,d=(e,t,a)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,u=(e,t)=>{for(var a in t||(t={}))s.call(t,a)&&d(e,a,t[a]);if(l)for(var a of l(t))p.call(t,a)&&d(e,a,t[a]);return e};const m={title:"5.10 Summary"},c=void 0,h={unversionedId:"style-guide/s5/10",id:"style-guide/s5/10",title:"5.10 Summary",description:"optional parts of the syntax",source:"@site/docs/style-guide/s5/10.mdx",sourceDirName:"style-guide/s5",slug:"/style-guide/s5/10",permalink:"/docs/style-guide/s5/10",draft:!1,tags:[],version:"current",frontMatter:{title:"5.10 Summary"},sidebar:"styleGuideSidebar",previous:{title:"5.9 Erroneous execution and bounded errors",permalink:"/docs/style-guide/s5/09"},next:{title:"6. Concurrency",permalink:"/docs/style-guide/s6/"}},k={},f=[{value:"optional parts of the syntax",id:"optional-parts-of-the-syntax",level:4},{value:"parameter lists",id:"parameter-lists",level:4},{value:"types",id:"types",level:4},{value:"data structures",id:"data-structures",level:4},{value:"expressions",id:"expressions",level:4},{value:"statements",id:"statements",level:4},{value:"visibility",id:"visibility",level:4},{value:"using exceptions",id:"using-exceptions",level:4},{value:"erroneous execution and bounded errors",id:"erroneous-execution-and-bounded-errors",level:4}],N={toc:f};function y(e){var t,a=e,{components:i}=a,d=((e,t)=>{var a={};for(var n in e)s.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&l)for(var n of l(e))t.indexOf(n)<0&&p.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=u(u({},N),d),r(t,o({components:i,mdxType:"MDXLayout"}))),(0,n.kt)("h4",u({},{id:"optional-parts-of-the-syntax"}),"optional parts of the syntax"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Associate names with loops when they are nested (Booch 1986, 1987)."),(0,n.kt)("li",{parentName:"ul"},"Associate names with any loop that contains an ",(0,n.kt)("inlineCode",{parentName:"li"},"exit"),"statement."),(0,n.kt)("li",{parentName:"ul"},"Associate names with blocks when they are nested ."),(0,n.kt)("li",{parentName:"ul"},"Use loop names on all ",(0,n.kt)("inlineCode",{parentName:"li"},"exit"),"statements from nested loops."),(0,n.kt)("li",{parentName:"ul"},"Include the defining program unit name at the end of a package\nspecification and body."),(0,n.kt)("li",{parentName:"ul"},"Include the defining identifier at the end of a task specification\nand body."),(0,n.kt)("li",{parentName:"ul"},"Include the entry identifier at the end of an ",(0,n.kt)("inlineCode",{parentName:"li"},"accept")," statement."),(0,n.kt)("li",{parentName:"ul"},"Include the designator at the end of a subprogram body."),(0,n.kt)("li",{parentName:"ul"},"Include the defining identifier at the end of a protected unit\ndeclaration.")),(0,n.kt)("h4",u({},{id:"parameter-lists"}),"parameter lists"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Name formal parametername formal parameters descriptively to reduce\nthe need for comments ."),(0,n.kt)("li",{parentName:"ul"},"Use named parameter association in calls of infrequently used\nsubprograms or entries with many formal parameters ."),(0,n.kt)("li",{parentName:"ul"},"Use named association when instantiating generics."),(0,n.kt)("li",{parentName:"ul"},"Use named association for clarification when the actual parameter is\nany literal or expression."),(0,n.kt)("li",{parentName:"ul"},"Use named association when supplying a nondefault value to an\noptional parameter."),(0,n.kt)("li",{parentName:"ul"},"Provide default parameters to allow for occasional, special use of\nwidely used subprograms or entries."),(0,n.kt)("li",{parentName:"ul"},"Place default parameters at the end of the formal parameter list."),(0,n.kt)("li",{parentName:"ul"},"Consider providing default values to new parameters added to an\nexisting subprogram."),(0,n.kt)("li",{parentName:"ul"},"Show the mode indication of all procedure and entry parameters\n(Nissen and Wallis 1984)."),(0,n.kt)("li",{parentName:"ul"},"Use the most restrictive parameter mode applicable to your\napplication.")),(0,n.kt)("h4",u({},{id:"types"}),"types"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use existing types as building blocks by deriving new types from\nthem."),(0,n.kt)("li",{parentName:"ul"},"Use range constraints on subtypes."),(0,n.kt)("li",{parentName:"ul"},"Define new types, especially derived types, to include the largest\nset of possible values, including boundary values."),(0,n.kt)("li",{parentName:"ul"},"Constrain the ranges of derived types with subtypes, excluding\nboundary values."),(0,n.kt)("li",{parentName:"ul"},"Use type derivation rather than type extension when there are no\nmeaningful components to add to the type."),(0,n.kt)("li",{parentName:"ul"},"Avoid anonymous array types."),(0,n.kt)("li",{parentName:"ul"},"Use anonymous array types for array variables only when no suitable\ntype exists or can be created and the array will not be referenced\nas a whole (e.g., used as a subprogram parameter)."),(0,n.kt)("li",{parentName:"ul"},"Use access parameters and access discriminants to guarantee that the\nparameter or discriminant is treated as a constant."),(0,n.kt)("li",{parentName:"ul"},"Derive from controlled types in preference to using limited private\ntypes."),(0,n.kt)("li",{parentName:"ul"},"Use limited private types in preference to private types."),(0,n.kt)("li",{parentName:"ul"},"Use private types in preference to nonprivate types."),(0,n.kt)("li",{parentName:"ul"},"Explicitly export needed operations rather than easing restrictions."),(0,n.kt)("li",{parentName:"ul"},"Use access-to-subprogram types for indirect access to subprograms."),(0,n.kt)("li",{parentName:"ul"},"Wherever possible, use abstract tagged types and dispatching rather\nthan access-to-subprogram types to implement dynamic selection and\ninvocation of subprograms.")),(0,n.kt)("h4",u({},{id:"data-structures"}),"data structures"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"When declaring a discriminant, use as constrained a subtype as\npossible (i.e., subtype with as specific a range constraint as\npossible)."),(0,n.kt)("li",{parentName:"ul"},"Use a discriminated record rather than a constrained array to\nrepresent an array whose actual values are unconstrained."),(0,n.kt)("li",{parentName:"ul"},"Use records to group heterogeneous but related data."),(0,n.kt)("li",{parentName:"ul"},"Consider records to map to I/O device data."),(0,n.kt)("li",{parentName:"ul"},"Use access types to class-wide types to implement heterogeneous\npolymorphic data structures."),(0,n.kt)("li",{parentName:"ul"},"Use tagged types and type extension rather than variant records (in\ncombination with enumeration types and case statements)."),(0,n.kt)("li",{parentName:"ul"},"Record structures should not always be flat. Factor out common\nparts."),(0,n.kt)("li",{parentName:"ul"},"For a large record structure, group related components into smaller\nsubrecords."),(0,n.kt)("li",{parentName:"ul"},"For nested records, pick element names that read well when inner\nelements are referenced."),(0,n.kt)("li",{parentName:"ul"},"Consider using type extension to organize large data structures."),(0,n.kt)("li",{parentName:"ul"},"Differentiate between static and dynamic data. Use dynamically\nallocated objects with caution."),(0,n.kt)("li",{parentName:"ul"},"Use dynamically allocated data structures only when it is necessary\nto create and destroy them dynamically or to be able to reference\nthem by different names."),(0,n.kt)("li",{parentName:"ul"},"Do not drop pointers to undeallocated objects."),(0,n.kt)("li",{parentName:"ul"},"Do not leave dangling references to deallocated objects."),(0,n.kt)("li",{parentName:"ul"},"Initialize all access variables and components within a record."),(0,n.kt)("li",{parentName:"ul"},"Do not rely on memory deallocation."),(0,n.kt)("li",{parentName:"ul"},"Deallocate explicitly."),(0,n.kt)("li",{parentName:"ul"},"Use length clauses to specify total allocation size."),(0,n.kt)("li",{parentName:"ul"},"Provide handlers for ",(0,n.kt)("inlineCode",{parentName:"li"},"Storage_Error"),"."),(0,n.kt)("li",{parentName:"ul"},"Use controlled types to implement private types that manipulate\ndynamic data."),(0,n.kt)("li",{parentName:"ul"},"Avoid unconstrained record objects unless your run-time environment\nreliably reclaims dynamic heap storage."),(0,n.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage, declare the following items only in the outermost, unnested\ndeclarative part of either a library package, a main subprogram, or\na permanent task:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Access types"),(0,n.kt)("li",{parentName:"ul"},"Constrained composite objects with nonstatic bounds"),(0,n.kt)("li",{parentName:"ul"},"Objects of an unconstrained composite type other than\nunconstrainedrecords"),(0,n.kt)("li",{parentName:"ul"},"Composite objects large enough (at compile time) for the\ncompiler to allocate implicitly on the heap"))),(0,n.kt)("li",{parentName:"ul"},"Unless your run-time environment reliably reclaims dynamic heap\nstorage or you are creating permanent, dynamically allocated tasks,\navoid declaring tasks in the following situations:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Unconstrained array subtypes whose components are tasks"),(0,n.kt)("li",{parentName:"ul"},"Discriminated record subtypes containing a component that is an\narray of tasks, where the array size depends on the value of the\ndiscriminant"),(0,n.kt)("li",{parentName:"ul"},"Any declarative region other than the outermost, unnested\ndeclarative part of either a library package or a main\nsubprogram"),(0,n.kt)("li",{parentName:"ul"},"Arrays of tasks that are not statically constrained"))),(0,n.kt)("li",{parentName:"ul"},"Minimize the use of aliased variables."),(0,n.kt)("li",{parentName:"ul"},"Use aliasing for statically created, ragged arrays (Rationale 1995,\n\xa73.7.1)."),(0,n.kt)("li",{parentName:"ul"},"Use aliasing to refer to part of a data structure when you want to\nhide the internal connections and bookkeeping information."),(0,n.kt)("li",{parentName:"ul"},"Use access discriminants to create self-referential data structures,\ni.e., a data structure one of whose components points to the\nenclosing structure."),(0,n.kt)("li",{parentName:"ul"},"Use modular types rather than a Boolean arrays when you create data\nstructures that need bit-wise operations, such as ",(0,n.kt)("inlineCode",{parentName:"li"},"and")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"or"),".")),(0,n.kt)("h4",u({},{id:"expressions"}),"expressions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"'First")," or ",(0,n.kt)("inlineCode",{parentName:"li"},"'Last")," instead of numeric literals to represent the\nfirst or last values of a range."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"'Range")," or the subtype name of the range instead of ",(0,n.kt)("inlineCode",{parentName:"li"},"'First .. 'Last"),"."),(0,n.kt)("li",{parentName:"ul"},"Use array attributes ",(0,n.kt)("inlineCode",{parentName:"li"},"'First"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"'Last"),", or ",(0,n.kt)("inlineCode",{parentName:"li"},"'Length")," instead of\nnumeric literals for accessing arrays."),(0,n.kt)("li",{parentName:"ul"},"Use the ",(0,n.kt)("inlineCode",{parentName:"li"},"'Range")," of the array instead of the name of the index\nsubtype to express a range."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"'Range")," instead of ",(0,n.kt)("inlineCode",{parentName:"li"},"'First .. 'Last")," to express a range."),(0,n.kt)("li",{parentName:"ul"},"Use parentheses to specify the order of subexpression evaluation to\nclarify expressions (NASA 1987)."),(0,n.kt)("li",{parentName:"ul"},"Use parentheses to specify the order of evaluation for\nsubexpressions whose correctness depends on left to right\nevaluation."),(0,n.kt)("li",{parentName:"ul"},"Avoid names and constructs that rely on the use of negatives ."),(0,n.kt)("li",{parentName:"ul"},"Choose names of flags so they represent states that can be used in\npositive form."),(0,n.kt)("li",{parentName:"ul"},"Use short-circuit forms of the logical operators to specify the\norder of conditions when the failure of one condition means that the\nother condition will raise an exception."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"<=")," and ",(0,n.kt)("inlineCode",{parentName:"li"},">=")," in relational expressions with real operands\ninstead of ",(0,n.kt)("inlineCode",{parentName:"li"},"="),".")),(0,n.kt)("h4",u({},{id:"statements"}),"statements"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Minimize the depth of nested expressions (Nissen and Wallis 1984)."),(0,n.kt)("li",{parentName:"ul"},"Minimize the depth of nested control structures (Nissen and Wallis\n1984)."),(0,n.kt)("li",{parentName:"ul"},"Try using simplification heuristics."),(0,n.kt)("li",{parentName:"ul"},"Use slices rather than a loop to copy part of an array."),(0,n.kt)("li",{parentName:"ul"},"Minimize the use of an ",(0,n.kt)("inlineCode",{parentName:"li"},"others")," choice in a ",(0,n.kt)("inlineCode",{parentName:"li"},"case"),"statement."),(0,n.kt)("li",{parentName:"ul"},"Do not use ranges of enumeration literals in ",(0,n.kt)("inlineCode",{parentName:"li"},"case")," statements."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"case")," statements rather than ",(0,n.kt)("inlineCode",{parentName:"li"},"if/elsif")," statements, wherever\npossible."),(0,n.kt)("li",{parentName:"ul"},"Use type extension and dispatching rather than ",(0,n.kt)("inlineCode",{parentName:"li"},"case")," statements, if\npossible."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"for")," loops, whenever possible."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"while")," loops when the number of iterations cannot be calculated\nbefore entering the loop but a simple continuation condition can be\napplied at the top of the loop."),(0,n.kt)("li",{parentName:"ul"},"Use plain loops with ",(0,n.kt)("inlineCode",{parentName:"li"},"exit")," statements for more complex situations."),(0,n.kt)("li",{parentName:"ul"},"Avoid ",(0,n.kt)("inlineCode",{parentName:"li"},"exit")," statements in ",(0,n.kt)("inlineCode",{parentName:"li"},"while")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"for")," loops."),(0,n.kt)("li",{parentName:"ul"},"Minimize the number of ways to exit a loop."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"exit")," statements to enhance the readability of loop termination\ncode (NASA 1987)."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"exit when ...")," rather than",(0,n.kt)("inlineCode",{parentName:"li"},"if ... then exit"),"whenever possible\n(NASA 1987)."),(0,n.kt)("li",{parentName:"ul"},"Review ",(0,n.kt)("inlineCode",{parentName:"li"},"exit")," statement placement."),(0,n.kt)("li",{parentName:"ul"},"Consider specifying bounds on loops."),(0,n.kt)("li",{parentName:"ul"},"Consider specifying bounds on recursion."),(0,n.kt)("li",{parentName:"ul"},"Do not use ",(0,n.kt)("inlineCode",{parentName:"li"},"goto")," statements."),(0,n.kt)("li",{parentName:"ul"},"Minimize the number of ",(0,n.kt)("inlineCode",{parentName:"li"},"return"),"statementsfrom a subprogram (NASA\n1987)."),(0,n.kt)("li",{parentName:"ul"},"Highlight ",(0,n.kt)("inlineCode",{parentName:"li"},"return"),"statements with comments or white space to keep\nthem from being lost in other code."),(0,n.kt)("li",{parentName:"ul"},"Use blocks to localize the scope of declarations."),(0,n.kt)("li",{parentName:"ul"},"Use blocks to perform local renaming."),(0,n.kt)("li",{parentName:"ul"},"Use blocks to define local exception handlers."),(0,n.kt)("li",{parentName:"ul"},"Use an aggregate instead of a sequence of assignments to assign\nvalues to all components of a record"),(0,n.kt)("li",{parentName:"ul"},"Use an aggregate instead of a temporary variable when building a\nrecord to pass as an actual parameter"),(0,n.kt)("li",{parentName:"ul"},"Use positional association only when there is a conventional\nordering of the arguments.")),(0,n.kt)("h4",u({},{id:"visibility"}),"visibility"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"When you need to provide visibility to operators, use the ",(0,n.kt)("inlineCode",{parentName:"li"},"use type"),"\nclause."),(0,n.kt)("li",{parentName:"ul"},"Avoid/minimize the use of the ",(0,n.kt)("inlineCode",{parentName:"li"},"use")," clause (Nissen and Wallis 1984)."),(0,n.kt)("li",{parentName:"ul"},"Consider using a package ",(0,n.kt)("inlineCode",{parentName:"li"},"renames")," clause rather than a ",(0,n.kt)("inlineCode",{parentName:"li"},"use")," clause\nfor a package."),(0,n.kt)("li",{parentName:"ul"},"Consider using the ",(0,n.kt)("inlineCode",{parentName:"li"},"use")," clause in the following situations:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"When standard packages are needed and no ambiguous references\nare introduced"),(0,n.kt)("li",{parentName:"ul"},"When references to enumeration literals are needed"))),(0,n.kt)("li",{parentName:"ul"},"Localize the effect of all ",(0,n.kt)("inlineCode",{parentName:"li"},"use")," clauses."),(0,n.kt)("li",{parentName:"ul"},"Limit the scope of a renaming declaration to the minimum necessary\nscope."),(0,n.kt)("li",{parentName:"ul"},"Rename a long, fully qualified name to reduce the complexity if it\nbecomes unwieldy."),(0,n.kt)("li",{parentName:"ul"},"Use renaming to provide the body of a subprogram if this subprogram\nmerely calls the first subprogram."),(0,n.kt)("li",{parentName:"ul"},"Rename declarations for visibility purposes rather than using the\nuse clause, except for operators ."),(0,n.kt)("li",{parentName:"ul"},"Rename parts when your code interfaces to reusable components\noriginally written with nondescriptive or inapplicable nomenclature."),(0,n.kt)("li",{parentName:"ul"},"Use a project-wide standard list of abbreviations to rename common\npackages."),(0,n.kt)("li",{parentName:"ul"},"Provide a ",(0,n.kt)("inlineCode",{parentName:"li"},"use type")," rather than a ",(0,n.kt)("inlineCode",{parentName:"li"},"renames")," clause to provide\nvisibility to operators."),(0,n.kt)("li",{parentName:"ul"},"Limit overloading to widely used subprograms that perform similar\nactions on arguments of different types (Nissen and Wallis 1984)."),(0,n.kt)("li",{parentName:"ul"},"Preserve the conventional meaning of overloaded operators (Nissen\nand Wallis 1984)."),(0,n.kt)("li",{parentName:"ul"},'Use "',(0,n.kt)("inlineCode",{parentName:"li"},"+"),'" to identify adding, joining, increasing, and enhancing\nkinds of functions.'),(0,n.kt)("li",{parentName:"ul"},'Use "',(0,n.kt)("inlineCode",{parentName:"li"},"-"),'" to identify subtraction, separation, decreasing, and\ndepleting kinds of functions.'),(0,n.kt)("li",{parentName:"ul"},"Use operator overloading sparingly and uniformly when applied to\ntagged types."),(0,n.kt)("li",{parentName:"ul"},"Define an appropriate equality operator for private types."),(0,n.kt)("li",{parentName:"ul"},"Consider redefining the equality operator for a private type."),(0,n.kt)("li",{parentName:"ul"},"When overloading the equality operator for types, maintain the\nproperties of an algebraic equivalence relation.")),(0,n.kt)("h4",u({},{id:"using-exceptions"}),"using exceptions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"When it is easy and efficient to do so, avoid causing exceptions to\nbe raised."),(0,n.kt)("li",{parentName:"ul"},"Provide handlers for exceptions that cannot be avoided."),(0,n.kt)("li",{parentName:"ul"},"Use exception handlers to enhance readability by separating fault\nhandling from normal execution."),(0,n.kt)("li",{parentName:"ul"},"Do not use exceptions and exception handlers as ",(0,n.kt)("inlineCode",{parentName:"li"},"goto")," statements."),(0,n.kt)("li",{parentName:"ul"},"Do not evaluate the value of an object (or a part of an object) that\nhas become abnormal because of the failure of a language-defined\ncheck."),(0,n.kt)("li",{parentName:"ul"},"When writing an exception handler for ",(0,n.kt)("inlineCode",{parentName:"li"},"others"),", capture and return\nadditional information about the exception through the\n",(0,n.kt)("inlineCode",{parentName:"li"},"Exception_Name"),", ",(0,n.kt)("inlineCode",{parentName:"li"},"Exception_Message"),", or ",(0,n.kt)("inlineCode",{parentName:"li"},"Exception_Information"),"\nsubprograms declared in the predefined package ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Exceptions"),"."),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"others")," only to catch exceptions you cannot enumerate\nexplicitly, preferably only to flag a potential abort."),(0,n.kt)("li",{parentName:"ul"},"During development, trap ",(0,n.kt)("inlineCode",{parentName:"li"},"others"),", capture the exception being\nhandled, and consider adding an explicit handler for that exception."),(0,n.kt)("li",{parentName:"ul"},"Handle all exceptions, both user and predefined ."),(0,n.kt)("li",{parentName:"ul"},"For every exception that might be raised, provide a handler in\nsuitable frames to protect against undesired propagation outside the\nabstraction ."),(0,n.kt)("li",{parentName:"ul"},"Do not rely on being able to identify the fault-raising, predefined,\nor implementation-defined exceptions."),(0,n.kt)("li",{parentName:"ul"},"Use the facilities defined in ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Exceptions")," to capture as much\ninformation as possible about an exception."),(0,n.kt)("li",{parentName:"ul"},"Use blocks to associate localized sections of code with their own\nexception handlers.")),(0,n.kt)("h4",u({},{id:"erroneous-execution-and-bounded-errors"}),"erroneous execution and bounded errors"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Unchecked_Conversion")," only with the utmost care (",(0,n.kt)("a",u({parentName:"li"},{href:"http://www.adahome.com/rm95/rm9x-13-09.html"}),"Ada\nReference Manual 1995,\n\xa713.9"),")."),(0,n.kt)("li",{parentName:"ul"},"Consider using the ",(0,n.kt)("inlineCode",{parentName:"li"},"'Valid")," attribute to check the validity of\nscalar data)."),(0,n.kt)("li",{parentName:"ul"},"Ensure that the value resulting from ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Unchecked_Conversion"),"\nproperly represents a value of the parameter's subtype."),(0,n.kt)("li",{parentName:"ul"},"Isolate the use of ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Unchecked_Conversion")," in package bodies."),(0,n.kt)("li",{parentName:"ul"},"Isolate the use of ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Unchecked_Deallocation")," in package bodies."),(0,n.kt)("li",{parentName:"ul"},"Ensure that no dangling reference to the local object exists after\nexiting the scope of the local object."),(0,n.kt)("li",{parentName:"ul"},"Minimize the use of the attribute ",(0,n.kt)("inlineCode",{parentName:"li"},"Unchecked_Access"),", preferably\nisolating it to package bodies."),(0,n.kt)("li",{parentName:"ul"},"Use the attribute ",(0,n.kt)("inlineCode",{parentName:"li"},"Unchecked_Access"),' only on data whose\nlifetime/scope is "library level."'),(0,n.kt)("li",{parentName:"ul"},'Use address clauses to map variables and entries to the hardware\ndevice or memory, not to model the FORTRAN "equivalence" feature.'),(0,n.kt)("li",{parentName:"ul"},"Ensure that the address specified in an attribute definition clause\nis valid and does not conflict with the alignment."),(0,n.kt)("li",{parentName:"ul"},"If available in your Ada environment, use the package\n",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Interrupts")," to associate handlers with interrupts."),(0,n.kt)("li",{parentName:"ul"},"Avoid using the address clause for nonimported program units."),(0,n.kt)("li",{parentName:"ul"},"Do not suppress exception checks during development."),(0,n.kt)("li",{parentName:"ul"},"If necessary, during operation, introduce blocks that encompass the\nsmallest range of statements that can safely have exception checking\nremoved."),(0,n.kt)("li",{parentName:"ul"},"Initialize all objects , including access values, prior to use."),(0,n.kt)("li",{parentName:"ul"},"Use caution when initializing access values."),(0,n.kt)("li",{parentName:"ul"},"Do not depend on default initialization that is not part of the\nlanguage."),(0,n.kt)("li",{parentName:"ul"},"Derive from a controlled type and override the primitive procedure\nto ensure automatic initialization."),(0,n.kt)("li",{parentName:"ul"},"Ensure elaboration of an entity before using it."),(0,n.kt)("li",{parentName:"ul"},"Use function calls in declarations cautiously."),(0,n.kt)("li",{parentName:"ul"},"Ensure that values obtained from ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Direct_IO")," and\n",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Sequential_IO")," are in range."),(0,n.kt)("li",{parentName:"ul"},"Use the ",(0,n.kt)("inlineCode",{parentName:"li"},"'Valid")," attribute to check the validity of scalar values\nobtained through ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Direct_IO")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"Ada.Sequential_IO.")),(0,n.kt)("li",{parentName:"ul"},"Prevent exceptions from propagating outside any user-defined\n",(0,n.kt)("inlineCode",{parentName:"li"},"Finalize")," or ",(0,n.kt)("inlineCode",{parentName:"li"},"Adjust")," procedure by providing handlers for all\npredefined and user-defined exceptions at the end of each procedure."),(0,n.kt)("li",{parentName:"ul"},"Do not invoke a potentially blocking operation within a protected\nentry, a protected procedure, or a protected function."),(0,n.kt)("li",{parentName:"ul"},"Do not use an asynchronous select statement within abort-deferred\noperations."),(0,n.kt)("li",{parentName:"ul"},"Do not create a task that depends on a master that is included\nentirely within the execution of an abort-deferred operation.")),(0,n.kt)("admonition",u({},{type:"note"}),(0,n.kt)("p",{parentName:"admonition"},'This page of the "Ada Quality and Style Guide" has been adapted from the\noriginal work at ',(0,n.kt)("a",u({parentName:"p"},{href:"https://en.wikibooks.org/wiki/Ada_Style_Guide"}),"https://en.wikibooks.org/wiki/Ada_Style_Guide"),", which is\nlicensed under the\n",(0,n.kt)("a",u({parentName:"p"},{href:"https://creativecommons.org/licenses/by-sa/3.0/"}),"Creative Commons Attribution-ShareAlike License"),";\nadditional terms may apply. Page not endorsed by Wikibooks or the Ada\nStyle Guide Wikibook authors. This page is licensed under the same license\nas the original work.")))}y.isMDXComponent=!0}}]);